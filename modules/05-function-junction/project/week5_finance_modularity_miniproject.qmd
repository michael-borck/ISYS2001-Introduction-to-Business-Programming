---
title: 'Week 5 Mini-Project: Modular Personal Finance Toolkit'
subtitle: 'Building Reusable Financial Functions in Google Colab'
jupyter: python3
---

## Project Overview

This week, you'll transform your financial decision-making skills into **modular, reusable functions**. Working in Google Colab, you'll learn how organizing code into functions makes it more readable, testable, and professional‚Äîeven within a notebook environment.

**Duration:** 1-3 hours  
**Goal:** Apply function definition, parameters, return values, and the `datetime` module to create a modular finance toolkit

### Learning Objectives

- Define functions with meaningful parameters and return values
- Break complex financial logic into smaller, reusable components  
- Organize code into logical "modules" using notebook cells
- Import and use the `datetime` module for timestamps
- Experience how modular design improves code organization and reusability
- Practice AI-assisted programming with constraint-based prompts

---

## Two Project Pathways

### üÜï **Pathway A: Standalone Finance Toolkit**
Perfect for students who want a fresh start or missed earlier weeks:
- Build a complete modular finance calculator from scratch
- Learn function design principles with financial examples
- Create your own reusable finance function library

### üîÑ **Pathway B: Refactor & Extend**  
For students who completed Weeks 3-4:
- Transform your existing tracker code into modular functions
- Add new features using proper function design
- Experience the benefits of refactoring legacy code

*Choose the pathway that fits your situation. Both lead to the same learning outcomes!*

---

## Google Colab Workflow

### üìù **How Modularity Works in Colab**

In Google Colab, we achieve modularity by organizing functions across multiple cells:

- **Cell 1:** Core financial calculation functions
- **Cell 2:** Data analysis functions  
- **Cell 3:** User interface and validation functions
- **Cell 4:** Main program that uses all the functions
- **Cell 5:** Testing and demonstrations

**Key Benefit:** Once you define a function in a cell and run it, that function becomes available in all subsequent cells!

---

## Cell 1: Core Financial Calculation Functions (30 minutes)

### üéØ Create Your Function Foundation

**Run this cell first to define your core financial functions:**

```{python}
# ============================================================================
# CELL 1: CORE FINANCIAL CALCULATION FUNCTIONS
# ============================================================================

def calculate_percentage(amount, total):
    """
    Calculate what percentage amount is of total.
    
    Parameters:
    amount (float): The partial amount
    total (float): The total amount
    
    Returns:
    float: Percentage (0-100), or 0 if total is 0
    
    Example: calculate_percentage(250, 1000) returns 25.0
    """
    # Your implementation here
    if total == 0:
        return 0
    return (amount / total) * 100

def categorize_expense(amount, monthly_budget):
    """
    Categorize an expense based on budget percentage.
    
    Parameters:
    amount (float): Expense amount
    monthly_budget (float): Total monthly budget
    
    Returns:
    str: "Major Expense" (‚â•20%), "Moderate Expense" (5-19%), or "Minor Expense" (<5%)
    
    Example: categorize_expense(200, 1000) returns "Moderate Expense"
    """
    # Your implementation here
    # Hint: Use the calculate_percentage() function you just defined!
    percentage = calculate_percentage(amount, monthly_budget)
    
    if percentage >= 20:
        return "Major Expense"
    elif percentage >= 5:
        return "Moderate Expense"
    else:
        return "Minor Expense"

def calculate_monthly_payment(principal, annual_rate, months):
    """
    Calculate monthly loan payment using simple formula.
    
    Parameters:
    principal (float): Loan amount
    annual_rate (float): Annual interest rate (as percentage, e.g., 5.5)
    months (int): Number of months
    
    Returns:
    float: Monthly payment amount
    
    Example: calculate_monthly_payment(10000, 5.0, 12) returns ~858.33
    """
    # Your implementation here
    # Handle the case where annual_rate is 0 (no interest)
    if annual_rate == 0:
        return principal / months
    
    monthly_rate = annual_rate / 12 / 100
    return principal * (monthly_rate * (1 + monthly_rate)**months) / ((1 + monthly_rate)**months - 1)

print("‚úÖ Core financial functions defined successfully!")
print("Test them in the next cell...")
```

### üß™ Test Your Core Functions

**Run this cell to test your functions:**

```{python}
# Test your core functions
print("Testing calculate_percentage:")
print(f"250 out of 1000: {calculate_percentage(250, 1000)}%")  # Should be 25.0
print(f"0 out of 500: {calculate_percentage(0, 500)}%")        # Should be 0.0
print(f"100 out of 0: {calculate_percentage(100, 0)}%")        # Should be 0.0

print("\nTesting categorize_expense:")
print(f"$200 of $1000 budget: {categorize_expense(200, 1000)}")   # Should be "Moderate Expense"
print(f"$50 of $1000 budget: {categorize_expense(50, 1000)}")     # Should be "Minor Expense"
print(f"$250 of $1000 budget: {categorize_expense(250, 1000)}")   # Should be "Major Expense"

print("\nTesting calculate_monthly_payment:")
print(f"$10,000 at 5% for 12 months: ${calculate_monthly_payment(10000, 5.0, 12):.2f}")
print(f"$5,000 at 0% for 24 months: ${calculate_monthly_payment(5000, 0, 24):.2f}")
```

---

## Cell 2: Data Analysis Functions (30 minutes)

### üéØ Add Data Processing Power

**Run this cell to define your data analysis functions:**

```{python}
# ============================================================================
# CELL 2: DATA ANALYSIS FUNCTIONS
# ============================================================================

def find_largest_expense(expenses):
    """
    Find the largest expense in a list.
    
    Parameters:
    expenses (list): List of expense amounts
    
    Returns:
    float: Largest expense, or 0 if list is empty
    """
    # Your implementation here
    if not expenses:  # Empty list
        return 0
    return max(expenses)

def find_smallest_expense(expenses):
    """
    Find the smallest expense in a list.
    
    Parameters:
    expenses (list): List of expense amounts
    
    Returns:
    float: Smallest expense, or 0 if list is empty
    """
    # Your implementation here
    if not expenses:
        return 0
    return min(expenses)

def calculate_average_expense(expenses):
    """
    Calculate average expense amount.
    
    Parameters:
    expenses (list): List of expense amounts
    
    Returns:
    float: Average expense, or 0 if list is empty
    """
    # Your implementation here
    if not expenses:
        return 0
    return sum(expenses) / len(expenses)

def count_expenses_by_category(expenses, monthly_budget):
    """
    Count expenses by category using the categorize_expense function.
    
    Parameters:
    expenses (list): List of expense amounts
    monthly_budget (float): Monthly budget for categorization
    
    Returns:
    dict: Dictionary with counts for each category
    Example: {"Major": 2, "Moderate": 5, "Minor": 8}
    """
    # Your implementation here
    # Hint: Use the categorize_expense() function from Cell 1!
    categories = {"Major": 0, "Moderate": 0, "Minor": 0}
    
    for expense in expenses:
        category = categorize_expense(expense, monthly_budget)
        if "Major" in category:
            categories["Major"] += 1
        elif "Moderate" in category:
            categories["Moderate"] += 1
        else:
            categories["Minor"] += 1
    
    return categories

def calculate_total_spent(expenses):
    """
    Calculate total amount spent.
    
    Parameters:
    expenses (list): List of expense amounts
    
    Returns:
    float: Total spent
    """
    # Your implementation here
    return sum(expenses) if expenses else 0

print("‚úÖ Data analysis functions defined successfully!")
print("Test them in the next cell...")
```

### üß™ Test Your Analysis Functions

**Run this cell to test your data analysis:**

```{python}
# Test with sample data
test_expenses = [450, 67.50, 89, 25, 120, 15, 300]
test_budget = 2000

print("Testing analysis functions with sample expenses:")
print(f"Expenses: {test_expenses}")
print(f"Budget: ${test_budget}")
print()

print(f"Total spent: ${calculate_total_spent(test_expenses):.2f}")
print(f"Largest expense: ${find_largest_expense(test_expenses):.2f}")
print(f"Smallest expense: ${find_smallest_expense(test_expenses):.2f}")
print(f"Average expense: ${calculate_average_expense(test_expenses):.2f}")
print(f"Category counts: {count_expenses_by_category(test_expenses, test_budget)}")

# Test edge cases
empty_list = []
print(f"\nTesting with empty list:")
print(f"Total: ${calculate_total_spent(empty_list):.2f}")
print(f"Average: ${calculate_average_expense(empty_list):.2f}")
```

---

## Cell 3: User Interface Functions (30 minutes)

### üéØ Create Interactive Components

**Run this cell to define your user interface functions:**

```{python}
# ============================================================================
# CELL 3: USER INTERFACE AND VALIDATION FUNCTIONS
# ============================================================================

def get_valid_amount(prompt):
    """
    Get a valid positive amount from user with input validation.
    
    Parameters:
    prompt (str): Message to display to user
    
    Returns:
    float: Valid positive amount
    """
    # Your implementation using while loop from Week 4
    while True:
        try:
            amount = float(input(prompt))
            if amount > 0:
                return amount
            else:
                print("Amount must be positive! Please try again.")
        except ValueError:
            print("Please enter a valid number!")

def collect_expenses():
    """
    Collect multiple expenses from user using sentinel pattern.
    
    Returns:
    tuple: (list of expense amounts, list of expense descriptions)
    """
    expenses = []
    descriptions = []
    
    print("\n--- Enter Your Expenses ---")
    print("Type 'done' when finished entering expenses")
    
    while True:
        expense_input = input("\nExpense amount (or 'done'): $")
        
        if expense_input.lower() == 'done':
            break
        
        try:
            amount = float(expense_input)
            if amount > 0:
                description = input("What was this expense for? ")
                expenses.append(amount)
                descriptions.append(description)
                
                # Show running total
                total_so_far = calculate_total_spent(expenses)
                print(f"Added ${amount:.2f} for {description}")
                print(f"Running total: ${total_so_far:.2f} ({len(expenses)} expenses)")
            else:
                print("Amount must be positive!")
        except ValueError:
            print("Please enter a valid number or 'done'!")
    
    return expenses, descriptions

def display_expense_analysis(expenses, descriptions, monthly_budget):
    """
    Display comprehensive expense analysis using all our functions.
    
    Parameters:
    expenses (list): List of expense amounts
    descriptions (list): List of expense descriptions  
    monthly_budget (float): User's monthly budget
    """
    if not expenses:
        print("\nüìù No expenses to analyze!")
        return
    
    print("\n" + "="*60)
    print("üìä EXPENSE ANALYSIS REPORT")
    print("="*60)
    
    # Basic statistics using our functions
    total_spent = calculate_total_spent(expenses)
    budget_percentage = calculate_percentage(total_spent, monthly_budget)
    average_expense = calculate_average_expense(expenses)
    largest_expense = find_largest_expense(expenses)
    smallest_expense = find_smallest_expense(expenses)
    
    print(f"üí∞ Financial Summary:")
    print(f"   Total expenses: {len(expenses)}")
    print(f"   Total spent: ${total_spent:.2f}")
    print(f"   Budget used: {budget_percentage:.1f}%")
    print(f"   Remaining budget: ${monthly_budget - total_spent:.2f}")
    print()
    
    print(f"üìà Spending Analysis:")
    print(f"   Average expense: ${average_expense:.2f}")
    print(f"   Largest expense: ${largest_expense:.2f}")
    print(f"   Smallest expense: ${smallest_expense:.2f}")
    print()
    
    # Category breakdown using our function
    categories = count_expenses_by_category(expenses, monthly_budget)
    print(f"üìä Expense Categories:")
    print(f"   Major expenses (‚â•20% of budget): {categories['Major']}")
    print(f"   Moderate expenses (5-19% of budget): {categories['Moderate']}")
    print(f"   Minor expenses (<5% of budget): {categories['Minor']}")
    print()
    
    # Detailed expense list
    print(f"üìù Expense Details:")
    for i, (amount, description) in enumerate(zip(expenses, descriptions), 1):
        category = categorize_expense(amount, monthly_budget)
        percentage = calculate_percentage(amount, monthly_budget)
        print(f"   {i}. ${amount:.2f} - {description} ({category}, {percentage:.1f}% of budget)")
    print()
    
    # Smart advice based on spending
    print(f"üí° Budget Advice:")
    if budget_percentage >= 90:
        print("   ‚ö†Ô∏è  Danger zone! You've used most of your budget. Consider reducing expenses.")
    elif budget_percentage >= 75:
        print("   ‚ö° Approaching budget limit. Be cautious with remaining spending.")
    elif budget_percentage >= 50:
        print("   üìä Halfway through budget. You're maintaining a good pace.")
    elif budget_percentage >= 25:
        print("   ‚úÖ Good progress! You're spending conservatively.")
    else:
        print("   üåü Excellent! You're well within budget with room for savings.")

def generate_timestamp():
    """
    Generate a formatted timestamp using datetime module.
    
    Returns:
    str: Formatted current date and time
    """
    from datetime import datetime
    current_time = datetime.now()
    return current_time.strftime("%Y-%m-%d %H:%M:%S")

print("‚úÖ User interface functions defined successfully!")
print("Ready to run the main program...")
```

---

## Cell 4: Main Finance Tracker Program (30 minutes)

### üéØ Bring It All Together

**Run this cell to execute your complete modular finance tracker:**

```{python}
# ============================================================================
# CELL 4: MAIN FINANCE TRACKER PROGRAM
# ============================================================================

def main():
    """
    Main program function that orchestrates the entire finance tracker.
    Uses all the functions defined in previous cells.
    """
    print("=" * 60)
    print("üè¶ MODULAR PERSONAL FINANCE TRACKER v1.0")
    print("=" * 60)
    
    # Add timestamp using datetime
    timestamp = generate_timestamp()
    print(f"Session started: {timestamp}")
    print()
    
    # Get user setup using our validation function
    name = input("Enter your name: ")
    monthly_budget = get_valid_amount("Enter your monthly budget: $")
    
    print(f"\nüëã Welcome {name}!")
    print(f"üí∞ Monthly budget: ${monthly_budget:.2f}")
    print(f"üìÖ Session time: {timestamp}")
    
    # Collect expenses using our collection function
    expenses, descriptions = collect_expenses()
    
    # Show comprehensive analysis using our analysis function
    display_expense_analysis(expenses, descriptions, monthly_budget)
    
    # Session summary
    print("=" * 60)
    print("üöÄ SESSION COMPLETE")
    print("=" * 60)
    print(f"Thank you {name}! You tracked {len(expenses)} expenses.")
    if expenses:
        total = calculate_total_spent(expenses)
        percentage = calculate_percentage(total, monthly_budget)
        print(f"Total spending: ${total:.2f} ({percentage:.1f}% of budget)")
    print("Your modular finance toolkit is ready for more advanced features!")
    
    # Return data for further analysis if needed
    return {
        'name': name,
        'budget': monthly_budget,
        'expenses': expenses,
        'descriptions': descriptions,
        'timestamp': timestamp
    }

# Run the main program
print("üé¨ Starting your modular finance tracker...")
print("All functions from previous cells are now available!")
print()

session_data = main()
```

---

## Cell 5: Testing and Bonus Features (30 minutes)

### üß™ Comprehensive Testing

**Run this cell to test your complete system:**

```{python}
# ============================================================================
# CELL 5: TESTING AND BONUS FEATURES
# ============================================================================

def run_automated_test():
    """
    Run automated test with predefined data to verify all functions work correctly.
    """
    print("üß™ RUNNING AUTOMATED SYSTEM TEST")
    print("-" * 40)
    
    # Test data
    test_expenses = [850, 125, 65, 45, 200, 75]
    test_descriptions = ["Rent payment", "Weekly groceries", "Gas for car", 
                        "Coffee and meals", "Utilities", "Entertainment"]
    test_budget = 2500
    
    print(f"Test Budget: ${test_budget}")
    print(f"Test Expenses: {len(test_expenses)} items")
    print()
    
    # Test all our functions
    total = calculate_total_spent(test_expenses)
    percentage = calculate_percentage(total, test_budget)
    average = calculate_average_expense(test_expenses)
    largest = find_largest_expense(test_expenses)
    smallest = find_smallest_expense(test_expenses)
    categories = count_expenses_by_category(test_expenses, test_budget)
    
    print("üìä TEST RESULTS:")
    print(f"   Total spent: ${total:.2f}")
    print(f"   Budget percentage: {percentage:.1f}%")
    print(f"   Average expense: ${average:.2f}")
    print(f"   Largest expense: ${largest:.2f}")
    print(f"   Smallest expense: ${smallest:.2f}")
    print(f"   Categories: {categories}")
    
    # Expected results
    expected_total = 1360
    expected_percentage = 54.4
    
    print(f"\n‚úÖ VERIFICATION:")
    print(f"   Expected total: ${expected_total} ‚Üí {'‚úÖ PASS' if abs(total - expected_total) < 0.01 else '‚ùå FAIL'}")
    print(f"   Expected percentage: {expected_percentage}% ‚Üí {'‚úÖ PASS' if abs(percentage - expected_percentage) < 0.1 else '‚ùå FAIL'}")
    
    return total == expected_total

# Bonus function: Savings goal calculator
def calculate_savings_timeline(current, target, monthly_save):
    """
    BONUS: Calculate months needed to reach savings goal.
    
    Parameters:
    current (float): Current savings amount
    target (float): Target savings goal
    monthly_save (float): Amount saved per month
    
    Returns:
    float: Months to goal (or infinity if impossible)
    """
    if monthly_save <= 0:
        return float('inf')
    
    remaining = target - current
    if remaining <= 0:
        return 0  # Goal already achieved
    
    return remaining / monthly_save

# Bonus function: Budget advice generator
def generate_detailed_advice(expenses, monthly_budget):
    """
    BONUS: Generate detailed financial advice based on spending patterns.
    """
    if not expenses:
        return "Start tracking expenses to get personalized advice!"
    
    total = calculate_total_spent(expenses)
    percentage = calculate_percentage(total, monthly_budget)
    categories = count_expenses_by_category(expenses, monthly_budget)
    average = calculate_average_expense(expenses)
    
    advice = []
    
    # Budget usage advice
    if percentage >= 90:
        advice.append("üö® URGENT: You're close to your budget limit!")
    elif percentage >= 75:
        advice.append("‚ö†Ô∏è WARNING: Slow down spending for this month.")
    elif percentage <= 25:
        advice.append("üåü EXCELLENT: Consider increasing your savings goals!")
    
    # Category advice
    if categories['Major'] > 2:
        advice.append(f"üí° TIP: You have {categories['Major']} major expenses. Review if any can be reduced.")
    
    # Average expense advice
    if average > monthly_budget * 0.1:
        advice.append(f"üí∞ INSIGHT: Your average expense (${average:.2f}) is high. Consider smaller, more frequent purchases.")
    
    return " ".join(advice) if advice else "üëç Your spending looks well-balanced!"

# Run the automated test
test_passed = run_automated_test()

print(f"\nüéØ BONUS FEATURES DEMO:")
print("-" * 30)

# Demo savings calculator
current_savings = 1500
target_goal = 5000
monthly_savings = 200
months_needed = calculate_savings_timeline(current_savings, target_goal, monthly_savings)
print(f"Savings goal example:")
print(f"   Current: ${current_savings}, Target: ${target_goal}, Monthly: ${monthly_savings}")
print(f"   Time to goal: {months_needed:.1f} months")

# Demo advice generator
demo_expenses = [800, 150, 90, 45, 300]  # Mix of large and small expenses
demo_budget = 2000
advice = generate_detailed_advice(demo_expenses, demo_budget)
print(f"\nAdvice for sample spending: {advice}")

print(f"\nüèÜ SYSTEM TEST: {'‚úÖ ALL TESTS PASSED' if test_passed else '‚ùå SOME TESTS FAILED'}")
```

---

## Part 6: AI Collaboration Reflection (15 minutes)

### ü§ñ Reflecting on AI-Assisted Development

**Add your reflections as comments in this cell:**

```{python}
# ============================================================================
# AI COLLABORATION REFLECTION
# ============================================================================

# MODULAR DESIGN REFLECTION:
# How did organizing functions into separate cells help you understand the code structure?
# Answer:

# Which functions were easiest/hardest to implement? Why?
# Answer:

# How did having functions in separate cells make testing easier?
# Answer:

# AI COLLABORATION REFLECTION:  
# What types of prompts worked best when asking AI for help with functions?
# Answer:

# When was it better to ask for explanations vs. complete code?
# Answer:

# How did setting constraints in your prompts affect the help you received?
# Answer:

# COLAB WORKFLOW REFLECTION:
# How does the cell-based approach compare to writing separate Python files?
# Answer:

# What are the advantages of being able to rerun individual function definitions?
# Answer:

# FUTURE DEVELOPMENT:
# What additional financial functions would be useful for your toolkit?
# Answer:

# How might you organize even more complex financial software in Colab?
# Answer:

print("üìù Reflection complete! You've mastered modular programming in Google Colab.")
```

### üéØ AI Prompting Best Practices You've Learned

Based on this project, here are key AI collaboration strategies:

**‚úÖ Effective Prompts:**
- *"Help me write a function that takes X and Y as parameters and returns Z, using only basic Python"*
- *"I'm getting this error in my function: [error]. Here's my code: [code]. What's wrong?"*
- *"Explain how this function works step by step so I can understand it"*

**‚ùå Less Effective Prompts:**
- *"Write my entire finance program"*
- *"Make this code better"*
- *"Fix everything that's wrong"*

**üéØ Key Insight:** Constraint-based prompting helps you learn while still getting AI assistance!

---

## üèÜ Mini-Project Complete!

### **What You've Accomplished:**

‚úÖ **Modular Design Mastery**: Organized complex functionality into logical, reusable functions  
‚úÖ **Function Expertise**: Created functions with parameters, return values, and proper documentation  
‚úÖ **Colab Workflow**: Mastered cell-based development and function reusability  
‚úÖ **Module Integration**: Successfully used the `datetime` module for timestamps  
‚úÖ **Code Organization**: Experienced how modular design improves maintainability  
‚úÖ **AI Partnership**: Practiced effective constraint-based programming with AI  

### **Programming Skills Developed:**
- **Function Design**: Parameters, return values, edge case handling
- **Code Modularity**: Organizing related functions into logical groups
- **Testing Strategies**: Systematic testing of individual functions and integration
- **Documentation**: Writing clear docstrings and comments
- **Professional Workflow**: Iterative development and testing

### **Finance Tracker Evolution:**
- **Week 3**: Smart decisions with if/elif/else ‚Üí now modularized as reusable functions
- **Week 4**: Loop-powered data collection ‚Üí now organized into clean interface functions  
- **Week 5**: **Modular design with cell-based organization**
- **Week 6 Preview**: Data persistence and advanced analytics

### **üéÆ Google Colab Advantages You've Discovered:**
- **Immediate Testing**: Define and test functions instantly
- **Interactive Development**: Modify and rerun individual components  
- **Visual Organization**: Each cell represents a logical module
- **Easy Sharing**: Simple to share specific functions with AI or classmates
- **No Setup Required**: Focus on learning, not environment configuration

### **üöÄ Next Week Preview:**
Week 6 will add **data persistence and advanced analytics**:
- Save expense data between sessions
- Generate monthly and weekly reports
- Create spending trend analysis
- Build comparison tools across time periods

### **Success Check:**
You're successful if your tracker:
- ‚úÖ Has functions organized logically across cells
- ‚úÖ Processes the automated test correctly
- ‚úÖ Demonstrates clear separation of concerns (calculation vs. UI vs. analysis)
- ‚úÖ Shows how modular design makes code more maintainable and testable
- ‚úÖ Uses functions effectively to avoid code repetition

### **üíæ Keep Building!**
Your modular function library becomes the foundation for all future finance tracker features. You're building something you'll actually want to use and expand!

---

## üìö Professional Development Connection

### **Real-World Relevance:**
Your cell-based modular approach mirrors how data scientists and financial analysts work:

- **Jupyter Notebooks**: Industry standard for financial analysis and modeling
- **Modular Functions**: Essential for reproducible financial research
- **Iterative Development**: Standard practice in quantitative finance
- **Documentation**: Critical for compliance and team collaboration

### **Industry Applications:**
- **Fintech Companies**: Use similar modular approaches for budgeting apps
- **Investment Firms**: Organize trading algorithms into reusable components
- **Banking**: Modular loan calculators and risk assessment tools
- **Personal Finance**: Apps like Mint and YNAB use modular architectures

---

**üåü Outstanding work! You've transformed from writing linear scripts to building modular, professional-quality software. Your functions are the building blocks for sophisticated financial analysis tools! üí∞üßÆ‚ú®**