---
title: "Code Detectives: Mastering the Art of Debugging"
subtitle: "From Print Statements to AI Assistance: A Beginner's Guide to Fixing Code"
format: jupyter-notebook
jupyter: python3
---

## Learning Objectives
By the end of this activity, you will be able to:
- Identify and rectify common syntax, runtime, and logical errors in Python code.
- **Utilise print statements and basic logging for program tracing and error identification.**
- **Understand the role of AI tools as assistants in the debugging process and apply them ethically.**
- **Begin to explore the use of debugger tools like breakpoints (conceptual introduction).**
- Develop analytical skills to understand error messages and improve faulty code.

## Introduction
Writing code is an act of creation, and like any creative process, it often involves a bit of trial and error! Debugging – the art of finding and fixing errors – is a fundamental skill for any programmer. This activity will introduce you to common error types, foundational debugging techniques, and how modern AI tools can assist you in becoming a more effective "Code Detective."

## Key Concepts
- **Syntax Errors**: Mistakes in the code's grammar that prevent the Python interpreter from understanding it (e.g., typos, missing colons). The program won't run.
- **Runtime Errors**: Errors that occur *while* the program is running, often due to unexpected situations (e.g., trying to divide by zero, accessing a file that doesn't exist). The program starts but then crashes.
- **Logical Errors**: The trickiest kind! The program runs without crashing, but it doesn't do what you intended, producing incorrect results or unexpected behaviour.

## Foundational Debugging Techniques

### 1. Reading the Tea Leaves: Understanding Error Messages
Python's error messages (tracebacks) are your first clue! They tell you:
- The *type* of error.
- The *file and line number* where the error occurred.
- A brief *description* of the problem.

**Activity 0: Decipher the Error (Warm-up)**
Look at this error message. What can you tell from it?
```

Traceback (most recent call last):
File "my\_script.py", line 5, in \<module\>
result = x / y
ZeroDivisionError: division by zero

```
*Your response:*
*(Expected: Error is ZeroDivisionError, happened in my_script.py on line 5, tried to divide by zero)*

### 2. The Investigator's Magnifying Glass: `print()` Statements
The humble `print()` statement is one of the most powerful and accessible debugging tools. You can insert `print()` statements at various points in your code to:
- Check the values of variables at different stages.
- See if certain parts of your code are being executed.
- Understand the flow of your program.

**Example:**
```{python}
def calculate_area(length, width):
    print(f"Calculating area with length: {length}, width: {width}") # Check inputs
    area = length * width
    print(f"Calculated area: {area}") # Check result before returning
    return area

# calculate_area(5, "3") # This would cause an error, print would show "3" is a string
```

### 3. Basic Logging: Keeping a Diary of Your Code

Logging is like a more organised version of `print()` statements, especially for larger programs or when you want to record information to a file. Python has a built-in `logging` module. For beginners, even a simple approach can be helpful.

**Simplified Logging Idea (for beginners):**
Instead of just `print()`, you could write messages to a list or a simple file to track events.

```{python}
log_messages = []

def process_data(data):
    log_messages.append(f"Starting to process: {data}")
    if not isinstance(data, int):
        log_messages.append(f"Error: Data {data} is not an integer!")
        return None
    result = data * 2
    log_messages.append(f"Finished processing. Result: {result}")
    return result

process_data(5)
process_data("oops")
# print("\n".join(log_messages)) # Review your log
```

*(Note: For more advanced logging, introduce the `logging` module itself in a later section or course).*

## Using AI Tools Ethically & Effectively in Debugging

AI tools (like LLMs) can be powerful partners in debugging, but they are not magic wands.

> **AI as a Debugging Assistant Workflow:**
>
> 1.  **Encounter a Bug:** Your code isn't working as expected.
> 2.  **Understand First:** Read the error message. Use `print()` statements to investigate variable states and program flow around the suspected error location. *Try to form a hypothesis about the bug yourself.*
> 3.  **Ask AI for Help (If Stuck):**
>       * Provide the relevant code snippet.
>       * Share the full error message.
>       * Explain what you *expect* the code to do.
>       * Explain what it's *actually* doing.
>       * Ask specific questions: "Can you explain this `TypeError`?" or "What are common reasons for this logical error in this context?" or "Can you suggest ways to debug this section of code?"
> 4.  **Critically Evaluate AI's Response:**
>       * Does the explanation make sense?
>       * Does the suggested fix address your hypothesised problem?
>       * *Don't just copy-paste.* Understand *why* the AI's suggestion might work.
> 5.  **Test and Verify:** Implement the suggestion (or your modified version of it) and test thoroughly.
>
> **Transparency:** Always disclose when and how you've used AI in your work.
> **Learning Partner:** Use AI to deepen your understanding, not as a shortcut to avoid thinking.

## Using AI Tools Ethically & Effectively in Debugging
AI tools (like Large Language Models or LLMs) can be powerful partners in debugging, but they are not magic wands. Your own understanding and critical thinking are paramount.

> **The Human-AI Partnership in Debugging:**
>
> 1.  **You're the Lead Detective:**
>     * **Investigate First:** Before turning to AI, always try to understand the problem yourself. Read Python's error messages carefully. Use `print()` statements to trace the flow of your program and inspect the values of variables near where you suspect the error is occurring.
>     * **Form a Hypothesis:** Based on your investigation, try to guess what might be wrong. *The clearer your own understanding of the potential issue and its location, the better you can guide an AI for useful assistance.*
>
> 2.  **Using AI as a Smart Assistant (If Stuck):**
>     * Provide the relevant code snippet.
>     * Share the full error message.
>     * Clearly explain what you *expect* the code to do.
>     * Describe what it's *actually* doing based on your `print()` investigations.
>     * Ask specific questions: "Can you explain this `TypeError` in the context of my code?" or "Given that variable `x` is `None` here (which I found using `print`), what are common reasons for this logical error?" or "Can you suggest different approaches to debug this section further?"
>
> 3.  **Critically Evaluate AI's Suggestions – This is Key!**
>     * **Does the explanation make sense based on your understanding?**
>     * **Does the suggested fix address your hypothesised root problem, or just a symptom?** Be wary of fixes that seem to work for one specific input but might not solve the underlying issue.
>     * ***Avoid "Patchwork Programming":*** Relying solely on AI to "just fix it" can sometimes lead to code that patches over a specific error for a special case without addressing the actual bug. This can create complex, hard-to-maintain code that breaks unexpectedly with new inputs. While it's harder to demonstrate with simple academic examples, in larger projects this can lead to code that *feels* like it works but is built on a shaky foundation.
>     * **Understand *Why*:** Don't just copy-paste AI-generated code. Strive to understand *why* the suggestion works (or doesn't). This is crucial for your learning and for maintaining control over your code.
>
> 4.  **Test, Verify, and Learn:**
>     * Implement the suggestion (or your modified, understood version of it).
>     * Test thoroughly with a variety of inputs, including edge cases you can think of.
>     * Whether the AI was helpful or not, reflect on what you learned about the bug and Python itself.
>
> **Human Oversight is Non-Negotiable:**
> AI is a tool to augment your abilities, not replace your critical judgment. The goal is to write clear, correct, and maintainable code that *you* understand and can stand behind.
>
> **Transparency:** Always disclose when and how you've used AI in your work.
> **Learning Partner:** Use AI to deepen your understanding, not as a shortcut to avoid thinking.



## Application Activities

### Activity 1: Spot the Bug (Syntax/Runtime)

**Scenario:** You are given a Python function intended to calculate the average of a list of numbers but it has an error.

```{python}
def calculate_list_average(numbers):
    total = 0
    for num in numbers:
        total += num
    return total / len(numbers) # What if numbers is empty?

# Test cases
print(calculate_list_average([1, 2, 3, 4, 5]))
# print(calculate_list_average([])) # This will cause a ZeroDivisionError
```

*Your task:*

1.  What type of error occurs if you pass an empty list to `calculate_list_average([])`?
2.  Use `print()` statements *inside the function* to observe the values of `total` and `len(numbers)` before the division.
3.  Correct the function to handle an empty list gracefully (e.g., return 0 or raise a more specific error).
4.  **(AI Challenge):** If you were stuck, how would you prompt an AI to help you debug the empty list scenario *without asking it to just fix the code*?

### Activity 2: Logical Fallacy Detective

**Task:** Analyse the following Python function that is supposed to categorise a person's age group. It has a logical error.

```{python}
def age_group(age):
    if age > 18: # Should this be >= 18 for adults?
        return "Adult"
    elif age < 13: # What about age 18 itself? Or age 13?
        return "Child"
    else: # This covers 13 to 18 (inclusive of 13, exclusive of 18 due to first if)
        return "Teenager"

# Test with print statements
# print(f"Age 12: {age_group(12)}") # Child - OK
# print(f"Age 13: {age_group(13)}") # Teenager - OK
# print(f"Age 17: {age_group(17)}") # Teenager - OK
# print(f"Age 18: {age_group(18)}") # Teenager - Problem! Should likely be Adult.
# print(f"Age 19: {age_group(19)}") # Adult - OK
```

*Your task:*

1.  Use `print()` statements with various ages (e.g., 12, 13, 17, 18, 19) to see what the function returns.
2.  Identify the logical flaw(s) regarding the age boundaries.
3.  Correct the function to accurately categorise ages (e.g., Child: 0-12, Teenager: 13-17, Adult: 18+).
4.  **(AI Challenge):** Describe how you could use an AI to help you *identify edge cases* for this function that you might not have thought of.

-----

## Peeking Inside: A Glimpse into Debuggers & Breakpoints (Advanced Sneak Peek)

While `print()` is fantastic, sometimes you need more power. Professional programmers often use **debuggers**.

**What is a Debugger?**
A debugger is a tool that lets you:

  - **Pause** your program's execution at specific points (called **breakpoints**).
  - **Inspect** the values of variables at that paused moment.
  - **Step through** your code line by line to see exactly how it executes.

Most Python IDEs (like VS Code, PyCharm, and even Google Colab) have built-in debuggers.

**How Breakpoints Work (Conceptual):**

1.  You mark a line in your code as a "breakpoint."
2.  When you run your program *in debug mode*, it stops when it hits that line.
3.  You can then look at the current state of all variables.
4.  You can then tell the debugger to execute the next line, step into a function call, or continue running until the next breakpoint.

**Why is this useful?**
It gives you a much more detailed and interactive view of your program's state than just `print()` statements, especially for complex bugs.

**(Optional Exploration):**
If your coding environment has a debugger (Colab does\!), try setting a breakpoint in one of the functions from the activities above and stepping through it. Don't worry if it seems complex now; this is just an introduction to the concept.

**(AI & Debuggers):** Some modern tools are starting to integrate AI with debuggers to suggest *why* a variable has a certain value at a breakpoint or to predict potential issues. This is an evolving area\!

-----

## Reflection

  - Which debugging technique (`print` statements, analyzing error messages) did you find most helpful for the activities? Why?
  - How did you (or how would you) use an AI tool to *assist* your debugging process for these activities, rather than just getting a solution?
  - How did you ensure the integrity of your work if you consulted an AI?
  - What's one thing you learned about how Python executes code or reports errors that was new to you?
  - Does the idea of using a debugger with breakpoints seem useful for more complex problems in the future?

Remember, debugging is a skill that improves with practice. It's like being a detective: you gather clues, form hypotheses, and test them until you solve the mystery!