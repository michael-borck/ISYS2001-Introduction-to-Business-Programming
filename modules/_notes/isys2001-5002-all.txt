
## Pre-Lab Modules

1. **Reviewing Basic Python Tools**  
   - **Objective:** Refresh the fundamentals: using `print()`, `input()`, and working with variables.  
   - **Content:**  
     - Quick refresher video or reading on Python syntax.  
     - Interactive notebook examples that illustrate assigning and printing variables.  
     - Mini-exercises: Write simple programs to display messages and capture user input.

2. **Introduction to Decision Making**  
   - **Objective:** Introduce if-else statements and logical operators.  
   - **Content:**  
     - Explanation of how conditionals work (e.g., “if”, “else”).  
     - Diagrams showing the flow of decisions.  
     - Example code snippets that compare values and print different outputs.

3. **Exploring the Weather Context**  
   - **Objective:** Connect programming logic to real-world weather scenarios.  
   - **Content:**  
     - Overview of common weather conditions (cold, warm, rainy, etc.) and simple metrics (temperature thresholds).  
     - Discussion on how a program might “decide” a weather message based on a number (temperature) provided by the user.

4. **Designing a Simple Menu**  
   - **Objective:** Learn how to build a text-based menu interface using basic output and input.  
   - **Content:**  
     - Steps to display a menu with numbered options using `print()`.  
     - How to prompt the user for a choice and capture that choice with `input()`.  
     - Practice exercises: Create a menu that lets a user choose between two simple messages.

---

## In-Lab Activities

1. **Activity 1: Crafting the Weather Menu**  
   - **Task:** Create a menu that presents options like:  
     1. Check Temperature  
     2. Check Humidity  
     3. Check Wind Speed  
     4. Exit  
   - **Focus:** Use `print()` to display the menu and `input()` to capture the user’s selection.  
   - **Discussion:** Explain how each option might trigger a different response in the code.

2. **Activity 2: Writing Weather Decision Logic**  
   - **Task:** Based on the menu selection, write code using if-else statements to provide a weather forecast.  
     - For example, if the user selects “Check Temperature,” prompt them to enter the current temperature, then use conditionals to output messages like “It’s cold – wear a jacket” or “It’s warm – enjoy the day!”  
   - **Focus:** Practice writing nested if-else statements and understanding logical comparisons.  
   - **Guidance:** Encourage students to trace through their code with sample inputs.

3. **Activity 3: Testing and Refining the Weather Forecaster**
    - **Task:** Test the weather forecaster with different inputs to see how the program responds.  
    - **Focus:** Debugging and refining the code based on the output.  
    - **Discussion:** Discuss how to handle unexpected inputs and improve the user experience.
  - **Focus:** Debugging and refining the code based on the output.
  - **Guidance:** Encourage students to experiment with various inputs to see how the program reacts. Discuss how to handle edge cases and improve the user experience.
---

## Weekly Project: "Simple Weather Forecaster"

**Project Description:**  
Students will create a basic weather forecasting script that:
- **Displays a Menu:**  
  Presents options such as:  
  1. Check Temperature  
  2. Check Humidity  
  3. Check Wind Speed  
  4. Exit

- **Handles User Input:**  
  Based on the selected option, the script will ask for a related input. For example, if “Check Temperature” is selected, the program prompts the user to input the current temperature.

- **Implements Decision Logic:**  
  Uses if-else statements to analyze the input. For instance:  
  - If temperature is below a certain threshold, print “It’s cold – expect a chilly day.”  
  - If temperature is moderate, print “It’s a pleasant day.”  
  - (Similar simple logic can be applied for humidity and wind speed.)

- **Integration and Reflection:**  
  Emphasize that the focus is on understanding how conditionals make decisions.  
  Explain that next week the code will be refactored to use functions, but for now, all logic is written directly in the main block.

**Project Requirements:**
- Must use only `print()`, `input()`, variables, and basic data types.  
- Encourage creativity in designing simple weather messages.  
- Save the project in a Google Colab Notebook and push the final version to GitHub.

**Project Tips:**
- Remind students that clarity of logic is more important than complex features.
- Suggest that they use AI tools (e.g., ChatGPT) to get hints on improving readability, but they must write and understand the code themselves.
- Emphasize careful planning: drawing out the decision tree before coding can help organize the logic.

---
title: "Designing a Simple Menu"
subtitle: "Module 4: Building a Text-Based Menu Interface"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Overview  
In this module, we'll learn how to create a text-based menu interface using basic output and input.  
You'll understand the steps needed to display a menu and capture the user's choice.

::: {.notes}
The "Overview" slide provides a high-level summary of the presentation, introducing the concept of a menu interface and its role in user interaction. It sets the stage for the subsequent slides, which will delve into the specifics of implementing menu interfaces using Python programming techniques.

The slide outlines the key topics that will be covered throughout the presentation, including the definition of a menu interface, displaying menus using the `print()` function, capturing user input, and a practical example of a simple menu programme. Additionally, it highlights the inclusion of a practice exercise and a summary of the key points, along with a look ahead to the next steps in the learning journey.
:::

# What Is a Menu Interface?  
- A menu interface presents the user with numbered options.  
- It guides the user to choose between different functionalities or messages.  
- This is a common technique to improve the user experience in text-based programmes.

::: {.notes}
A menu interface is a powerful tool for guiding users through text-based programmes. It presents users with a list of numbered options, each corresponding to a specific functionality or message. By selecting an option, the user can easily navigate to their desired action without the need for complex commands or inputs.

Menu interfaces are a common technique for improving user experience in text-based programmes. They provide a clear and intuitive structure that helps users understand the available options and make informed decisions. By breaking down the programme into distinct choices, menu interfaces reduce confusion and make the programme more accessible to a wider range of users.
:::

# Displaying a Menu with `print()`  
- Use the `print()` function to list out the menu options.  
- Each option is displayed on a separate line for clarity.  
- Example:
  
  ```python
  print("1. Show greeting")
  print("2. Display farewell")
  ```

::: {.notes}
The `print()` function is a powerful tool for displaying information to users, and it's particularly useful when creating menu interfaces. By using `print()` to list out the available options, each on a separate line, you can present a clear and easily readable menu to the user. This approach helps to avoid confusion and ensures that the user can quickly identify and select their desired choice.

To illustrate this concept, the slide includes an example of how a menu might be displayed using `print()`. By examining this example, you can see how the function is used to create a well-formatted menu, with each option presented on a new line for improved readability. This example serves as a foundation for understanding how to create effective menu interfaces in your own programs.
:::

# Capturing User Input  
- Use the `input()` function to prompt the user for a choice.  
- Store the user's input in a variable for further processing.  
- Example:
  
  ```python
  choice = input("Enter your choice (1 or 2): ")
  ```
  
- This allows your programme to react based on the user's selection.

::: {.notes}
To capture user input in your programme, use the `input()` function, which prompts the user to enter a choice. The user's response is then stored in a variable for further processing within the programme. For example, you might display a menu of options and ask the user to select one by entering a corresponding number or letter.

By capturing and storing the user's input, your programme can react dynamically based on the selection made. This allows for interactive decision-making and enables your programme to follow different paths or perform specific actions depending on the user's preferences. Utilising the `input()` function is a fundamental way to create responsive and engaging command-line interfaces that adapt to user input.
:::

# Example: A Simple Menu Programme  
- Combining `print()` and `input()` to create a functional menu:
  
  ```python
  print("Menu:")
  print("1. Show greeting")
  print("2. Display farewell")
  choice = input("Enter your choice (1 or 2): ")
  
  if choice == "1":
      print("Hello! Welcome to our programme.")
  elif choice == "2":
      print("Goodbye! Have a nice day.")
  else:
      print("Invalid choice. Please try again.")
  ```
  
- This snippet demonstrates how to guide the user and respond to their input.

::: {.notes}
This slide demonstrates how to create a functional menu by combining the `print()` and `input()` functions in Python. The code snippet guides the user through a series of options and prompts them to make a selection, which the program then responds to accordingly.

By presenting a clear and concise menu interface, the user can easily navigate the available choices and interact with the program effectively. This example serves as a foundation for building more complex menu-driven applications, highlighting the importance of user-friendly design and logical flow in software development.
:::

# Practice Exercise  
- Create your own menu programme that lets a user choose between two simple messages.  
- Steps to follow:
  1. Display two menu options using `print()`.
  2. Prompt the user to enter their choice with `input()`.
  3. Use an if-else structure to print the corresponding message.
- Experiment with different messages and options.

::: {.notes}
To complete this practice exercise, create your own simple menu programme that presents the user with a choice between two messages. Experiment with different messages and options to gain a better understanding of how menu interfaces work. Follow the steps outlined in the previous slides to guide you through the process of displaying the menu using `print()` statements and capturing the user's input.

This exercise provides an opportunity to apply the concepts covered so far and reinforce your learning. Feel free to be creative with your messages and options, and don't hesitate to try different variations to see how they affect the user experience. By practising and experimenting with menu interfaces, you'll develop a stronger grasp of the fundamentals and be better prepared for more advanced programming challenges.
:::

# Summary and Next Steps  
- You learned how to build a text-based menu using basic Python functions.  
- Key points:
  - Display options with `print()`.
  - Capture choices using `input()`.
  - Process user input with conditional statements.
- With these skills, you're ready to create interactive programmes that respond to user selections.

::: {.notes}
In this slide, we summarise the key points you've learned about building a text-based menu using basic Python functions. You now know how to display menu options using the `print()` function, capture user choices with `input()`, and process user input using conditional statements. These fundamental skills form the foundation for creating interactive programmes that respond to user selections.

With the knowledge gained from this presentation, you're ready to apply these techniques to develop your own menu-driven programmes. As you continue to practise and expand your Python skills, you'll be able to create increasingly sophisticated interactive applications that engage users and provide a seamless experience. The possibilities are endless, and the concepts covered in this presentation will serve as a solid starting point for your future programming endeavours.
:::

---
title: "Introduction to Decision Making"
subtitle: "Conditionals and Logical Operators"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Overview  
In this module, we'll introduce the fundamentals of decision making in Python.  
You'll learn how to use if-else statements and logical operators to make your programmes respond to different conditions.

::: {.notes}
The overview slide introduces the topic of conditionals in programming. It sets the stage for the rest of the presentation, which will cover what conditionals are, how they work, logical operators, visualising decision flow, an example of a simple weather decision, and an activity where participants can write their own conditionals.

This slide serves as a roadmap for the presentation, giving the audience a clear idea of what to expect in the coming slides. It's important to highlight the key points that will be covered and to emphasise the practical nature of the presentation, which includes an example and a hands-on activity.
:::

# What Are Conditionals?  
- Conditionals allow your programme to make decisions based on data.  
- They let you execute different code blocks depending on whether a condition is True or False.  
- Keywords include `if`, `elif`, and `else`.

::: {.notes}
Conditionals are a fundamental concept in programming that allow your code to make decisions based on specific conditions. By evaluating whether a condition is True or False, the programme can execute different blocks of code accordingly. This enables your programme to respond dynamically to various situations and inputs.

The key components of conditionals are the `if`, `elif` (else if), and `else` keywords. The `if` statement checks the initial condition, and if it evaluates to True, the corresponding code block is executed. If the condition is False, the programme moves on to the next `elif` statement, if present, and evaluates its condition. This process continues until a True condition is found or the `else` block is reached, which is executed if none of the previous conditions were True.
:::

# How Conditionals Work  
- The `if` statement checks a condition.  
- If the condition is True, the indented block of code runs.  
- Otherwise, the programme can either move to an `elif` (else if) or `else` block.  
- Example:
  
  ```python
  temperature = 18
  if temperature < 20:
      print("It's chilly!")
  else:
      print("It's warm!")
  ```

::: {.notes}
The `if` statement in programming checks a condition, and if that condition evaluates to True, the indented block of code following the `if` statement will execute. This allows the programme to make decisions based on certain criteria being met.

If the condition is not met (evaluates to False), the programme can either move to an `elif` (else if) statement to check additional conditions, or to an `else` block which will run if none of the previous conditions were True. This branching logic enables different code paths to be taken depending on the state of the programme at runtime.
:::

# Logical Operators  
- Logical operators combine multiple conditions:  
  - **and**: Both conditions must be True.  
  - **or**: At least one condition must be True.  
  - **not**: Reverses the truth value of a condition.
- Example:
  
  ```python
  temperature = 22
  is_raining = False
  if temperature > 20 and not is_raining:
      print("Great day for a picnic!")
  ```

::: {.notes}
Logical operators are used to combine multiple conditions in programming. The "and" operator requires both conditions to be true for the overall expression to be true. The "or" operator only needs at least one condition to be true for the overall expression to be true. The "not" operator reverses the truth value of a condition, so if a condition is true, "not" will make it false, and vice versa.

For example, consider the expression "if temperature > 20 and raining == False". This will only be true when the temperature is greater than 20 and it is not raining. If either the temperature is 20 or below, or it is raining, the expression will be false. Logical operators allow for more complex decision-making in programs by combining simple conditions.
:::

# Visualising Decision Flow  
Imagine your code as a flowchart:  
- **Start**  
  ↓  
- Evaluate condition (e.g., temperature)  
  ↓  
- **Yes:** Execute if-block  
  **No:** Move to else-block  
  ↓  
- **End**  
This diagram helps you understand how your programme chooses a path.

::: {.notes}
This slide visualises the flow of a simple conditional statement. It begins with a "Start" point, then evaluates a condition such as checking the temperature. If the condition is true, the flow moves to executing the code block associated with the "Yes" branch before reaching the "End" point.

By showing the decision flow as a linear sequence of steps, this diagram helps to break down the logic of a conditional into distinct stages. The "Yes" and "No" branches clearly illustrate the different paths the code may take depending on the outcome of the condition evaluation.
:::

# Example: A Simple Weather Decision  
Consider this code snippet:
  
```python
temperature = int(input("Enter the current temperature: "))
if temperature < 15:
    print("It's quite cold today.")
elif temperature < 25:
    print("It's a pleasant day.")
else:
    print("It's hot today!")
```
- This programme makes a decision based on the temperature entered by the user.

::: {.notes}
This example demonstrates how a simple program can make decisions based on user input. Here, the user enters a temperature value, and the program checks if it is above or below a certain threshold (in this case, 20 degrees Celsius). Depending on the result of this comparison, the program will print out a different message - either "It's warm outside" or "It's cold outside".

This is a very basic example of how conditionals can be used to create programs that respond differently based on certain conditions. By using logical operators and multiple conditional statements, much more complex decision-making processes can be implemented. However, this simple weather program serves as a good starting point for understanding the fundamental concepts behind conditionals in programming.
:::

# Activity: Write Your Own Conditionals  
- Practice writing a simple programme that:  
  1. Prompts the user for a number.  
  2. Uses an if-else structure to decide if the number is high or low.
- Experiment with different conditions to see how the flow changes.

::: {.notes}
In this activity, participants will have the opportunity to apply their knowledge of conditionals by writing a simple program. They should experiment with various conditions to observe how the program's flow changes based on the conditions they define.

Encourage participants to be creative and think of real-world scenarios where conditionals can be used to make decisions. Remind them to use the logical operators they've learned and to visualise the decision flow as they write their program. Offer assistance if needed, and allocate sufficient time for participants to complete the activity.
:::

# Summary and Next Steps  
- We explored how conditionals work with `if`, `elif`, and `else`.  
- We learned to use logical operators to combine conditions.  
- Understanding these concepts is vital for building interactive and responsive programmes.  
- In the next module, we'll apply these decision-making tools to create a simple weather forecaster.

::: {.notes}
In this module, we have explored the fundamental concepts of conditionals in programming using the `if`, `elif`, and `else` statements. These statements allow our programmes to make decisions based on specified conditions, enabling them to respond differently depending on the input or state of variables. We also learned how to combine multiple conditions using logical operators such as `and`, `or`, and `not`, which gives us even more control over the flow of our code.

As we move forward, it is crucial to recognise that a solid grasp of conditionals and logical operators is essential for creating interactive and responsive programmes. These concepts form the foundation of decision-making in programming, allowing us to build software that can adapt to various situations and user inputs. In the upcoming module, we will apply the knowledge gained here to develop a simple weather forecaster, demonstrating how these decision-making tools can be used to solve real-world problems.
:::

---
title: "Exploring the Weather Context"
subtitle: "Module 3: Connecting Programming Logic to Real-World Weather Scenarios"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Welcome to the Weather Context  
In this module, we explore how to connect programming logic with real-world weather scenarios.  
You'll see how simple metrics and conditions can be used to generate meaningful weather messages.

::: {.notes}
Welcome to the Weather Context, where we'll explore how weather conditions impact our code and decision-making processes. We'll discuss common weather conditions, such as sunny, cloudy, rainy, and snowy, and how they can affect our software applications. By understanding these weather patterns, we can create more dynamic and adaptable code that responds intelligently to the environment.

Throughout this presentation, we'll delve into temperature thresholds and how they can trigger specific actions or decisions within our code. We'll examine real-world examples of how temperature data can be used to make informed choices, such as adjusting air conditioning settings or providing personalised recommendations to users. By the end of this session, you'll have a solid foundation in incorporating weather context into your programming projects, enabling you to create more engaging and contextually aware applications.
:::

# Connecting Code to Weather  
- Programming logic can model everyday situations such as weather forecasting.  
- Using conditionals, we can create a programme that decides which weather message to display based on user input.  
- This approach helps bridge abstract code with tangible, real-world examples.

::: {.notes}
Programming logic can be used to model everyday situations, such as weather forecasting. By using conditionals, we can create a programme that decides which weather message to display based on user input, such as temperature, humidity, or precipitation. This approach helps learners connect abstract coding concepts with tangible, real-world examples, making the learning process more engaging and relevant.

When teaching programming, it's crucial to provide relatable examples that learners can easily grasp. Weather forecasting serves as an excellent example, as it demonstrates how code can be used to make decisions based on specific conditions. By walking learners through the process of creating a weather-based decision-making programme, they can better understand the practical applications of programming concepts like conditionals, variables, and user input.
:::

# Common Weather Conditions  
- Consider the following typical weather conditions:  
  - **Cold:** Low temperatures, possibly with frost.  
  - **Warm:** Moderate temperatures, ideal for outdoor activities.  
  - **Hot:** High temperatures, which might require extra precautions.  
  - **Rainy:** Indicating precipitation and potentially cooler conditions.  
- These categories can be mapped to simple numeric thresholds.

::: {.notes}
This slide presents an overview of common weather conditions, focusing on temperature and precipitation. It introduces four main categories: cold, warm, hot, and rainy. Each category is associated with specific temperature ranges and characteristics, such as frost for cold weather and the need for extra precautions in hot conditions. The slide also mentions that rainy weather indicates precipitation and potentially cooler temperatures.

The slide suggests that these weather categories can be mapped to simple numeric thresholds, which will be explored further in the presentation. By categorising weather conditions based on temperature and precipitation, it becomes possible to make decisions and take appropriate actions depending on the prevailing conditions. This forms the foundation for connecting code to weather data and creating weather-aware applications or systems.
:::

# Temperature Thresholds  
- We can define temperature ranges to represent different weather conditions.  
- Example thresholds might be:  
  - **Cold:** Temperature below 15°C  
  - **Warm:** Temperature between 15°C and 25°C  
  - **Hot:** Temperature above 25°C  
- These thresholds help the programme decide which message to display.

::: {.notes}
In this slide, we introduce the concept of defining temperature ranges to represent different weather conditions. By setting specific thresholds, such as cold being below 15°C, warm being between 15°C and 25°C, and hot being above 25°C, we can categorise the weather into distinct categories. This allows us to create a clear set of criteria for our programme to use when deciding which message to display.

These temperature thresholds form the basis for the decision-making process in our weather programme. By comparing the current temperature to these predefined ranges, the programme can determine the appropriate message to show the user. For example, if the temperature is below 15°C, the programme will display a message indicating cold weather conditions. Similarly, temperatures between 15°C and 25°C will trigger a message for warm weather, while temperatures above 25°C will result in a message for hot weather.
:::

# Decision Making Based on Temperature  
- A programme can use an input number (the temperature) to choose a weather message.  
- Example code snippet:
  
  ```python
  temperature = int(input("Enter the current temperature: "))
  if temperature < 15:
      print("It's quite cold today. Stay warm!")
  elif temperature < 25:
      print("The weather is pleasant today.")
  else:
      print("It's hot today. Keep cool!")
  ```
  
- This snippet illustrates how numeric input can drive decisions in your code.

::: {.notes}
The programme uses a numeric input, the temperature, to select an appropriate weather message. The example code snippet demonstrates how the temperature value is compared against predefined thresholds using conditional statements (if-else) to determine the corresponding weather message to display.

This code snippet serves as a practical illustration of how numeric inputs can be utilized to guide decision-making processes within a programme. By evaluating the temperature value against specific thresholds, the code can intelligently choose the most suitable weather message, showcasing the power of data-driven decision-making in programming.
:::

# Visualising Weather Decisions  
Imagine a flowchart:  
- **Start** → Get temperature input  
- **Is temperature < 15°C?**  
  - Yes: Output "Cold" message  
  - No: Proceed to next condition  
- **Is temperature < 25°C?**  
  - Yes: Output "Warm" message  
  - No: Output "Hot" message  
- This diagram helps understand how the programme navigates different conditions.

::: {.notes}
This slide, titled "Visualising Weather Decisions", presents a flowchart that illustrates the decision-making process of a weather programme based on temperature input. The flowchart begins with the programme receiving a temperature input, then proceeds to evaluate the temperature against two conditional statements: is the temperature less than 15°C, and if not, is it less than 25°C? Depending on the outcome of these evaluations, the programme will output either a "Cold", "Warm", or "Hot" message.

The slide's content serves as a visual aid to help the audience understand how the weather programme navigates through different temperature conditions to arrive at the appropriate output message. By presenting the decision-making process in a clear, step-by-step manner, the flowchart enables the audience to grasp the logic behind the programme's functionality easily. This slide is part of a larger presentation that covers various aspects of weather-related programming, from introducing the context to designing personalised weather decision trees.
:::

# Activity: Design Your Weather Decision Tree  
- Draw your own flowchart to decide a weather message based on temperature.  
- Consider adding extra conditions such as "rainy" or "windy" if you wish.  
- Discuss your design with peers to refine your decision-making process.

::: {.notes}
In this activity, students will create their own weather decision tree flowchart. They will decide on a weather message based on temperature and can optionally include additional conditions such as rain or wind. This hands-on exercise allows students to apply the concepts covered in the previous slides and think critically about the decision-making process involved in determining weather messages.

After completing their individual flowcharts, students will have the opportunity to discuss their designs with their peers. This collaborative element encourages them to explain their thought process, consider alternative approaches, and refine their decision trees based on feedback. Through this activity, students will gain a deeper understanding of how to structure and visualise weather-based decisions using flowcharts.
:::

# Summary and Reflection  
- We reviewed common weather conditions and set simple temperature thresholds.  
- You saw how a basic input can lead to a decision that outputs a weather message.  
- This module lays the foundation for building a weather forecaster by linking real-world data with programming logic.  
- Reflect on how this approach makes abstract concepts more tangible.

::: {.notes}
In this module, we explored common weather conditions and established simple temperature thresholds to guide our decision-making process. By connecting a basic input to a specific output in the form of a weather message, we demonstrated how programming logic can be applied to real-world scenarios.

This approach serves as a foundation for building a more comprehensive weather forecaster, bridging the gap between abstract concepts and tangible applications. Take a moment to consider how this method can be extended to create more sophisticated systems that utilise real-world data to generate meaningful outputs.
:::

---
title: "Reviewing Basic Python Tools"
subtitle: "Basic Python Tools"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Overview
In this module we will review the essential Python tools you need to get started with programming.  
We'll explore how to display messages with `print()`, capture user input with `input()`, and work with variables and basic data types.  
Let’s begin our journey into Python!

::: {.notes}
Welcome to the exciting world of Python programming! In this introductory workshop, we'll explore the fundamentals of Python and equip you with the knowledge and skills to start your programming journey.

Throughout the session, we'll cover essential topics such as using the `print()` function to display output, interacting with users through the `input()` function, working with variables to store and manipulate data, and introducing the basic primitive data types in Python. By the end of the workshop, you'll have a solid foundation to build upon as you continue learning and practising Python programming.
:::

# Understanding `print()`
- The `print()` function is used to display information on the screen.
- It is a fundamental tool for debugging and communicating with the user.
- Example:
  
  ```python
  print("Hello, world!")
  ```
  
- Notice how the text is enclosed in quotes.

::: {.notes}
The `print()` function displays information on the screen and is enclosed in parentheses. Text to be printed must be enclosed in quotes, either single ('') or double (""). The `print()` function is a fundamental tool for debugging code and communicating with the user, as it allows the programmer to display messages or values at specific points in the program's execution.

In this slide, we introduce the basic syntax and usage of the `print()` function. We highlight the importance of enclosing the text to be printed in quotes, which is a common mistake made by beginners. We also discuss the role of `print()` in debugging and interacting with users, setting the stage for more advanced topics in future slides.
:::

# Exploring `input()`
- The `input()` function allows your programme to receive data from the user.
- It pauses programme execution until the user enters some text.
- Example:
  
  ```python
  name = input("What is your name? ")
  print("Hello, " + name + "!")
  ```
  
- This is the first step to making your programme interactive.

::: {.notes}
The `input()` function is a powerful tool in Python that enables your programme to accept user input, making it interactive and dynamic. When `input()` is called, the programme pauses execution and waits for the user to enter some text, which can then be stored in a variable for further processing.

To demonstrate the usage of `input()`, consider the following example code: `name = input("Please enter your name: ")`. In this case, the programme will display the prompt "Please enter your name: " and wait for the user to type in their name, which will be assigned to the variable `name`. This basic example illustrates how `input()` can be used to create engaging and responsive programmes that adapt to user input.
:::

# Working with Variables
- Variables are used to store data values.
- A variable is created the moment you assign it a value using the equals sign (`=`).
- Example:
  
  ```python
  age = 25
  print("Age:", age)
  ```
  
- Variables can hold different types of data, such as numbers or text.

::: {.notes}
Variables are fundamental building blocks in programming, allowing you to store and manipulate data values. To create a variable, you simply assign it a value using the equals sign (`=`). For example, `x = 5` creates a variable named `x` and assigns it the value of 5. Variables can hold various types of data, such as numbers (integers or floats) and text (strings).

It's crucial to choose meaningful variable names that reflect the purpose or content of the data they hold. This enhances code readability and makes it easier to understand and maintain your programs. As you progress in your programming journey, you'll encounter more complex data types and learn how to perform operations and calculations using variables. Mastering the concept of variables is a key step in becoming a proficient programmer.
:::

# Introduction to Primitive Data Types
- **Strings:** Text enclosed in quotes (e.g., `"sunny"`).
- **Integers:** Whole numbers (e.g., `10`).
- **Floats:** Numbers with decimal points (e.g., `3.14`).
- **Booleans:** `True` or `False` values.
- Example:
  
  ```python
  temperature = 20.5   # Float
  weather = "cloudy"   # String
  is_raining = False   # Boolean
  ```

::: {.notes}
In this slide, we introduce the four primitive data types in programming: strings, integers, floats, and booleans. Strings are used to represent text and are enclosed in quotes, such as "sunny". Integers are whole numbers like 10, while floats are numbers with decimal points, such as 3.14. Booleans, on the other hand, represent true or false values.

By understanding these primitive data types, you'll be able to effectively store and manipulate different kinds of data in your programs. Whether you're working with text, whole numbers, decimal numbers, or true/false values, these data types form the foundation of your programming toolkit. We'll explore an example that demonstrates how these data types can be used in practice.
:::

# Putting It All Together
- Let’s combine what we’ve learnt:
  1. Display a message with `print()`.
  2. Capture user input using `input()`.
  3. Store the input in a variable.
- Example programme:
  
  ```python
  print("Welcome to the weather programme!")
  temp = input("Enter the current temperature: ")
  print("You entered", temp, "degrees.")
  ```
  
- This simple code snippet demonstrates how our tools work in harmony.

::: {.notes}
Let's take a moment to consolidate our newfound knowledge by examining a concise code example that seamlessly integrates the concepts we've covered. This example will showcase the interplay between `print()`, `input()`, variables, and primitive data types, providing a clear demonstration of how these fundamental building blocks come together to create a functional program.

By dissecting this code snippet, we'll gain a deeper appreciation for the way these elements interact and contribute to the overall functionality of the program. This hands-on approach will reinforce our understanding of the core concepts and serve as a foundation for tackling more complex programming challenges in the future.
:::

# Summary and Next Steps
- In this module we reviewed:
  - The `print()` function for output.
  - The `input()` function for gathering user input.
  - How to create and use variables.
  - Basic data types in Python.
- With these fundamentals in place, you’re well-prepared to tackle more complex projects.
- Up next, we will begin exploring decision making with conditionals in our weather forecasting project.

::: {.notes}
In this module, we reviewed the fundamental concepts of Python programming, including the `print()` function for displaying output, the `input()` function for gathering user input, and the creation and use of variables. We also introduced the basic data types in Python, such as integers, floats, and strings, which form the building blocks of more complex programs.

With a solid grasp of these essential concepts, you are now well-equipped to take on more challenging projects and explore the vast possibilities that Python offers. In the upcoming module, we will delve into decision making using conditionals, which will allow you to create more dynamic and interactive programs. This knowledge will be applied to our exciting weather forecasting project, where you will have the opportunity to put your newfound skills into practice.
:::

1. What is the purpose of the print() function in Python, and how do I use it?
The print() function is a fundamental tool used to display information on the screen. It's essential for debugging and communicating with the user. To use it, enclose the text or variables you want to display within the parentheses, ensuring text is enclosed in quotes. For example, print("Hello, world!") will display "Hello, world!" on the screen.

2. How does the input() function work, and why is it important?
The input() function allows your program to receive data from the user. When called, the program pauses execution and waits for the user to enter text and press Enter. This text can then be stored in a variable for later use, making your programs interactive. For example, name = input("Please enter your name: ") will prompt the user to enter their name, which is then assigned to the variable name.

3. What are variables in Python, and how do I create them?
Variables are used to store data values. You create a variable the moment you assign a value to it using the equals sign (=). For instance, age = 30 creates a variable named age and assigns it the value 30. Variables are essential for manipulating and working with data within your program.

4. What are the four basic primitive data types in Python?
The four basic primitive data types are:

- Strings: Text enclosed in quotes (e.g., "sunny").
- Integers: Whole numbers (e.g., 10).
- Floats: Numbers with decimal points (e.g., 3.14).
- Booleans: True or False values.

5. Can you give an example of how to combine print(), input(), and variables in a simple program?
name = input("Please enter your name: ")

print("Hello, " + name + "!")

This code first uses input() to ask the user for their name and stores it in the name variable. Then, it uses print() to display a greeting that includes the user's name.

6. Why is choosing meaningful names for my variables important?
Choosing meaningful variable names significantly improves code readability and maintainability. Names that reflect the purpose or content of the data they hold make it easier to understand what the code is doing, both for you and for others who may read your code in the future.

7. What role does the print() function play in debugging code?
The print() function is a valuable debugging tool because it allows you to display the values of variables or messages at specific points in your code's execution. This helps you track the flow of your program and identify any unexpected values or errors. By strategically placing print() statements, you can gain insights into what's happening behind the scenes and pinpoint the source of issues.

8. What are conditionals in programming, and why are they important?
Conditionals are a fundamental programming concept that allows your program to make decisions based on data. They enable different code blocks to be executed depending on whether a specific condition is True or False. Conditionals are crucial for creating interactive and responsive programs that can adapt to different situations and user inputs, providing flexibility in program execution by reacting dynamically to various scenarios. The key components of conditionals are the if, elif (else if), and else keywords.

9. How does an if statement work in Python?
The if statement checks a condition. If the condition evaluates to True, the indented block of code immediately following the if statement is executed. If the condition is False, the program can move to an elif (else if) statement to check another condition, or to an else block, which executes if none of the previous conditions were True. In essence, the if statement allows a program to execute certain instructions only when specific criteria are met.

10. What is the purpose of elif and else statements when used with if statements?
The elif (else if) statement provides an opportunity to check an additional condition if the initial if condition is False. You can have multiple elif statements to test for a series of conditions. The else statement provides a default block of code that executes only if none of the preceding if or elif conditions are True. Together, if, elif, and else create a decision-making structure that allows your program to handle various scenarios based on different conditions, ensuring comprehensive coverage in your logic.

11. What are logical operators, and how are they used in conditional statements?
Logical operators combine multiple conditions within a conditional statement. The primary logical operators are:

- and: Both conditions must be True for the overall expression to be True.
- or: At least one condition must be True for the overall expression to be True.
- not: Reverses the truth value of a condition (i.e., True becomes False, and False becomes True).

These operators enable more complex and nuanced decision-making processes by combining simple conditions. For example, if temperature > 20 and raining == False: checks if the temperature is above 20 and it is not raining before executing the associated code block.

12. Can you explain how to visualise the flow of a conditional statement?
Imagine your code as a flowchart. It starts, evaluates a condition (e.g., checking temperature), and then branches based on the result:
Start ↓
Evaluate condition (e.g., temperature) ↓
Yes: Execute if-block No: Move to else-block ↓
End

If the condition is True, the if-block of code is executed. If the condition is False, the flow moves to the else-block (if present). This visualisation helps in understanding the different paths the code can take based on the conditions evaluated.

13. Could you provide an example of a practical application of conditionals in a simple program?
Consider a program that determines whether it's warm or cold based on a user-entered temperature. The program would:

- Prompt the user to enter a temperature.
- Use an if statement to check if the temperature is above a certain threshold (e.g., 20 degrees Celsius).
- If the temperature is above the threshold, print "It's warm outside."
- Otherwise (using an else statement), print "It's cold outside."

This simple weather decision illustrates how conditionals allow programs to respond differently based on specific conditions, demonstrating adaptability through user inputs.

14. What is the main goal of using weather scenarios in programming education?
The primary goal is to make abstract programming concepts, such as conditionals and variables, more tangible and relatable for learners. By using real-world examples like weather forecasting, students can see how code can be used to model and respond to everyday situations. This helps them understand the practical applications of programming logic and makes the learning process more engaging.

15. How can weather conditions like 'cold', 'warm', and 'hot' be used in a program?
These weather conditions can be mapped to specific numeric temperature ranges. For instance, "cold" might be defined as temperatures below 15°C, "warm" as temperatures between 15°C and 25°C, and "hot" as temperatures above 25°C. A program can then use these temperature thresholds to determine the appropriate weather message to display to the user.

16. How can a program use temperature input to make a decision about the weather?
A program can use conditional statements (if-else) to compare the input temperature against predefined thresholds. For example, if the temperature is less than 15°C, the program can output a "Cold" message. If it's between 15°C and 25°C, it outputs "Warm", and if it's above 25°C, it outputs "Hot". This demonstrates how numeric input can drive decision-making in code.

17. What is the purpose of a flowchart in visualising weather decisions?
A flowchart provides a visual representation of the decision-making process within a weather program. It illustrates the steps the program takes to evaluate the temperature input and determine the corresponding weather message. This helps to clarify the logic and flow of the program, making it easier to understand how different temperature conditions lead to different outputs.

18. Why are temperature thresholds important in connecting code to weather?
Temperature thresholds provide a clear and defined boundary between different weather conditions. By establishing specific thresholds, such as those for 'cold', 'warm', and 'hot' weather, you provide the program with a clear set of criteria to use when deciding which message to display.

19. Beyond temperature, what other weather conditions could be included in a more complex weather program?
Besides temperature, other conditions such as precipitation (rain, snow), wind speed, and humidity could be included. These conditions can be integrated into the program using additional conditional statements to create a more nuanced and accurate weather forecast.

20. How does relating a basic input to a specific output support building more complex programming systems?
This approach lays the groundwork for creating more sophisticated systems that utilize real-world data to generate meaningful outputs. It builds a bridge between abstract coding concepts and practical applications, which can then be extended to create more comprehensive and intricate weather programs.

21. What can be learned from designing a weather decision tree?
Designing a weather decision tree helps in understanding and visualising how weather-based decisions can be structured. It encourages critical thinking about the decision-making process involved in determining weather messages and allows for exploration of alternative approaches and refinement of decision based on feedback. It showcases the practical implications and power of data-driven decision-making in programming.

22. What is a menu interface and why is it useful in text-based programs?
A menu interface is a user interface that presents the user with a list of numbered or labelled options. Each option corresponds to a specific function or message within the program. It's useful because it provides a clear and intuitive way for users to navigate and interact with text-based programs, improving the user experience by simplifying command selection and reducing confusion.

23. How can I display a menu of options in Python?
You can use the print() function to display a menu of options. Each option should be displayed on a separate line for clarity. For example:

print("1. Option A")
print("2. Option B")
print("3. Option C")

24. How do I capture user input to determine their menu selection?
Use the input() function to prompt the user to enter their choice. Store the user's input in a variable. For example:
choice = input("Enter your choice: ")

25. How can my program react differently based on the user's menu selection?
Use conditional statements (like if-elif-else) to check the value of the user's input variable and execute different code blocks accordingly. For example:
choice = input("Enter your choice: ")

if choice == "1":
    print("You selected Option A.")
elif choice == "2":
    print("You selected Option B.")
else:
    print("Invalid choice.")

26. What are the basic Python functions required to create a simple text-based menu?
The two fundamental functions are print() for displaying the menu options and input() for capturing the user's selection. These functions, combined with conditional statements, form the basis of a simple menu program.

27. Can you provide an example of a complete, simple menu program?
print("1. Greet the user")
print("2. Say goodbye")

choice = input("Enter your choice (1 or 2): ")

if choice == "1":
    print("Hello there!")
elif choice == "2":
    print("Goodbye!")
else:
    print("Invalid choice.")
---
title: "Staff Answer Guide: Mastering OOP: Design Choices Unpacked"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


**Date Prepared:** April 24, 2025

This guide provides sample solutions and evaluation points for the student worksheet focused on OOP design, justification, and ethical AI usage in Python.

## Introduction & Key Concepts
Ensure students understand the definitions provided, particularly:

* **Class:** The blueprint (`Book`, `Patron`).
* **Object:** An instance (`my_book`, `a_patron`).
* **Encapsulation:** Bundling data (attributes) and methods operating on that data within a class, controlling access to internal state (e.g., managing `is_checked_out` via methods).
* **(Inheritance/Polymorphism):** While not directly implemented in the core activities, these are background concepts. Polymorphism could be relevant if discussing how different item types (`Book`, `DVD`) might have different `check_out` logic but the same method name.

## Application Activities

### Activity 1: Designing a Simple Class (`Book`)

**Objective:** Define a `Book` class with relevant attributes and methods for basic library operations, including state management (availability).

**Expected Code Structure:**

```python
# Write your class definition here.
class Book:
    """
    Represents a book in a library system, managing its details and availability.
    """
    def __init__(self, title, author, year):
        """
        Initialises a new Book object.

        Args:
            title (str): The title of the book.
            author (str): The author of the book.
            year (int): The year of publication.
        """
        self.title = title
        self.author = author
        self.year = year
        self.is_checked_out = False # Attribute to track availability (state)

    def check_out(self):
        """
        Marks the book as checked out if it is currently available.
        Returns:
            bool: True if successfully checked out, False otherwise.
        """
        if not self.is_checked_out:
            self.is_checked_out = True
            print(f"'{self.title}' has been checked out.")
            return True
        else:
            print(f"'{self.title}' is already checked out.")
            return False

    def check_in(self):
        """
        Marks the book as available (checked in) if it is currently checked out.
        Returns:
            bool: True if successfully checked in, False otherwise.
        """
        if self.is_checked_out:
            self.is_checked_out = False
            print(f"'{self.title}' has been checked in.")
            return True
        else:
            print(f"'{self.title}' is already checked in.")
            return False

    def display_details(self):
        """ Displays the book's details and availability status. """
        status = "Checked Out" if self.is_checked_out else "Available"
        print(f"Title: {self.title}, Author: {self.author}, Year: {self.year}, Status: {status}")

# --- Example Usage (Optional - for testing the class) ---
# book1 = Book("The Lord of the Rings", "J.R.R. Tolkien", 1954)
# book1.display_details()
# book1.check_out()
# book1.display_details()
# book1.check_in()
# book1.display_details()
```

**Evaluation Notes:**

* Check for correct class and `__init__` syntax.
* Attributes `title`, `author`, `year` should be present.
* Crucially, there should be an attribute to track state (like `is_checked_out` or `is_available`), initialised appropriately.
* `check_out` and `check_in` methods should modify this state attribute *conditionally* (i.e., check the current state before changing).
* Methods should ideally provide feedback (print statements or return values) indicating success or failure. Returning a boolean is good practice for interaction (used in Extension).

### Activity 2: Justifying Your Design

**Objective:** Students should articulate the reasoning behind their `Book` class structure, linking it to OOP principles.

**Sample Justification:**

```
# Provide your justification here.
My design for the `Book` class encapsulates all relevant information (title, author, year) and behaviors (checking in, checking out) related to a single book within one structure. This follows the OOP principle of **Encapsulation**, keeping data and methods that operate on that data together.

The inclusion of the `is_checked_out` attribute is essential for managing the book's state internally. The `check_in` and `check_out` methods act as controlled interfaces to modify this state, preventing invalid operations (like checking out an already checked-out book) and hiding the direct manipulation of the `is_checked_out` variable from outside the class.

This design offers benefits like:
- **Modularity:** Each `Book` object is a self-contained unit.
- **Reusability:** The `Book` class can be used to create many book instances.
- **Maintainability:** If the logic for checking books in/out needs to change, modifications are localised to the `Book` class methods.

While Polymorphism isn't heavily demonstrated here, if we later added other item types (like `DVD` or `Magasine`) with their own `check_in`/`check_out` methods, we could potentially treat them interchangeably in parts of the system using polymorphic behavior.
```

**Evaluation Notes:**

* Look for a clear explanation of *why* specific attributes and methods were chosen.
* The justification *must* connect the design to **Encapsulation**. Does the student explain how data and methods are bundled? Do they mention controlled access to state via methods?
* Mentioning benefits like modularity, reusability, or maintainability shows a deeper understanding.
* Bonus points for correctly identifying that Polymorphism isn't the primary principle demonstrated here but explaining how it *could* apply in a broader context.

## Extension Challenge (`Patron` class)

**Objective:** Design a `Patron` class that interacts with the `Book` class, managing borrowing and returning actions.

**Expected Code Structure:**

```python
# (Assume the enhanced Book class from Activity 1 with boolean returns is available)

class Patron:
    """
    Represents a library patron who can borrow and return books.
    """
    def __init__(self, name, patron_id):
        """
        Initialises a new Patron object.

        Args:
            name (str): The name of the patron.
            patron_id (str): The unique ID of the patron.
        """
        self.name = name
        self.patron_id = patron_id
        self.borrowed_books = [] # List to hold references to borrowed Book objects

    def borrow_book(self, book):
        """
        Attempts to borrow a book. Checks availability via the book object.

        Args:
            book (Book): The Book object instance to borrow.
        """
        print(f"\nPatron '{self.name}' attempting to borrow '{book.title}'...")
        if isinstance(book, Book): # Basic type check
            if book.check_out(): # Call the book's method, which handles state change & returns status
                self.borrowed_books.append(book)
                print(f"'{book.title}' successfully borrowed by {self.name}.")
            else:
                # check_out method already printed the reason (e.g., "already checked out")
                print(f"Patron '{self.name}' could not borrow '{book.title}'.")
        else:
            print("Invalid item provided. Cannot borrow.")


    def return_book(self, book):
        """
        Attempts to return a book. Checks if the patron has borrowed it.

        Args:
            book (Book): The Book object instance to return.
        """
        print(f"\nPatron '{self.name}' attempting to return '{book.title}'...")
        if isinstance(book, Book) and book in self.borrowed_books:
            if book.check_in(): # Call the book's method, which handles state change & returns status
                self.borrowed_books.remove(book)
                print(f"'{book.title}' successfully returned by {self.name}.")
            else:
                # check_in method already printed the reason (e.g., "already checked in")
                 print(f"Patron '{self.name}' could not return '{book.title}' (state issue).")
        elif not isinstance(book, Book):
             print("Invalid item provided. Cannot return.")
        else: # Book object valid, but not found in borrowed list
            print(f"Patron '{self.name}' did not borrow '{book.title}'. Cannot return.")


    def display_borrowed_books(self):
        """ Displays the list of books currently borrowed by the patron. """
        print(f"\nBooks currently borrowed by {self.name} ({self.patron_id}):")
        if not self.borrowed_books:
            print("  None.")
        else:
            for book in self.borrowed_books:
                # Accessing attributes of the contained Book objects
                print(f"  - {book.title} by {book.author}")

# --- Example Usage (Showing Interaction) ---
# book_a = Book("Dune", "Frank Herbert", 1965)
# book_b = Book("Foundation", "Isaac Asimov", 1951)
# patron1 = Patron("Alice", "P101")

# patron1.display_borrowed_books()
# patron1.borrow_book(book_a) # Alice borrows Dune
# book_a.display_details()    # Show Dune is checked out
# patron1.borrow_book(book_a) # Alice tries to borrow Dune again (fails)
# patron1.borrow_book(book_b) # Alice borrows Foundation
# patron1.display_borrowed_books() # Show Alice has Dune and Foundation

# patron1.return_book(book_a) # Alice returns Dune
# book_a.display_details()    # Show Dune is available again
# patron1.display_borrowed_books() # Show Alice only has Foundation
# patron1.return_book(book_a) # Alice tries to return Dune again (fails)
```

**Evaluation Notes:**

* Check `Patron` class definition with `__init__` storing `name`, `patron_id`, and an empty list for `borrowed_books`.
* Verify `borrow_book` method:
    * Takes a `book` object as input.
    * Calls the `book` object's `check_out` method.
    * Adds the book to `borrowed_books` *only if* `check_out` succeeds.
    * Includes basic error handling/messaging.
* Verify `return_book` method:
    * Takes a `book` object as input.
    * Checks if the `book` is actually in the `borrowed_books` list.
    * Calls the `book` object's `check_in` method.
    * Removes the book from `borrowed_books` *only if* it was present and `check_in` succeeds.
    * Includes basic error handling/messaging.
* The interaction demonstrates how objects of different classes collaborate by calling each other's methods to manage state changes.

## Reflection

**Objective:** Assess the student's metacognition regarding their learning process and ethical use of AI in the context of OOP design.

**Evaluation Guidance:**

* **AI Helpfulness:** Ask for specifics. "Did AI help brainstorm attributes/methods?" "Did AI help structure the class interaction in the extension?" "Did AI help refine the justification paragraph?" Look for concrete examples of prompts used or suggestions received.
* **Integrity:** How did the student ensure they weren't just blindly copying AI output, especially for design choices? "Did you compare AI suggestions with OOP principles discussed in class?" "Did you consider *why* the AI suggested a certain structure?" "Did you modify or reject AI suggestions based on your own understanding or the project requirements?" "Did you test the AI-assisted code thoroughly?" Look for evidence of **Critical Evaluation** and treating the AI as a **Learning Partner**, not just an answer generator. Linking back to **Transparency** (acknowledging use) is also key.
---
title: "Staff Answer Guide: First Steps in Python: Crafting Your First Class"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

This guide provides the solutions and evaluation points for the student worksheet focused on introducing Python classes and ethical AI usage.

## Introduction & Key Concepts
Ensure students have grasped the basic definitions:

* **Class:** Blueprint (e.g., the `Book` definition).
* **Object:** Instance created from the blueprint (e.g., specific book instances like `book1`, `book2`).
* **Attribute:** Variable associated with an object (e.g., `title`, `author`).
* **Method:** Function associated with an object (e.g., `display_info`).

## Application Activities

### Activity 1: Design a Simple Class

**Objective:** Students should define a class `Book` with an initialiser (`__init__`) to set `title` and `author` attributes, and a method (`display_info`) to print these attributes.

**Expected Code Structure:**

```python
# Define the Book class here
class Book:
    """
    Represents a book with a title and author.
    """
    def __init__(self, title, author):
        """
        Initialises a new Book object.

        Args:
            title (str): The title of the book.
            author (str): The author of the book.
        """
        self.title = title  # Assign the title argument to the instance attribute 'title'
        self.author = author # Assign the author argument to the instance attribute 'author'

    def display_info(self):
        """
        Prints the book's title and author.
        """
        print(f"Title: {self.title}, Author: {self.author}")

# Note: No output is expected from just defining the class.
```

**Evaluation Notes:**

* Check for correct class definition syntax (`class Book:`).
* Verify the `__init__` method (constructor) is defined correctly with `self`, `title`, and `author` parameters.
* Ensure attributes are assigned using `self.attribute_name = parameter_name`.
* Check for the `display_info` method definition, taking `self` as the parameter.
* The method should correctly access and print the instance attributes (`self.title`, `self.author`). F-strings are common, but other printing methods are acceptable.

### Activity 2: Implement and Test Your Class

**Objective:** Students should use the `Book` class definition from Activity 1 to create two distinct book objects and call their `display_info` method.

**Expected Code:**

```python
# Implement the Book class and create instances here

# (Include the class definition from Activity 1 here or assume it's already executed)
class Book:
    """
    Represents a book with a title and author.
    """
    def __init__(self, title, author):
        """
        Initialises a new Book object.
        Args:
            title (str): The title of the book.
            author (str): The author of the book.
        """
        self.title = title
        self.author = author

    def display_info(self):
        """
        Prints the book's title and author.
        """
        print(f"Title: {self.title}, Author: {self.author}")

# Create instances (objects) of the Book class
book1 = Book("The Hitchhiker's Guide to the Galaxy", "Douglas Adams")
book2 = Book("Pride and Prejudice", "Jane Austen")

# Display information for each book
print("Book 1 Info:")
book1.display_info()

print("\nBook 2 Info:")
book2.display_info()
```

**Expected Output:**

```
Book 1 Info:
Title: The Hitchhiker's Guide to the Galaxy, Author: Douglas Adams

Book 2 Info:
Title: Pride and Prejudice, Author: Jane Austen
```

**Evaluation Notes:**

* Verify the class definition is present or correctly referenced.
* Check that at least two instances are created using `ClassName(arguments)`.
* Ensure the `display_info` method is called correctly on each instance (`instance_name.method_name()`).
* The output should reflect the data provided when creating the instances.

### Extension Challenge: Enhance Your Class

**Objective:** Students should modify the `Book` class to include `year_published`, update the display method, add an `update_author` method, and test these changes.

**Expected Code:**

```python
# Enhance and test the Book class here

class Book:
    """
    Represents a book with a title, author, and publication year.
    Includes methods to display info and update the author.
    """
    def __init__(self, title, author, year_published):
        """
        Initialises a new Book object.

        Args:
            title (str): The title of the book.
            author (str): The author of the book.
            year_published (int): The year the book was published.
        """
        self.title = title
        self.author = author
        self.year_published = year_published # Added attribute

    def display_info(self):
        """
        Prints the book's title, author, and publication year.
        """
        # Updated to include year_published
        print(f"Title: {self.title}, Author: {self.author}, Year: {self.year_published}")

    def update_author(self, new_author):
        """
        Updates the author of the book.

        Args:
            new_author (str): The new author's name.
        """
        print(f"Updating author for '{self.title}' from '{self.author}' to '{new_author}'...")
        self.author = new_author # Modify the instance attribute

# --- Testing the Enhanced Class ---

# Create an instance of the enhanced class
book3 = Book("1984", "George Orwell", 1949)

print("Original Info:")
book3.display_info()

# Update the author (Example scenario: Correcting a typo or pseudonym)
book3.update_author("Eric Arthur Blair (George Orwell)") # Using the author's real name as an example update

print("\nUpdated Info:")
book3.display_info()

```

**Expected Output:**

```
Original Info:
Title: 1984, Author: George Orwell, Year: 1949
Updating author for '1984' from 'George Orwell' to 'Eric Arthur Blair (George Orwell)'...

Updated Info:
Title: 1984, Author: Eric Arthur Blair (George Orwell), Year: 1949
```

**Evaluation Notes:**

* Check the `__init__` method signature and body include `year_published`.
* Verify `display_info` is updated to show the new attribute.
* Ensure the `update_author` method is defined correctly, taking `self` and `new_author`, and that it modifies `self.author`.
* Check that the test code creates an instance of the *enhanced* class, calls `display_info`, calls `update_author`, and calls `display_info` again to show the change.

## Reflection

**Objective:** Assess the student's understanding of the learning process, potential applications, and their approach to using AI tools ethically.

**Evaluation Guidance:**
There are no single "right" answers here. Look for thoughtful and specific responses.

* **How might you use this new knowledge in future projects?**
    * Look for connections to real-world scenarios or other programming concepts. Examples: Managing user data, creating game elements (characters, items), organising data records, building simple simulations, structuring larger applications. Vague answers like "to write code" are less insightful.
* **Reflect on how you used AI tools during this activity.**
    * Encourage honesty and specificity, referencing the AI Tips or other uses. Examples: "I asked ChatGPT for the basic syntax of a Python class as suggested," "I used GitHub Copilot to auto-complete method names," "I asked Bard to explain `self`," "I pasted my code and asked an AI to check for errors or suggest improvements." This relates to the **Transparency** guideline.
* **Describe how you ensured the integrity of your work when using AI assistance.**
    * Look for evidence of critical engagement with AI suggestions. Examples: "I compared the AI's suggestion with the lecture notes/documentation," "The AI gave me code, but I rewrote it to make sure I understood it," "I tested the AI's code to see if it actually worked as expected," "I didn't just copy-paste; I used it to understand the concept and then wrote my own version." This relates to the **Critical Evaluation** and **Learning Partner** guidelines. Assess if the student treated the AI as a tool to *aid* understanding, not just a source of answers.

---
title: "Staff Answer Guide: Exploring Code Paradigms: Procedural vs Object-Oriented in Python"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


## Introduction & Key Concepts
This guide provides solutions and evaluation points for the student worksheet comparing procedural and object-oriented programming (OOP) paradigms in Python.
Ensure students can differentiate the core ideas:

* **Procedural Programming:** Focuses on sequences of instructions grouped into functions/procedures. Data tends to be separate from the functions that operate on it.
* **Object-Oriented Programming (OOP):** Focuses on bundling data (attributes) and behavior (methods) together into objects created from class blueprints.
* **Class:** The template/blueprint (e.g., the `Triangle` definition).
* **Object:** A specific instance created from the class (e.g., `my_triangle`).

## Application Activities

### Activity 1: Identifying Paradigms in Real Code

**Scenario Code:**
```python
def calculate_area(base, height):
    return 0.5 * base * height

area = calculate_area(5, 10)
print("Area:", area)
```

**Expected Response:**

* **Paradigm:** Procedural Programming.
* **Justification:**
    * The code is organised around a function (`calculate_area`) that performs a specific task.
    * Data (`base`, `height`, `area`) is defined separately and passed into the function.
    * There are no classes or objects being defined or used. The focus is on the *procedure* (the function call) rather than on objects having state and behavior.

**Evaluation Notes:**

* The student must correctly identify the paradigm as procedural.
* The justification should mention the use of functions, the separation of data and functions, and the absence of classes/objects.

### Activity 2: Refactoring to OOP

**Task:** Convert the procedural code to an OOP structure using a `Triangle` class.

**Expected Code:**

```python
# Procedural code (for reference)
# def calculate_area(base, height):
#     return 0.5 * base * height
# area = calculate_area(5, 10)
# print("Area:", area)

# Refactor to OOP below

class Triangle:
    """
    Represents a triangle with a base and height,
    and can calculate its area.
    """
    def __init__(self, base, height):
        """
        Initialises a Triangle object with base and height.
        Args:
            base (float/int): The base length of the triangle.
            height (float/int): The height of the triangle.
        """
        self.base = base     # Store base as an instance attribute
        self.height = height # Store height as an instance attribute

    def calculate_area(self):
        """
        Calculates the area of the triangle using its base and height.
        Returns:
            float: The calculated area.
        """
        # Method uses the object's own attributes (self.base, self.height)
        return 0.5 * self.base * self.height

# --- Using the OOP approach ---
# 1. Create an instance (object) of the Triangle class
my_triangle = Triangle(5, 10)

# 2. Call the method on the object to perform the calculation
area_oop = my_triangle.calculate_area()

# 3. Print the result
print("OOP Area:", area_oop)
```

**Expected Output:**
```
OOP Area: 25.0
```

**Evaluation Notes:**

* Check for correct class definition syntax (`class Triangle:`).
* Verify the `__init__` method initialises `base` and `height` as instance attributes (`self.base`, `self.height`).
* Ensure the `calculate_area` method is defined within the class, takes `self`, and uses `self.base` and `self.height`.
* Check that an instance of `Triangle` is created (`my_triangle = Triangle(...)`).
* Verify the `calculate_area` method is called correctly on the instance (`my_triangle.calculate_area()`).

### Extension Task: Enhance the Triangle Class

**Task:** Add perimeter calculation and input validation to the `Triangle` class. *Note: Calculating the perimeter requires the lengths of the three sides. The area calculation uses base and height. For simplicity, we'll add three side attributes alongside base and height, and validate all. Acknowledge that for a general triangle, base/height aren't sufficient alone for perimeter, and side lengths aren't sufficient alone for the area formula used.*

**Expected Code:**

```python
import math # Needed for more complex area if using sides, but sticking to original area formula here.

class Triangle:
    """
    Represents a triangle with base, height, and three side lengths.
    Includes methods for area and perimeter calculation, and input validation.
    """
    def __init__(self, base, height, side1, side2, side3):
        """
        Initialises a Triangle object with dimensions and side lengths.

        Args:
            base (float/int): The base length (for area calc).
            height (float/int): The height (for area calc).
            side1 (float/int): Length of the first side (for perimeter/validation).
            side2 (float/int): Length of the second side (for perimeter/validation).
            side3 (float/int): Length of the third side (for perimeter/validation).

        Raises:
            ValueError: If any dimension/side is not positive, or if sides
                      do not form a valid triangle (triangle inequality).
        """
        # Input Validation
        if not all(isinstance(val, (int, float)) and val > 0 for val in [base, height, side1, side2, side3]):
            raise ValueError("Base, height, and all sides must be positive numbers.")

        # Triangle Inequality Check (sum of any two sides must be greater than the third)
        if not (side1 + side2 > side3 and side1 + side3 > side2 and side2 + side3 > side1):
            raise ValueError("The given side lengths do not form a valid triangle.")

        # Assign attributes if validation passes
        self.base = base
        self.height = height
        self.side1 = side1
        self.side2 = side2
        self.side3 = side3
        # Note: We store base/height and sides separately as per the task evolution.
        # In a real-world scenario, you might derive some from others if possible
        # (e.g., for a right triangle) or use formulas like Heron's for area from sides.

    def calculate_area(self):
        """
        Calculates the area using base and height.
        Returns:
            float: The calculated area.
        """
        return 0.5 * self.base * self.height

    def calculate_perimeter(self):
        """
        Calculates the perimeter using the three side lengths.
        Returns:
            float: The calculated perimeter.
        """
        return self.side1 + self.side2 + self.side3

# --- Testing the Enhanced Class ---
try:
    # Example valid triangle (e.g., a 3-4-5 right triangle, base=3, height=4)
    valid_triangle = Triangle(base=3, height=4, side1=3, side2=4, side3=5)
    print(f"Valid Triangle - Area: {valid_triangle.calculate_area()}")
    print(f"Valid Triangle - Perimeter: {valid_triangle.calculate_perimeter()}")

    # Example invalid triangle (violates triangle inequality)
    print("\nAttempting to create invalid triangle (sides 1, 2, 5):")
    invalid_triangle_sides = Triangle(base=1, height=1, side1=1, side2=2, side3=5)

except ValueError as e:
    print(f"Error creating triangle: {e}")

try:
    # Example invalid input (non-positive value)
    print("\nAttempting to create triangle with non-positive side:")
    invalid_triangle_input = Triangle(base=3, height=4, side1=3, side2=4, side3=-5)

except ValueError as e:
    print(f"Error creating triangle: {e}")
```

**Expected Output:**
```
Valid Triangle - Area: 6.0
Valid Triangle - Perimeter: 12.0

Attempting to create invalid triangle (sides 1, 2, 5):
Error creating triangle: The given side lengths do not form a valid triangle.

Attempting to create triangle with non-positive side:
Error creating triangle: Base, height, and all sides must be positive numbers.
```

**Evaluation Notes:**

* Check `__init__` includes parameters for sides (`side1`, `side2`, `side3`).
* Verify input validation logic:
    * Checks if inputs are numeric and positive.
    * Checks the triangle inequality theorem.
    * Raises `ValueError` appropriately.
* Ensure the `calculate_perimeter` method is correctly implemented using `self.side1`, `self.side2`, `self.side3`.
* Check the example usage demonstrates both successful creation/method calls and catches validation errors using `try...except`.
* Comments explaining the structure (especially the separate handling of base/height for area and sides for perimeter) are a plus.

## Reflection

**Objective:** Evaluate the student's synthesis of the concepts, self-awareness of AI tool usage, and commitment to academic integrity.

**Evaluation Guidance:**
Focus on the depth and specificity of the answers.

* **Reflect on how you might use the knowledge of different programming paradigms in your future projects.**
    * Look for understanding of trade-offs. When might procedural be suitable (simple scripts, linear workflows, performance-critical loops)? When is OOP better (modeling complex entities, code reuse via inheritance/polymorphism, large projects needing organisation, GUI development)? Specific examples strengthen the response.
* **Discuss how you used AI tools during this activity and evaluate their effectiveness.**
    * Encourage specific examples related to the tasks: "Asked AI for syntax to define a class," "Asked AI how to refactor the function into a method," "Used AI to generate ideas for input validation," "Asked AI to explain the difference between procedural and OOP with examples."
    * Evaluation: Was the AI helpful? Did it provide correct information? Was it easy to integrate its suggestions? This shows engagement with the **Learning Partner** aspect.
* **Describe how you ensured the integrity of your work when using AI suggestions.**
    * Look for actions demonstrating **Critical Evaluation** and **Transparency**. Examples: "I cross-referenced the AI's explanation with the worksheet/lecture notes," "I tested the code suggested by the AI to ensure it worked and I understood it," "I modified the AI's suggestion to fit the specific requirements of the task," "I treated the AI as a tutor to explain concepts, then wrote the code myself," "I noted where AI contributed significantly." Avoidance of simple copy-pasting should be evident.

---
title: "🌤️ Weather Question Parser Worksheet"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

> A beginner-friendly guide to parsing weather questions using pseudocode and LLMs

## Introduction

Natural Language Processing (NLP) lets computers understand human language. In this worksheet, we'll design a system that can understand weather questions like "Will it rain tomorrow in Sydney?" by extracting:

- **Location**: Sydney
- **Time Period**: tomorrow
- **Weather Attribute**: rain

## What You'll Learn

In this worksheet, you will:
1. Understand different approaches to natural language parsing
2. Learn how to effectively use reference documentation with LLMs
3. Design a weather parser using pseudocode
4. Practice intentional prompting with LLMs to convert your design to Python
5. Learn how to use AI as a thinking partner in development

## Assessment Connection

**Important:** The skills you develop in this worksheet directly relate to your upcoming assessment. In this unit, your AI conversations with LLMs will be assessed and weighted more heavily than the resulting code. This is because the ability to effectively prompt, question, and collaborate with AI tools is becoming a critical skill for developers.

The weather parser you create here will not only help you understand NLP concepts but also provide a useful component you can apply in your assignment. Pay special attention to the intentional prompting techniques, follow-up questioning, and your approach to teaching the LLM about the hands-on-ai package—these are exactly the skills your assessment will evaluate.

## Different Approaches to NLP

There are several ways to solve this problem:

1. **Keyword Matching**: Using pattern recognition to find important words
2. **Template Matching**: Comparing questions to pre-defined templates
3. **Traditional NLP**: Using specialized linguistic analysis libraries
4. **LLM Integration**: Using AI language models

For beginners, the LLM approach can be surprisingly accessible while giving excellent results!

## Step 1: Introducing the hands-on-ai Package

The hands-on-ai package provides tools to work with language models easily. You should have access to a reference guide (`hands_on_ai_llm_guide.txt`) that explains the package's features.

### Teaching the LLM About hands-on-ai

Before asking the LLM to help you implement your parser, you need to teach it about the hands-on-ai package:

1. Upload the `hands_on_ai_llm_guide.txt` reference document to your chat with the LLM
2. Use an initial prompt like this to help the LLM understand the context:

```
I've uploaded a reference guide for the hands-on-ai package. Please review it to understand the package's capabilities, especially the chat module that we'll use for building a weather question parser. After reviewing, please confirm you understand how the package works.
```

## Step 2: Understanding the Problem

Before writing any code, let's break down what we're trying to accomplish:

1. Take a natural language question about weather
2. Extract structured information (location, time, weather attribute)
3. Return this information in a consistent format

## Step 3: Designing Our Weather Parser (Pseudocode)

Let's design our solution in pseudocode:

```
FUNCTION ParseWeatherQuestion(question)
    // Create a prompt for the language model
    prompt = "Extract location, time period, and weather attribute from: " + question
    
    // Send prompt to language model using hands-on-ai
    response = SendToLanguageModel(prompt)
    
    // Convert response to structured format
    result = ParseJsonResponse(response)
    
    // Set default values for missing information
    IF result does not have "location" OR result["location"] is empty THEN
        result["location"] = none
    END IF
    
    IF result does not have "time_period" OR result["time_period"] is empty THEN
        result["time_period"] = "today"
    END IF
    
    IF result does not have "weather_attribute" OR result["weather_attribute"] is empty THEN
        result["weather_attribute"] = "general"
    END IF
    
    RETURN result
END FUNCTION
```

## Step 4: Converting Pseudocode to Python with Intentional Prompting

Now that you've designed your parser in pseudocode and taught the LLM about the hands-on-ai package, it's time to convert this design to Python code.

### 🧠 What Is Intentional Prompting?

**Intentional prompting** means you:
- Ask the AI to **explain** its reasoning
- Ask questions that lead to deeper understanding of Python concepts
- Refine and adapt prompts when the first response isn't quite right
- Know when to question, correct, or reject AI-generated code
- Use the AI as a **thinking partner**, not just a code generator

### Example Intentional Prompt

Here's an example of how to intentionally prompt an LLM to help convert our pseudocode to Python:

```
Now that you understand the hands-on-ai package, I'd like your help implementing a weather question parser. I have the following pseudocode design:

FUNCTION ParseWeatherQuestion(question)
    // Create a prompt for the language model
    prompt = "Extract location, time period, and weather attribute from: " + question
    
    // Send prompt to language model using hands-on-ai
    response = SendToLanguageModel(prompt)
    
    // Convert response to structured format
    result = ParseJsonResponse(response)
    
    // Set default values for missing information
    IF result does not have "location" OR result["location"] is empty THEN
        result["location"] = none
    END IF
    
    IF result does not have "time_period" OR result["time_period"] is empty THEN
        result["time_period"] = "today"
    END IF
    
    IF result does not have "weather_attribute" OR result["weather_attribute"] is empty THEN
        result["weather_attribute"] = "general"
    END IF
    
    RETURN result
END FUNCTION

Please help me convert this to Python code using the hands-on-ai package. In your response:

1. First, explain which specific functions from the hands-on-ai.chat module would work best for parsing weather questions
2. Show me how to improve the prompt to get better structured data (JSON)
3. Write the Python implementation with comments explaining each step
4. Explain any potential errors and how to handle them
5. Suggest a simple way to test the function

After seeing your implementation, I want to understand WHY you made certain choices, not just copy the code.
```

## Step 5: Follow-up Questions for Deeper Understanding

After receiving the LLM's implementation, ask follow-up questions to deepen your understanding:

```
Thank you for the implementation. I have some follow-up questions:

1. I notice you used the get_response function from hands-on-ai.chat. Would using one of the personality bots like teacher_bot or coder_bot give better results for parsing? Why or why not?

2. Could we improve the error handling? What specific types of errors might occur when parsing JSON from an LLM response?

3. How would you modify this implementation to handle more complex weather questions like "Will I need sunscreen and a hat this weekend at the beach?" that contain multiple weather attributes?

4. If we wanted to make this part of a complete weather application, what would be the next step after parsing the question?
```

This type of follow-up demonstrates intentional prompting - you're asking "why" questions and exploring improvements rather than just accepting the first solution.

## Step 6: Experiments and Reflection

Once you have your implementation, test it with these questions:

- "Will it rain tomorrow in Sydney?"
- "What's the temperature in Tokyo today?"
- "Do I need an umbrella in London this weekend?"
- "Is it going to be windy in Chicago?"
- "How cold will it be in New York tomorrow?"

**Reflection Questions:**
1. How well did the LLM understand your pseudocode design?
2. What improvements did the LLM suggest to your original design?
3. What errors or edge cases did you encounter?
4. How could you further improve the prompt to get more accurate parsing?

## For Advanced Users: Exploring Advanced Techniques

If you're comfortable with the basic implementation, try exploring these advanced concepts:

### Using Custom Bots for Specialized Parsing

The hands-on-ai package allows creating custom bots with specific personalities and system prompts. Ask the LLM how you could create a specialized "weather parser bot" using code like this pseudocode:

```
FUNCTION CreateWeatherBot()
    // Create specialized bot for weather parsing
    SET system_prompt = "You are an expert at extracting structured data from weather questions."
    SET personality = "technical"
    
    RETURN CustomBot with system_prompt and personality
END FUNCTION
```

### Adding Schema Validation

For more reliable parsing, consider asking the LLM about adding schema validation to your implementation:

```
I'd like to ensure the parsed data always matches a specific structure. How could I use Python's data validation tools to ensure my weather query results always contain valid location, time_period, and weather_attribute fields? Please explain the concept and show me an example.
```

### Using the Agent Module for Complex Weather Questions

The hands-on-ai package includes an "agent" module with tools for multi-step reasoning. Ask the LLM how you might use this for more complex weather analysis:

```
Looking at the hands-on-ai reference guide, I see there's an "agent" module with tools for multi-step reasoning. How could I use this to handle more complex weather questions that might require calculations or conversions, like "Will it be warmer tomorrow in New York than it was yesterday in Boston?"
```

## Key Takeaways

1. LLMs make complex NLP tasks accessible to beginners
2. Pseudocode helps design solutions before jumping into implementation
3. Intentional prompting transforms AI from a code generator to a thinking partner
4. Reference documentation can be uploaded to LLMs to help them understand specific libraries
5. Follow-up questions deepen understanding and improve solutions

## Exercises

1. **Basic**: 
   - Upload the hands-on-ai reference guide and ask the LLM to explain which parts are most relevant for weather parsing
   - Create an intentional prompt to add one more field to extract from weather questions

2. **Intermediate**: 
   - Write pseudocode for a command-line interface for your parser
   - Ask the LLM to compare using the chat module versus the agent module for this task

3. **Challenge**: 
   - Design pseudocode for connecting your parser to a weather API
   - Ask the LLM to help implement a custom weather bot that can both parse questions and answer them using sample weather data

## Teaching LLMs About Domain-Specific Tools

This worksheet demonstrates a powerful approach to learning: using LLMs as collaborative learning partners by teaching them about specific tools and packages. You can apply this same approach to other domains by:

1. Finding or creating a reference document about your tool/library
2. Uploading it to the LLM
3. Using intentional prompting to ask the LLM to help you understand and use the tool
4. Following up with deeper questions to explore advanced features

## Resources

- Hands-On AI Documentation (from the reference guide you uploaded)
- [Effective Prompting Strategies for LLMs](https://example.com/prompting)
- [Python JSON and Error Handling](https://example.com/python-json)
---
title: "Unlocking Object-Oriented Programming: Simplifying Complexity"
subtitle: "A Beginner's Guide to the Foundations of OOP"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


# Introduction to Object-Oriented Programming

* What is Object-Oriented Programming (OOP)?
* Why is OOP important in modern software development?
* Overview of key OOP concepts: Classes and Objects

::: {.notes}
Welcome to the intriguing world of Object-Oriented Programming! OOP is a programming paradigm based on the concept of "objects", which can contain data in the form of fields (often known as attributes or properties), and code, in the form of procedures (often known as methods). This approach is crucial in modern software development because it helps organise software design, making it easier to manage and modify. Today, we’ll explore the foundational concepts that make OOP a preferred choice among programmers for developing robust and scalable applications.
:::

# Understanding Classes and Objects

* Definition of a Class
* Definition of an Object
* How Classes and Objects interact

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

my_dog = Dog("Rex", 5)
```

::: {.notes}
In Object-Oriented Programming, a class is like a blueprint for creating objects. An object is an instance of a class. When the class is defined, no memory is allocated, but when it's instantiated, a piece of memory is allocated to accommodate the object. For instance, in Python, the 'Dog' class creates a 'Dog' object with attributes like name and age. This demonstrates how classes and objects interact: the class provides the structure, and the object provides the actual content.
:::

# Key Principles of OOP: Encapsulation

* What is Encapsulation?
* Why Encapsulation is vital
* Example of Encapsulation

```python
class Account:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.__balance = balance  # Private attribute

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print("Deposit successful")
```

::: {.notes}
Encapsulation is one of the fundamental concepts in OOP. It refers to the bundling of data with the methods that operate on that data. Encapsulation hides the internal state of an object from the outside world and only allows modification through a set of public methods. This is crucial as it prevents external entities from tampering with the internal state, thus ensuring data integrity and security. The example above shows a bank account where the balance is kept private, safely encapsulated within the class.
:::

# Key Principles of OOP: Inheritance

* What is Inheritance?
* Benefits of using Inheritance in OOP
* Example of Inheritance

```python
class Animal:
    def __init__(self, name):
        self.name = name

class Dog(Animal):
    def speak(self):
        return "Woof!"
```

::: {.notes}
Inheritance is a mechanism in OOP that allows a new class to inherit properties and methods from an existing class. The primary benefit of inheritance is reusability—you can create a new class based on an existing class without modifying it, thus promoting code reusability and redundancy reduction. The example demonstrates a 'Dog' class inheriting from an 'Animal' class, acquiring its attributes and potentially adding or modifying others, like the 'speak' method.
:::

# Key Principles of OOP: Polymorphism

* What is Polymorphism?
* Why it enhances flexibility
* Example of Polymorphism

```python
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"
```

::: {.notes}
Polymorphism in OOP allows objects of different classes to be treated as objects of a common superclass. It enhances flexibility and integration by allowing the same interface to be used for different underlying forms (data types). This means that a single function can interact with different data types, as shown in the example where both 'Dog' and 'Cat' classes override the 'speak' method of their superclass 'Animal' to perform class-specific functionality.
:::

# Comparing Procedural vs OOP

* Definition of Procedural Programming
* Key differences between Procedural and OOP
* Advantages of OOP over Procedural

::: {.notes}
Procedural programming is a programming paradigm based upon the concept of procedure calls, where procedures (also known as routines, subroutines or functions) contain a series of computational steps to be carried out. In contrast, OOP organises software design around data, or objects, rather than functions and logic. The main advantage of OOP over procedural programming is that it is more modular and allows for classes to be reused in different programs, thereby reducing redundancy and making maintenance easier.
:::

# Applying OOP Concepts: A Python Example

* Design a simple class-based system in Python
* Demonstrate encapsulation, inheritance, and polymorphism

```python
# Simple Bank Account Class
class Account:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.__balance = balance

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print("Deposit successful")

class SavingsAccount(Account):
    def __init__(self, owner, balance=0, interest_rate=0.01):
        super().__init__(owner, balance)
        self.interest_rate = interest_rate

    def apply_interest(self):
        self.__balance += self.__balance * self.interest_rate
```

::: {.notes}
The above example illustrates a practical implementation of OOP concepts in Python. A 'SavingsAccount' class inherits from a general 'Account' class and adds a specific attribute and method related to the interest rate. This shows encapsulation (private balance), inheritance (inherits from Account), and polymorphism (method overriding for specific functionalities). Such implementations demonstrate the power and flexibility of OOP in designing real-world applications.
:::

# Conclusion: Embracing OOP for Better Software Design

* Recap of the key OOP concepts and their benefits
* How OOP can lead to more efficient and manageable code
* Encouragement to explore further with more complex projects

::: {.notes}
Today, we've explored the essential principles of Object-Oriented Programming and how they form the backbone of modern software design. By understanding and implementing classes, encapsulation, inheritance, and polymorphism, you can create more efficient, scalable, and manageable code. I encourage you to apply these principles in your projects and continue exploring more complex OOP scenarios to truly master this powerful programming paradigm.
:::---
title: "From Procedural to Object-Oriented: A Refactoring Journey"
subtitle: "Mastering Python's OOP Features for Better Software Design"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


# Introduction to Refactoring

* Understanding the need for refactoring
* Procedural vs Object-Oriented Programming
* Benefits of moving to Object-Oriented Code

::: {.notes}
Welcome to our session on refactoring procedural code to object-oriented code in Python. Refactoring involves modifying the code to improve its structure without changing its functionality. This process is crucial for maintaining code efficiency and readability as projects grow. Today, we'll explore why and how to transition from a procedural to an object-oriented approach, which promotes modularity and reusability in programming.
:::

# What is Object-Oriented Programming?

* Definition of Object-Oriented Programming (OOP)
* Core concepts: Classes, Objects
* Encapsulation, Inheritance, and Polymorphism

::: {.notes}
Object-Oriented Programming (OOP) is a programming paradigm based on the concept of "objects", which can contain data in the form of fields (often known as attributes), and code, in the form of procedures (often known as methods). OOP allows programmers to create modules that can be reused across different programs. The three pillars of OOP—encapsulation, inheritance, and polymorphism—help in building secure and robust programs.
:::

# Analysing a Procedural Code Example

* Typical structure of procedural code
* Example: Weather Dashboard procedural implementation
* Limitations in scalability and maintenance

::: {.notes}
Let's start with a procedural code example from a typical Weather Dashboard application. This code is linear and function-based, which can make it harder to manage as it grows. Procedural code often becomes more complex and difficult to maintain as new features are added. This complexity can lead to errors and reduce the code's overall reliability.
:::

# Introducing Classes and Objects

* Converting procedural code into classes
* Defining attributes and methods
* Example: Refactoring Weather Dashboard

::: {.notes}
To refactor our procedural code, we begin by identifying natural groupings of data and functions, which can be transformed into classes and objects. For instance, a 'Weather' class could encapsulate attributes like temperature and humidity, along with methods to compute forecast details. This encapsulation makes the code more organized and readable.
:::

# Implementing Inheritance

* What is inheritance?
* Benefits of using inheritance in refactoring
* Example: Extending the Weather class

::: {.notes}
Inheritance is a powerful feature of OOP that allows a new class to inherit attributes and methods from an existing class. In our Weather Dashboard, we might have a general 'Weather' class and specialised classes like 'RainyWeather' or 'SunnyWeather' that inherit from it. This approach reduces redundancy and enhances the clarity of the code structure.
:::

# Exploring Polymorphism

* Concept of polymorphism in OOP
* How polymorphism enhances flexibility
* Example: Different display methods for weather conditions

::: {.notes}
Polymorphism gives us the flexibility to call the same method on different objects and have each of them respond in a unique way. In the context of our Weather Dashboard, polymorphism allows different weather classes to use a common interface for displaying information, which the specific class can override to reflect different weather conditions appropriately.
:::

# Case Study: Refactoring in Action

* Step-by-step refactoring process
* Before and after code comparison
* Challenges faced and how they were resolved

::: {.notes}
Now, let's look at a practical refactoring case study. We'll take a procedural version of the Weather Dashboard and step through its transformation into an OOP design. This will include creating classes, implementing inheritance, and utilising polymorphism. We'll also discuss the challenges encountered during refactoring, such as integrating legacy code and testing changes.
:::

# Benefits of OOP Refactoring

* Improved code readability and maintenance
* Enhanced ability to extend and manage large applications
* Facilitates teamwork and code reuse

::: {.notes}
Refactoring to OOP offers numerous benefits. The code becomes easier to understand, which simplifies maintenance. It's also more scalable, making it easier to extend with new features without disrupting existing functionality. Additionally, OOP's modular nature enhances teamwork by allowing developers to work on different modules simultaneously without conflict.
:::

# Conclusion and Next Steps

* Review of key concepts and benefits
* Encouragement to practice refactoring
* Resources and further learning

::: {.notes}
To summarise, refactoring from procedural to object-oriented code in Python enhances code quality and development efficiency. We encourage you to apply these concepts to refactor your own projects. Continue your learning journey with further resources like Python’s official documentation on classes and real-world examples from sites like Real Python.
:::---
title: "Unlocking OOP: Mastering Inheritance and Polymorphism"
subtitle: "A Beginner’s Guide to Structuring Code Efficiently"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to Inheritance and Polymorphism

* Understanding the pillars of Object-Oriented Programming (OOP)
* Defining inheritance and polymorphism
* Importance in software development

::: {.notes}
Welcome to our exploration of Object-Oriented Programming, focusing on two fundamental concepts: inheritance and polymorphism. These concepts are vital for creating modular and reusable code that is easier to manage and extend. In this session, you'll learn how these principles can help streamline your coding projects and make your software designs more efficient and adaptable.
:::

# What is Inheritance?

* A mechanism to create new classes using existing classes
* Reduces redundancy and increases reusability
* Example: Creating a 'Car' class from a 'Vehicle' class

::: {.notes}
Inheritance is a powerful feature of OOP that allows a new class to inherit attributes and methods from an existing class. For instance, if you have a 'Vehicle' class, you can create a 'Car' class that inherits properties like wheels and engine from 'Vehicle'. This inheritance mechanism prevents the need to rewrite code and enhances reusability.
:::

# What is Polymorphism?

* Concept of using a unified interface to operate on objects of different classes
* Enables flexibility in programming
* Example: Calling the .drive() method on a 'Car' or 'Bike' object

::: {.notes}
Polymorphism allows different classes to be treated through the same interface, highlighting one of the key strengths of OOP: flexibility. An example of polymorphism is having a generic .drive() method that can be applied to different types of vehicles like 'Car' and 'Bike', which might implement this method in slightly different ways but achieve the same type of functionality.
:::

# Benefits of Using Inheritance

* Simplifies and reduces the complexity of code
* Enhances the clarity of the programming structure
* Promotes code reusability and maintenance

::: {.notes}
Using inheritance in programming not only simplifies your codebase by reducing redundancy but also clarifies the structure of your programs. It promotes greater code reusability, which is a significant advantage when maintaining and updating systems. This can lead to more robust and error-free code.
:::

# Benefits of Using Polymorphism

* Increases the flexibility of code
* Simplifies code management and extension
* Facilitates adding new features without altering existing code

::: {.notes}
Polymorphism enhances the flexibility of your code by allowing the use of a single interface to interact with different data types. This simplifies management and extension of code, particularly when new features need to be added or when the system needs to evolve with minimal changes to the existing codebase.
:::

# Practical Example: Inheritance

```python
class Vehicle:
    def start(self):
        print("Engine start")

class Car(Vehicle):
    def open_trunk(self):
        print("Trunk opened")

# Use Car
my_car = Car()
my_car.start()  # Inherited method
my_car.open_trunk()  # New method
```

::: {.notes}
This Python code demonstrates how the 'Car' class inherits from the 'Vehicle' class. The 'Car' class can use the 'start' method defined in 'Vehicle', demonstrating reusability, and it also has its own method 'open_trunk'. This example illustrates how inheritance can be practically applied in programming to enhance functionality and reduce code duplication.
:::

# Practical Example: Polymorphism

```python
class Vehicle:
    def drive(self):
        print("Vehicle driving")

class Car(Vehicle):
    def drive(self):
        print("Car driving fast")

class Bike(Vehicle):
    def drive(self):
        print("Bike driving on a trail")

# Polymorphic use
vehicles = [Car(), Bike()]
for vehicle in vehicles:
    vehicle.drive()
```

::: {.notes}
In this example, both 'Car' and 'Bike' classes override the 'drive' method of the 'Vehicle' class. When calling 'drive' on each object within the loop, the appropriate class-specific method is executed, demonstrating polymorphism. This allows each class to implement an action in a way that's appropriate for its context.
:::

# Conclusion

* Recap of inheritance and polymorphism
* Their roles in clean, efficient, and reusable code
* Encouragement to apply these concepts in your projects

::: {.notes}
Today, we've uncovered the essentials of inheritance and polymorphism, two pillars of Object-Oriented Programming that make our code more efficient, clean, and reusable. As you continue developing your programming skills, try to incorporate these concepts into your projects, particularly in scenarios where code reusability and flexibility are crucial.
:::

# Further Learning and Resources

* Explore Python's official documentation on classes
* Delve into further studies with real-world projects
* Use resources like Real Python for deeper understanding

::: {.notes}
To further your understanding of inheritance and polymorphism, I recommend exploring additional resources such as Python's official documentation and tutorials from Real Python. Practical application through projects will also greatly enhance your grasp of these concepts. Keep learning and experimenting to become proficient in these essential OOP techniques.
:::---
title: "Module 3: Computational Thinking and Algorithm Design"
subtitle: "Breaking Down Problems and Designing Effective Solutions"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Module 3: Computational Thinking and Algorithm Design

Welcome to Module 3. In this module, we explore how to break down complex problems into manageable steps and design effective algorithms. These skills are key to building our User Preferences project and serve as the foundation for all programming.

::: {.notes}
This module introduces the fundamental concepts of computational thinking and algorithm design, which form the foundation for problem-solving in computer science. We will explore the process of breaking down complex problems into manageable steps, allowing us to develop efficient and effective solutions.

Throughout this module, we will learn how to utilise pseudocode as a planning tool, enabling us to outline our algorithms before diving into the actual coding process. By following a simplified development methodology, we will gain hands-on experience in applying computational thinking principles to real-world scenarios, empowering us to tackle a wide range of programming challenges.
:::

# What is Computational Thinking?

- It is the process of breaking problems into smaller, manageable parts.
- It involves recognising patterns and organising steps logically.
- This mindset helps you devise clear, step-by-step solutions.
- In our User Preferences project, computational thinking guides the way we capture and process user data.

::: {.notes}
Computational thinking is a problem-solving approach that involves breaking complex problems into smaller, more manageable parts. By recognising patterns and organising steps logically, we can develop clear, step-by-step solutions to these problems. This mindset is particularly useful in the field of computer science, where it helps us to create efficient and effective algorithms.

In our User Preferences project, computational thinking plays a crucial role in guiding the way we capture and process user data. By breaking down the process into smaller, well-defined steps, we can ensure that our solution is both accurate and efficient. This approach allows us to identify potential issues early on and develop a robust solution that meets the needs of our users.
:::

# Breaking Problems into Steps

- Divide a complex problem into simple, individual tasks.
- Tackle each task one at a time.
- For example, a User Preferences programme can be split into:
  - Collecting user input.
  - Processing the data.
  - Displaying a personalised output.

::: {.notes}
Breaking complex problems into smaller, manageable tasks is a key aspect of computational thinking. By dividing a problem into simple, individual steps, you can tackle each task one at a time, making the overall problem less overwhelming. This approach allows you to focus on solving each sub-problem independently, which can lead to a more efficient and effective solution.

To illustrate this concept, consider the example of creating a User Preferences programme. Instead of trying to solve the entire problem at once, you can split it into three main tasks: collecting user input, processing the data, and displaying a personalised output. By addressing each task separately, you can develop a clear plan of action and write code that is more organised and easier to debug. This step-by-step approach forms the foundation of algorithm design and is essential for creating well-structured, efficient programs.
:::

# Pseudocode: Your Planning Tool

- Pseudocode is an informal way to plan your solution without worrying about syntax.
- It lets you outline the logic before writing actual Python code.
- Example for our User Preferences project:
  ```
  Prompt user for name
  Prompt user for favourite colour
  Display personalised greeting using name and colour
  ```
- This step helps you visualise the programme structure clearly.

::: {.notes}
Pseudocode is a valuable tool for planning and outlining the logic of your solution before diving into writing actual Python code. It allows you to focus on the problem-solving process and structure of your programme without getting bogged down in syntax details. By using pseudocode, you can break down the problem into manageable steps and clearly visualise the flow of your programme.

Let's look at an example of how pseudocode can be applied to our User Preferences project. By writing out the high-level steps and logic in plain language, we can map out the key components and flow of the programme. This planning process helps identify any potential issues or areas that need further clarification before starting to code. Once you have a solid pseudocode outline, translating it into Python becomes a more straightforward task.
:::

# Simplified Development Methodology

Our six-step process to design a programme:

1. **Understand the problem:** Restate it in your own words.
2. **Identify the input and output:** Determine what information is needed and what the programme should produce.
3. **Work the problem by hand:** Solve a small example manually.
4. **Write the pseudocode:** Outline the logical steps to solve the problem.
5. **Convert the pseudocode to Python:** Translate your outline into working code.
6. **Test with a variety of data:** Ensure your solution works under different scenarios.

::: {.notes}
The Simplified Development Methodology breaks down the process of solving problems using computational thinking into four key stages: planning, implementation, testing, and evaluation. It provides a structured approach to guide programmers through the development lifecycle, from analysing the problem and designing a solution, to writing code, testing it thoroughly, and refining the solution based on feedback.

By following this methodology, programmers can tackle complex problems in a systematic and organised manner. The planning stage involves understanding the problem, identifying inputs and outputs, and creating a high-level solution using tools like pseudocode or flowcharts. Implementation focuses on translating the plan into working code, while testing ensures the solution performs as expected and handles edge cases. Finally, evaluation allows for reflection on the solution's effectiveness and identification of areas for improvement, fostering continuous learning and growth as a programmer.
:::

# Hands-On Activity

**Task:**  
- Write pseudocode for your User Preferences project using the six-step methodology.
- Begin by restating the problem in your own words.
- Identify the inputs (e.g. name, favourite colour) and the desired output (a personalised greeting).
- Work through an example by hand.
- Write your pseudocode outlining each step.
- Discuss your pseudocode with a peer and refine your approach before converting it to Python in a future session.

::: {.notes}
In this hands-on activity, students will apply the six-step methodology to write pseudocode for their User Preferences project. They should begin by restating the problem in their own words, ensuring they have a clear understanding of the task at hand. Next, they will identify the required inputs, such as the user's name and favourite colour, and the desired output, which is a personalised greeting.

Students will then work through an example manually, step by step, to gain a practical understanding of the process. Following this, they will write their pseudocode, outlining each step in a clear and logical manner. Finally, students will discuss their pseudocode with a peer, providing an opportunity for feedback and refinement before they convert their pseudocode into Python code in a future session.
:::

---
title: "Module 2: Using Input and Output in Python"
subtitle: "Speak and Listen: Empowering Your Programmes with Interactive Input and Output"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Module Overview

Welcome to Module 2. In this module, we explore how to interact with users through Python. We will learn how to capture user input using the `input()` function and display output with `print()`. These skills are essential for our User Preferences project.

::: {.notes}
This module introduces the fundamental concepts of input and output in Python programming. We will explore the `input()` function for capturing user input and the `print()` function for displaying output to the console. The module also covers techniques for formatting output using the `print()` function to create well-organised and visually appealing text.

Throughout the module, we will engage in hands-on activities to reinforce the concepts covered in each section. By the end of this module, you will have a solid understanding of how to interact with users through input and output operations in Python, enabling you to create more interactive and dynamic programs.
:::

# The `input()` Function: Overview

- The `input()` function allows you to receive user input as text.
- It displays a prompt message, pauses the programme, and waits for the user’s response.
- All input received is in the form of a string.
- Example:  
  ```python
  name = input("What is your name? ")
  ```

::: {.notes}
The `input()` function is a powerful tool in Python that enables developers to receive user input as text. When called, it displays a prompt message to the user, pauses the program execution, and waits for the user to enter a response. This function is particularly useful for creating interactive programs that require user participation.

It's important to note that all input received through the `input()` function is treated as a string, regardless of the type of data entered by the user. This means that if you require numerical input, you'll need to explicitly convert the received string to the appropriate data type, such as an integer or float, using functions like `int()` or `float()`. The slide also mentions that an example will be provided to demonstrate the usage of the `input()` function.
:::

# Capturing and Storing User Input

- Storing input in a variable lets you re-use the information.
- You can prompt the user with clear, concise messages.
- Consider the following example:  
  ```python
  favourite_colour = input("What is your favourite colour? ")
  ```
- This information will later be used to personalise outputs in our project.

::: {.notes}
Storing user input in a variable allows for reusability and flexibility in your program. By assigning the captured input to a variable, you can access and manipulate that information at any point in your code. This enables you to personalise outputs, perform calculations, or make decisions based on the user's input. It's important to provide clear and concise prompts to guide the user and ensure they understand what information is expected from them.

Let's consider an example where we prompt the user to enter their name and store it in a variable called `name`. We can then use that variable to display a personalised greeting, such as "Hello, [name]! Welcome to our program." This demonstrates how capturing and storing user input can enhance the interactivity and customisation of your program. Throughout our project, we will leverage this technique to create a more engaging and tailored experience for the user.
:::

# The `print()` Function: Displaying Output

- The `print()` function outputs information to the screen.
- It can display strings, variables, and results of operations.
- Example:  
  ```python
  print("Hello, " + name + "!")
  ```
- This helps to create personalised messages for the user.

::: {.notes}
The `print()` function is a fundamental tool in Python for displaying output to the user. It can handle a variety of data types, including strings, variables, and the results of operations, making it a versatile and essential part of any Python program. By using `print()`, developers can provide clear and informative messages to guide users through their applications.

One of the key benefits of the `print()` function is its ability to create personalised messages for the user. By incorporating variables and other dynamic content into the output, programs can generate tailored responses based on user input or other factors. This helps to make the user experience more engaging and interactive, encouraging users to continue interacting with the application.
:::

# Formatting Output with `print()`

- You can combine text and variables using:
  - String concatenation.
  - Comma-separated items (which adds spaces automatically).
- Example using commas:  
  ```python
  print("Hello,", name)
  ```
- These methods allow you to format your output neatly and clearly.

::: {.notes}
You can combine text and variables in `print()` statements using string concatenation or comma-separated items. String concatenation involves joining strings and variables using the `+` operator, while using commas automatically adds spaces between the items. For example, `print("Hello,", name)` would display "Hello, [name]" with a space after the comma.

Formatting your output with `print()` allows you to present information clearly and neatly. By combining text and variables effectively, you can create meaningful and readable output messages. This is particularly useful when displaying user-provided input, results from calculations, or any other dynamic content in your program.
:::

# Hands-On Activity: Basic Input and Output

**Task:** Create a simple programme that:
- Asks the user for their name.
- Asks for their favourite colour.
- Displays a personalised message that incorporates both inputs.

**Instructions:**
1. Use `input()` to capture the user's name and favourite colour.
2. Store the responses in variables.
3. Use `print()` to output a message, for example:  
   > "Hi [name], it's great to know your favourite colour is [colour]!"

::: {.notes}
This hands-on activity reinforces the concepts of basic input and output in Python. The activity involves asking the user for their name and favourite colour using the `input()` function, and then storing those values in variables.

The activity then demonstrates how to use the `print()` function to display a personalised message that incorporates both the user's name and favourite colour. This serves as a practical example of how to combine user input with output formatting to create a custom, interactive experience.
:::

# Additional Considerations

- Remember that every input is received as a string.  
- Think about how you might use this information in your User Preferences project.
- In future modules, we will explore converting input into other types and further refining output formatting.

::: {.notes}
When capturing user input with the `input()` function, it's important to remember that the entered data is always received as a string, regardless of whether the user enters text, numbers, or other characters. This means that if you require the input to be used as a different data type, such as an integer or float, you will need to explicitly convert it using functions like `int()` or `float()`.

In the upcoming User Preferences project, you may find yourself needing to store and manipulate user-entered data. By keeping in mind that input is received as strings, you can plan accordingly and incorporate the necessary type conversions to ensure your program processes the data correctly. As we progress through future modules, we will explore techniques for converting input into other data types and learn how to further customize the formatting of output using the `print()` function.
:::

# Summary

- You have learned how to capture user input using `input()` and display information with `print()`.
- These functions form the basis of interactive programmes.
- Apply these skills in your User Preferences project to create engaging, personalised user experiences.

::: {.notes}
In this slide, we summarise the key takeaways from the module on capturing user input with `input()` and displaying information using `print()`. These functions are fundamental building blocks for creating interactive programmes that engage users and provide personalised experiences. By mastering these skills, you'll be well-equipped to gather valuable data from users and present meaningful output.

As you work on your User Preferences project, apply the techniques covered in this module to craft programmes that dynamically respond to user input. Experiment with different prompts and formatting options to make your output more visually appealing and informative. Remember, effective communication between your programme and the user is crucial for creating successful applications that meet user needs and expectations.
:::

---
title: "Module 1: Understanding Data, Values, and Data Types"
subtitle: "Data Demystified: Unlocking the Building Blocks of Your Digital World"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Module Overview

In this module we will:
- Define what data is.
- Explore basic data types in Python.
- Understand how variables store data.
- Connect these ideas to our User Preferences project.

::: {.notes}
This slide provides an overview of the module, outlining the key topics that will be covered. We'll start by defining what data is and exploring some real-life examples to help contextualise the concept. Then, we'll dive into the basic data types in Python, such as integers, floats, strings, and booleans, and see how they're used in practice.

Next, we'll learn about variables and how they store data in Python programs. We'll discuss naming conventions, assignment, and reassignment of values. Finally, we'll connect these ideas to our User Preferences project, demonstrating how the concepts covered in this module are applied in a practical setting. Throughout the module, there will be hands-on activities to reinforce your understanding of the material.
:::

# What is Data?

- Data is information that is stored and processed by a computer.
- It can be numerical, textual, or a combination of both.
- In programming, data is the foundation on which our programmes operate.

::: {.notes}
Data is the foundation of all computer programs. It encompasses numerical values, text, or a combination of both, providing the raw material that software manipulates and processes. Without data, programs would have nothing to operate on, making it a crucial component in the field of programming.

In the context of Python programming, data is categorised into various types, each with its own characteristics and uses. These basic data types include integers for whole numbers, floats for decimal values, strings for textual information, and booleans for true/false values. Understanding these data types and how to work with them effectively is essential for writing functional and efficient Python code.
:::

# Real-Life Examples of Data

- Consider a student's details: name, age, and favourite colour.
- Everyday examples include shopping lists or contact records.
- In our User Preferences project, data represents the choices made by users.

::: {.notes}
This slide illustrates real-life examples of data to help students grasp the concept more tangibly. A student's details, such as their name, age, and favourite colour, serve as a relatable example. Similarly, everyday instances like shopping lists or contact records demonstrate how data is used in our daily lives.

In the context of our User Preferences project, data represents the choices made by users. This practical application highlights the relevance of data in real-world scenarios and reinforces the importance of understanding data for the students' future projects and endeavours.
:::

# Basic Data Types in Python

Python supports several basic data types:
- **Integers:** Whole numbers (e.g., 5, -3)
- **Floats:** Decimal numbers (e.g., 3.14, -0.001)
- **Strings:** Text (e.g., "hello", "favourite")
- **Booleans:** True or False values

::: {.notes}
In Python, there are four fundamental data types: integers, floats, strings, and booleans. Integers are whole numbers, both positive and negative, such as 5 or -3. Floats, on the other hand, are decimal numbers like 3.14 or -0.001. Strings represent text and are enclosed in double quotes, for example, "hello" or "favourite".

Booleans are a special data type that can only have two values: True or False. They are used to represent the truth or falsity of a condition or statement in Python. It's crucial to understand these basic data types as they form the building blocks for more complex data structures and algorithms in Python programming.

Integers are use to 'count', floats are used to 'measure', strings are used to 'label' and booleans are used to 'choose'.
:::

# Data Types in Context

- A student’s age as an integer.
- A rating or score as a float.
- A user’s name or favourite colour as a string.
- A confirmation (yes/no) as a Boolean.
- These examples are directly related to our User Preferences project.

::: {.notes}
In this slide, we explore how basic data types are applied in a real-world context, specifically within our User Preferences project. We see that an integer can be used to represent a student's age, while a float is suitable for storing a rating or score. When dealing with textual information, such as a user's name or favourite colour, we utilise strings. Lastly, Boolean values are employed to capture binary choices, like a yes/no confirmation.

These practical examples demonstrate the relevance and importance of selecting the appropriate data type for each piece of information we intend to work with. By understanding how to apply these data types in a meaningful way, we can ensure that our code is efficient, readable, and maintainable. As we progress through the User Preferences project, we will continue to encounter scenarios where choosing the correct data type is crucial for the success of our program.
:::

# Understanding Variables

- Variables are named containers that hold data.
- The value stored in a variable determines its data type.
- Variables allow us to refer to data by name, making our code clearer.
- They stand in for the data itself when performing operations.

::: {.notes}
Variables are named containers that store data, allowing us to refer to it by name and making our code more readable. The value held in a variable determines its data type, such as integers, floating-point numbers, or strings. By using variables, we can perform operations on the data without directly referencing the values themselves.

Variables play a crucial role in programming by providing a way to label and manipulate data effectively. They enable us to assign meaningful names to our data, making the code more self-explanatory and easier to understand. When we need to use or modify the data, we simply refer to the variable name instead of the actual value, which simplifies the coding process and reduces the likelihood of errors.
:::

# Hands-On Activity

**Task:**  
- Write a short Python programme to create and display variables.  
- For example:
  - `name = "Alice"`
  - `age = 25`
  - `favourite_colour = "blue"`
- Use `print()` to display each variable.
- Reflect on how the variable names clarify the type and purpose of the data.

::: {.notes}
In this hands-on activity, you will write a short Python programme to create and display variables. The example provided demonstrates how to assign values to variables with descriptive names such as 'name', 'age', and 'favourite_colour'. After assigning the values, you will use the print() function to display each variable.

As you work through this activity, reflect on how the variable names help clarify the type and purpose of the data they store. Well-chosen variable names make your code more readable and easier to understand, both for yourself and others who may work with your code in the future. This is an important practice to develop as you continue learning and writing Python programmes.
:::

---
title: "Module 4: Variables and Operations"
subtitle: "Storing and Manipulating Data in Python: Turning Data into Action"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Module 4: Variables and Operations

Welcome to Module 4. In this module, we learn how variables not only store data but also work with operations to manipulate that data. These skills are key to personalising our User Preferences project by performing calculations and customising outputs.

::: {.notes}
In this module, we will explore the fundamental concepts of variables and operations in programming. We will start by reviewing what variables are and how they are used to store and manipulate data. The assignment operator will be introduced, along with the concept of reassigning variables to new values. We will then dive into the basic arithmetic operations that can be performed on variables, such as addition, subtraction, multiplication, and division.

The order of precedence for these operations will be discussed, highlighting the importance of understanding how expressions are evaluated. We will look at examples using preference-related data to illustrate how variables and operations can be used in real-world scenarios. The module will include a hands-on activity to reinforce the concepts covered and provide an opportunity for practice. Finally, we will summarise the key points and reflect on the significance of variables and operations in programming.
:::

# Review of Variables

- Variables are named containers that hold data.
- They make it easier to reference and manipulate data in your code.
- A variable’s type is determined by the data it holds (e.g., integer, float, string, Boolean).

::: {.notes}
Variables are named containers that store data within a program, making it easier to reference and manipulate information throughout the code. The type of data a variable holds determines its classification, such as integer, float, string, or Boolean.

Understanding variables is essential for writing efficient and organised code. By assigning meaningful names to variables, programmers can create more readable and maintainable programs, reducing the likelihood of errors and making it simpler to modify the code in the future.
:::

# The Assignment Operator

- The assignment operator (`=`) is used to store a value in a variable.
- Example:
  ```python
  name = "Alice"
  age = 30
  ```
- It assigns the value on the right to the variable on the left.

::: {.notes}
The assignment operator (`=`) is used to store a value in a variable. For example, if we write `x = 5`, the value 5 is assigned to the variable `x`. The assignment operator always assigns the value on the right side of the equals sign to the variable on the left side.

It's crucial to understand how the assignment operator works, as it forms the basis for storing and manipulating data in variables. Throughout this module, we'll explore how to assign values to variables, reassign those values, and perform basic arithmetic operations using the variables. Mastering the assignment operator is a fundamental step in learning to program effectively.
:::

# Reassigning Variables

- Variables can be updated or reassigned.
- Example:
  ```python
  age = 30
  age = age + 1  # Now, age becomes 31
  ```
- This flexibility lets us perform calculations and update data as needed.

::: {.notes}
Variables in programming can be reassigned to new values as needed, providing flexibility for performing calculations and updating data. The example code snippet on the slide demonstrates this concept by initially assigning a value to a variable, then reassigning it to a new value later in the code.

Reassigning variables allows programmers to work with changing data throughout the execution of a program. By updating variables with new values, complex calculations can be performed, user input can be incorporated, and the program can respond to changing conditions dynamically.
:::

# Basic Arithmetic Operations

- Python supports several arithmetic operators:
  - Addition (`+`)
  - Subtraction (`-`)
  - Multiplication (`*`)
  - Division (`/`)
  - Floor Division (`//`)
  - Modulus (`%`)
  - Exponentiation (`**`)
- These operations let you perform calculations using variables.

::: {.notes}
Python supports several arithmetic operators for performing calculations using variables. These include addition (`+`), subtraction (`-`), multiplication (`*`), division (`/`), floor division (`//`), modulus (`%`), and exponentiation (`**`). By utilising these operators, you can manipulate numeric values stored in variables to carry out mathematical operations within your Python code.

The slide "Basic Arithmetic Operations" is part of Module 4, which focuses on variables and operations. This module covers topics such as reviewing variables, the assignment operator, reassigning variables, order of precedence, and examples using preference-related data. The slide itself is followed by a hands-on activity to reinforce the concepts and a summary and reflection section to consolidate the learnings from the module.
:::

# Order of Precedence

- Python evaluates expressions in a specific order:
  1. Parentheses `()`
  2. Exponentiation `**`
  3. Multiplication, Division, Floor Division, Modulus (`*`, `/`, `//`, `%`)
  4. Addition and Subtraction (`+`, `-`)
- For example:
  ```python
  result = 2 + 3 * 4  # Evaluates as 2 + (3 * 4) = 14
  ```

::: {.notes}
Python evaluates expressions in a specific order, known as the order of precedence or operator precedence. This order determines which operations are performed first when an expression contains multiple operators. For example, multiplication and division have higher precedence than addition and subtraction, so they are evaluated first in an expression like "2 + 3 * 4". Understanding the order of precedence is crucial for writing correct and efficient Python code.

The order of precedence in Python follows the common mathematical conventions, with parentheses having the highest precedence, followed by exponentiation, multiplication and division, and finally addition and subtraction. When operators have the same precedence, they are evaluated from left to right. It's important to use parentheses to explicitly specify the desired order of evaluation when multiple operators are involved, as this can make the code more readable and prevent unintended results.
:::

# Examples Using Preference-Related Data

- Suppose you want to calculate the total cost of a selected item including tax:
  ```python
  base_price = 20
  tax_rate = 0.1
  total_cost = base_price + (base_price * tax_rate)
  print("Total cost is", total_cost)
  ```
- Such examples show how arithmetic operations help personalise data based on user preferences.

::: {.notes}
The slide titled "Examples Using Preference-Related Data" demonstrates how arithmetic operations can be used to personalise data based on user preferences. The example provided calculates the total cost of a selected item, including tax, which showcases how basic math can be applied to real-world scenarios in programming.

This slide is part of the larger module on "Variables and Operations", which covers essential concepts such as the assignment operator, reassigning variables, basic arithmetic operations, and order of precedence. By presenting practical examples like calculating total cost with tax, the slide helps learners understand the relevance and utility of these fundamental programming concepts in creating dynamic, user-centric applications.
:::

# Hands-On Activity

**Task:**  
- Write a simple programme that:
  1. Asks the user for their current age and their birth year.
  2. Uses arithmetic operations to calculate the expected age by subtracting the birth year from the current year.
  3. Displays a confirmation message with the calculated age.
- This exercise will reinforce using variables, the assignment operator, and basic arithmetic in a real-world context.

::: {.notes}
In this hands-on activity, students will write a simple programme that reinforces the use of variables, the assignment operator, and basic arithmetic operations. The exercise will provide a real-world context for students to apply these fundamental programming concepts.

The activity will challenge students to create a programme that demonstrates their understanding of the topics covered in the previous slides, such as declaring and reassigning variables, using the assignment operator, and performing arithmetic operations while considering the order of precedence rules. By completing this practical exercise, students will gain hands-on experience and solidify their knowledge of these essential programming concepts.
:::

# Summary and Reflection

- We reviewed how variables store data and how the assignment operator works.
- We explored basic arithmetic operators and their order of precedence.
- These concepts empower you to perform dynamic calculations in your User Preferences project.
- Reflect on how these operations can be applied to personalise data in future projects.
```

::: {.notes}
In this presentation, we reviewed the fundamental concepts of variables and operations in programming. We started by discussing how variables store data and how the assignment operator is used to assign values to variables. We also explored the concept of reassigning variables, which allows us to update the value stored in a variable throughout the program's execution.

Next, we delved into the world of basic arithmetic operations, including addition, subtraction, multiplication, and division. We examined the order of precedence, which determines the sequence in which operations are performed in an expression. To solidify these concepts, we looked at examples using preference-related data, demonstrating how these operations can be applied to personalise data in real-world scenarios. Finally, we engaged in a hands-on activity to put our newfound knowledge into practice and reflect on how these concepts can be applied to future projects.
:::

1. What is data in the context of programming, and why is it important?

Data, in programming, is information that is stored and processed by a computer. It can be numerical, textual, or a combination of both. Data forms the foundation upon which all programs operate; without data, programs would have nothing to manipulate or process. Understanding data is crucial because the effectiveness and functionality of your code depends on how well you handle and process data.

2. What are the four basic data types in Python? Can you provide examples of each?

Python has four fundamental data types:

Integers: Whole numbers, both positive and negative. (e.g., 5, -3, 0)
Floats: Decimal numbers. (e.g., 3.14, -0.001, 2.0)
Strings: Textual data, enclosed in quotation marks. (e.g., "hello", "Python", "favourite colour")
Booleans: Represent truth values, either True or False.
3. How are the basic data types applied in a real-world context, such as a User Preferences project?

Data types are used to accurately represent different types of information. For example:

A user's age would be represented as an integer.
A product rating could be a float.
A user's name or favourite hobby would be a string.
Whether a user agrees to terms and conditions would be a Boolean.
4. What are variables and what role do they play in programming?

Variables are named containers used to store data. They allow you to refer to data by a meaningful name, making your code more readable and easier to understand. The value stored in a variable determines its data type. Variables enable you to manipulate and perform operations on data without directly referencing the values themselves.

5. How does the value stored in a variable determine its data type?

Python is dynamically typed, meaning that the data type of a variable is determined by the value that is assigned to it. For instance, if you assign the value 5 to a variable, Python automatically infers that the variable is an integer. If you assign the value "hello", Python understands it as a string. The data type is associated with the value, not explicitly declared for the variable.

6. Why are meaningful variable names important in programming?

Meaningful variable names are crucial for code readability and maintainability. Descriptive names (e.g., user_age instead of a) clarify the purpose and type of data that a variable holds. This makes it easier for you and others to understand what the code is doing, reducing errors and simplifying future modifications or debugging.

7. Can you reassign the value of a variable? If so, how does this affect the variable's data type?

Yes, you can reassign the value of a variable in Python. When you reassign a variable with a value of a different data type, the variable's data type changes accordingly. For example:

my_variable = 10  # my_variable is an integer

my_variable = "Hello"  # my_variable is now a string

8. Give a practical example of writing a simple Python program to create and display variables.

# Assigning values to variables

name = "Alice"  # String

age = 25  # Integer

favourite_colour = "blue"  # String



# Displaying the variables

print(name)

print(age)

print(favourite_colour)

This program creates three variables: name, age, and favourite_colour, and assigns them string and integer values respectively. The print() function is then used to display the values of each variable. This demonstrates how variables store data and how descriptive names can clarify the purpose of the stored information.

NotebookLM can be inaccurate; please double-check its responses.FAQ: Understanding Data, Values, and Data Types in Python
1. What is data in the context of programming, and why is it important?

Data, in programming, is information that is stored and processed by a computer. It can be numerical, textual, or a combination of both. Data forms the foundation upon which all programs operate; without data, programs would have nothing to manipulate or process. Understanding data is crucial because the effectiveness and functionality of your code depends on how well you handle and process data.

2. What are the four basic data types in Python? Can you provide examples of each?

Python has four fundamental data types:

Integers: Whole numbers, both positive and negative. (e.g., 5, -3, 0)
Floats: Decimal numbers. (e.g., 3.14, -0.001, 2.0)
Strings: Textual data, enclosed in quotation marks. (e.g., "hello", "Python", "favourite colour")
Booleans: Represent truth values, either True or False.
3. How are the basic data types applied in a real-world context, such as a User Preferences project?

Data types are used to accurately represent different types of information. For example:

A user's age would be represented as an integer.
A product rating could be a float.
A user's name or favourite hobby would be a string.
Whether a user agrees to terms and conditions would be a Boolean.
4. What are variables and what role do they play in programming?

Variables are named containers used to store data. They allow you to refer to data by a meaningful name, making your code more readable and easier to understand. The value stored in a variable determines its data type. Variables enable you to manipulate and perform operations on data without directly referencing the values themselves.

5. How does the value stored in a variable determine its data type?

Python is dynamically typed, meaning that the data type of a variable is determined by the value that is assigned to it. For instance, if you assign the value 5 to a variable, Python automatically infers that the variable is an integer. If you assign the value "hello", Python understands it as a string. The data type is associated with the value, not explicitly declared for the variable.

6. Why are meaningful variable names important in programming?

Meaningful variable names are crucial for code readability and maintainability. Descriptive names (e.g., user_age instead of a) clarify the purpose and type of data that a variable holds. This makes it easier for you and others to understand what the code is doing, reducing errors and simplifying future modifications or debugging.

7. Can you reassign the value of a variable? If so, how does this affect the variable's data type?

Yes, you can reassign the value of a variable in Python. When you reassign a variable with a value of a different data type, the variable's data type changes accordingly. For example:

my_variable = 10  # my_variable is an integer

my_variable = "Hello"  # my_variable is now a string

8. Give a practical example of writing a simple Python program to create and display variables.

# Assigning values to variables

name = "Alice"  # String

age = 25  # Integer

favourite_colour = "blue"  # String



# Displaying the variables

print(name)

print(age)

print(favourite_colour)

This program creates three variables: name, age, and favourite_colour, and assigns them string and integer values respectively. The print() function is then used to display the values of each variable. This demonstrates how variables store data and how descriptive names can clarify the purpose of the stored information.

9. What is the purpose of the input() function in Python, and what data type does it return?

The input() function allows Python programs to receive text-based input from the user. It pauses the program's execution, displays a prompt message on the screen, and waits for the user to enter a response. Importantly, the input() function always returns the user's input as a string, regardless of whether the user enters numbers, text, or other characters. You might need to convert the string to another data type (like an integer or a float) if you want to perform mathematical operations or comparisons.

10. Why is it useful to store the result of the input() function in a variable?

Storing user input in a variable is useful because it allows you to reuse and manipulate the information provided by the user later in your program. For example, you can use the stored value to personalise messages, perform calculations, or make decisions based on the user's input. Without storing the input in a variable, you would have to ask the user for the same information again each time you needed it.

11. How does the print() function work, and what can it display?

The print() function is Python's way of displaying output to the user on the screen (usually the console). It can display various data types, including strings, numbers, variables, and the results of operations. You can also combine text and variables to create personalised messages or provide informative feedback to the user.

12. What are the different ways to combine text and variables when using the print() function, and what are the advantages of each?

There are two main methods to combine text and variables when using print(): string concatenation and comma-separated items.
String concatenation uses the + operator to join strings and variables together. It's flexible but can be less readable, especially with many elements. You also need to manually convert non-string variables to strings using str() before concatenating them.
Comma-separated items involve listing the items you want to print, separated by commas. print() automatically inserts a space between each item. This approach is often more readable and doesn't require explicit type conversions.

13. What is an example of a simple programme using input() and print()?

A simple programme using input() and print() could ask the user for their name and favourite colour and then display a personalised message:

name = input("What is your name? ")
colour = input("What is your favourite colour? ")
print("Hello,", name + "! Your favourite colour is", colour + ".")

14. What should you keep in mind when dealing with user input in Python, especially concerning data types?

It is crucial to remember that the input() function always returns the user's input as a string. Therefore, if you need to use the input as a number for calculations or comparisons, you must explicitly convert it to the appropriate data type (e.g., int() for integers or float() for floating-point numbers). Failing to do so can lead to errors or unexpected results. Always validate user input to ensure it meets your program's requirements before processing it.

15. How can the knowledge of input() and print() be applied in a User Preferences project?

In a User Preferences project, input() can be used to gather information about the user's preferences (e.g., favourite movie genre, preferred notification settings). This information can then be stored in variables and used to customise the application's behaviour or display personalised content. The print() function can be used to provide feedback to the user, display their preferences, or present tailored recommendations.

16. What will be covered in future modules that builds on the concepts of input() and print()?

Future modules will delve into more advanced techniques for manipulating and formatting output, including string formatting methods that provide greater control over the appearance of the printed text. We'll also explore how to convert input into different data types, handle potential errors during the conversion process, and validate user input to ensure data integrity. This will allow you to create more robust and user-friendly interactive programmes.


17. What is computational thinking, and why is it important in programming?

Computational thinking is a problem-solving approach that involves breaking down complex problems into smaller, more manageable parts. It includes recognising patterns, organising steps logically, and devising clear, step-by-step solutions. In programming, it's crucial because it helps to create efficient and effective algorithms, ensuring code is well-structured, easier to debug, and more maintainable. It's especially important in projects like the User Preferences project, guiding how you capture and process data.

18. How can I break down a complex problem into smaller, manageable tasks?

To break down a complex problem, start by identifying the major components or goals. Then, divide each component into smaller, more specific tasks. Tackle each task individually, focusing on solving one sub-problem at a time. For example, in a User Preferences programme, you might break it down into collecting user input, processing the data, and displaying a personalised output.

19. What is pseudocode, and how is it used in algorithm design?

Pseudocode is an informal way to plan your solution to a programming problem before writing actual code. It allows you to outline the logic and steps involved without being concerned about the specific syntax of a programming language. Using pseudocode helps you visualise the programme structure, identify potential issues, and refine your approach before you start coding in Python or another language.

20. What are the key steps in the Simplified Development Methodology, and how do they contribute to effective problem-solving?

The six-step Simplified Development Methodology is:

- Understand the problem: Restate it in your own words to ensure clarity.
- Identify the input and output: Determine what information the programme needs and what it should produce.
- Work the problem by hand: Solve a small example manually to understand the logic.
- Write the pseudocode: Outline the logical steps to solve the problem.
- Convert the pseudocode to Python: Translate the outline into working code.
- Test with a variety of data: Ensure the solution works in different scenarios.

These steps provide a structured approach to problem-solving, ensuring you fully understand the problem, plan your solution effectively, and thoroughly test your code.

21. How does the Simplified Development Methodology help with debugging?

By working through each step in the Simplified Development Methodology, especially creating pseudocode and testing thoroughly, potential errors are easier to identify and rectify. Pseudocode allows you to catch logical flaws early on before even writing code. Testing with diverse data helps reveal edge cases and input-related issues that might otherwise go unnoticed, thus simplifying the debugging process.

22. In the User Preferences project, what are some examples of inputs and outputs that I might consider?

In a User Preferences project, inputs could include the user's name, age, location, favourite colour, preferred type of content (e.g., movies, music, books), and communication preferences. The desired outputs could then be a personalised greeting, recommended content based on their preferences, a customized colour scheme for the application interface, or targeted notifications.

23. Why is it important to test a program with a variety of data?

Testing with a variety of data is essential to ensure that your program works correctly under different conditions and handles edge cases effectively. Different data types (e.g., numbers, text, special characters), ranges (e.g., very large or very small numbers), and combinations of inputs can expose potential bugs or vulnerabilities that might not be apparent with limited testing. Thorough testing helps to improve the reliability and robustness of your solution.

24. How does working through an example by hand help in algorithm design?

Working through a small example by hand allows you to fully understand the logic and steps required to solve the problem. By manually performing the calculations or operations, you can gain a deeper insight into the problem's dynamics and identify any hidden complexities or edge cases. This understanding then informs the creation of accurate and efficient pseudocode, which can be readily translated into a working program.


25. What is a variable in Python, and why are they important?

Variables are named storage locations in a computer's memory that hold data. They are crucial because they allow us to store, reference, and manipulate data within a program. Using variables makes code more readable, maintainable, and reusable, as it provides a way to refer to data using meaningful names instead of directly using the data itself. The data in these variables determine their type, such as integers, floats, strings or Boolean values.

26. How does the assignment operator work in Python?

The assignment operator, represented by the equals sign (=), is used to assign a value to a variable. The expression on the right-hand side of the operator is evaluated, and the resulting value is then stored in the variable on the left-hand side. For example, x = 5 assigns the integer value 5 to the variable x. The assignment operator is fundamental for storing and manipulating data within variables.

27. Can a variable's value be changed after it is initially assigned? If so, how?

Yes, variables in Python can be reassigned to new values after their initial assignment. This is done by using the assignment operator (=) again with the same variable name and a new value. For instance, if we initially have age = 25, we can later reassign the variable with age = 30. This flexibility allows for dynamic calculations and updates as needed throughout the program's execution.

28. What are the basic arithmetic operators available in Python, and what do they do?

Python provides a range of arithmetic operators for performing mathematical calculations:
    + (Addition): Adds two values together.
    - (Subtraction): Subtracts the second value from the first.
    * (Multiplication): Multiplies two values.
    / (Division): Divides the first value by the second, resulting in a floating-point number.
    // (Floor Division): Divides the first value by the second, resulting in the largest possible integer.
    % (Modulus): Returns the remainder of the division of the first value by the second.
    ** (Exponentiation): Raises the first value to the power of the second.

These operators allow you to manipulate numerical data stored in variables and perform various calculations.

29. What is meant by "order of precedence" in arithmetic operations, and why is it important?

The "order of precedence" refers to the rules that determine the order in which operations are performed in an expression containing multiple operators. Python follows a specific order:

- Parentheses ()
- Exponentiation **
- Multiplication, Division, Floor Division, Modulus (*, /, //, %)
- Addition and Subtraction (+, -)

Understanding the order of precedence is vital because it ensures that expressions are evaluated correctly and produce the expected results. Using parentheses can override the default order and explicitly define the desired calculation sequence.

30. How can variables and arithmetic operations be used in the context of personalising user preferences?

Variables and arithmetic operations are fundamental to personalising user preferences in software applications. For instance, you can store a user's age, preferred discount rate, or selected item price in variables. Then, using arithmetic operations, you can calculate discounts, total costs, or personalised recommendations based on these preferences. For example, calculate the total cost of an item including tax: total_cost = item_price * (1 + tax_rate).

31. Describe an example scenario that combines variables, arithmetic operations, and user input.

Consider a programme that calculates a user's expected age. The programme first prompts the user to enter their current age and birth year, storing these values in variables called current_age and birth_year, respectively. Then, it calculates the expected age by subtracting the birth_year from the current year: expected_age = current_year - birth_year. Finally, it displays a message confirming the calculated age. This demonstrates the combined use of variables, arithmetic operations, and user input to provide a personalised output.

32. How does reassigning variables empower more complex programmes?

Reassigning variables allows programmers to work with changing data throughout the execution of a program. By updating variables with new values, complex calculations can be performed, user input can be incorporated, and the program can respond to changing conditions dynamically.
NotebookLM can be inaccurate; please double-check its responses.---
title: "STAFF ANSWER GUIDE: Activity 1: Personalised Greeting & User Preferences"
subtitle: "From Input to Impact: Crafting Personalised Greetings in Python"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Staff Answer Guide for Activity 1

## Overview

This guide provides a sample solution and explanations for Activity 1: Personalized Greeting & User Preferences. The goal of this activity is to reinforce:
- How to collect user input with `input()`.
- Storing responses in variables.
- Producing personalised output using `print()`.

This resource is intended to assist tutors in guiding students through the exercise and addressing common pitfalls.

## Sample Solution

Below is a sample solution that demonstrates two acceptable approaches to constructing the output message.

```python
# Step 1: Collect user input and store responses in variables
name = input("What is your name? ")
favourite_colour = input("What is your favourite colour? ")
favourite_food = input("What is your favourite food? ")

# Step 2: Construct a personalised greeting using string concatenation
greeting = "Hello, " + name + "! Your favourite colour is " + favourite_colour + " and you love " + favourite_food + "."
print(greeting)

# Alternatively, using comma-separated arguments in print() for automatic spacing:
print("Hello,", name + "!", "Your favourite colour is", favourite_colour + ",", "and you love", favourite_food + ".")
```

## Explanation of the Code

- **Collecting Input:**  
  - The `input()` function prompts the user and returns their response as a string.
  - Each response is stored in a variable (`name`, `favourite_colour`, and `favourite_food`), which can be reused later in the programme.

- **Constructing the Output Message:**  
  There are two common methods shown:
  
  1. **String Concatenation using the `+` Operator:**  
     - Combines literal strings with variables.
     - Example: `"Hello, " + name + "!"`  
     - Tutors should remind students to manage spaces and punctuation carefully.
  
  2. **Using Comma-Separated Arguments in `print()`:**  
     - Multiple items passed to `print()` are automatically separated by a space.
     - Example: `print("Hello,", name + "!")`  
     - This method simplifies formatting by reducing the need to explicitly include spaces.

- **Output:**  
  - Both methods produce a personalised message that incorporates the user's inputs.
  - Encourage students to test with various inputs to ensure their programme works as intended.

## Tutor Tips

- **Common Pitfalls:**  
  - Students might forget that `input()` always returns a string, even if the user enters numbers.
  - Managing spaces correctly when using the `+` operator can be challenging. Encourage them to compare the two methods.
  
- **Discussion Points:**  
  - Ask students why it is useful to store user input in variables.
  - Discuss the readability benefits of each method and when one might be preferred over the other.
  
- **Further Exploration:**  
  - Once students are comfortable, mention that f-strings provide an even cleaner way to format output and will be introduced later.
  - Invite students to extend the programme by adding another preference (e.g., favourite hobby) to further personalise their greeting.
---
title: "STAFF ANSWER GUIDE: Activity 3: User Preferences with Simplified Methodology"
subtitle: "From Blueprint to Code: Building Your User Preferences Programme Step by Step"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Staff Answer Guide: Activity 3 – User Preferences with Simplified Methodology

## Overview

This guide provides a sample solution and detailed explanations for Activity 3. In this activity, students are guided through a structured problem-solving methodology to design and implement a User Preferences programme. Key steps include:

1. **State the Problem**
2. **Describe Input and Output**
3. **Work the Problem by Hand**
4. **Develop an Algorithm (Pseudocode)**
5. **Write the Code**
6. **Tackle Mini-Challenges**

In addition, students are encouraged to use AI tools to clarify their thought process and verify their work—while ensuring that all AI suggestions stay within the course scope (i.e., using only input(), print(), basic data types, and variables).



## Detailed Breakdown

### Step 1 – State the Problem

- **Student Task:**  
  Define the goal: build a programme that collects user preferences and displays them in a personalised summary.

- **Staff Explanation:**  
  Students should identify what information to gather (e.g., name, favourite colour, favourite food, and hobby) and decide how to present it. 

- **AI Usage Tip:**  
  Encourage students to ask an AI tool to rephrase their description. For example:  
  > "Can you restate my description of a user preferences programme to ensure I have captured the intent correctly?"  
  Remind them to verify that the AI’s response aligns with the topics covered so far.



### Step 2 – Describe Input and Output

- **Student Task:**  
  List the inputs (name, favourite colour, favourite food, favourite hobby) and define the expected output (e.g., a summary message).

- **Staff Explanation:**  
  Mapping the inputs to a clear output helps structure the programme. The expected output might be:  
  > "Hello, [name]! Your favourite colour is [colour], you love [food], and you enjoy [hobby]."

- **AI Usage Tip:**  
  Students can ask, "What are some creative ways to format a user preferences summary?" but must ensure the suggestions only use basic concepts.



### Step 3 – Work the Problem by Hand

- **Student Task:**  
  Use sample inputs (e.g., name = "Alice", favourite colour = "Blue", favourite food = "Pasta", favourite hobby = "Reading") to manually determine the expected output.

- **Staff Explanation:**  
  This step validates the student’s understanding. The manually written output should match what the code will generate.

- **AI Usage Tip:**  
  If unsure, students may ask, "Does this output message clearly reflect the provided inputs?" ensuring the feedback adheres to current learning.



### Step 4 – Develop an Algorithm (Pseudocode)

- **Student Task:**  
  Write pseudocode outlining the logical steps. An example might be:

  ```plain
  1. Start the programme.
  2. Prompt the user for their name and store the input.
  3. Prompt for favourite colour and store the input.
  4. Prompt for favourite food and store the input.
  5. Prompt for favourite hobby and store the input.
  6. Construct a summary message using the inputs.
  7. Print the summary message.
  8. End the programme.
  ```

- **Staff Explanation:**  
  Pseudocode helps bridge the planning phase with the coding phase. It doesn’t need to follow Python syntax.

- **AI Usage Tip:**  
  Students can ask an AI tool, "Can you review my pseudocode and suggest improvements?" Remind them to keep suggestions within the basics they have learned.



### Step 5 – Write the Code

- **Student Task:**  
  Translate the pseudocode into a Python script. A sample solution might be:

  ```python
  # Collect user input for various preferences
  name = input("What is your name? ")
  favourite_colour = input("What's your favourite colour? ")
  favourite_food = input("What's your favourite food? ")
  favourite_hobby = input("What's your favourite hobby? ")

  # Construct and display a personalised summary message
  print("\nHello, " + name + "!")
  print("Your favourite colour is " + favourite_colour + 
        ", you love " + favourite_food + 
        ", and you enjoy " + favourite_hobby + ".")
  ```

- **Staff Explanation:**  
  This code uses string concatenation and demonstrates the basic usage of input() and print() functions. Emphasize that this solution should not include advanced topics like functions, f-strings, or exception handling yet.

- **AI Usage Tip:**  
  In case of errors or confusion, students should ask follow-up questions like, "How can I improve this code using only input(), print(), and variables?" This ensures that AI feedback remains aligned with current topics.



### Mini-Challenges

The worksheet includes optional mini-challenges to encourage creative problem-solving:

1. **Starred Preferences:**  
   Print each preference on a separate line with a star at the beginning.

   ```python
   print("* Name:", name)
   print("* Favourite Colour:", favourite_colour)
   print("* Favourite Food:", favourite_food)
   print("* Favourite Hobby:", favourite_hobby)
   ```

2. **Age Calculator Challenge:**  
   Ask for the birth year, calculate the age, and print it.  
   *Note:* This may introduce the concept of basic arithmetic and importing modules, so students should verify with an AI tool if uncertain.
   
   ```python
   import datetime
   birth_year = int(input("What year were you born? "))
   current_year = datetime.datetime.now().year
   age = current_year - birth_year
   print("You are", age, "years old!")
   ```

3. **(Optional Advanced) F-String Formatting:**  
   Refactor the summary message using f-strings for cleaner syntax.  
   *Note:* This challenge is optional and should only be attempted if the student is comfortable with the material.
   
   ```python
   print(f"Hello, {name}! Your favourite colour is {favourite_colour}, you love {favourite_food}, and you enjoy {favourite_hobby}.")
   ```

- **Staff Explanation:**  
  These challenges reinforce the core concepts and gently introduce new ideas. Tutors should stress that students must use only what they've learned so far unless they explicitly choose to explore the advanced option.  

- **AI Usage Tip:**  
  Remind students to ask, "Can you explain how to complete this mini-challenge using only the topics we've covered?" if they receive suggestions that include more advanced content.



## Testing and Reflection

- **Testing:**  
  Students should test their programmes with various input scenarios. For example, when inputting "Alice" for the name, "blue" for the favourite colour, and so on, the output should match the expected result.

- **Reflection Questions:**  
  - How did planning (pseudocode) assist in coding the solution?
  - Which mini-challenge did you find most useful or interesting?
  - How did using AI tools enhance your understanding?  
    (Encourage them to verify and ask follow-up questions if any AI response uses concepts beyond input(), print(), and basic variables.)

- **Staff Explanation:**  
  Discuss the importance of systematic planning and how AI tools can be used to clarify and refine ideas—provided the student critically evaluates the output against what they’ve learned.



## Tutor Tips

- **Planning Emphasis:**  
  Encourage students to invest time in planning and pseudocoding before coding.

- **Comparative Discussion:**  
  Ask students to share both their pseudocode and final solutions. Compare the structured approach to earlier, less formal methods (like Activity 2).

- **Critical Evaluation of AI Outputs:**  
  Remind students that if any AI suggestion includes advanced topics (e.g., user-defined functions, exceptions, f-strings), they should ask follow-up questions to have the explanation tailored to the current level of learning.

- **Encourage Experimentation:**  
  Support creative extensions and mini-challenges as long as the core solution remains aligned with the course content.



## Conclusion

This staff guide is designed to help tutors support students through Activity 3. The guide includes a sample pseudocode, a basic Python solution, and mini-challenges—all supplemented with AI usage tips. These tips aim to encourage students to ask follow-up questions and critically evaluate AI outputs, ensuring that their solutions use only the concepts taught so far.

Happy tutoring!
---
title: "STAFF ANSWER GUIDE: User Preferences Survey Project"
subtitle: "Applying Industry Best Practices in a Real-World Environment"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Staff Answer Guide: User Preferences Survey Project

## Overview

This project collates several exercises from the week’s activities and requires students to build a simple User Preferences Survey using Python. The purpose is to practice fundamental concepts (variables, data types, input(), print(), and basic operations) while adhering to industry best practices. These best practices include using descriptive names, proper documentation, version control, and careful use of AI for guidance.

This guide provides sample answers and discussion points for tutors.



## Step 1 – State the Problem

**Expected Student Response:**  
Students should clearly articulate that the goal of the programme is to collect a user's preferences (such as name, favourite colour, favourite food, and favourite hobby) and then display a personalized summary message.

*Example Answer:*  
> "The programme is designed to ask the user for their name, favourite colour, favourite food, and favourite hobby. It will then use this data to generate a personalized greeting, such as 'Hello, Alice! Your favourite colour is blue, you love pizza, and you enjoy reading.'"

**Discussion Points:**  
- Verify that students have captured both the input data and the expected output.
- Emphasise that the problem statement must be clear and concise.

**AI Tip for Students:**  
Students are encouraged to ask an AI tool to rephrase their description. Tutors can suggest:  
> "Can you restate my description of a User Preferences Survey program using only input(), print(), and variables?"  
Ensure the AI’s response is in line with the basic concepts taught so far.



## Step 2 – Describe Input and Output

**Expected Student Response:**  
Students should list the inputs and clearly describe the expected output.

*Inputs:*  
- `user_name` (string)
- `fav_colour` (string)
- `fav_food` (string)
- `fav_hobby` (string)

*Expected Output:*  
A summary message formatted as:  
> "Hello, [user_name]! Your favourite colour is [fav_colour], you love [fav_food], and you enjoy [fav_hobby]."

**Discussion Points:**  
- Ensure that students understand the mapping between the inputs and the output.
- Discuss why a clear specification of inputs and outputs is important for planning.

**AI Tip for Students:**  
Ask an AI tool for creative formatting ideas, ensuring that suggestions remain within the basic techniques of input(), print(), and string concatenation.



## Step 3 – Work the Problem by Hand

**Expected Student Response:**  
Students should simulate the programme by writing sample inputs and manually determining the expected output.

*Sample Simulation:*  
- **Inputs:**  
  - `user_name`: "Alice"  
  - `fav_colour`: "blue"  
  - `fav_food`: "pizza"  
  - `fav_hobby`: "reading"
- **Expected Output:**  
  > "Hello, Alice! Your favourite colour is blue, you love pizza, and you enjoy reading."

**Discussion Points:**  
- Highlight that working the problem by hand helps to verify understanding before coding.
- Encourage students to try multiple scenarios.

**AI Tip for Students:**  
If uncertain, ask:  
> "Does this output message clearly reflect the provided inputs?"  
Review the AI feedback to ensure consistency.



## Step 4 – Develop an Algorithm (Pseudocode)

**Expected Student Response:**  
Students should produce pseudocode that outlines the logical steps of the programme. The pseudocode does not need to be written in Python syntax.

*Sample Pseudocode:*
```plain
1. Start the program.
2. Prompt the user for their name and store it in user_name.
3. Prompt the user for their favourite colour and store it in fav_colour.
4. Prompt the user for their favourite food and store it in fav_food.
5. Prompt the user for their favourite hobby and store it in fav_hobby.
6. Create a summary message using the stored inputs.
7. Print the summary message.
8. End the program.
```

**Discussion Points:**  
- Emphasize that pseudocode helps bridge planning and coding.
- Ask students to compare their pseudocode with a sample solution.

**AI Tip for Students:**  
Students can ask an AI tool:  
> "Can you review my pseudocode for a User Preferences Survey program and suggest improvements?"  
Ensure that the suggestions stay within the basic concepts taught.



## Step 5 – Write the Code

**Expected Student Response:**  
Students will translate their pseudocode into Python code using basic operations, input(), and print().

*Sample Python Code:*
```python
# Collect user input for preferences
user_name = input("What is your name? ")
fav_colour = input("What's your favourite colour? ")
fav_food = input("What's your favourite food? ")
fav_hobby = input("What's your favourite hobby? ")

# Construct the personalized summary message
summary = "Hello, " + user_name + "! Your favourite colour is " + fav_colour + \
          ", you love " + fav_food + ", and you enjoy " + fav_hobby + "."

# Display the summary message
print(summary)
```

**Discussion Points:**  
- Point out the importance of descriptive variable names.
- Discuss how comments and clear structure improve code readability.
- Verify that the solution uses only the concepts covered so far (no advanced topics).

**AI Tip for Students:**  
If any confusion arises, students can ask:  
> "Can you review my Python code for a User Preferences Survey and suggest improvements using only input(), print(), and basic variables?"  
This ensures that the solution remains aligned with course content.



## Reflection on Industry Best Practices

**Expected Reflection Points:**
- **Descriptive Names & Comments:**  
  How did using meaningful variable names and inline comments improve the clarity of the code?
- **Version Control:**  
  Emphasize the importance of frequent saves and using descriptive commit messages on GitHub.
- **Documentation:**  
  Reflect on how documenting the thought process in text cells helped understand and refine the solution.
- **Collation of Exercises:**  
  Note that this project collates several weekly activities. This approach is intentional and allows for reflection on whether students are improving in following industry best practices.

**Discussion Points:**  
- Discuss with students how this structured approach compares with more ad-hoc methods.
- Encourage them to critically evaluate any AI output they received and verify that it uses only the core topics covered so far.

**AI Tip for Students:**  
Ask an AI tool, "Can you suggest improvements to my project documentation and commit message examples based on industry best practices?" Ensure that any advice given adheres to the basic concepts learned.



## Final Reflection and Next Steps

**Expected Student Reflections:**
- How did following a structured methodology help in organizing the solution?
- Which aspects of industry best practices were most challenging to implement, and how can they be improved?
- How did the process of collating exercises help in understanding the overall project?

**Next Steps:**
- Experiment with adding new inputs or modifying the output format.
- Save your work frequently and use descriptive commit messages when uploading to GitHub.
- Share your completed project with peers and discuss possible improvements.

**Discussion Points for Tutors:**
- Encourage students to continue refining their code and documentation.
- Remind them that the best practices followed here are examples from the industry—useful habits to emulate as they grow in their careers.



## Tutor Tips

- **Encourage Reflection:**  
  Ask students to share what they learned about the importance of planning and documentation.
- **Emphasize Best Practices:**  
  Highlight the benefits of using descriptive names, version control, and proper commenting.
- **Foster Critical Use of AI:**  
  Remind students that AI is a tool to aid learning, but they should always verify that its suggestions are appropriate for their current level.



This staff answer guide is intended to provide a robust framework to support and evaluate student work on the User Preferences Survey Project. It emphasizes both the technical aspects and the industry best practices that are crucial for a successful software development career.

Happy tutoring!
---
title: "STAFF ANSWER GUIDE: Activity 2: Ad-Hoc User Preferences Survey"
subtitle: "Explore and Experiment: Crafting Your Own User Preferences Survey"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Staff Answer Guide: Activity 2 – Ad-Hoc User Preferences Survey

## Overview

This guide provides a sample solution and explanations for Activity 2. The goal is to create a Python script that gathers user preferences in an ad-hoc manner and then displays them. The exercise encourages experimentation with basic input/output functions in Python. In addition, mini-challenges are included to foster creative problem-solving and to hint at upcoming concepts such as basic calculations and alternative output formatting.

## Sample Solution

Below is one example of how a student might implement the activity. Note that there is no single correct solution—students are encouraged to be creative.

### Main Survey Implementation

```python
# Collect user input for various preferences
name = input("What is your name? ")
favourite_colour = input("What's your favourite colour? ")
favourite_food = input("What's your favourite food? ")
favourite_hobby = input("What's your favourite hobby? ")

# Option 1: Using string concatenation
print("Hello, " + name + "! Your favourite colour is " + favourite_colour +
      ", you love " + favourite_food + ", and you enjoy " + favourite_hobby + ".")

# Option 2: Using comma-separated arguments for automatic spacing
print("Hello,", name + "!", "Your favourite colour is", favourite_colour + ",",
      "you love", favourite_food + ", and you enjoy", favourite_hobby + ".")
```

## Mini-Challenges

These mini-challenges are designed to stimulate further creativity and introduce additional concepts:

### Challenge 1: Starred Preferences
Print each preference on a separate line with a star (`*`) at the beginning of each line.

```python
print("* Name:", name)
print("* Favourite Colour:", favourite_colour)
print("* Favourite Food:", favourite_food)
print("* Favourite Hobby:", favourite_hobby)
```

### Challenge 2: Age Calculator
Ask the user for their birth year and calculate how old they will be this year.  
*Hint: You may use the `datetime` module to get the current year.*

```python
import datetime

birth_year = int(input("What year were you born? "))
current_year = datetime.datetime.now().year
age = current_year - birth_year
print("You are", age, "years old!")
```

### Challenge 3 (Optional Advanced): F-String Formatting
Refactor the summary message to use Python's f-string formatting instead of string concatenation. (This is an optional advanced challenge intended for students who wish to explore newer formatting methods.)

```python
print(f"Hello, {name}! Your favourite colour is {favourite_colour}, you love {favourite_food}, and you enjoy {favourite_hobby}.")
```

## Explanation of the Code

- **Collecting Input:**  
  - The `input()` function is used to prompt the user for information.
  - Each response is stored in its own variable (e.g., `name`, `favourite_colour`) for later use.

- **Constructing the Output Message:**  
  - **Option 1 (String Concatenation):**  
    Combines strings using the `+` operator. Note that extra spaces and punctuation must be managed manually.
  - **Option 2 (Comma-Separated Arguments):**  
    When multiple arguments are passed to `print()`, Python automatically inserts spaces between them.

- **Mini-Challenges:**  
  - **Starred Preferences:**  
    This challenge reinforces printing multiple lines and adds a simple formatting twist.
  - **Age Calculator:**  
    Introduces the concept of using external modules (like `datetime`) and basic arithmetic operations to perform a calculation.
  - **F-String Formatting:**  
    Provides a glimpse into a modern way of formatting strings. This challenge is optional and can be attempted by more advanced students.

## Tutor Tips

- **Encourage Flexibility:**  
  Remind students that there are several ways to construct their output. The goal is to practice and understand basic input/output operations.
  
- **Address Common Issues:**  
  - Ensure students understand that the `input()` function always returns a string.
  - Clarify the differences between string concatenation and using commas in the `print()` function.
  
- **Mini-Challenges as Extensions:**  
  - Explain that the mini-challenges are optional but provide great opportunities to stretch their understanding.
  - For the f-string challenge, emphasize that it’s an introduction to a topic that will be covered in more detail later.

- **Discussion Points:**  
  - Ask students what other preferences they might add.
  - Discuss the benefits of clear output formatting.
  - Encourage students to share creative modifications they made to the program.

## Extension Ideas

- **Additional Preferences:**  
  Invite students to add more questions (e.g., favourite movie, book, travel destination) to further personalize the output.
  
- **Refactoring:**  
  Once students are comfortable, challenge them to refactor their code for improved readability or to implement functions to reuse code.
---
title: "Unravelling Python Dictionaries: A Beginner's Guide"
subtitle: "Mastering the Art of Key-Value Storage"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# What is a Python Dictionary?

- A dictionary is a collection of key-value pairs
- Keys are unique identifiers used to access values
- Values can be any data type, including other collections
- Dictionaries are unordered, unlike lists or tuples

::: {.notes}
In Python, a dictionary is a powerful data structure that allows you to store and retrieve data using unique keys. Unlike lists or tuples, which are ordered collections, dictionaries are unordered. Each piece of information in a dictionary is stored as a key-value pair, where the key acts as a unique identifier to access the corresponding value.

The keys in a dictionary can be any immutable data type, such as strings, numbers, or tuples, while the values can be any valid Python object, including other collections like lists or even other dictionaries. This flexibility makes dictionaries incredibly versatile and useful for a wide range of applications, from storing configuration settings to building complex data models.
:::

# Creating a Dictionary

```python
# Create an empty dictionary
my_dict = {}

# Create a dictionary with initial key-value pairs
person = {
    "name": "Alex",
    "age": 30,
    "city": "Sydney"
}
```

::: {.notes}
To create a dictionary in Python, you can use curly braces `{}` to enclose the key-value pairs. Each pair is separated by a colon `:`, with the key on the left and the value on the right.

You can create an empty dictionary by simply using the curly braces, like `my_dict = {}`. This gives you a blank canvas to start building your dictionary.

Alternatively, you can create a dictionary with some initial key-value pairs, as shown in the `person` example. Here, we have three key-value pairs: "name" is associated with the string "Alex", "age" is associated with the integer 30, and "city" is associated with the string "Sydney".

The keys in a dictionary can be any immutable data type, such as strings, numbers, or tuples, while the values can be any valid Python object, including other collections like lists or even other dictionaries.
:::

# Accessing Dictionary Values

```python
person = {
    "name": "Alex",
    "age": 30,
    "city": "Sydney"
}

# Access values using keys
print(person["name"])  # Output: "Alex"
print(person["age"])   # Output: 30

# Use the get() method to handle missing keys
print(person.get("occupation", "Not found"))  # Output: "Not found"
```

::: {.notes}
To access the values stored in a dictionary, you can use the keys as indices, just like you would with a list or tuple. Simply place the key inside square brackets `[]` after the dictionary name.

In the example, we access the values associated with the keys "name" and "age" by using `person["name"]` and `person["age"]`, respectively. This will output the corresponding values: "Alex" and 30.

If you try to access a key that doesn't exist in the dictionary, you'll get a `KeyError`. To handle this, you can use the `get()` method, which allows you to provide a default value to return if the key is not found. In the example, we use `person.get("occupation", "Not found")` to retrieve the value for the "occupation" key, but since it doesn't exist, the method returns the default value "Not found".

Using the `get()` method is a safe way to access dictionary values, as it prevents your code from crashing if a key is missing.
:::

# Adding and Updating Entries

```python
person = {
    "name": "Alex",
    "age": 30,
    "city": "Sydney"
}

# Add a new key-value pair
person["occupation"] = "Software Engineer"

# Update an existing value
person["age"] = 31

print(person)
# Output: {'name': 'Alex', 'age': 31, 'city': 'Sydney', 'occupation': 'Software Engineer'}
```

::: {.notes}
Dictionaries are mutable, which means you can add new key-value pairs or update the values of existing keys.

To add a new key-value pair, simply assign a value to a new key. In the example, we add the key "occupation" and assign it the value "Software Engineer".

To update an existing value, you can assign a new value to the corresponding key. Here, we change the value of the "age" key from 30 to 31.

After making these changes, the `person` dictionary now contains four key-value pairs: "name" is associated with "Alex", "age" is associated with 31, "city" is associated with "Sydney", and "occupation" is associated with "Software Engineer".

Modifying dictionaries in this way is a common operation and allows you to keep your data up-to-date and relevant.
:::

# Removing Entries

```python
person = {
    "name": "Alex",
    "age": 30,
    "city": "Sydney"
}

# Remove a key-value pair
del person["age"]

# Use the pop() method to remove a key-value pair and get the value
occupation = person.pop("occupation", "Not found")
print(occupation)  # Output: "Not found"

print(person)
# Output: {'name': 'Alex', 'city': 'Sydney'}
```

::: {.notes}
Dictionaries also allow you to remove key-value pairs. There are a few ways to do this:

1. Using the `del` keyword: You can remove a specific key-value pair by using the `del` keyword followed by the dictionary name and the key you want to remove. In the example, we use `del person["age"]` to remove the "age" key-value pair.

2. Using the `pop()` method: The `pop()` method allows you to remove a key-value pair and get the value associated with that key. If the key doesn't exist, you can provide a default value to be returned. In the example, we use `person.pop("occupation", "Not found")` to remove the "occupation" key-value pair (if it exists) and store the value in the `occupation` variable. Since the key doesn't exist, the method returns the default value "Not found".

After removing the key-value pairs, the `person` dictionary now only contains the "name" and "city" keys.

Removing entries from a dictionary is useful when you need to clean up or update your data, especially if certain information is no longer relevant or needed.
:::

# Looping through a Dictionary

```python
person = {
    "name": "Alex",
    "age": 30,
    "city": "Sydney"
}

# Loop through keys
for key in person:
    print(key)
# Output:
# name
# age
# city

# Loop through key-value pairs
for key, value in person.items():
    print(f"{key}: {value}")
# Output:
# name: Alex
# age: 30
# city: Sydney
```

::: {.notes}
Dictionaries are very versatile, and you can loop through them in various ways to access their contents.

The most basic way is to loop through the keys using a `for` loop. In the example, we simply iterate over the `person` dictionary, and for each iteration, the `key` variable will be assigned the current key.

A more common and useful way to loop through a dictionary is to use the `items()` method, which returns a view object containing the key-value pairs. This allows you to access both the keys and the values in each iteration. In the example, we use `for key, value in person.items()` to unpack each key-value pair into the `key` and `value` variables, respectively.

Looping through a dictionary is a great way to perform operations on all the key-value pairs, such as printing them out, modifying the values, or performing some other logic based on the data.
:::

# Dictionary Methods

- `len(dict)`: Returns the number of key-value pairs in the dictionary
- `dict.keys()`: Returns a view object containing the keys
- `dict.values()`: Returns a view object containing the values
- `dict.items()`: Returns a view object containing the key-value pairs
- `dict.get(key, default)`: Returns the value for the given key, or the default value if the key is not found
- `dict.pop(key, default)`: Removes the key-value pair and returns the value, or the default value if the key is not found
- `dict.update(other_dict)`: Merges the key-value pairs from another dictionary into the current one

::: {.notes}
Dictionaries in Python come with a variety of built-in methods that allow you to perform common operations on them. Here are some of the most useful methods:

- `len(dict)`: Returns the number of key-value pairs in the dictionary.
- `dict.keys()`: Returns a view object containing all the keys in the dictionary.
- `dict.values()`: Returns a view object containing all the values in the dictionary.
- `dict.items()`: Returns a view object containing the key-value pairs as tuples.
- `dict.get(key, default)`: Returns the value associated with the given key, or the default value if the key is not found.
- `dict.pop(key, default)`: Removes the key-value pair with the given key and returns the value. If the key is not found, it returns the default value.
- `dict.update(other_dict)`: Merges the key-value pairs from another dictionary into the current one, overwriting any existing keys.

These methods provide a wide range of functionality for working with dictionaries, from getting information about the dictionary's contents to modifying and manipulating the data.
:::

# Nested Dictionaries

```python
person = {
    "name": "Alex",
    "age": 30,
    "address": {
        "street": "123 Main St",
        "city": "Sydney",
        "state": "NSW"
    }
}

# Access nested values
print(person["address"]["city"])  # Output: "Sydney"

# Update a nested value
person["address"]["state"] = "Victoria"

print(person)
# Output: {'name': 'Alex', 'age': 30, 'address': {'street': '123 Main St', 'city': 'Sydney', 'state': 'Victoria'}}
```

::: {.notes}
Dictionaries can also contain other dictionaries, creating a nested data structure. This is particularly useful when you need to model more complex data, such as information about a person that includes their address details.

In the example, the `person` dictionary has a key called "address" that is associated with another dictionary containing the street, city, and state information.

To access the nested values, you can chain the keys together, separating them with square brackets `[]`. In the example, we use `person["address"]["city"]` to get the value "Sydney" for the "city" key in the nested "address" dictionary.

Similarly, you can update the values of the nested dictionary by assigning new values to the corresponding keys. Here, we change the "state" value in the "address" dictionary from "NSW" to "Victoria".

Nested dictionaries allow you to build sophisticated data models that reflect the real-world relationships and hierarchies in your data.
:::

# Conclusion

- Dictionaries are unordered collections of key-value pairs
- Keys must be unique and can be any immutable data type
- Values can be any valid Python object, including other collections
- Dictionaries are versatile and can be used for a wide range of applications
- Key operations include creating, accessing, modifying, and removing entries
- Dictionaries can be nested to model complex data structures

::: {.notes}
In this presentation, we've covered the basics of Python dictionaries, a powerful data structure that allows you to store and retrieve data using unique keys.

We've learned that dictionaries are unordered collections of key-value pairs, where the keys must be unique and can be any immutable data type, while the values can be any valid Python object, including other collections like lists or even other dictionaries.

We've explored how to create dictionaries, access and modify their contents, remove entries, an---
title: "Mastering Dictionary Methods and Operations"
subtitle: "Unlocking the Power of Python's Versatile Data Structure"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to Dictionaries

- What are dictionaries in Python?
- Key-value pairs for storing and retrieving data
- Advantages over other data structures
- Common use cases for dictionaries

::: {.notes}
Dictionaries are a fundamental data structure in Python, allowing you to store and retrieve data using unique keys. Unlike lists, which store data in an ordered sequence, dictionaries are unordered collections of key-value pairs. This makes them incredibly versatile and efficient for a wide range of tasks, from data processing to program configuration.

Some of the key advantages of dictionaries include fast lookup times, the ability to associate data with meaningful labels, and the flexibility to store different data types within the same structure. Dictionaries are commonly used for tasks like tracking inventory, managing user preferences, and building recommendation systems.
:::

# Creating and Populating Dictionaries

- Initialising an empty dictionary
- Adding key-value pairs
- Using different data types as keys and values
- Example: Building a contact list

::: {.notes}
To create a new dictionary in Python, you can simply use curly braces `{}`. You can then add key-value pairs using the assignment operator `=`. The keys in a dictionary can be strings, numbers, or even other immutable data types like tuples. The values can be any valid Python object, including other dictionaries, lists, or even functions.

Let's look at an example of building a simple contact list using a dictionary. We'll create keys for people's names and store their phone numbers and email addresses as the corresponding values. This demonstrates how dictionaries allow you to associate multiple pieces of information with a single identifier.
:::

# Accessing and Retrieving Data

- Accessing values using keys
- Handling missing keys (KeyError)
- Using the `get()` method for safer access
- Retrieving all keys or values

::: {.notes}
Once you've created a dictionary, you can access the values stored within it by using the corresponding keys. Simply use square brackets `[]` and the key name to retrieve the associated value.

However, it's important to handle the case where a key doesn't exist in the dictionary, as this will raise a `KeyError`. To avoid this, you can use the `get()` method, which allows you to provide a default value to return if the key is not found.

Dictionaries also provide methods to retrieve all the keys or all the values as separate lists, which can be useful for various operations and data processing tasks.
:::

# Common Dictionary Operations

- Checking if a key exists
- Adding, modifying, and removing key-value pairs
- Iterating over keys, values, or key-value pairs
- Merging dictionaries using the `update()` method

::: {.notes}
In addition to accessing and retrieving data, dictionaries support a variety of common operations that make them a powerful tool in your Python programming arsenal.

You can use the `in` keyword to check if a particular key exists in a dictionary. To add, modify, or remove key-value pairs, you simply assign a new value to an existing key or use the `del` keyword to remove a key-value pair.

Dictionaries are also iterable, allowing you to loop over their keys, values, or key-value pairs. This makes them useful for tasks like processing data or generating reports.

Finally, you can use the `update()` method to merge two dictionaries, which can be handy when working with data from multiple sources.
:::

# Nested Dictionaries

- Storing dictionaries within dictionaries
- Accessing and manipulating nested data
- Use case: Representing hierarchical data

::: {.notes}
Dictionaries can also contain other dictionaries as values, creating a nested data structure. This allows you to represent more complex, hierarchical data, such as a database of employees with information about their departments, salaries, and contact details.

To access and manipulate data within a nested dictionary, you can use a combination of keys to drill down to the desired value. This can take some practice, but it's a powerful technique for working with structured data.

Nested dictionaries are particularly useful when you need to model real-world scenarios that have a hierarchical nature, such as organisational structures, product catalogues, or geographic data. By nesting dictionaries, you can maintain a logical and efficient representation of the data.
:::

# Dictionary Comprehensions

- Concise way to create new dictionaries
- Filtering, transforming, and combining data
- Example: Creating a dictionary of squares

::: {.notes}
Dictionary comprehensions provide a compact and expressive way to create new dictionaries from existing data. Similar to list comprehensions, dictionary comprehensions use a single line of code to generate key-value pairs based on some transformation or filtering logic.

This can be a powerful tool for tasks like data manipulation, feature engineering, or creating lookup tables. Let's look at an example of using a dictionary comprehension to create a dictionary of squares, where the keys are the numbers 1 through 10, and the values are the squares of those numbers.

Dictionary comprehensions help you write more concise and readable code, especially when working with larger or more complex data structures.
:::

# Best Practices and Tips

- Choosing appropriate data types for keys and values
- Handling missing keys and default values
- Iterating over dictionaries efficiently
- Optimising performance for large dictionaries

::: {.notes}
As you become more comfortable working with dictionaries, it's important to keep a few best practices and tips in mind:

First, be thoughtful about the data types you use for your keys and values. Strings, numbers, and tuples make good key choices, while you can store any valid Python object as a value.

When accessing dictionary values, always be prepared to handle missing keys to avoid `KeyError` exceptions. The `get()` method is a great way to provide default values in these cases.

Efficient iteration is also important, especially when working with large dictionaries. Looping over the `.keys()`, `.values()`, or `.items()` methods can help you traverse the dictionary in the most appropriate way for your use case.

Finally, for extremely large dictionaries, you may need to consider performance optimisations, such as using a specialized data structure like a `defaultdict` or `OrderedDict` from the `collections` module.

Following these best practices will help you write more robust, efficient, and maintainable code when working with dictionaries in Python.
:::

# Conclusion

- Key takeaways from the presentation
- Importance of dictionaries in Python programming
- Resources for further learning

::: {.notes}
In this presentation, we've explored the powerful capabilities of dictionaries in Python. We've learned that dictionaries are flexible, efficient data structures that allow you to store and retrieve data using unique keys.

Dictionaries offer many advantages over other data structures, such as fast lookup times, the ability to associate data with meaningful labels, and the flexibility to store different data types within the same structure. We've seen how dictionaries can be used in a wide range of applications, from building contact lists to representing hierarchical data.

By mastering dictionary methods and operations, you'll be well on your way to becoming a more proficient Python programmer. To continue your learning journey, I recommend exploring the official Python documentation, as well as searching for online tutorials and coding challenges that focus on dictionary usage.

Remember, the more you practice working with dictionaries, the more comfortable and confident you'll become in leveraging this versatile data structure in your Python projects.
:::
```---
title: "Mastering Python Data Structures"
subtitle: "Building the Foundation for Powerful Data Applications"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Welcome to Python Data Structures

- What are data structures and why are they important?
- The core data structures in Python
- How to choose the right data structure for your needs

::: {.notes}
In this presentation, we'll dive into the world of Python data structures. Data structures are the fundamental building blocks of any programming language, allowing us to organize and manage data in efficient and meaningful ways. Understanding how to work with different data structures is crucial for developing powerful and effective applications.

We'll start by exploring what data structures are and why they're so important, then we'll take a closer look at the core data structures available in Python. By the end, you'll have a solid grasp of how to select the right data structure for your specific needs, setting you up for success in your Python programming journey.
:::

# The Core Python Data Structures

- Lists
- Tuples
- Dictionaries
- Sets

::: {.notes}
The four core data structures in Python are:

1. Lists: Ordered collections of items that can be of different data types. Lists are versatile and allow for easy manipulation, such as adding, removing, and sorting elements.

2. Tuples: Ordered collections of items that are immutable, meaning their contents cannot be changed after creation. Tuples are useful for storing data that should remain constant.

3. Dictionaries: Unordered collections of key-value pairs, allowing for efficient data lookup and retrieval. Dictionaries are great for representing complex relationships and modeling real-world scenarios.

4. Sets: Unordered collections of unique elements. Sets are useful for tasks like finding common elements, removing duplicates, and performing set operations like union and intersection.

Understanding the strengths and use cases of each of these data structures will empower you to choose the right tool for the job and write more efficient, effective Python code.
:::

# Lists

- Ordered collection of items
- Can contain items of different data types
- Supports a variety of operations, such as:
  - Indexing
  - Slicing
  - Appending
  - Inserting
  - Removing

::: {.notes}
Lists are one of the most fundamental and versatile data structures in Python. They are ordered collections of items, which means the elements maintain a specific sequence. This allows you to access individual elements using their index.

Lists can contain items of different data types, such as numbers, strings, and even other data structures like dictionaries or even other lists. This flexibility makes lists a powerful tool for organizing and manipulating data.

Some common operations you can perform on lists include indexing to access specific elements, slicing to extract a subset of elements, appending new items, inserting elements at specific positions, and removing items. These operations make lists highly adaptable and useful for a wide range of programming tasks.
:::

# Tuples

- Ordered collection of items
- Immutable, meaning the contents cannot be changed
- Useful for storing data that should remain constant
- Faster than lists for certain operations

::: {.notes}
Tuples are similar to lists in that they are ordered collections of items. However, the key difference is that tuples are immutable, meaning you cannot modify their contents after creation.

This immutability makes tuples useful for storing data that should remain constant, such as configuration settings, geographic coordinates, or database records. Since the contents of a tuple cannot be changed, they are generally faster than lists for certain operations.

Tuples are often used to return multiple values from a function, as the return values are guaranteed to remain unchanged. They can also be used as dictionary keys, as dictionaries require immutable objects as keys.

While tuples may seem less flexible than lists, their immutability can be a strength in certain situations where you need to ensure the integrity of your data.
:::

# Dictionaries

- Unordered collection of key-value pairs
- Keys must be unique and immutable (like strings or numbers)
- Values can be of any data type
- Efficient data lookup and retrieval

::: {.notes}
Dictionaries are a powerful data structure in Python that store data in key-value pairs. Unlike lists and tuples, dictionaries are unordered, meaning the elements are not stored in a specific sequence.

Each element in a dictionary has a unique key, which is used to access the associated value. The keys must be immutable data types, such as strings or numbers, while the values can be of any data type, including other data structures like lists or even other dictionaries.

Dictionaries are highly efficient for data lookup and retrieval, as they use hash tables under the hood. This makes them an excellent choice for tasks like maintaining a database of customer information, tracking inventory, or representing complex relationships in your data.

By leveraging the power of key-value pairs, dictionaries allow you to build sophisticated data models and access specific pieces of information quickly and easily.
:::

# Sets

- Unordered collection of unique elements
- Elements must be immutable (like strings or numbers)
- Useful for tasks like:
  - Finding common elements
  - Removing duplicates
  - Performing set operations (union, intersection, difference)

::: {.notes}
Sets are another useful data structure in Python, representing an unordered collection of unique elements. Unlike lists and dictionaries, sets do not allow duplicate values. Each element in a set must be an immutable data type, such as a string or a number.

Sets are particularly helpful for tasks that involve finding common elements, removing duplicates, or performing set operations like union, intersection, and difference. For example, you could use a set to quickly identify the unique words in a text document or the common interests between two groups of people.

The unique and unordered nature of sets makes them efficient for tasks that require quickly checking the presence or absence of an element. This can be especially useful in data cleaning, analysis, and processing workflows.
:::

# When to Use Each Data Structure

- Lists: Ordered collections, good for sequential data
- Tuples: Immutable ordered collections, good for constant data
- Dictionaries: Unordered key-value pairs, good for modeling relationships
- Sets: Unordered unique elements, good for membership tests and set operations

::: {.notes}
Now that we've covered the core Python data structures, let's discuss when you might choose to use each one:

Lists are a great choice when you need to work with ordered, sequential data, such as a list of items in a shopping cart or a chronological series of events.

Tuples are useful when you have data that should remain constant, like configuration settings or geographic coordinates. Their immutability can help ensure the integrity of your data.

Dictionaries are ideal for modeling real-world relationships and representing complex data structures. They allow for efficient lookup and retrieval of information, making them useful for tasks like maintaining customer records or inventory management.

Sets are particularly helpful when you need to perform operations on unique elements, such as finding common interests, removing duplicates, or checking membership. They can be a great choice for data cleaning and processing tasks.

Choosing the right data structure for your specific needs will help you write more efficient, effective, and maintainable Python code.
:::

# Recap

- Python has four core data structures: lists, tuples, dictionaries, and sets
- Each data structure has its own strengths and use cases
- Lists are ordered, mutable collections
- Tuples are ordered, immutable collections
- Dictionaries are unordered key-value pairs
- Sets are unordered collections of unique elements
- Selecting the appropriate data structure is crucial for effective Python programming

::: {.notes}
In this presentation, we've explored the four core data structures in Python: lists, tuples, dictionaries, and sets. Each of these data structures has its own unique characteristics and use cases, and understanding when to use each one is crucial for effective Python programming.

Lists are ordered, mutable collections that are great for working with sequential data. Tuples are also ordered, but they are immutable, making them useful for storing constant data. Dictionaries are unordered key-value pairs, allowing for efficient data lookup and retrieval, and are well-suited for modeling real-world relationships. Finally, sets are unordered collections of unique elements, making them useful for tasks like finding common elements, removing duplicates, and performing set operations.

By mastering these fundamental data structures, you'll be well on your way to building powerful and efficient Python applications. Remember to choose the right data structure for the job at hand, as this will help you write cleaner, more maintainable code.
:::

# Thank You!

- Questions?
- Resources for further learning

::: {.notes}
Thank you for joining me on this introduction to Python data structures. I hope you now have a better understanding of the core data structures available in Python and how to choose the right one for your needs.

If you have any questions or would like to explore this topic further, please don't hesitate to ask. There are also many great resources available online, such as the official Python documentation, tutorials, and coding challenges, that can help you deepen your knowledge and skills.

Remember, mastering data structures is a crucial step in becoming a proficient Python programmer. Keep practicing, experimenting, and building projects, and you'll be well on your way to creating powerful, efficient, and maintainable applications.

Thank you for your attention, and I wish you all the best in your Python learning journey!
:::---
title: "STAFF ANSWER: Designing a Smart Inventory System: Justifying Decisions"
subtitle: "Applying Analytical Thinking to Inventory Management"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

Activity 1: Conceptual Application & Analysis

1. Key considerations for choosing a dictionary-based approach:
   - Efficient storage and retrieval of inventory data using the key-value structure
   - Ability to easily associate product information (e.g., name, SKU, quantity) with a unique identifier (the key)
   - Suitability for handling a large and dynamic inventory with frequent updates

2. Potential challenges and limitations of using a dictionary:
   - Handling complex inventory data that may require more structure than a simple key-value pair
   - Potential performance issues for large inventories or frequent updates (dictionary lookups have O(1) time complexity, but the underlying hash table implementation can degrade with many collisions)
   - Difficulty in maintaining order or sorting of inventory items (dictionaries are unordered)
   - Limitations in reporting and aggregating inventory data compared to more structured data models

3. Structuring the dictionary:
   - Use product SKU or unique ID as the dictionary key
   - Store relevant inventory information as the value, such as:
     - Product name
     - Quantity in stock
     - Reorder threshold
     - Supplier information
   - Consider using nested dictionaries or other data structures within the values to handle more complex inventory data

Activity 2: Evaluation, Comparison, and Justification

1. Key principles and assumptions of JIT and EOQ:
   - Just-in-Time (JIT):
     - Principle: Produce or deliver goods only as they are needed, minimizing inventory
     - Assumptions: Reliable and frequent supplier deliveries, stable demand, low setup costs
   - Economic Order Quantity (EOQ):
     - Principle: Determine the optimal order quantity to minimize total inventory costs
     - Assumptions: Constant and known demand, fixed ordering and holding costs

2. Advantages and disadvantages of JIT and EOQ for the given business scenario:
   - JIT advantages: Reduced inventory costs, less waste, improved cash flow
   - JIT disadvantages: Reliance on reliable suppliers, potential stock-outs, sensitivity to demand changes
   - EOQ advantages: Systematic approach to determining optimal order quantities, lower ordering costs
   - EOQ disadvantages: Requires accurate demand forecasting, potential for excessive inventory

3. Recommendation and justification:
   Given the small size of the business and the potential for demand fluctuations, the EOQ strategy may be more suitable. The EOQ approach provides a structured way to balance ordering and holding costs, which aligns better with the business owner's needs. While JIT can offer cost savings, the risk of stock-outs may be too high for a small retail business. The EOQ strategy provides a more stable and predictable inventory management system, which is likely more suitable for the given scenario.

Extension: Integrating Concepts

1. Modifying the dictionary structure:
   - Add a "reorder_level" key to track the minimum inventory level that triggers a reorder
   - Include a "forecast" key to store predicted future demand for each product
   - Consider using a nested dictionary to group related inventory data (e.g., product details, sales history, reorder information)

2. Algorithms and techniques for automated reordering and forecasting:
   - Automated reordering:
     - Monitor inventory levels and trigger a reorder when the "reorder_level" is reached
     - Use the EOQ formula to determine the optimal reorder quantity
   - Forecasting:
     - Implement a simple moving average or exponential smoothing algorithm to predict future demand
     - Use the forecasted demand to update the "forecast" key in the dictionary

3. Potential challenges and mitigation strategies:
   - Handling exceptions and edge cases (e.g., sudden demand spikes, supplier issues)
   - Ensuring data integrity and consistency as the inventory system grows more complex
   - Integrating the dictionary-based system with other business systems (e.g., sales, accounting)
   - Scaling the system to handle a larger, more diverse inventory

Reflection:

1. The analytical and evaluative skills practiced in this activity can be applied to other complex, real-world problems that require critical thinking, problem-solving, and justification of design choices. These skills are valuable in software engineering, project management, and various other fields.

2. AI tools were used to explain the underlying principles of JIT and EOQ in a different way, which helped deepen the understanding for the justification needed in Activity 2. The AI's suggestions were critically evaluated to assess their relevance and significance for the expanded inventory management system in the Extension activity.

3. Critically evaluating information and justifying choices was challenging, as it required a deep understanding of the concepts and the ability to apply them to a specific business scenario. The process was insightful, as it forced me to consider multiple perspectives, anticipate potential issues, and provide well-reasoned arguments to support the recommended solutions.---
title: "STAFF ANSWER: Optimising Dictionary Performance: Evaluating Options for Large Datasets"
subtitle: "Analysing Trade-offs and Justifying Choices for Efficient Data Structures"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## Activity 1: Conceptual Application & Analysis

Key factors to consider when selecting a dictionary implementation:
- **Time complexity:** The efficiency of key operations (lookup, insertion, deletion) is crucial, especially for large datasets. Aim for O(1) time complexity for these operations.
- **Space complexity:** The memory usage of the data structure should be reasonable and scale well with the dataset size.
- **Concurrency handling:** If the data needs to be accessed and modified by multiple users/processes, the data structure should support thread-safe or lock-free operations.
- **Ease of use:** The implementation should be straightforward and integrate well with the rest of the system.

The large dataset size (millions of products) would likely make a standard dictionary implementation inefficient due to the potential for hash collisions and linear search times. Alternative data structures like hash tables, ordered dictionaries, or tries may be more suitable.

Potential challenges and trade-offs:
- Hash tables offer constant-time lookups, but may have higher memory usage and potential issues with hash collisions as the dataset grows.
- Ordered dictionaries provide efficient sorting and range queries, but may have slightly higher overhead compared to standard dictionaries.
- Tries offer efficient prefix-based lookups, but can have higher memory usage for sparse datasets.

The choice would depend on the specific requirements of the system, such as the frequency and nature of the lookups, the need for sorting or range queries, and the available memory resources.

## Activity 2: Evaluation, Comparison, and Justification

Two suitable dictionary-based data structures for the caching system:
1. **Concurrent Hash Table**: A thread-safe hash table implementation, such as the `ConcurrentHashMap` in Java or the `concurrent.ConcurrentHashMap` in Python, which provides efficient concurrent access and modification.
2. **Ordered Dictionary**: An ordered dictionary data structure, such as the `OrderedDict` in Python or a `TreeMap` in Java, which maintains the keys in sorted order and supports efficient range queries.

Comparison:
- **Time complexity:**
  - Concurrent Hash Table: O(1) for lookup, insertion, and deletion on average.
  - Ordered Dictionary: O(log n) for lookup, insertion, and deletion.
- **Space complexity:**
  - Concurrent Hash Table: Higher memory usage due to the need for additional metadata for concurrency handling.
  - Ordered Dictionary: Slightly higher memory usage compared to a standard dictionary due to the overhead of maintaining the sorted order.
- **Concurrency handling:**
  - Concurrent Hash Table: Provides built-in thread-safety and atomic operations.
  - Ordered Dictionary: May require additional synchronization mechanisms to ensure thread-safety.
- **Ease of implementation and maintenance:**
  - Concurrent Hash Table: Relatively straightforward to implement, with well-established libraries available.
  - Ordered Dictionary: Slightly more complex to implement, but many libraries provide ready-to-use implementations.

Justification:
For the concurrent caching system, the **Concurrent Hash Table** would be the most appropriate choice. The constant-time lookups and updates are crucial for the caching requirements, and the built-in thread-safety simplifies the implementation and ensures the cache can be accessed and modified concurrently without issues. While the Ordered Dictionary offers useful features like range queries, the slightly higher time complexity and the need for additional concurrency handling make it less suitable for this specific use case.

## Extension: Optimising Dictionary Performance in a Real-World Scenario

To design an efficient data processing pipeline for the log file analysis, the following dictionary-based data structures could be used:

1. **Trie (Prefix Tree)**: Tries can be used to efficiently store and retrieve log entries based on the timestamp or user ID. Tries provide O(k) time complexity for lookup, insertion, and deletion, where k is the length of the key (e.g., timestamp or user ID). This makes them well-suited for quickly filtering and grouping the log data by these metadata fields.

2. **Hash Table**: A standard hash table implementation can be used to store aggregated or summarised data from the log entries, such as counts, averages, or other metrics per user or time period. The constant-time lookups and updates make hash tables efficient for these types of operations.

Justification:
- Handling large datasets with millions of entries:
  - Tries can efficiently store and retrieve data based on the log entry metadata, even for very large datasets, without suffering from hash collisions.
  - Hash tables can scale well to store the aggregated data, as their performance is not significantly impacted by the dataset size.
- Efficiently grouping and aggregating data:
  - Tries enable fast prefix-based lookups and grouping of log entries by timestamp or user ID.
  - Hash tables provide constant-time access to the aggregated metrics, allowing efficient data summarisation.
- Optimising lookup and update operations:
  - Tries offer O(k) time complexity for lookups, insertions, and deletions, where k is the length of the key (e.g., timestamp or user ID).
  - Hash tables provide O(1) average-case time complexity for lookups, insertions, and deletions.
- Trade-offs between time complexity, space usage, and ease of implementation:
  - Tries have a slightly higher space complexity compared to hash tables, but their performance characteristics make them well-suited for this scenario.
  - Hash tables are generally simpler to implement and maintain, with readily available library implementations.

By using a combination of tries and hash tables, the data processing pipeline can efficiently handle the large log dataset, quickly group and aggregate the data, and provide fast lookups and updates to support the analysis tasks.

## Reflection

1. The analytical and evaluative skills practiced in this worksheet, such as comparing the performance characteristics of different data structures, considering trade-offs, and justifying choices, are highly applicable to many other areas of computer science and software engineering. These skills can be used to optimize the performance and design of various systems, not just dictionary-based data structures.

2. In this worksheet, I used AI tools (e.g., asking an AI to summarize key factors or suggest potential issues) to supplement my own understanding and analysis. I found the AI's suggestions to be a helpful starting point, but I critically evaluated them and incorporated only the relevant insights into my justifications. Using AI in this way allowed me to explore the problem from different angles and deepen my comprehension, rather than simply relying on the AI-generated answers.

3. Critically evaluating information and justifying choices was a valuable exercise that required me to deeply understand the concepts and trade-offs involved. It was challenging to consider all the relevant factors and articulate a well-reasoned argument, but this process helped solidify my understanding of dictionary performance optimization and develop my critical thinking skills. The need to justify my choices forced me to think more deeply about the problem and consider alternative approaches, which was insightful and will be helpful in future problem-solving tasks.---
title: "STAFF ANSWER: Mastering Dictionaries: Unlocking Insights from Business Data"
subtitle: "Analyse, Evaluate, and Justify Your Decisions with Dictionaries"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## Activity 1: Conceptual Application & Analysis

1. To calculate the total revenue generated from the sales data:

   - Iterate through the `sales_data` dictionary using a `for` loop or the `items()` method.
   - For each product, multiply the `price` and `qty_sold` values to get the revenue for that product.
   - Sum up the individual product revenues to get the total revenue.

   Example code:
   ```python
   total_revenue = 0
   for product_id, product_data in sales_data.items():
       revenue = product_data['price'] * product_data['qty_sold']
       total_revenue += revenue
   print(f"Total revenue: ${total_revenue:.2f}")
   ```

   Potential challenges:
   - Handling missing or invalid data in the dictionary (e.g., missing price or quantity sold).
   - Accounting for discounts, taxes, or other factors that may impact the final revenue calculation.

2. To determine the best-selling product:

   - Iterate through the `sales_data` dictionary and keep track of the product with the highest `qty_sold` value.
   - Use the `max()` function with a `key` parameter to find the product with the maximum quantity sold.

   Example code:
   ```python
   best_selling_product = max(sales_data.items(), key=lambda x: x[1]['qty_sold'])
   print(f"The best-selling product is {best_selling_product[1]['name']} with {best_selling_product[1]['qty_sold']} units sold.")
   ```

   Explanation:
   - The `max()` function is used to find the key-value pair with the maximum `qty_sold` value.
   - The `key` parameter in `max()` specifies that we want to compare the values of the `qty_sold` field for each product.
   - The resulting `best_selling_product` variable contains the product ID and its corresponding data dictionary, from which we can extract the product name and quantity sold.

## Activity 2: Evaluation, Comparison, and Justification

To evaluate the two new product options and recommend the better one:

1. Calculate the potential monthly revenue for each new product:
   - Product A: $19.99 x 50 units = $999.50
   - Product B: $14.75 x 80 units = $1,180.00

2. Compare the potential monthly revenue:
   - Product B has a higher potential monthly revenue of $1,180.00 compared to $999.50 for Product A.

3. Justify the recommendation:
   - Based on the potential monthly revenue, Product B would be the better addition to the business. The higher estimated sales volume and slightly lower price point for Product B result in a higher overall revenue potential compared to Product A.

   Additional factors to consider (per the AI tip):
   - Production costs and profit margins for each product
   - Potential cannibalization of existing product sales
   - Customer demand and market trends for the new product types

   By considering these additional factors, you can provide a more comprehensive justification for the recommendation.

## Extension: Combining Concepts

1. Calculate the total revenue generated from all products:
   ```python
   total_revenue = 0
   for product_data in sales_data.values():
       total_revenue += product_data['price'] * product_data['qty_sold']
   print(f"Total revenue: ${total_revenue:.2f}")
   ```

2. Determine the product with the highest total revenue:
   ```python
   highest_revenue_product = max(sales_data.items(), key=lambda x: x[1]['price'] * x[1]['qty_sold'])
   print(f"The product with the highest total revenue is {highest_revenue_product[1]['name']}")
   ```

3. Calculate the average price of all products:
   ```python
   total_price = sum(product_data['price'] for product_data in sales_data.values())
   average_price = total_price / len(sales_data)
   print(f"The average price of all products is ${average_price:.2f}")
   ```

Explanation:
- For the total revenue, we iterate through the values in the `sales_data` dictionary and multiply the price and quantity sold for each product, then sum the results.
- To find the product with the highest total revenue, we use the `max()` function with a `key` parameter that calculates the total revenue for each product (price * quantity sold) and returns the product with the maximum value.
- To calculate the average price, we sum the prices of all products and divide by the number of products in the `sales_data` dictionary.

## Reflection

1. The analytical and evaluative skills practiced with dictionaries can be applied to many other data structures and problem domains, such as:
   - Analyzing and manipulating complex data structures (e.g., nested dictionaries, lists of dictionaries) to extract insights.
   - Choosing appropriate data representations (e.g., lists, sets, dataframes) to model and solve problems effectively.
   - Evaluating the trade-offs and suitability of different data structures for specific use cases.
   - Justifying design decisions and data analysis approaches based on the characteristics and capabilities of the chosen data structures.

2. In this worksheet, I used AI tools to suggest alternative approaches and identify additional factors to consider when evaluating the new product options. The AI's suggestions helped me broaden my perspective and incorporate more comprehensive considerations into my justification. However, I carefully examined the AI's outputs, verified their relevance and accuracy, and adapted them to fit the specific requirements of the task.

3. Critically evaluating information and justifying choices was challenging, as it required me to think critically about the assumptions, limitations, and potential biases in the data and analysis. It was insightful to consider alternative viewpoints and factors that could impact the decision-making process. This exercise helped me develop a more holistic and nuanced approach to problem-solving and decision-making.## 🧠🤖 AI Conversation Worksheet – Debugging AI Outputs  
> **Title**: *Be the Boss: Guide the AI to Build a Gradebook*

---

### 🧩 The Challenge:
> Build a **Gradebook Program** that:
> - Stores **student names and their test scores**
> - Uses a **function** to calculate average score
> - Handles **invalid input** and **empty scores**
> - Outputs each student’s **name and average**

---

### 🗣 Prompt 1: “Can you help me write a program that stores student names and scores, and prints their average?”

**🤖 AI Response (has subtle mistakes):**
```python
students = {
    "Alice": "85, 90, 78",
    "Bob": "70, 88, 92"
}

for name in students:
    avg = sum(students[name]) / len(students[name])
    print(f"{name}: {avg}")
```

---

### ❌ What’s wrong with this code?

✅ Use this space to **list the problems**:

- _________________________________________________________  
- _________________________________________________________  

🧠 Hint: Think about **data types**, **string vs. list**, and `sum()`.

✏️ Suggested Prompt:  
`"Your code stores scores as strings. Can you fix it so each student has a list of numbers instead?"`

---

### 🗣 Prompt 2: “Can you fix the scores so they’re stored as numbers in a list?”

**🤖 AI Response (better, but still not ideal):**
```python
students = {
    "Alice": [85, 90, 78],
    "Bob": [70, 88, 92]
}

for name in students:
    total = 0
    for score in students[name]:
        total += score
    avg = total / 3
    print(f"{name} average is {avg}")
```

---

### ❌ Critique This:

1. What assumption is made about score count?
2. Could we use a function here?

✏️ Prompt Idea:  
`"Can you make a function to calculate the average of any list of scores, instead of assuming 3?"`

---

### 🗣 Prompt 3: “Please use a function to calculate the average instead of hardcoding ‘3’.”

**🤖 AI Response (Oops! Watch this one):**
```python
def average(scores):
    return sum(scores) / len(scores)

for name in students:
    print(f"{name} average: {average(name)}")
```

---

### ❌ Spot the Mistake:

- What is being passed to `average()` here?
- Why does it crash?

✏️ Prompt Idea:  
`"You're passing the name to average instead of the list of scores. Can you fix the for-loop?"`

---

### 🗣 Prompt 4: Fixing the Loop

**🤖 AI Response (Corrected):**
```python
def average(scores):
    return sum(scores) / len(scores)

for name, scores in students.items():
    print(f"{name} average: {average(scores)}")
```

🎉 This version works — but now let’s push it further...

---

### 🗣 Prompt 5: “Can you modify the code to ask the user to enter student names and scores?”

**🤖 AI Response (Flawed Input Handling):**
```python
students = {}

while True:
    name = input("Enter name (or 'done'): ")
    if name == "done":
        break
    scores = input("Enter scores separated by spaces: ")
    students[name] = scores.split()
```

---

### ❌ Critique the Input Code:

- Are the scores strings or integers?
- What happens if the user enters bad input?

✏️ Prompt Idea:  
`"Can you convert the scores to integers and ignore blank entries?"`

---

### 🗣 Prompt 6: Fix Input Parsing

**🤖 AI Response (Improving):**
```python
scores = [int(s) for s in scores.split() if s.strip() != ""]
```

✏️ Extension Prompt:  
`"Can you skip entries that aren’t valid numbers?"`

---

### 🗣 Final Prompt: “Can you combine this with the average function and print student averages?”

**🤖 AI Final Version (Almost There... but what’s missing?):**
```python
def average(scores):
    return sum(scores) / len(scores)

for name in students:
    print(f"{name} average: {average(students[name])}")
```

---

### ❌ Final Check:

- Does this handle **empty scores**?
- What if someone enters no valid numbers?

✏️ Prompt Idea:  
`"Can you make sure the average function handles an empty list without crashing?"`

---

### ✅ Your Turn: Rewrite the Final Version with Fixes

```python
# Your improved version here:
```

---

### 🔍 Wrap-Up: What You Learned About Directing the AI

- What kinds of mistakes did the AI make?
- How did your understanding of Python help you fix them?
- How would you change your prompts next time?

✏️ Notes:  
_________________________________________________________  
_________________________________________________________  

---
## 🐍 Python Problem Solving Handout

### 💡 Core Concepts

| Concept     | Description / Python Examples                            |
|-------------|-----------------------------------------------------------|
| **Input**   | `input()`, `pyinputplus`, function arguments/parameters   |
| **Output**  | `print()`, `return`                                       |
| **Store**   | Variables, assignment `=`, lists `[]`, dictionaries `{}`  |
| **Calculate** | `+`, `-`, `*`, `/`, `//`, `%`, `**`<br>`<`, `<=`, `>`, `>=`, `==`<br>`in`, `not`, `and`, `or` |
| **Decisions** | `if`, `if-else`, `if-elif`                              |
| **Repeat**  | `for`, `while`, list comprehensions                       |

---

### 🧠 Simple Methodology: From Problem to Program

#### ✏️ Design (Think First)
1. **Restate the problem in your own words**  
2. **Identify input and output**  
3. **Work the problem by hand**  
4. **Write pseudocode** (plain-English steps)

➡️ Use comments (`#`) to turn pseudocode into your starting point in Python.

#### 🧑‍💻 Coding (Do)
5. **Convert to Python** – Start writing real code  
6. **Test with a variety of data** – Try different inputs and edge cases

> 💬 Tip: If something isn’t working, go back to Step 3 or 4. Try smaller test cases or break down the logic.
## 🧠🤖 AI Conversation Worksheet – Advanced Programming via Prompting  
> **Title**: *Guiding the AI: Building a Python Gradebook*

### 🧩 Task:  
> **Create a gradebook program that:**
> - Uses a dictionary to store student names and their list of scores  
> - Has a function to calculate average score  
> - Prints each student’s name and average  
> - Handles edge cases (e.g., empty lists, invalid inputs)

---

### 👣 Step-by-Step Prompt Walkthrough

---

### 🔹 Prompt 1: Start Simple

**You ask AI:**  
🟢 `"Can you help me write a Python program to store student names and their test scores, and print their average?"`

**AI replies:**  
```python
students = {
    "Alice": [85, 90, 78],
    "Bob": [70, 88, 92],
    "Charlie": [100, 100, 90]
}

for name, scores in students.items():
    avg = sum(scores) / len(scores)
    print(f"{name} has an average of {avg}")
```

---

### 🔍 Reflection:
> ✅ **What’s good about this solution?**  
> ⚠️ **What’s missing?** (Think: user-defined functions, flexibility, edge cases)

✏️ **Your notes:**  
___________________________________________________________  
___________________________________________________________  

---

### 🔹 Prompt 2: Add a Function

**You ask AI:**  
🟢 `"Can you turn the average calculation into a function?"`

**AI replies:**  
```python
def average(scores):
    return sum(scores) / len(scores)

for name, scores in students.items():
    print(f"{name} has an average of {average(scores)}")
```

---

### 🧠 Pause & Think:

> What if `scores` is an empty list?  
> Try this prompt:  
🟢 `"What happens if a student has no scores? Can you fix that?"`

---

### 🔹 Prompt 3: Improve Robustness

**AI replies:**  
```python
def average(scores):
    if not scores:
        return 0
    return sum(scores) / len(scores)
```

> 💬 Not bad — but is returning 0 always the best choice?

✏️ **Optional Critique:**  
___________________________________________________________  
___________________________________________________________  

---

### 🔂 Optional Fork:
> You realize you want to enter student data manually.

🟢 Prompt: `"Can I ask the user to enter student names and scores?"`

---

### 🔹 Prompt 4: Collect User Input

**AI tries (but gives this shaky code):**  
```python
students = {}
while True:
    name = input("Enter student name (or 'done'): ")
    if name == "done":
        break
    scores = input("Enter scores separated by commas: ").split(",")
    students[name] = scores
```

---

### 🔍 Let’s Critique That:

- 🚫 Scores are strings, not numbers  
- 🚫 No validation  
- ✅ Good start using loop & dictionary

✏️ **Prompt suggestion to fix it:**  
🟢 `"Can you convert scores to numbers and skip blanks?"`

---

### 🔹 Prompt 5: Improve Input Handling

**AI replies:**  
```python
students = {}
while True:
    name = input("Enter student name (or 'done'): ")
    if name == "done":
        break
    raw_scores = input("Enter scores separated by commas: ")
    scores = [int(s) for s in raw_scores.split(",") if s.strip().isdigit()]
    students[name] = scores
```

---

### ✅ Final Prompt: Combine with Function

🟢 `"Can you combine this with the average function and print each student's name and average?"`

---

### ✨ Final Result (AI replies):  
```python
def average(scores):
    if not scores:
        return "No scores"
    return sum(scores) / len(scores)

students = {}
while True:
    name = input("Enter student name (or 'done'): ")
    if name == "done":
        break
    raw_scores = input("Enter scores separated by commas: ")
    scores = [int(s) for s in raw_scores.split(",") if s.strip().isdigit()]
    students[name] = scores

for name, scores in students.items():
    print(f"{name}: Average = {average(scores)}")
```

---

### 🧠 Reflection: Directing the AI Like a Programmer

> - What *concepts* helped you understand what to ask?
> - When did you have to **correct or clarify** the AI?
> - Could someone without a good grasp of `dict`, `functions`, `input()` etc. make this work?

✏️ **Your Thoughts:**  
___________________________________________________________  
___________________________________________________________  

---
## 🧠🤖 AI-Powered Python Worksheet  
> *Using AI to Think, Design, and Code with Python*

### 🧩 Problem Statement:
> **Write a program that calculates the average test score from a list of scores input by the user.**

---

### PART 1 — Understanding the Problem (with AI support)

| Step | What You Do | Your Prompt to the AI | AI Response Notes |
|------|-------------|------------------------|--------------------|
| 1. Restate the problem | Rephrase it in your own words | `"Can you help me restate this problem clearly: I need a program that calculates average test scores?"` | |
| 2. Identify Input & Output | Figure out what goes in/out | `"What inputs does this program need? What should it output?"` | |
| 3. Work it by hand | Try an example yourself | N/A – write down how you’d manually do it | |
| 4. Write pseudo code | Ask AI to help with steps | `"Can you help me write pseudocode for this problem?"` | |

---

### PART 2 — Coding with AI

| Step | Your Goal | Your Prompt to the AI | AI Code / Response |
|------|-----------|------------------------|--------------------|
| 5. Convert to Python | Ask AI to write code from the pseudocode | `"Can you convert the pseudocode above into working Python code?"` | |
| 6. Test with data | Try different examples | `"Can you show how this program would work with scores: 90, 85, 78?"` | |
| 🛠 Debug or Refine | Identify & fix issues | `"The code gives an error if I enter nothing. Can you help me fix that?"` | |

---

### 🧠 Reflection

- ✅ What did the AI do well?
- ⚠️ What did you still have to guide or fix?
- 💬 What would you ask differently next time?

---

## 🛠 Bonus: Explore Programming Concepts with the AI

Ask AI to explain or show examples for:

| Concept     | Prompt Example |
|-------------|----------------|
| Input       | `"How do I get user input in Python?"` |
| Output      | `"What’s the difference between print() and return?"` |
| Store       | `"How do I store numbers in a list?"` |
| Calculate   | `"What’s the difference between / and // in Python?"` |
| Decisions   | `"How do I use if-else to check for a passing score?"` |
| Repeat      | `"How do I loop through a list of scores?"` |


1. **Build a progression of complexity**: Your current materials already show a nice progression from basic to more complex interactions. Consider organizing exercises that explicitly build from simpler concepts to more complex integrations.

2. **Incorporate reflection points**: Add more structured reflection prompts throughout your materials to help students internalize what they're learning about both programming concepts and effective prompting.

3. **Add visual guides**: Consider creating flowcharts of effective prompting patterns that students can reference. This could show the decision tree of when to use different types of prompts.

4. **Create starter templates**: Provide students with "prompt templates" for different programming scenarios that they can customize.

5. **Peer review component**: Add an exercise where students review each other's AI conversations and identify ways to improve their prompting.

6. **Challenge scenarios**: Include specific programming challenges where the AI is intentionally programmed to provide initially flawed solutions, requiring careful prompting to resolve.

## Key Improvements in the New Materials

1. The **Complete AI Programming Conversation Exercise** provides a fully worked example that follows your six-step methodology while showing non-linear paths students might explore.

2. The **Guide to Intentional Prompting** explains the concept, categorizes different types of prompts, and provides concrete patterns students can follow.

3. The **Prompt Templates** document organizes effective prompts by the six core programming concepts from your handout, giving students a reference library.

4. The **Assessment Guide** helps you evaluate student progress in AI prompting as a skill, with rubrics and sample activities.

5. The **Loops Worksheet** demonstrates how one specific core concept can be deeply explored through the intentional prompting approach.

These materials complement your existing worksheets by providing more structured guidance, conceptual frameworks, and practical exercises that turn AI interactions into meaningful learning experiences.

---
title: "Unlocking the Power of Iteration: Beyond the Basics"
subtitle: "Mastering Nested Loops and List Comprehensions in Python"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Welcome to Advanced Iteration

* Introduction to advanced iteration techniques
* Why nested loops and list comprehensions matter
* How these techniques improve code efficiency and readability
* What we'll cover in today's presentation

::: {.notes}
Welcome to our exploration of advanced iteration techniques in Python! Today we'll be building on your foundational knowledge of loops to discover more sophisticated ways to work with data. Nested loops and list comprehensions are powerful tools that allow you to write more efficient, readable code while solving complex problems.

Throughout this presentation, we'll examine how these techniques work, when to use them, and how they can simplify your code. Whether you're processing multi-dimensional data or transforming collections of items, these iteration techniques will become valuable additions to your programming toolkit. By the end of this session, you'll have a solid understanding of how to implement and leverage these patterns in your own code.
:::

# Review: Basic Iteration

* Refresher on simple for loops
* Common loop patterns with single collections
* Limitations of basic loops
* Setting the stage for advanced techniques

```python
# Basic for loop
for item in collection:
    print(item)
    
# Looping with index
for i in range(len(collection)):
    print(f"Item {i}: {collection[i]}")
```

::: {.notes}
Before diving into advanced topics, let's quickly refresh our understanding of basic loops. In Python, a simple for loop allows us to iterate through a collection like a list or string, performing the same operation on each item. We can also use the range() function to generate indices when we need to track positions.

While these basic patterns are incredibly useful, they have limitations when dealing with more complex data structures or when we need to perform multiple levels of iteration. As your programming challenges become more sophisticated, you'll encounter situations where basic loops become unwieldy or inefficient. This is where our advanced techniques come in, allowing us to express more complex operations in cleaner, more efficient ways.
:::

# Nested Loops: The Concept

* What are nested loops?
* The outer loop and inner loop relationship
* How execution flows in nested structures
* Common use cases for nested iteration

```python
# Basic nested loop structure
for outer_item in outer_collection:
    for inner_item in inner_collection:
        print(f"{outer_item}, {inner_item}")
```

::: {.notes}
Nested loops are simply loops within loops. When we nest loops, the inner loop runs completely for each iteration of the outer loop. Think of it like the hands of a clock: the minute hand (inner loop) makes a complete rotation for each hour (outer loop) that passes. This structure is particularly useful when working with multi-dimensional data or when you need to compare each item in a collection with every other item.

Understanding the execution flow is crucial: for each single iteration of the outer loop, the inner loop runs completely from start to finish. This creates a multiplicative effect on the number of operations - if the outer loop runs 5 times and the inner loop runs 10 times, the inner code block will execute 50 times total. This powerful pattern enables us to process matrices, grids, and perform combinatorial operations that would be difficult to express with simple loops.
:::

# Nested Loops: Practical Examples

* Working with multi-dimensional data
* Generating combinations and permutations
* Processing matrices and tables
* Comparing all items in a collection

```python
# Printing a multiplication table
for i in range(1, 6):
    for j in range(1, 6):
        print(f"{i} × {j} = {i*j}")
    print("-----")  # Separator between rows
```

::: {.notes}
Nested loops shine when working with structured data that has multiple dimensions. The example shown creates a simple multiplication table, where each combination of numbers is processed to display their product. This pattern extends naturally to processing data in grids, such as pixels in an image or cells in a spreadsheet.

Another common application is generating all possible combinations or pairs from collections. For instance, if you need to compare each item in a list with every other item (like finding all possible matchups in a tournament), nested loops make this straightforward. While these operations can require significant computational resources as the collections grow larger, they are often the clearest way to express these kinds of operations, especially for beginners working with moderately sized datasets.
:::

# Nested Loop Challenges

* Understanding iteration complexity
* Avoiding common pitfalls
* Performance considerations
* Readability and maintainability concerns

```python
# Potential performance issue with large datasets
for i in range(1000):
    for j in range(1000):
        # This inner code runs 1,000,000 times!
        result = i * j
```

::: {.notes}
While nested loops are powerful, they come with challenges worth noting. The most significant is performance - nested loops multiply the number of operations performed, which can lead to slow code when working with large datasets. The example shown would perform one million operations, which might be acceptable for some applications but prohibitively slow for others.

Another common pitfall is the complexity of maintaining and debugging deeply nested code. When loops are nested three or more levels deep, the code becomes difficult to read and reason about. It's often better to refactor such code, either by splitting complex operations into separate functions or by using more advanced techniques like list comprehensions. As you work with nested loops, be mindful of these trade-offs and consider whether there might be more efficient or readable approaches to your specific problem.
:::

# Introduction to List Comprehensions

* What are list comprehensions?
* Basic syntax and structure
* Advantages over traditional loops
* When to use list comprehensions

```python
# Traditional approach with for loop
squares = []
for x in range(10):
    squares.append(x**2)

# Equivalent list comprehension
squares = [x**2 for x in range(10)]
```

::: {.notes}
List comprehensions offer a concise, elegant way to create lists based on existing collections. They package the operation of looping through items, transforming them, and collecting the results in a single expressive line of code. As shown in our example, what takes multiple lines with traditional loops can often be accomplished in a single line with a list comprehension.

Beyond just saving space, list comprehensions can sometimes be more efficient than equivalent loop code, as they're optimized at the implementation level. They're particularly valuable when you need to transform data from one form to another or filter items based on certain conditions. The syntax may look intimidating at first, but it follows a natural language-like pattern: "Give me x squared for each x in the range of numbers from 0 to 9." Once you become comfortable with this pattern, you'll find list comprehensions make your code more readable and expressive.
:::

# Advanced List Comprehensions

* Adding conditional logic (filtering)
* Nested list comprehensions
* Working with multiple collections
* Converting between data structures

```python
# Filtering with conditional logic
even_squares = [x**2 for x in range(10) if x % 2 == 0]

# Nested list comprehension (flattening a matrix)
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [num for row in matrix for num in row]
```

::: {.notes}
List comprehensions become even more powerful when combined with conditional logic and nesting. Adding a condition allows you to filter items based on certain criteria - in our example, we're only including squares of even numbers. This ability to filter while transforming makes list comprehensions incredibly versatile for data processing tasks.

Nested list comprehensions mimic the behaviour of nested for loops but in a more compact form. While the syntax can be tricky to parse at first, it follows a specific pattern where each "for" clause corresponds to a level of nesting, reading from left to right. The example shown flattens a matrix (a list of lists) into a single list, demonstrating how nested comprehensions can simplify working with multi-dimensional data. As with nested loops, be mindful of readability - sometimes breaking complex operations into multiple steps can make your code easier to understand and maintain.
:::

# Comparing Nested Loops and List Comprehensions

* Clarity vs. conciseness trade-offs
* Performance considerations
* When to use each approach
* Best practices for readable code

```python
# Nested loops approach
result = []
for i in range(3):
    for j in range(3):
        result.append((i, j))

# Equivalent list comprehension
result = [(i, j) for i in range(3) for j in range(3)]
```

::: {.notes}
Choosing between nested loops and list comprehensions involves balancing several factors. Nested loops often provide more clarity for complex operations, especially when multiple steps or complex logic are involved. They're easier to debug and can be clearer for beginners to understand. List comprehensions, on the other hand, offer conciseness and can sometimes provide better performance, but may become difficult to read when they include multiple levels of nesting or complex conditions.

As a rule of thumb, consider using list comprehensions for straightforward transformations and filters, and nested loops when the logic becomes complex or when you need to perform multiple operations within each iteration. Remember that code readability is paramount - if a list comprehension becomes so complex that it's difficult to understand at a glance, breaking it down into explicit loops or multiple steps might be the better approach. The goal is to write code that clearly expresses your intent, not just to use the most concise syntax possible.
:::

# Real-World Applications

* Data processing and transformation
* Image processing (pixel manipulation)
* Generating test cases and simulations
* Working with JSON and nested data structures

```python
# Processing structured data
data = [
    {"name": "Alice", "scores": [85, 90, 78]},
    {"name": "Bob", "scores": [92, 88, 95]}
]
# Calculate average score for each person
averages = {person["name"]: sum(person["scores"])/len(person["scores"])
            for person in data}
```

::: {.notes}
Advanced iteration techniques are not just academic exercises - they solve real problems in everyday programming. Data processing often involves transforming, filtering, and aggregating collections, tasks that are well-suited to list comprehensions and nested loops. The example shown uses a dictionary comprehension (a close relative of list comprehensions) to calculate average scores from a nested data structure, demonstrating how these techniques help navigate complex data.

These patterns appear in many applications: image processing uses nested loops to manipulate pixels in a grid; simulations often generate combinations of parameters; and data processing frequently involves extracting and transforming values from nested structures like JSON. As you encounter these scenarios in your own projects, you'll develop an intuition for which technique fits each situation. Remember that the best approach is often the one that most clearly expresses your intent while maintaining appropriate performance for your specific use case.
:::

# Wrap-Up and Best Practices

* Choose the right tool for the task
* Prioritise readability over cleverness
* Break complex operations into manageable steps
* Practice and experiment with these techniques

::: {.notes}
As we conclude our exploration of advanced iteration techniques, remember that mastery comes through thoughtful practice. When approaching a problem that requires iteration, consider both nested loops and list comprehensions, evaluating which approach best suits your specific needs. While list comprehensions offer elegant conciseness, sometimes explicit nested loops provide better clarity.

Keep readability as your north star - code is read far more often than it's written, and clear code saves time and prevents bugs. Don't hesitate to break complex operations into multiple steps with meaningful variable names to document your intent. As you practice these patterns, you'll develop an intuition for when each approach shines. Remember that these advanced techniques aren't about showing off coding prowess but about expressing your solution in the most appropriate, maintainable way possible.
:::---
title: "Mastering Python Lists: Beyond the Basics"
subtitle: "Powerful Techniques for Efficient Data Manipulation"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to Lists

* What are lists in Python?
* Why lists are fundamental data structures
* Common applications of lists in programming
* How lists compare to other data structures

::: {.notes}
Welcome to our exploration of Python lists! Lists are one of Python's most versatile and commonly used data structures. At their core, lists are ordered collections that can store multiple items of different types. What makes lists particularly powerful is their flexibility—they can contain numbers, strings, and even other lists, all within a single structure.

Lists serve as the foundation for many programming tasks, from storing user inputs to managing complex datasets. Throughout this presentation, we'll examine various techniques for manipulating lists effectively, focusing on built-in methods that make working with lists both intuitive and efficient for beginners and experienced programmers alike.
:::

# List Basics

* Creating lists: `my_list = [1, 2, 3, 'hello']`
* Accessing elements: `my_list[0]` → `1`
* List indexing (zero-based)
* Negative indexing: `my_list[-1]` → `'hello'`
* Slicing lists: `my_list[1:3]` → `[2, 3]`

::: {.notes}
Let's start with the fundamentals of working with lists. Creating a list in Python is as simple as placing comma-separated values within square brackets. What's particularly useful about Python lists is how they handle indexing—with the first element at position 0, not 1 as you might expect. This zero-based indexing is consistent across many programming languages.

Python also offers handy features like negative indexing, where -1 refers to the last element, making it easy to access elements from the end of a list. Slicing is another powerful technique that allows you to extract a portion of a list using the format `list[start:end]`, where the end index is exclusive. These basic operations form the building blocks for more complex list manipulations we'll explore in the following slides.
:::

# Common List Methods: Adding Elements

* `append()`: Add an item to the end
  * `my_list.append(4)` → `[1, 2, 3, 'hello', 4]`
* `insert()`: Add an item at a specific position
  * `my_list.insert(1, 'new')` → `[1, 'new', 2, 3, 'hello']`
* `extend()`: Add multiple items from another iterable
  * `my_list.extend([5, 6])` → `[1, 2, 3, 'hello', 5, 6]`

::: {.notes}
Python provides several intuitive methods for adding elements to lists. The `append()` method is perhaps the most frequently used—it simply adds an item to the end of a list. This is perfect for when you're collecting items one at a time, such as during user input or data processing.

When you need more control over where an element is placed, `insert()` allows you to specify the exact position. The `extend()` method is particularly useful when combining lists, as it adds each element of the second list individually rather than nesting it. Understanding the differences between these methods is crucial, as using the wrong one (like using `append()` instead of `extend()` when adding multiple items) can lead to unexpected results in your data structure.
:::

# Common List Methods: Removing Elements

* `remove()`: Delete a specific value
  * `my_list.remove('hello')` → `[1, 2, 3]`
* `pop()`: Remove an item at a specific position and return it
  * `my_list.pop(1)` → returns `2`, list becomes `[1, 3]`
* `del` statement: Remove an item or slice
  * `del my_list[0]` → list becomes `[3]`
* `clear()`: Remove all items
  * `my_list.clear()` → `[]`

::: {.notes}
Removing elements from lists is just as important as adding them, and Python offers multiple approaches for different scenarios. The `remove()` method searches for a specific value and removes the first occurrence, which is useful when you know what to remove but not where it is. If it doesn't find the value, Python will raise an error, so it's often paired with an if statement in practice.

The `pop()` method is particularly versatile as it not only removes an item (by default, the last one) but also returns it, allowing you to use the removed value. The `del` statement offers more flexibility, allowing you to remove individual items or slices. Finally, the `clear()` method provides a quick way to empty a list completely without reassigning it. Each of these methods has its own use case, and selecting the right one depends on your specific requirements.
:::

# List Ordering and Sorting

* `sort()`: Sort the list in place
  * `numbers.sort()` → `[1, 2, 3, 4, 5]`
* Sorting with custom key function
  * `names.sort(key=len)` → sorts by string length
* `reverse()`: Reverse the order of elements
  * `my_list.reverse()`
* Built-in `sorted()` function: Create a new sorted list
  * `sorted_list = sorted(my_list)`

::: {.notes}
Ordering and sorting operations are essential when working with lists containing related items. The `sort()` method rearranges elements in ascending order by default, directly modifying the original list. This in-place sorting is efficient when you don't need to preserve the original order. For more complex sorting scenarios, you can provide a custom key function—for example, sorting strings by length rather than alphabetically.

The `reverse()` method simply flips the order of elements, which is useful for changing sort direction or implementing simple algorithms. When you need to keep the original list intact, the built-in `sorted()` function creates a new sorted list without modifying the source. Understanding these ordering operations helps you organise data efficiently, whether you're displaying information to users or preparing data for further processing.
:::

# List Comprehensions

* Concise way to create new lists
* Basic syntax: `[expression for item in iterable]`
* Example: `[x**2 for x in range(5)]` → `[0, 1, 4, 9, 16]`
* Adding conditions: `[x for x in range(10) if x % 2 == 0]` → `[0, 2, 4, 6, 8]`
* Advantages over traditional for loops

::: {.notes}
List comprehensions represent one of Python's most elegant features, allowing you to create new lists with a single line of code. This approach is not only more concise than traditional for loops but often more readable once you become familiar with the syntax. The basic pattern follows a natural language structure: "give me this expression for each item in this iterable."

The real power of list comprehensions becomes apparent when you add conditions to filter elements. For example, creating a list of only even numbers becomes remarkably simple. While traditional for loops might be easier for beginners to understand initially, list comprehensions typically execute faster and encourage a more functional programming style. They're particularly valuable when transforming data or extracting specific elements from existing collections—tasks that are common in data analysis and processing.
:::

# Finding Information in Lists

* `index()`: Find the position of an item
  * `my_list.index('hello')` → returns the index
* `count()`: Count occurrences of an item
  * `my_list.count(2)`
* `in` operator: Check if an item exists
  * `if 'hello' in my_list:`
* `len()`: Get the length of a list
  * `len(my_list)`

::: {.notes}
Extracting information from lists is a crucial skill for effective programming. The `index()` method helps you locate where a specific value appears in a list, which is particularly useful when you need to find and then modify or remove elements. Be aware that this method raises an error if the value isn't found, so it's often used with the `in` operator as a safety check.

The `count()` method provides a quick way to count how many times a specific value appears, which is valuable for data analysis tasks. The `in` operator offers a readable way to check for existence, making your code more intuitive. Finally, the built-in `len()` function gives you the total number of elements in a list, which is essential for loop control and validation. These tools for finding information enable you to make informed decisions about how to process your list data.
:::

# Advanced List Operations

* Copying lists properly: `new_list = old_list.copy()`
* Nested lists for multi-dimensional data
* Unpacking lists: `a, b, c = [1, 2, 3]`
* List as arguments: `function(*my_list)`
* Using `map()` and `filter()` with lists

::: {.notes}
As you become more comfortable with basic list operations, several advanced techniques can enhance your programming toolkit. Proper list copying is essential to avoid unintended side effects—using `copy()` creates a new list rather than just another reference to the same list. This distinction is crucial when modifying data, as changes to a copied list won't affect the original.

Nested lists provide a way to represent multi-dimensional data, such as grids or matrices. List unpacking offers an elegant syntax for assigning multiple variables at once, while the star operator (`*`) lets you use list elements as individual arguments to functions. Functions like `map()` and `filter()` provide functional programming approaches to list transformation. These advanced operations might seem complex initially, but they make your code more expressive and efficient once mastered.
:::

# Practical List Applications

* Data collection and storage
* Building user interfaces and menus
* Implementing algorithms (queues, stacks)
* Data analysis and transformation
* Working with external data sources
* List processing in real-world projects

::: {.notes}
Let's connect our technical knowledge to practical applications. Lists appear everywhere in real-world programming—they're the backbone of data collection systems, where information is gathered and stored for further processing. In user interfaces, lists often represent menu options or collections of UI elements that need to be managed dynamically.

From an algorithmic perspective, lists can implement fundamental data structures like queues and stacks, enabling complex operations like tracking history or managing order-dependent processes. In data analysis, lists frequently serve as intermediate structures during transformation pipelines. Whether you're developing a simple script to process CSV files or building complex applications that interact with databases, understanding list manipulation techniques will significantly improve your ability to write efficient, maintainable code.
:::

# Summary and Best Practices

* Choose the right list method for each task
* Consider performance implications for large lists
* Use list comprehensions for cleaner code
* Remember that lists are mutable (modifiable)
* Balance readability and efficiency
* Practice with real-world examples

::: {.notes}
As we conclude our exploration of Python lists, remember that the choice of list method significantly impacts both code readability and performance. For large datasets, operations like `insert()` at the beginning of a list can be costly, while `append()` at the end is typically very efficient. Understanding these performance characteristics helps you write more optimised code.

List comprehensions offer a powerful balance between conciseness and readability, but don't sacrifice clarity for brevity. Always keep in mind that lists are mutable, meaning they can be modified after creation—this is both a strength and a potential source of bugs if not managed carefully. The best way to master list manipulation is through practice with real data and real problems. As you apply these techniques in your projects, you'll develop an intuitive sense for which approaches work best in different scenarios.
:::---
title: "The Power of Lists: Building Your Data Collection Toolkit"
subtitle: "Mastering the Fundamentals of Creating and Accessing Data Collections"
author: "Michael Borck"
format:
   pptx:
     reference-doc: ../../../_assets/template.pptx
   pdf:
     toc: false
     colorlinks: true
   docx:
     toc: false
     highlight-style: github
   html:
     toc: true
     toc-expand: 2
     embed-resources: true
---

# The Power of Lists

* Lists are ordered collections of items
* One of the most versatile data structures in programming
* Foundation for many applications
* Essential skill for any programmer

::: {.notes}
Welcome to our presentation on list fundamentals! Lists are one of the most powerful tools in programming, allowing us to store and organise multiple items in a single variable. Whether you're building a simple to-do application or analysing complex datasets, understanding lists is essential.

Today, we'll explore how to create and access data within lists. We won't be covering loops yet—that's coming in the next module—but you'll learn everything you need to start working with collections of data effectively. These skills form the foundation for more advanced programming concepts we'll explore later.
:::

# Creating Lists

* Lists can contain multiple values in a single variable
* Created using square brackets `[]`
* Can contain any data type (numbers, strings, etc.)
* Elements are separated by commas

```python
# Empty list
my_list = []

# List of numbers
numbers = [1, 2, 3, 4, 5]

# List of strings
colours = ["red", "green", "blue"]

# Mixed data types
mixed = [42, "hello", True, 3.14]
```

::: {.notes}
Creating lists in Python is straightforward. You simply use square brackets and separate individual items with commas. What makes lists particularly flexible is their ability to hold different types of data—you can store numbers, strings, booleans, or even other lists within a list.

Think of a list like a shopping list, where each item is stored in sequence. This ordering is important, as we'll see when we discuss accessing list elements. When you're just starting out, experiment with creating different types of lists to get comfortable with the syntax. Try making lists of your favourite foods, films, or any collection of items that interests you.
:::

# List Indexing

* Accessing individual elements using indices
* Indices start at 0 (first element is at position 0)
* Use square brackets with the index number
* Negative indices count from the end (-1 for last element)

```python
fruits = ["apple", "banana", "cherry", "date"]

# Accessing elements
first_fruit = fruits[0]  # "apple"
second_fruit = fruits[1]  # "banana"
last_fruit = fruits[-1]  # "date"
```

::: {.notes}
Understanding list indexing is crucial when working with lists. In Python (and most programming languages), we count positions starting from 0, not 1. This means the first element is at index 0, the second at index 1, and so on. This zero-based indexing can be confusing at first, but it quickly becomes second nature.

A helpful feature in Python is the ability to use negative indices to access elements from the end of the list. For example, -1 refers to the last element, -2 to the second-last, and so forth. This is particularly useful when you don't know the exact length of a list but need to access its final elements. When teaching beginners about indexing, I often recommend visualising the list with position numbers written above each element to reinforce this concept.
:::

# List Slicing

* Extract multiple elements from a list
* Syntax: `list_name[start:end]`
* Returns elements from `start` up to (but not including) `end`
* Omitting `start` begins from index 0
* Omitting `end` goes until the end of the list

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

first_three = numbers[0:3]  # [0, 1, 2]
middle = numbers[3:7]      # [3, 4, 5, 6]
last_four = numbers[-4:]    # [6, 7, 8, 9]
every_second = numbers[::2] # [0, 2, 4, 6, 8]
```

::: {.notes}
List slicing extends the concept of indexing to allow us to access a range of elements at once. The syntax `list_name[start:end]` creates a new list containing elements from the start index up to, but not including, the end index. This "up to but not including" pattern is common in programming and takes some getting used to.

Slicing offers incredible flexibility. You can omit the start index to slice from the beginning, omit the end index to slice until the end, or even use a third parameter (as in `numbers[::2]`) to specify a step value, which lets you take every nth element. Think of slicing as cutting pieces from a loaf of bread—you specify where to start cutting and where to stop, and you get everything in between.
:::

# List Methods

* Functions built into lists
* Common methods for adding items:
  * `append()` - adds an item to the end
  * `insert()` - adds an item at a specific position
* Common methods for removing items:
  * `remove()` - removes a specific value
  * `pop()` - removes and returns an item at a specific index

```python
shopping = ["bread", "milk"]

# Adding items
shopping.append("eggs")        # ["bread", "milk", "eggs"]
shopping.insert(0, "butter")   # ["butter", "bread", "milk", "eggs"]

# Removing items
shopping.remove("milk")        # ["butter", "bread", "eggs"]
last_item = shopping.pop()     # ["butter", "bread"], last_item = "eggs"
```

::: {.notes}
List methods provide powerful tools for manipulating lists. These built-in functions let you modify lists in various ways without having to write complex code. Understanding these methods is essential for effective list manipulation.

The append and insert methods allow you to add items to a list. Append is simpler, always adding to the end, while insert gives you more control by specifying the exact position. For removing items, remove lets you specify the value to remove, while pop removes an item at a specific position and returns it, which can be useful when you need to use the removed value. Think of these methods as different ways to modify your shopping list—adding forgotten items or crossing off items you've already purchased.
:::

# List Properties

* Lists are mutable (can be changed after creation)
* Lists maintain order of elements
* Lists can contain duplicate values
* Finding the length with `len()`
* Checking for values with `in`

```python
numbers = [3, 1, 4, 1, 5, 9]

# Modifying elements
numbers[0] = 10          # [10, 1, 4, 1, 5, 9]

# Length of list
length = len(numbers)    # 6

# Checking membership
has_five = 5 in numbers  # True
has_seven = 7 in numbers # False
```

::: {.notes}
Understanding list properties helps you work with them effectively. Unlike some data structures, lists are mutable, meaning you can change their contents after creating them. This makes them incredibly flexible for storing data that might need to change.

Lists also maintain the order of elements, which is crucial for many applications. The `len()` function tells you how many elements are in a list, while the `in` operator lets you check if a specific value exists in the list. These features are particularly useful when validating data or implementing search functionality. Whenever you're working with collections of data that need to maintain order and might require modifications, lists are often the go-to data structure.
:::

# Lists vs Other Data Types

* String: ordered collection of characters (immutable)
* Tuple: ordered collection like lists (immutable)
* Dictionary: key-value pairs (unordered in older Python versions)
* Set: unordered collection of unique elements

```python
# Comparison
my_list = [1, 2, 3]           # Mutable, ordered
my_tuple = (1, 2, 3)          # Immutable, ordered
my_dict = {"a": 1, "b": 2}    # Key-value pairs
my_set = {1, 2, 3}            # Unique elements only
```

::: {.notes}
While lists are incredibly versatile, they're just one of several collection types in Python. Understanding the differences between these types helps you choose the right tool for specific tasks. Strings, like lists, are ordered collections, but they're specifically for text and are immutable (cannot be changed after creation). Tuples are similar to lists but immutable, making them useful when you want to ensure data doesn't change.

Dictionaries use key-value pairs instead of indices, allowing you to access elements by name rather than position. Sets are collections of unique elements with no duplicates allowed. Each type has its strengths—lists excel when you need an ordered collection that can change, tuples when order matters but immutability is required, dictionaries when you need named access, and sets when you only care about unique membership. In real-world programming, you'll often use multiple types together to solve complex problems.
:::

# Common List Operations

* Joining two lists with `+`
* Repeating lists with `*`
* Finding an item's index with `index()`
* Counting occurrences with `count()`
* Sorting lists with `sort()` or `sorted()`

```python
list1 = [1, 2, 3]
list2 = [4, 5, 6]

# Combine lists
combined = list1 + list2      # [1, 2, 3, 4, 5, 6]

# Repeat lists
repeated = list1 * 3          # [1, 2, 3, 1, 2, 3, 1, 2, 3]

numbers = [3, 1, 4, 1, 5]
position = numbers.index(4)   # 2
occurrences = numbers.count(1) # 2
numbers.sort()                # [1, 1, 3, 4, 5]
```

::: {.notes}
Beyond basic creation and access, Python provides many powerful operations for working with lists. The `+` operator joins lists together, while `*` lets you repeat a list multiple times. The `index()` method finds the position of an item (returning the first occurrence if duplicates exist), and `count()` tells you how many times an item appears in a list.

Sorting is another common operation, with two main approaches: `sort()` modifies the original list in place, while `sorted()` returns a new sorted list without changing the original. These operations give you tremendous flexibility when manipulating collections of data. For instance, when building a playlist app, you might use `+` to combine genre-specific lists, `index()` to find a specific song, and `sort()` to arrange songs alphabetically.
:::

# Practical Applications of Lists

* Storing collections of related items
* Building data-driven applications
* Managing user inputs
* Implementing data structures (stacks, queues)
* Foundation for data analysis

```python
# Example: Simple to-do list application
todo_list = []

# Add tasks
todo_list.append("Complete assignment")
todo_list.append("Read chapter 5")
todo_list.append("Prepare for quiz")

# Mark a task as complete (remove it)
todo_list.remove("Read chapter 5")

# Current tasks: ["Complete assignment", "Prepare for quiz"]
```

::: {.notes}
Lists have countless practical applications in real-world programming. In fact, they're so fundamental that it's hard to imagine building modern applications without them. From simple to-do lists to complex data analysis, lists provide the structure needed to organise and manipulate collections of data.

As a beginner, implementing a basic to-do list application is an excellent way to practise list operations. You can add tasks with `append()`, remove completed tasks with `remove()`, and display the current list to the user. This simple example demonstrates how lists facilitate data management in applications. As you advance, you'll use lists as building blocks for more complex data structures like stacks (last-in, first-out) and queues (first-in, first-out), which have applications in everything from browser history management to printer job scheduling.
:::

# Next Steps

* In the next module: loops for iterating through lists
* Future topics:
  * List comprehensions
  * Nested lists (lists within lists)
  * Advanced list operations
  * Working with libraries that use lists (NumPy, Pandas)
* Practice is key to mastery!

::: {.notes}
Today we've covered the fundamentals of creating and accessing lists, but this is just the beginning of your journey. In the next module, we'll explore loops, which will allow you to process every element in a list automatically—a crucial skill for working with larger collections of data.

As you continue learning, you'll encounter more advanced list concepts like list comprehensions (a concise way to create lists), nested lists (lists containing other lists), and powerful libraries built around list-like structures. The skills you've learned today form the foundation for all of this future learning. I encourage you to practice regularly by creating small programs that use lists—perhaps a contact list, a music playlist, or a collection of your favourite quotes. Remember, programming is like learning an instrument: regular practice leads to mastery.
:::---
title: "The Power of Repetition: Mastering Loop Structures"
subtitle: "Understanding For and While Loops in Programming"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to Loop Structures

* Programming often requires repeating actions
* Loops are control structures that automate repetition
* Two primary loop types: For loops and While loops
* Essential for efficient, scalable code
* Foundational concept for all programming languages

::: {.notes}
Welcome to our presentation on loop structures! When writing programs, we frequently encounter situations where we need to perform the same action multiple times. Rather than writing the same code over and over, programming languages provide loop structures to handle repetition efficiently. 

In this presentation, we'll focus on the two most common loop types: For loops and While loops. Understanding these structures is fundamental to programming as they appear in virtually every programming language and are used in countless applications, from simple counters to complex data processing algorithms. Mastering loops will significantly enhance your ability to write clean, efficient code.
:::

# The Problem: Why We Need Loops

* Manual repetition is tedious and error-prone
* Consider checking 1,000 numbers for even/odd status
* Without loops:
  * Write the same code 1,000 times
  * Hard to maintain and update
* With loops:
  * Write the logic once
  * Let the computer handle repetition

::: {.notes}
Imagine you need to check whether each number in a list of 1,000 numbers is even or odd. Without loops, you would need to write the same checking code 1,000 times—a tedious and error-prone approach. If you later discovered a bug in your logic, you'd need to fix it in all 1,000 places!

Loops solve this problem elegantly by allowing you to write the logic once and then instruct the computer to repeat it as many times as needed. This not only makes your code more concise and readable but also much easier to maintain. When your requirements change, you only need to update the logic in one place, and the loop will apply that updated logic to all iterations.
:::

# For Loops: Concept and Structure

* Used when the number of iterations is known beforehand
* Components of a For loop:
  * Initialisation (starting value)
  * Condition (when to stop)
  * Update statement (how to change the counter)
* Executes a specific number of times
* Common uses: iterating over collections, counting

::: {.notes}
For loops are the perfect choice when you know exactly how many times you need to repeat an action. They follow a clear structure with three key components: initialisation (where we set our starting point), a condition (that determines when to stop), and an update statement (that changes our counter with each iteration).

Think of a For loop like a recipe that says "stir the mixture 20 times." You know exactly how many stirs to perform before you start. For loops are commonly used to process elements in a collection (like items in a list), perform actions a set number of times, or count up or down between specific values. Their predictable nature makes them easy to understand and reason about.
:::

# For Loop: Python Example

* Basic syntax in Python:

```python
for variable in sequence:
    # Code to repeat
```

* Example: Printing numbers 1 through 5

```python
for i in range(1, 6):
    print(i)
# Output: 1 2 3 4 5
```

* Example: Iterating through a list

```python
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print("I like " + fruit)
```

::: {.notes}
The Python For loop has a straightforward syntax that makes it particularly readable. The loop variable (often named 'i' for 'index', or something more descriptive like 'fruit') takes on each value in the specified sequence, one at a time, and the indented code block executes once for each value.

The `range()` function is frequently used with For loops to generate a sequence of numbers. In our first example, `range(1, 6)` creates a sequence from 1 up to (but not including) 6, so the loop prints numbers 1 through 5. In the second example, we iterate directly through a list of fruits, demonstrating how loops can work with different data types. This flexibility makes For loops incredibly versatile for all kinds of repetitive tasks.
:::

# While Loops: Concept and Structure

* Used when the number of iterations is unknown beforehand
* Continues as long as a specified condition is true
* Components:
  * Initialisation (before the loop)
  * Condition (when to continue)
  * Update statement (inside the loop)
* May execute zero or many times
* Requires careful condition design to avoid infinite loops

::: {.notes}
While loops are fundamentally different from For loops because they're designed for scenarios where you don't know in advance how many iterations you'll need. Instead of counting, a While loop continues executing as long as its specified condition remains true. This makes While loops particularly useful for situations that depend on user input, external data, or complex conditions.

The structure of a While loop requires careful attention. You typically initialise variables before the loop begins, check a condition at the start of each iteration, and include statements inside the loop that eventually change the condition to false. If you forget to update the condition, you might create an "infinite loop" that never ends—a common beginner mistake. While loops give you more flexibility but also require more responsibility to ensure they terminate properly.
:::

# While Loop: Python Example

* Basic syntax in Python:

```python
while condition:
    # Code to repeat
    # Update condition
```

* Example: Counting to 5

```python
count = 1
while count <= 5:
    print(count)
    count += 1
# Output: 1 2 3 4 5
```

* Example: User input validation

```python
password = ""
while password != "secret":
    password = input("Enter password: ")
print("Access granted")
```

::: {.notes}
In Python, While loops begin with the keyword "while" followed by a condition that evaluates to either True or False. As long as the condition is True, the indented code block continues to execute. Notice that in our counting example, we need to manually initialise the counter before the loop and increment it inside the loop—steps that For loops handle automatically.

The second example demonstrates a practical application of While loops: validating user input. The loop continues asking for a password until the user enters the correct one. This kind of interaction couldn't easily be handled with a For loop because we don't know how many attempts the user will need. While loops excel at these open-ended scenarios where the number of iterations depends on dynamic conditions.
:::

# Choosing the Right Loop

* For loops: Best when you know the number of iterations
  * Iterating through collections
  * Counting a specific number of times
  * Processing sequences

* While loops: Best for conditional repetition
  * User input validation
  * Waiting for a condition to be met
  * Unknown number of iterations

* Both can often solve the same problem in different ways

::: {.notes}
Choosing between For and While loops is an important skill that improves with practice. Generally, if you can answer the question "How many times will this loop run?" before the loop starts, a For loop is probably the better choice. For loops are typically more concise and less prone to errors since they handle the initialisation and incrementation automatically.

While loops shine in situations where the termination depends on a condition that can't be predicted in advance. They're perfect for scenarios like processing input until the user enters a specific value, or running a simulation until a certain state is reached. Remember that most problems can be solved with either type of loop, but choosing the appropriate one will make your code clearer and more maintainable.
:::

# Common Loop Patterns

* Loop control statements:
  * `break`: Exit the loop immediately
  * `continue`: Skip to the next iteration
  
* Nested loops: Loops within loops
  * Useful for working with multi-dimensional data
  
* Accumulators: Building results during iteration
  * Summing values, collecting results

* Loop and a half: Checking conditions mid-loop

::: {.notes}
Beyond the basic loop structures, several common patterns appear frequently in programming. The `break` statement allows you to exit a loop immediately when a certain condition is met, while `continue` lets you skip the rest of the current iteration and move to the next one. These control statements are powerful tools for making your loops more efficient.

Nested loops—placing one loop inside another—are essential for working with multi-dimensional data structures like matrices or tables. Accumulators are variables that collect or combine results during iteration, such as summing numbers or building a list of results. The "loop and a half" pattern addresses situations where you need to check conditions in the middle of processing each item. These patterns build on the basic loop structures to solve more complex problems elegantly.
:::

# Loop Pitfalls and Best Practices

* Common mistakes to avoid:
  * Infinite loops (forgetting to update condition)
  * Off-by-one errors (including or excluding endpoints)
  * Inefficient loop designs

* Best practices:
  * Keep loops simple and focused
  * Use meaningful variable names
  * Consider performance for large datasets
  * Test boundary conditions (first/last iterations)

::: {.notes}
Loops can be tricky, especially for beginners. Infinite loops occur when the termination condition is never met, causing your program to hang indefinitely. Off-by-one errors happen when you mistakenly include or exclude an element at the boundaries of your iteration range—for example, iterating from 0 to 9 when you meant 1 to 10. These bugs can be subtle and frustrating to track down.

Following best practices can help you avoid these pitfalls. Keep your loops focused on a single task, use variable names that clearly indicate their purpose (e.g., `student_index` rather than just `i`), and consider the performance implications when working with large datasets. Always test your loops with attention to the boundary conditions—what happens on the first and last iterations? Taking these precautions will help you write more reliable loop structures.
:::

# Summary and Further Practice

* Loops are essential programming constructs
* For loops: Use when the iteration count is known
* While loops: Use for condition-based repetition
* Practice is key to mastery
* Next steps:
  * Experiment with different loop types
  * Solve problems using loops
  * Learn about loop variants in different languages

::: {.notes}
We've covered the fundamental concepts of For and While loops, examining their structures, use cases, and some common patterns and pitfalls. Remember that For loops are best when you know the number of iterations in advance, while While loops excel when the repetition depends on a condition that may change dynamically.

To truly master loops, there's no substitute for practice. Try rewriting While loops as For loops and vice versa to understand their differences and similarities. Tackle programming challenges that involve repetition, such as processing lists, validating input, or implementing algorithms. As you progress, you'll also encounter variations of these basic loop structures in different programming languages, but the core concepts you've learned today will remain relevant regardless of the language you use.
:::---
title: "Staff Answer Guide: ColabTurtlePlus Worksheet"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---



## Setup Checklist

- Ensure ColabTurtlePlus is installed on all student machines with `pip install ColabTurtlePlus`
- If using Google Colab, have students run `!pip install ColabTurtlePlus` in a code cell at the beginning
- Verify internet connectivity for SVG rendering
- Have the second worksheet (Chatbot) ready for the second hour

## Expected Learning Outcomes

By the end of this worksheet, students should be able to:
1. Use basic ColabTurtlePlus commands to create drawings
2. Apply loops to repeat drawing operations
3. Create and manipulate lists of data (colors, coordinates, etc.)
4. Combine loops and lists to create more complex patterns
5. Understand the concept of iteration and how to use it efficiently

## Activity 1: Getting Started with ColabTurtlePlus

### Expected Output
Students should see a window with a turtle that draws a simple square.


### Common Issues
- **Error: No module named 'ColabTurtlePlus'** - Student needs to run the pip install command
- **No output visible** - Check if `done()` was called at the end
- **Square doesn't appear centered** - Check if the setup dimensions are correct and if clearscreen() was called

### Teaching Notes
- The parameters for `setup()` define the width and height of the drawing area
- The `speed()` function accepts values 1-13, with 13 being the fastest
- Point out the difference between creating object-oriented `t = Turtle()` versus procedural style

## Activity 2: Using Lists with ColabTurtlePlus

### Expected Output
Students should see a series of colored lines followed by colored squares.


### Discussion Questions
- What is the advantage of storing the colors in a list rather than setting each color individually?
- How does the index `i` help us access different elements in the colors list?
- What would happen if we had more colors than squares or more squares than colors?

### Teaching Notes
- The list indexing using `colors[i]` is a key concept to emphasize
- Point out how the nested loops work (outer loop for colors, inner loop for drawing squares)
- Discuss the difference between `for color in colors` and `for i in range(len(colors))`

## Activity 3: Nested Loops and Patterns

### Expected Output
Students should see a colorful spiral followed by a pattern of filled circles.


### Code Explanation
- The modulo operator `i % len(spiral_colors)` creates a repeating pattern through the colors list
- The size variable increases by 2 each iteration, creating the expanding spiral
- The positions list contains tuples of (x,y) coordinates for each circle

### Teaching Notes
- The modulo operator is worth explaining in detail as many students find it confusing
- Explain how lists can store different types of data (strings for colors, tuples for positions)
- Discuss how `begin_fill()` and `end_fill()` work together to create filled shapes

## Activity 4: Create Your Own Pattern

### Sample Solution
Here's a sample solution students might create:

```python
clearscreen()
setup(400, 400)
showborder()
t = Turtle()
t.shape("turtle")
t.speed(6)

# Create lists for colors and sizes
my_colors = ["blue", "purple", "teal"]
my_sizes = [20, 40, 60, 80, 100]

# Draw a series of concentric squares with different colors
for i, size in enumerate(my_sizes):
    # Get the color (cycle through if more sizes than colors)
    current_color = my_colors[i % len(my_colors)]
    t.color(current_color)
    
    # Move to starting position for this square
    t.penup()
    t.goto(-size/2, -size/2)  # Bottom left corner of square
    t.pendown()
    
    # Draw the square
    for _ in range(4):
        t.forward(size)
        t.left(90)

# Display the final pattern
done()
```

### Alternative Solution
A different approach students might take:

```python
clearscreen()
setup(400, 400)
showborder()
t = Turtle()
t.shape("turtle")
t.speed(10)

# Create a list of angles for a star
angles = [144, 144, 144, 144, 144]
colors = ["red", "orange", "yellow", "green", "blue"]

# Draw a colorful star
t.penup()
t.goto(0, 50)
t.pendown()

for i in range(5):
    t.color(colors[i])
    t.forward(150)
    t.right(angles[i])

done()
```

### Discussion Points
- How did students choose to organize their lists?
- Did they use nested loops effectively?
- What creative approaches did they take to create interesting patterns?

## Extension: Multiple Turtles and Shapes

### Expected Output
Students should see a gold star and a green triangle drawn by two different turtles.



### Teaching Notes
- Creating multiple turtles with different characteristics is a key feature of ColabTurtlePlus
- The `draw_shape` function is an example of how to reuse code for different shapes
- Lists of coordinates are a powerful way to define complex shapes

### Common Questions
- **Can I have more than two turtles?** Yes, you can create as many as you need
- **How do coordinates work in ColabTurtlePlus?** By default, (0,0) is the center of the screen in "standard" mode
- **How do I save my drawing?** Use `saveSVG()` to save the drawing as an SVG file

## Challenge: Create Something Artistic

### Expected Output
Students should see a colorful flower with multiple petals.


### Key Concepts Demonstrated
- Using loops to create repeating patterns (petals)
- Using modulo to cycle through a color list
- Creating complex shapes with simple geometric operations
- Using fill to create colored regions

## Transition to Chatbot Activity

### Discussion Points
- How are the concepts of loops and lists transferable to other applications?
- What similarities might exist between graphic patterns and conversation patterns?
- How might lists be useful for storing conversation history?

## Assessment Criteria

To evaluate student understanding, look for:

1. **Basic Skills (C grade)**
   - Successfully completes Activities 1 & 2
   - Can create a simple pattern using loops
   - Understands basic list access

2. **Intermediate Skills (B grade)**
   - Successfully completes all required activities
   - Creates an original pattern in Activity 4
   - Uses nested loops effectively
   - Demonstrates understanding of list indexing

3. **Advanced Skills (A grade)**
   - Completes extension activities
   - Creates complex, creative patterns
   - Efficiently combines loops and lists
   - Adds additional features or customizations
   - Can explain code concepts to others

## Common Student Mistakes

1. **Loop Confusion**
   - Forgetting to indent code inside loops
   - Mixing up range() parameters
   - Not understanding when to use nested loops

2. **List Errors**
   - Using an index that's out of range (e.g., accessing element 5 in a 5-item list)
   - Forgetting that indexing starts at 0
   - Not understanding list slicing

3. **Coordinate Confusion**
   - Forgetting that (0,0) is at center of screen
   - Mixing up x and y coordinates
   - Not accounting for the drawing extending beyond screen boundaries

## Time Management

- Activity 1: ~10 minutes
- Activity 2: ~15 minutes
- Activity 3: ~15 minutes
- Activity 4: ~15 minutes
- Extension/Challenge: ~10 minutes

If students are progressing rapidly, encourage them to try the Challenge activity. If they are struggling, focus on ensuring they understand the core concepts in Activities 1-3 before moving on.

## Additional ColabTurtlePlus Features to Highlight

If time permits, you can introduce these additional features:

- Different turtle shapes: `t.shape("arrow")`, `t.shape("circle")`, etc.
- Stamping: `t.stamp()` to leave an impression without drawing a line
- Pen size: `t.pensize(3)` to change line thickness
- Fill rule options: `t.fillrule("evenodd")` vs `t.fillrule("nonzero")`
- SVG saving: `saveSVG()` to export drawings

## Preparation for Hour 2 (Chatbot)

Before transitioning to the chatbot activity, ensure:
- All students have completed at least through Activity 3
- Students understand the basic concepts of loops and lists
- You've discussed how these concepts will apply to the next activity
- Everyone has access to the `simple_bot` package for the next portion---
title: "Staff Answer Guide: Build-A-Bot Worksheet"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


## Setup Checklist

- Ensure the `simple_bot` package is properly installed and accessible to all students
- Verify that the local Ollama server is running and accessible
- Test the connection to ensure `get_response()` works correctly
- Have sample responses prepared in case the AI service is unavailable

## Expected Learning Outcomes

By the end of this worksheet, students should be able to:
1. Use loops to create continuous interactions with a chatbot
2. Create and manipulate lists to store conversation history
3. Implement basic command structures using conditionals and lists
4. Apply the concepts of loops and lists to a conversational interface
5. Understand how to provide context to an AI using previous messages

## Activity 1: One-Shot Bot Response

### Expected Output
Students should successfully import the `simple_bot` package and get a single response from the AI.

```
Ask the bot something: What is Python?
Bot: Python is a high-level, interpreted programming language known for its readability and simplicity. It supports multiple programming paradigms including procedural, object-oriented, and functional programming. Python is widely used for web development, data analysis, artificial intelligence, scientific computing, and automation.
```

### Common Issues
- **ImportError**: Student needs to check that `simple_bot` is correctly installed
- **No response from bot**: Check connection to Ollama server
- **Delayed response**: Reassure students that the first response might take longer as the model loads

### Teaching Notes
- Explain that `get_response()` sends the text to an AI model running locally on the Ollama server
- Point out that this is a simple sequential execution - one question, one answer
- Ask students to identify limitations of this approach (doesn't remember context, can't have a conversation)

## Activity 2: Creating a Looping Bot

### Expected Output
Students should see a continuous conversation loop that exits when they type 'bye', 'quit', or 'exit'.

```
Welcome to LoopBot! Ask me anything! Type 'bye' to quit.
You: Hello
Bot: Hello! How can I assist you today?
You: What can you do?
Bot: I'm a simple AI assistant trained to have conversations and answer questions. I can provide information, help with tasks, offer suggestions, and engage in casual discussion. Feel free to ask me anything!
You: bye
Bot: Goodbye! 👋
```

### Code Explanation
- The `while True:` creates an infinite loop that continues until explicitly broken
- The `if user_input.lower() in ["bye", "quit", "exit"]:` checks for exit commands
- The `break` statement exits the loop when an exit command is detected
- Each iteration of the loop gets new input and displays a response

### Teaching Notes
- Emphasize how the loop creates continuous interaction
- Discuss the importance of providing an exit condition to break out of infinite loops
- Ask students how this improves upon the one-shot approach from Activity 1

## Activity 3: Adding Memory with Lists

### Expected Output
Students should see a bot that remembers previous inputs and can report on its memory when asked.

```
Welcome to MemoryBot! I'll try to remember what you say.
You: Hello
Bot: Hello! How can I assist you today?
You: My name is Alex
Bot: Nice to meet you, Alex! How can I help you today?
You: what do you remember
Bot memory contains:
  1. Hello
  2. My name is Alex
  3. what do you remember
You: bye
Bot: Chat ended. I remembered 3 messages. Bye! 👋
```

### Code Explanation
- `memory = []` creates an empty list to store the conversation history
- `memory.append(user_input)` adds each new input to the memory list
- `len(memory)` returns the number of items stored in the list
- `for i, message in enumerate(memory):` loops through each item in the memory list with its position

### Common Questions
- **Why does the bot repeat my last message?** Because we're appending the message to memory before getting a response
- **What would happen if we store thousands of messages?** Memory usage would increase and could potentially slow down the program
- **Does the AI see all the remembered messages?** In this implementation, the AI only sees the current message, not the memory

## Activity 4: Enhanced Memory Bot Challenge

### Sample Solution
Here's a complete implementation that students might create:

```python
# Your enhanced memory bot implementation
print("\nYour Advanced MemoryBot! Type 'help' for commands.")

# Import the needed package
from simple_bot import get_response

# Create your lists and initialize variables here
memory = []
commands = ["help", "memory", "clear", "bye"]

# Write your loop here
while True:
    user_input = input("You: ")
    
    # Implement the command handling
    if user_input.lower() == "bye":
        print("Bot: Goodbye!")
        break
    elif user_input.lower() == "help":
        print("Available commands:", ", ".join(commands))
    elif user_input.lower() == "memory":
        if memory:
            print("I remember these messages:")
            for i, msg in enumerate(memory):
                print(f"  {i+1}. {msg}")
        else:
            print("My memory is empty!")
    elif user_input.lower() == "clear":
        memory = []
        print("Memory cleared!")
    else:
        # Add message to memory
        memory.append(user_input)
        
        # Keep only the last 3 items using list slicing
        if len(memory) > 3:
            memory = memory[-3:]
            
        # Join the memory items with newlines to create context
        context = "\n".join(memory)
        
        # Send the context to get a more informed response
        response = get_response(context)
        print("Bot:", response)
        print(f"(Memory size: {len(memory)} messages)")
```

### Alternative Approach
A different approach might use a dictionary to track both user inputs and bot responses:

```python
from simple_bot import get_response

print("\nDual Memory Bot! Type 'help' for commands.")

# Track both sides of the conversation
conversation = {
    "user": [],
    "bot": []
}
commands = ["help", "history", "clear", "bye"]

while True:
    user_input = input("You: ")
    
    if user_input.lower() == "bye":
        print("Bot: Chat ended. Goodbye!")
        break
    elif user_input.lower() == "help":
        print("Available commands:", ", ".join(commands))
    elif user_input.lower() == "history":
        if conversation["user"]:
            print("Conversation history:")
            for i in range(len(conversation["user"])):
                print(f"  You: {conversation['user'][i]}")
                print(f"  Bot: {conversation['bot'][i]}")
        else:
            print("No conversation history yet!")
    elif user_input.lower() == "clear":
        conversation = {"user": [], "bot": []}
        print("History cleared!")
    else:
        # Add to user history
        conversation["user"].append(user_input)
        
        # Create context from the last 3 exchanges
        if len(conversation["user"]) > 3:
            conversation["user"] = conversation["user"][-3:]
            conversation["bot"] = conversation["bot"][-3:]
            
        # Create context string with both user and bot messages
        context = ""
        for i in range(len(conversation["user"])-1):
            context += f"User: {conversation['user'][i]}\n"
            context += f"Bot: {conversation['bot'][i]}\n"
        context += f"User: {conversation['user'][-1]}"
        
        # Get response
        response = get_response(context)
        print("Bot:", response)
        
        # Add to bot history
        conversation["bot"].append(response)
```

### Key Concepts to Look For
- Proper handling of commands using conditionals
- Use of list methods (append, slicing with [-3:])
- Properly joining messages into context
- Checking for empty lists before trying to display them
- Displaying relevant information to the user

## Extension: Personality Bot Challenge

### Expected Output
Students should be able to switch between different bot personalities.

```
Multi-Personality Bot! Type 'personalities' to see options.
You: personalities
Available personalities: regular, pirate, emoji, formal
To change, type 'switch to [personality]'
You: switch to pirate
Bot: Switched to pirate personality!
You: What is Python?
PirateBot: Arrr, matey! Python be a programmin' language that's easy to learn and powerful to use! Many a scallywag starts their codin' journey with it! Treasure be waitin'!
```

### Solution Explanation
- `personalities = ["regular", "pirate", "emoji", "formal"]` stores available options
- `current_personality = "regular"` tracks which personality is active
- `startswith()` checks if the input begins with "switch to"
- A conditional structure selects the right function based on the current personality

### Common Issues
- Forgetting to import the personality functions (`pirate_bot`, `emoji_bot`)
- Not checking if the requested personality exists in the list
- Confusion about string methods like `startswith()` and `replace()`

## Creating Custom Bot Personalities

### Sample Implementation
Here's how students might implement a custom bot personality:

```python
from simple_bot import get_response

# Define a custom personality
def wise_dragon_bot(message):
    return get_response(message, system="You are a wise old dragon who answers questions in riddles and ancient wisdom.")

print("\nWise Dragon Bot Test:")
print(wise_dragon_bot("How do I debug my code?"))
```

### Expected Output
```
Wise Dragon Bot Test:
To untangle the webs of code that confound thee, young seeker, first thou must observe with patience. Look for the tracks of thy prey—the elusive bug—in the sands of thy console output. Set traps with print statements to reveal its hiding place. Break thy journey into smaller quests, testing each portion of thy code in isolation. Remember, even the mightiest dragon must sometimes step back to see the entire mountain. In the ancient scrolls, it is written: "To understand the bug, one must become the bug." Walk through thy code as the machine would, one instruction at a time, and the truth shall reveal itself.
```

### Teaching Notes
- Explain that the `system` parameter gives instructions to the AI about how to respond
- Discuss the concept of "persona" in AI interactions
- Encourage creativity while keeping responses appropriate

## Assessment Criteria

To evaluate student understanding, look for:

1. **Basic Skills (C grade)**
   - Successfully implements the looping bot
   - Can add items to a list for memory
   - Uses basic conditionals for commands

2. **Intermediate Skills (B grade)**
   - Successfully implements the enhanced memory bot
   - Correctly uses list slicing to limit memory
   - Properly provides context to the AI
   - Implements multiple commands correctly

3. **Advanced Skills (A grade)**
   - Implements the personality switching functionality
   - Creates custom personalities with the system parameter
   - Adds creative extensions to the basic requirements
   - Code is well-organized and commented

## Common Student Mistakes

1. **Loop Control Flow Issues**
   - Forgetting to include a break statement for exit commands
   - Adding too many nested conditions making code difficult to follow
   - Not handling edge cases (empty input, unexpected commands)

2. **List Management Errors**
   - Attempting to access indexes that don't exist
   - Not checking if the list is empty before trying to display it
   - Incorrect use of slicing syntax to limit the memory size

3. **Context Building Problems**
   - Not properly joining the list items with newlines
   - Sending too much context to the AI (causing confusion)
   - Not providing enough context to maintain conversation flow

## Time Management

- Activity 1: ~5 minutes
- Activity 2: ~10 minutes
- Activity 3: ~15 minutes
- Activity 4: ~20 minutes
- Extension: ~10 minutes

If students are progressing rapidly, encourage them to implement additional features like:
- Error handling for API connection issues
- Saving conversation history to a file
- Loading different system prompts from a configuration file

## Connecting Back to Turtle Graphics

Help students see the parallels between the two worksheets:
- Both use loops to repeat actions (drawing shapes vs. continuing conversation)
- Both use lists to store collections (colors/coordinates vs. message history)
- Both combine loops and lists to create more complex behavior

## Stretch Goals for Advanced Students

If some students finish early, suggest these extensions:
- Implement a chat log feature that saves conversations to a file
- Create a menu of different personalities the bot can switch between
- Add a feature to summarize the conversation so far
- Create a "reset context" command that keeps the memory but starts a fresh conversation

## Troubleshooting the `simple_bot` Package

If students encounter issues with the `simple_bot` package:

1. **ImportError**
   - Verify the package is installed correctly
   - Check for typos in the import statement

2. **Connection Issues**
   - Ensure the Ollama server is running
   - Check for network connectivity issues

3. **Slow Responses**
   - Remind students the first response may be slow as the model loads
   - Suggest using shorter prompts for testing

4. **API-Related Errors**
   - Have a backup activity ready if the API service is down
   - Consider implementing a simple mock version of `get_response()` that returns fixed responses

## Final Project Ideas

To extend learning beyond the workshop, suggest these project ideas:
1. Create a specialized bot for a specific domain (sports, cooking, etc.)
2. Build a chatbot that can play a text-based game
3. Combine the turtle graphics with the chatbot to create a drawing assistant
4. Create a study helper bot that quizzes students on course material

## Reflection Questions for Wrap-up

End the session with these discussion questions:
1. How did using loops make your program more interactive?
2. How did lists help you create a more intelligent conversation?
3. What similarities did you notice between the two activities?
4. How might you use these concepts in other programming projects?
5. What was the most challenging part of building your chatbot?---
title: STAFF ANSWER Weather Presenter Bot Mini-Project (Student Version)e
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Weather Forecast Analyzer: Staff Answer Guide

## Project Overview
This guide provides complete solutions and teaching notes for the Weather Forecast Analyzer mini-project. This project helps students practice working with lists, loops, conditionals, and basic calculations without requiring dictionaries, classes, or file I/O.

## Complete Solutions

### Task 1: Print Weather Report
```python
def print_weather_report(data):
    print("\n===== WEEKLY WEATHER REPORT =====\n")
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        humidity = day_data[2]
        wind = day_data[3]
        condition_code = day_data[4]
        condition = condition_names[condition_code]
        
        print(f"{day}: {temp}°C, {humidity}% humidity, {wind} km/h wind, {condition}")
```

**Key concepts**: Loops, list indexing, f-strings

### Task 2: Find Temperature Extremes
```python
def find_temperature_extremes(data):
    warmest_day = data[0][0]
    warmest_temp = data[0][1]
    coldest_day = data[0][0]
    coldest_temp = data[0][1]
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        
        if temp > warmest_temp:
            warmest_day = day
            warmest_temp = temp
        
        if temp < coldest_temp:
            coldest_day = day
            coldest_temp = temp
    
    return ([warmest_day, warmest_temp], [coldest_day, coldest_temp])
```

**Key concepts**: Variables to track extremes, conditionals, nested lists, return values

### Task 3: Calculate Averages
```python
def calculate_averages(data):
    total_temp = 0
    total_humidity = 0
    total_wind = 0
    days = len(data)
    
    for day_data in data:
        total_temp += day_data[1]
        total_humidity += day_data[2]
        total_wind += day_data[3]
    
    avg_temp = round(total_temp / days, 1)
    avg_humidity = round(total_humidity / days, 1)
    avg_wind = round(total_wind / days, 1)
    
    return [avg_temp, avg_humidity, avg_wind]
```

**Key concepts**: Summation, division, rounding, lists as return values

### Task 4: Count Conditions
```python
def count_conditions(data):
    # Create a list of zeros with the same length as condition_names
    counts = [0] * len(condition_names)
    
    # Loop through the data and increment the count for each condition found
    for day_data in data:
        condition_code = day_data[4]
        counts[condition_code] += 1
    
    return counts
```

**Key concepts**: List creation with multiplication, using list indices as counters

### Task 5: Create Temperature Chart
```python
def create_temperature_chart(data):
    print("\n===== TEMPERATURE CHART =====\n")
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        
        # Create a bar using █ characters (one per degree)
        temp_bar = "█" * temp
        
        print(f"{day}: {temp_bar} ({temp}°C)")
```

**Key concepts**: String repetition, text-based visualization

### Task 6: Check Severe Weather
```python
def check_severe_weather(data):
    alerts = []
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        humidity = day_data[2]
        wind = day_data[3]
        condition_code = day_data[4]
        
        # Check for severe conditions
        if condition_code == 4:  # Thunderstorm
            alerts.append(f"Thunderstorm expected on {day}")
        
        if wind > 20:
            alerts.append(f"High winds ({wind} km/h) expected on {day}")
        
        if humidity > 90:
            alerts.append(f"Very high humidity ({humidity}%) expected on {day}")
        
        if temp < 0:
            alerts.append(f"Freezing temperature ({temp}°C) expected on {day}")
        elif temp > 35:
            alerts.append(f"Extreme heat ({temp}°C) expected on {day}")
    
    return alerts
```

**Key concepts**: Multiple conditions, building lists dynamically, string formatting

### Task 7: Suggest Activities
```python
def suggest_activities(data):
    activities = []
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        condition_code = day_data[4]
        
        # Choose an activity based on weather
        if condition_code == 0:  # Sunny
            if temp > 25:
                activity = "Go to the beach or pool"
            else:
                activity = "Go for a hike or picnic"
        elif condition_code == 1:  # Partly Cloudy
            activity = "Perfect for outdoor sports"
        elif condition_code == 2:  # Cloudy
            activity = "Visit a park or go for a walk"
        elif condition_code == 3:  # Rainy
            activity = "Visit a museum or watch a movie"
        elif condition_code == 4:  # Thunderstorm
            activity = "Stay indoors with a good book"
        elif condition_code == 5:  # Snowy
            activity = "Build a snowman or go sledding"
        else:
            activity = "Check weather again"
        
        activities.append((day, activity))
    
    return activities
```

**Key concepts**: Nested conditionals, tuples, complex decision-making

## Common Student Questions and Answers

### 1. "I'm confused about how to access the weather data. What does `day_data[1]` mean?"
**Answer**: The `weather_data` is a list of lists. Each inner list represents one day's data. When we loop through `weather_data`, each `day_data` is one of those inner lists. So `day_data[0]` is the day name, `day_data[1]` is the temperature, and so on. Think of it like a table where each row is a day, and each column is a different weather attribute.

### 2. "Why do we need to return a tuple with two lists in the `find_temperature_extremes` function?"
**Answer**: The function needs to return two pieces of information: the warmest day and the coldest day. Each of these needs both a day name and a temperature. We put each pair (day name, temperature) in its own list, and then return both lists inside a tuple. This way, when the main function calls it, it can easily unpack both pieces of information with: `warmest, coldest = find_temperature_extremes(weather_data)`.

### 3. "I don't understand the line `counts = [0] * len(condition_names)` in the count_conditions function."
**Answer**: This creates a new list filled with zeros. The `len(condition_names)` tells us how many different weather conditions we have, and the `* len(condition_names)` part repeats the `[0]` that many times. So if we have 6 possible conditions, this creates `[0, 0, 0, 0, 0, 0]`. Then we can use each position to count a specific condition.

### 4. "What does the `█` character do in the temperature chart function?"
**Answer**: That's a special character called a "block" that creates a solid bar when printed. By repeating it (using `"█" * temp`), we create a visual bar where each block represents one degree Celsius. This gives us a simple visual chart using just text.

### 5. "When I run my code, I get an error that says 'TypeError: can only concatenate str (not "int") to str'. What's wrong?"
**Answer**: This error happens when you try to combine a string and a number directly, like `"Temperature: " + temp`. You need to convert the number to a string first, like `"Temperature: " + str(temp)`. Alternatively, you can use an f-string like `f"Temperature: {temp}"`, which automatically handles the conversion.

### 6. "In the severe weather check, why do we have separate if statements instead of using elif?"
**Answer**: We use separate `if` statements because we want to check for multiple severe conditions that could happen on the same day. With `elif`, only one condition would be checked. For example, a day could be both very hot AND have high winds, and we want to report both of those alerts.

### 7. "Why do we use tuples in the activities list but not in other functions?"
**Answer**: In the `suggest_activities` function, we need to keep two pieces of information together for each day: the day name and the suggested activity. A tuple like `(day, activity)` is a good way to keep these paired. The main function then unpacks these pairs with `for day, activity in activities:`. In other functions, we use lists when we need to modify the data, and tuples when we just need to group related items.

### 8. "I'm having trouble with the for loops. How do I know when to use them?"
**Answer**: Generally, use a for loop when you need to:
- Process each item in a collection (like each day in `weather_data`)
- Perform the same operation multiple times
- Build a new collection based on an existing one
In this project, we often need to process each day's weather data, so we use `for day_data in data:` to go through each day one by one.

### 9. "What's the difference between `return` and `print`?"
**Answer**: `print` displays information to the console but doesn't save it for later use in your program. `return` sends data back from a function so it can be stored in a variable and used later. For example, the `calculate_averages` function returns a list of values that the main function can then use to print specific messages.

### 10. "My temperature chart looks weird. The bars are too long for some temperatures."
**Answer**: If you're testing with very high temperatures, the bars might be too long to display nicely. You could modify the function to scale the bars, for example by dividing the temperature by 2 or using a different character. For example: `temp_bar = "█" * (temp // 2)` would make each block represent 2 degrees.

## Teaching Tips

### Understanding List Structure
Draw a table representation of the weather data on the board:

| Index | Day       | Temp | Humidity | Wind | Condition |
|-------|-----------|------|----------|------|-----------|
| 0     | Monday    | 23   | 65       | 8    | 0 (Sunny) |
| 1     | Tuesday   | 21   | 70       | 10   | 1 (Partly)|
| ...   | ...       | ...  | ...      | ...  | ...       |

Explain that `weather_data[0]` gets the first row: `["Monday", 23, 65, 8, 0]`
And `weather_data[0][1]` gets the temperature (23) from that row.

### Demonstrating Loop Patterns
Show the common pattern for processing each day:
```python
for day_data in weather_data:
    # day_data is now each individual day's list
    day_name = day_data[0]
    temperature = day_data[1]
    # ... work with this data
```

### Introducing Testing Techniques
Encourage students to test each function individually:
```python
# Test the print_weather_report function
print_weather_report(weather_data)

# Test the calculate_averages function
averages = calculate_averages(weather_data)
print(f"Average temperature: {averages[0]}°C")
```

## Extension Implementation Ideas

### Random Weather Generation
```python
def generate_random_weather():
    days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
    new_data = []
    
    for day in days:
        temp = random.randint(0, 35)
        humidity = random.randint(30, 95)
        wind = random.randint(0, 30)
        condition = random.randint(0, 5)
        
        day_data = [day, temp, humidity, wind, condition]
        new_data.append(day_data)
    
    return new_data
```

### Temperature Trend Analysis
```python
def analyze_temperature_trend(data):
    temperatures = [day[1] for day in data]
    
    # Compare first half with second half
    first_half = sum(temperatures[:len(temperatures)//2]) / (len(temperatures)//2)
    second_half = sum(temperatures[len(temperatures)//2:]) / (len(temperatures) - len(temperatures)//2)
    
    if second_half > first_half:
        return "Getting warmer through the week"
    elif second_half < first_half:
        return "Getting cooler through the week"
    else:
        return "Temperatures are stable through the week"
```

## Assessment Rubric

| Criteria | Excellent (A) | Satisfactory (B/C) | Needs Improvement (D/F) |
|----------|---------------|--------------------|-----------------------|
| **Task Completion** | All 7 functions implemented correctly | 5-6 functions working correctly | Fewer than 5 functions working |
| **Code Logic** | Logic is sound with optimal solutions | Logic works but may not be optimal | Logic has significant flaws |
| **Lists Usage** | Effectively uses lists for all data | Generally uses lists appropriately | Struggles with list operations |
| **Loops** | Correctly implements all required loops | Most loops implemented correctly | Problems with loop implementation |
| **Conditionals** | Uses conditionals effectively and efficiently | Basic conditionals implemented correctly | Incorrect or missing conditions |
| **Creativity** | Highly creative activity suggestions or extensions | Standard activity suggestions | Minimal effort in suggestions |
| **Code Style** | Well-formatted, clear variable names | Generally readable code | Poor formatting, unclear naming |---
title: Weather Presenter Bot Mini-Project (Student Version)e
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Weather Forecast Analyser Mini-Project

## Project Overview
In this mini-project, students will create a program that analyses a week's worth of weather forecast data using only lists and basic Python concepts. The program will perform various calculations and provide insights about the weather patterns.

## Learning Objectives
- Work with lists and nested lists
- Apply selection logic (if/elif/else)
- Use loops to process data
- Perform calculations (min, max, average)
- Generate text-based visualisations
- Practice importing modules

## Starter Code

```python
# Weather Forecast Analyser
# Analyse a week's worth of weather data and provide insights

import random  # For random weather generation
import time    # For program timing and pauses

# Sample weather data for a week
# Format: [day_name, temperature, humidity, wind_speed, condition_code]
# Condition codes: 0=Sunny, 1=Partly Cloudy, 2=Cloudy, 3=Rainy, 4=Thunderstorm, 5=Snowy

weather_data = [
    ["Monday", 23, 65, 8, 0],
    ["Tuesday", 21, 70, 10, 1],
    ["Wednesday", 18, 80, 12, 2],
    ["Thursday", 17, 85, 15, 3],
    ["Friday", 16, 75, 14, 3],
    ["Saturday", 19, 60, 8, 1],
    ["Sunday", 22, 55, 6, 0]
]

# Weather condition names (for translating codes to text)
condition_names = ["Sunny", "Partly Cloudy", "Cloudy", "Rainy", "Thunderstorm", "Snowy"]

# TASK 1: Complete this function to print a formatted weather report
def print_weather_report(data):
    """
    Prints a nicely formatted report of the week's weather
    """
    print("\n===== WEEKLY WEATHER REPORT =====\n")
    
    # Your code here:
    # Loop through the weather data and print each day's information
    # Format example: "Monday: 23°C, 65% humidity, 8 km/h wind, Sunny"
    pass

# TASK 2: Complete this function to find the warmest and coldest days
def find_temperature_extremes(data):
    """
    Find the warmest and coldest days of the week
    Returns a tuple with two lists: (warmest_day_info, coldest_day_info)
    """
    # Your code here:
    # Loop through the data to find the day with highest and lowest temperature
    # Return them as a tuple with two elements: ([warmest_day_name, temp], [coldest_day_name, temp])
    pass

# TASK 3: Complete this function to calculate average weather values
def calculate_averages(data):
    """
    Calculate average temperature, humidity, and wind speed for the week
    Returns a list with the three averages: [avg_temp, avg_humidity, avg_wind]
    """
    # Your code here:
    # Loop through the data to sum up the values, then calculate averages
    # Round the averages to one decimal place
    pass

# TASK 4: Complete this function to count the occurrences of each weather condition
def count_conditions(data):
    """
    Count how many days have each weather condition
    Returns a list of counts in the same order as condition_names
    """
    # Your code here:
    # Create a list of seros with the same length as condition_names
    # Loop through the data and increment the count for each condition found
    pass

# TASK 5: Complete this function to create a simple text-based temperature chart
def create_temperature_chart(data):
    """
    Create a simple text-based chart showing temperature for each day
    Each bar should be made of █ characters, one for each degree Celsius
    """
    print("\n===== TEMPERATURE CHART =====\n")
    
    # Your code here:
    # Loop through the data
    # For each day, print the name and a bar made of █ characters (one per degree)
    # Example: "Monday: ███████████████████████ (23°C)"
    pass

# TASK 6: Complete this function to check if any severe weather is expected
def check_severe_weather(data):
    """
    Check if any severe weather conditions are expected
    Severe weather is defined as:
    - Thunderstorm (condition code 4)
    - High winds (> 20 km/h)
    - Very high humidity (> 90%)
    - Very low or very high temperatures (< 0°C or > 35°C)
    """
    # Your code here:
    # Loop through the data and check for severe conditions
    # If found, return a list of alerts (strings describing the issues)
    # If none found, return an empty list
    pass

# TASK 7: Complete this function to suggest activities based on the weather
def suggest_activities(data):
    """
    Suggest activities based on the weather for each day
    Returns a list of tuples: [(day_name, activity), ...]
    """
    activities = []
    
    # Your code here:
    # Loop through the data
    # Based on the conditions, temperature, etc., suggest an appropriate activity
    # Append (day_name, activity) tuples to the activities list
    
    return activities

# Main function - already completed for you
def main():
    print("Welcome to the Weather Forecast Analyser!")
    time.sleep(1)
    
    # Print the basic weather report
    print_weather_report(weather_data)
    time.sleep(1)
    
    # Find and display temperature extremes
    warmest, coldest = find_temperature_extremes(weather_data)
    print(f"\nWarmest day: {warmest[0]} ({warmest[1]}°C)")
    print(f"Coldest day: {coldest[0]} ({coldest[1]}°C)")
    time.sleep(1)
    
    # Calculate and display averages
    avg_temp, avg_humidity, avg_wind = calculate_averages(weather_data)
    print(f"\nWeekly Averages:")
    print(f"Temperature: {avg_temp}°C")
    print(f"Humidity: {avg_humidity}%")
    print(f"Wind Speed: {avg_wind} km/h")
    time.sleep(1)
    
    # Count and display weather conditions
    condition_counts = count_conditions(weather_data)
    print("\nWeather Conditions This Week:")
    for i in range(len(condition_names)):
        if condition_counts[i] > 0:
            print(f"{condition_names[i]}: {condition_counts[i]} day(s)")
    time.sleep(1)
    
    # Display temperature chart
    create_temperature_chart(weather_data)
    time.sleep(1)
    
    # Check for severe weather
    severe_alerts = check_severe_weather(weather_data)
    if severe_alerts:
        print("\n⚠️ WEATHER ALERTS ⚠️")
        for alert in severe_alerts:
            print(f"- {alert}")
    else:
        print("\nNo severe weather expected this week.")
    time.sleep(1)
    
    # Suggest activities
    activities = suggest_activities(weather_data)
    print("\nRecommended Activities:")
    for day, activity in activities:
        print(f"{day}: {activity}")

# Run the program
if __name__ == "__main__":
    main()
```

## Project Tasks

Students need to complete the following tasks:

1. **Create a Weather Report**: Format and display the weather data in a readable way.
2. **Find Temperature Extremes**: Determine the warmest and coldest days of the week.
3. **Calculate Weather Averages**: Find average temperature, humidity, and wind speed.
4. **Count Weather Conditions**: Count occurrences of each weather condition type.
5. **Create a Temperature Chart**: Generate a simple text-based bar chart for temperatures.
6. **Check for Severe Weather**: Identify any potentially severe weather conditions.
7. **Suggest Activities**: Recommend activities based on the forecast for each day.

## Extension Challenges

For students who finish early:

1. **Add Weather Data Generation**: Write a function that randomly generates a new week of weather data.
2. **Create a Rain Prediction Model**: Based on humidity and temperature, predict if it might rain.
3. **Implement a Temperature Trend Analysis**: Identify if the week is getting warmer or cooler.
4. **Create a Simple Text-Based Weather Animation**: Use ASCII art to animate weather (e.g., falling rain).

## Sample Solution Guidance

### Task 1: Print Weather Report
```python
def print_weather_report(data):
    print("\n===== WEEKLY WEATHER REPORT =====\n")
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        humidity = day_data[2]
        wind = day_data[3]
        condition_code = day_data[4]
        condition = condition_names[condition_code]
        
        print(f"{day}: {temp}°C, {humidity}% humidity, {wind} km/h wind, {condition}")
```

### Task 2: Find Temperature Extremes
```python
def find_temperature_extremes(data):
    warmest_day = data[0][0]
    warmest_temp = data[0][1]
    coldest_day = data[0][0]
    coldest_temp = data[0][1]
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        
        if temp > warmest_temp:
            warmest_day = day
            warmest_temp = temp
        
        if temp < coldest_temp:
            coldest_day = day
            coldest_temp = temp
    
    return ([warmest_day, warmest_temp], [coldest_day, coldest_temp])
```

### Task 5: Create Temperature Chart
```python
def create_temperature_chart(data):
    print("\n===== TEMPERATURE CHART =====\n")
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        
        # Create a bar using █ characters (one per degree)
        temp_bar = "█" * temp
        
        print(f"{day}: {temp_bar} ({temp}°C)")
```

## Assessment Criteria

Students will be evaluated based on:

1. **Correct Implementation**: Functions work as expected and produce correct results.
2. **Code Organisation**: Code is well-structured and easy to follow.
3. **Use of Lists**: Effective use of lists for data storage and manipulation.
4. **Selection Logic**: Appropriate use of if/elif/else statements.
5. **Loop Implementation**: Proper use of loops to process data.
6. **Creativity**: Especially for the activity suggestions and extended challenges.

## Teaching Tips

1. **Start with Data Exploration**: Have students print and examine the weather data structure before implementing functions.
2. **Encourage Step-by-Step Development**: Suggest students complete one function at a time and test it before moving on.
3. **Review List Indexing**: Remind students about accessing elements in nested lists.
4. **Introduce Tuple Unpacking**: Show how to unpack tuples in assignments (e.g., `warmest, coldest = find_temperature_extremes()`).
5. **Emphasise Reusability**: Point out how functions can be reused (e.g., using `find_temperature_extremes()` for other analyses).

## Connection to Final Project

This mini-project prepares students for their weather API dashboard by:

1. Familiarising them with weather data structure and terminology
2. Teaching them how to extract insights from weather data
3. Practicing the calculation of weather statistics
4. Creating visualisations of weather information
5. Building a foundation for more complex data handling---
title: "Mastering Data Processing Techniques in Business"
subtitle: "Evaluating and Applying Effective Strategies"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Evaluating Data Processing Techniques

* Understanding the role of data processing in business
* Key concepts: Efficiency, reliability, and scalability
* Importance of choosing the right technique

::: {.notes}
Data processing is a critical aspect of modern businesses that involves collecting, cleaning, and analysing data to make informed decisions. The right data processing techniques can enhance efficiency, ensure data reliability, and scale as business needs grow. This presentation will explore various techniques and how to evaluate them in the context of business applications, particularly focusing on the use of the pandas library and Python programming.
:::

# Introduction to pandas

* What is pandas? 
* Core features of pandas for data processing
* How pandas supports business data analysis

::: {.notes}
The pandas library is a powerful tool for data manipulation and analysis in Python. It provides data structures and operations for manipulating numerical tables and time series. This is especially useful in business contexts where decision-making is data-driven, requiring quick and accurate data processing. We will explore how pandas can transform raw data into actionable insights.
:::

# Advanced Data Structures

* Overview of Python data structures
* Importance of choosing the right structure for the task
* Examples: Lists, Dictionaries, DataFrames

::: {.notes}
Python offers a variety of data structures that are fundamental to efficient data processing. Choosing the right structure, such as lists for ordered data, dictionaries for key-value pairs, or DataFrames for tabular data, can significantly affect the performance and simplicity of data processing tasks. Understanding these structures will help you design more effective data processing solutions.
:::

# Evaluating Effectiveness

* Criteria for evaluating data processing techniques
* Case study: Weather report generation
* Assessing pandas functions in real-world applications

::: {.notes}
To evaluate data processing techniques, we consider criteria such as speed, ease of use, and the ability to handle large datasets. For instance, in generating accurate weather reports, how effectively can pandas manage and manipulate large volumes of data? This real-world application demonstrates the practical utility of pandas in business contexts, highlighting its robustness and flexibility.
:::

# Algorithm Design and Efficiency

* What makes an algorithm efficient?
* Critiquing a sample data processing algorithm
* Balancing complexity and performance

::: {.notes}
An efficient algorithm is key to processing data quickly and reliably. We will examine a sample algorithm to understand factors that contribute to its efficiency, such as minimal processing time and optimal resource usage. It's crucial to balance complexity and performance to avoid over-engineering solutions while ensuring they meet business requirements.
:::

# Synthesising Knowledge for Projects

* Integrating Python and pandas for the weather project
* Decision-making in data presentation
* Analytical techniques to summarise weather trends

::: {.notes}
In our ongoing project to generate weekly weather reports, integrating Python's data structures with pandas' functionality allows for sophisticated data manipulation and analysis. This synthesis requires critical decisions about data presentation—how to summarise trends and which analytical techniques to use, ensuring the reports are both informative and accessible.
:::

# Workshop Activities and Peer Learning

* Exploring basics of pandas
* Designing efficient data structures


::: {.notes}
Our workshop activities will provide hands-on experience with pandas and help you understand how to design efficient data structures.
:::

# Resources and Continuing Your Learning

* Utilising online resources like pandas Documentation
* Engaging with community forums and tutorials
* Importance of continuous learning in data processing

::: {.notes}
To further your learning in data processing, engaging with available resources such as the pandas documentation, community forums, and online tutorials is crucial. Data processing techniques and tools evolve rapidly, and staying updated through continuous learning will be key to maintaining and enhancing your skills in a business context.
:::

# Conclusion and Next Steps

* Evaluating and applying data processing techniques
* Encouragement to apply these techniques in your projects
* Next week: Deepening skills in pandas and Python

::: {.notes}
We've explored various data processing techniques and how to evaluate their effectiveness in business contexts. I encourage you to apply what you've learned today in your projects, especially in generating the weekly weather reports. Looking ahead, we will continue to deepen our skills in pandas and Python, building on the strong foundation laid today.
:::---
title: "Mastering pandas: Essential Skills for Data Processing"
subtitle: "Unlock the Power of Python for Effective Data Analysis"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to pandas

* Overview of pandas in Python
* Importance of pandas in data processing
* Objectives of today's session

::: {.notes}
Welcome to our introductory session on pandas, a pivotal library in Python for data analysis and manipulation. pandas stands out for its powerful data structures that allow for efficient data manipulation and analysis, essential in business and data science applications. Today, we aim to familiarise you with the basics of pandas, understand its significance in handling large datasets, and prepare you to utilise its functionalities for practical data processing tasks.
:::

# What is pandas?

* pandas: Python library for data manipulation
* Key features: DataFrame and Series objects
* Used extensively for data cleaning, transformation, and analysis

::: {.notes}
pandas is a fundamental library in the Python programming landscape, designed for detailed data manipulation and analysis. At the heart of pandas are two primary data structures: DataFrames, which are essentially tabular data structures, and Series, which are single-dimensional arrays. These structures are not only powerful but also intuitive, making pandas an indispensable tool in data science and business analytics for tasks like data cleaning, transforming datasets, and complex data analysis.
:::

# Installing and Importing pandas

* Installing pandas: `pip install pandas`
* Importing in Python: `import pandas as pd`
* Checking version: `print(pd.__version__)`

::: {.notes}
Before diving into data manipulation, you'll need to install pandas on your system. This is easily done using the pip package manager. Once installed, you can import pandas, typically as 'pd', which is a standard shorthand used in the Python community. It is also good practice to check the installed version to ensure compatibility with your data processing scripts.
:::

# pandas Data Structures

* Understanding Series: 1D array, homogeneous data
* Exploring DataFrame: 2D table, heterogeneous data
* Creating these structures from scratch

```python
import pandas as pd
# Creating a Series
series = pd.Series([1, 2, 3])
# Creating a DataFrame
dataframe = pd.DataFrame({'Name': ['Alice', 'Bob'], 'Age': [25, 30]})
```

::: {.notes}
The two primary data structures in pandas, Series and DataFrames, cater to different needs in data processing. A Series is ideal for single-dimensional data and operates similar to a Python list but with additional functionalities. A DataFrame, on the other hand, is more complex and can be thought of as a table where data is organised in rows and columns, allowing for more extensive data manipulation. Understanding how to create and manipulate these structures is foundational in leveraging pandas effectively.
:::

# Basic Operations in pandas

* Viewing data: `head()`, `tail()`
* Descriptive statistics: `describe()`
* Data selection and filtering

```python
# Viewing the first few rows of a DataFrame
dataframe.head()
# Generating descriptive statistics
dataframe.describe()
```

::: {.notes}
Basic operations in pandas are straightforward yet powerful. Functions like `head()` and `tail()` allow you to quickly inspect the beginning and end of datasets, which is particularly useful in large datasets to get a quick overview. The `describe()` function provides a summary of the statistics related to the DataFrame columns, offering insights into data distribution, count, mean, and other important metrics. These operations are essential for initial data exploration and analysis.
:::

# Data Cleaning with pandas

* Handling missing values: `dropna()`, `fillna()`
* Data type conversions: `astype()`
* Renaming columns and indexes

```python
# Handling missing values by filling them
dataframe.fillna(value="Unknown")
# Changing data type of a column
dataframe['Age'] = dataframe['Age'].astype(float)
```

::: {.notes}
Data cleaning is a crucial step in data processing, ensuring the accuracy and completeness of the data set. pandas provides robust tools for handling missing values and erroneous data types, which are common issues in real-world data. Methods like `dropna()` and `fillna()` help in managing missing data, while `astype()` is used for converting data types to ensure consistency in operations and analyses.
:::

# Advanced Data Manipulation

* Grouping data: `groupby()`
* Merging and joining data frames: `merge()`, `join()`
* Pivot tables and cross-tabulations: `pivot_table()`

```python
# Grouping data by a column and calculating mean
dataframe.groupby('Name')['Age'].mean()
# Merging two DataFrames
pd.merge(df1, df2, on='employee_id')
```

::: {.notes}
As you become more comfortable with pandas, you'll start to explore more complex data manipulation techniques. Grouping data allows for segmenting the dataset and applying functions like mean or sum, which is essential in data analysis. Merging and joining tables are critical when working with relational data, enabling you to combine data from different sources effectively. These advanced techniques are vital for thorough data analysis and decision-making processes.
:::

# Conclusion: Why pandas?

* Facilitates extensive data analysis and manipulation
* Integrates seamlessly with other Python libraries
* Essential tool for data scientists and business analysts

::: {.notes}
To sum up, mastering pandas is indispensable for anyone aspiring to work in data science or business analytics. Its comprehensive functionalities for handling, cleaning, and analysing data make it a preferred choice among professionals. Additionally, its integration with other Python libraries enhances its utility, making it a robust tool for real-world data processing tasks. As we conclude, I encourage you to delve deeper into pandas through practice and exploration to fully leverage its capabilities in your projects.
:::---
title: "Exploring Advanced Data Structures in Python"
subtitle: "Enhancing Data Management for Effective Business Solutions"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


# Introduction to Advanced Data Structures

* Overview of basic vs advanced data structures
* Importance of selecting the right data structure
* Focus of today's presentation: Advanced structures in Python

::: {.notes}
Welcome to our session on advanced data structures in Python. Today, we'll differentiate between basic and advanced data structures and understand why choosing the right one is crucial for optimising data management, especially in business applications. This presentation will specifically focus on advanced structures that can enhance our ability to handle complex data efficiently.
:::

# Arrays and Lists in Python

* Recap of basic structures: Arrays and Lists
* Characteristics and use cases
* Limitations that lead to advanced structures

::: {.notes}
Before diving into advanced structures, let's recap arrays and lists, which are the foundational data structures in Python. Arrays store elements of the same type, while lists can contain elements of different types. They are essential for simple data collection but have limitations in size modification and data access speed, prompting the need for more complex structures.
:::

# Dictionaries and Sets

* Introduction to Dictionaries and Sets
* Key-value pairs in Dictionaries
* Uniqueness in Sets - ideal for distinct element storage

::: {.notes}
Moving to more complex types, dictionaries store data in key-value pairs, making data retrieval fast and efficient. Sets, on the other hand, are collections of unique elements. Both are used widely when data integrity and speed are crucial, such as managing user information or ensuring no duplicate entries in data sets.
:::

# Trees and Graphs

* What are Trees and Graphs?
* Types of Trees (Binary, AVL, Red-Black Tree)
* Real-world application: Hierarchical data management

::: {.notes}
Trees and graphs represent more advanced data structures. Trees organise data hierarchically and are invaluable in applications like file systems or decision processes. Graphs help in representing complex networks like social connections or web links. Understanding these structures is crucial for managing structured data effectively.
:::

# Hash Tables

* Explaining Hash Tables
* Handling collisions in hash tables
* Usage: Fast data retrieval

::: {.notes}
Hash tables are a type of data structure that provides very fast data retrieval. They work by mapping keys to indices in an array using a hash function. However, handling collisions—where different keys map to the same index—is crucial for their efficiency. Hash tables are widely used in database indexing and caching.
:::

# Implementing Advanced Data Structures

* Example: Using a Binary Tree in Python
* Code demonstration

```python
class TreeNode:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

def insert(root, key):
    if root is None:
        return TreeNode(key)
    else:
        if root.val < key:
            root.right = insert(root.right, key)
        else:
            root.left = insert(root.left, key)
    return root
```

::: {.notes}
Let's look at a practical example of implementing a binary tree in Python. This simple class and function allow us to insert new nodes in a sorted manner. Understanding and implementing such structures can significantly improve the efficiency of data operations, especially in processing large volumes of data.
:::

# Choosing the Right Data Structure

* Factors to consider: Speed, Memory, Complexity
* Examples of matching business needs to structures

::: {.notes}
Choosing the right data structure is crucial and depends on factors like operation speed, memory usage, and complexity of implementation. For instance, hash tables might be perfect for quick lookups in customer databases, while trees could be better for organising product categories.
:::

# Conclusion and Recap

* Recap of key advanced data structures
* Importance in business applications
* Encouragement to explore further in Python

::: {.notes}
Today, we explored several advanced data structures that play vital roles in managing complex data efficiently. These structures are particularly important in business contexts where large volumes of data need fast and efficient processing. I encourage you to delve deeper into these structures with Python to enhance your programming and data management skills.
:::

# Questions and Further Learning

* Open for questions
* Suggest further reading and practice resources

::: {.notes}
Thank you for your attention! I am now open to any questions you might have. For further learning, I recommend exploring the pandas documentation and additional Python tutorials available online. Practising these concepts will solidify your understanding and improve your data handling capabilities in real-world scenarios.
:::# 🧰 Week 11 Mini-Project: Building Your Safe Utils Module

**Topic:** Creating Error-Resistant Utility Functions  
**Goal:** Build a Python module of reusable "safe_" wrapper functions that handle errors gracefully

## 📝 Introduction

When programs encounter unexpected situations, they often crash with error messages. While these errors are helpful for debugging, they can create a poor user experience. In this mini-project, you'll:

1. Learn why programs crash and how to prevent it
2. Create wrapper functions that make unsafe operations safe
3. Build your own Python module that you can reuse in future projects

### 🔄 Connecting to Previous Knowledge

Earlier in the semester, we used packages like **PyInputPlus** to handle user input validation without worrying about exception handling:

```python
import pyinputplus as pyip

# Gets an integer input with automatic validation
age = pyip.inputInt("Enter your age: ")
```

Similarly, we used **pandas** to process file contents without dealing with low-level file operations:

```python
import pandas as pd

# Reads a CSV file without manual file handling
df = pd.read_csv("data.csv")
```

Now it's time to understand what's happening "under the hood" of these helpful packages and build our own error-resistant utilities!

## 🧭 Part 1: Understanding Errors with Unreliable Input

### Example 1: JSON Parsing

Try running this in a Python cell:

```python
import json

bad_json = "Not valid JSON at all!"
parsed = json.loads(bad_json)
```

❓What happens?

✍️ **Write the error message here:**

```text
# Your answer here
```

### Example 2: Converting Text to Numbers

Try running this:

```python
user_input = "hello"
number = int(user_input)
```

✍️ **Write the error message here:**

```text
# Your answer here
```

### Example 3: Reading Files

Try running this:

```python
with open("file_that_doesnt_exist.txt", "r") as f:
    content = f.read()
```

✍️ **Write the error message here:**

```text
# Your answer here
```

## 🛡️ Part 2: Adding Basic Protection with try/except

### How to Handle JSON Errors

```python
import json

bad_json = "Not valid JSON at all!"

try:
    parsed = json.loads(bad_json)
    print("JSON parsed successfully:", parsed)
except json.JSONDecodeError:
    parsed = {}
    print("JSON parsing failed, using empty dictionary instead.")
```

### How to Handle Conversion Errors

```python
user_input = "hello"

try:
    number = int(user_input)
    print("Converted to number:", number)
except ValueError:
    number = 0
    print("Conversion failed, using 0 instead.")
```

### How to Handle File Errors

```python
try:
    with open("file_that_doesnt_exist.txt", "r") as f:
        content = f.read()
        print("File content:", content)
except FileNotFoundError:
    content = ""
    print("File not found, using empty string instead.")
```

🧠 **Question:** Why do we use `try` blocks in these examples?

```text
# Your answer here
```

## 🧰 Part 3: Creating Reusable Safe Wrapper Functions

Let's wrap the error-handling logic into reusable functions:

### Safe JSON Parser

```python
def safe_json_loads(text):
    """
    Safely parse JSON, returning an empty dict if parsing fails.
    
    Args:
        text (str): The JSON string to parse
        
    Returns:
        dict: The parsed JSON data or an empty dict if parsing failed
    """
    try:
        return json.loads(text)
    except json.JSONDecodeError:
        return {}
```

### Safe Integer Converter

```python
def safe_int(text):
    """
    Safely convert text to integer, returning 0 if conversion fails.
    
    Args:
        text (str): The text to convert to an integer
        
    Returns:
        int: The converted integer or 0 if conversion failed
    """
    try:
        return int(text)
    except ValueError:
        return 0
```

### Safe File Reader

```python
def safe_read_file(filename):
    """
    Safely read a file, returning an empty string if reading fails.
    
    Args:
        filename (str): The path to the file to read
        
    Returns:
        str: The file content or an empty string if reading failed
    """
    try:
        with open(filename, "r", encoding="utf-8") as f:
            return f.read()
    except Exception as e:
        print(f"Could not read file: {e}")
        return ""
```

**Note:** While pandas is excellent for processing structured data files (like CSV or Excel), understanding basic file operations is still essential. This function demonstrates proper file handling with the `with` statement, which ensures files are properly closed even if errors occur.

## 🧪 Part 4: Testing Your Safe Functions

Test your safe functions with both valid and invalid inputs:

```python
# Test safe_json_loads
print(safe_json_loads('{"name": "Alice"}'))         # Should return a dictionary
print(safe_json_loads("This is not JSON!"))         # Should return {}

# Test safe_int
print(safe_int("123"))       # Should return 123
print(safe_int("hello"))     # Should return 0

# Test safe_read_file
print(safe_read_file("existing_file.txt"))          # Should return file content
print(safe_read_file("non_existent_file.txt"))      # Should return ""
```

## 🔧 Part 5: Build Your Own Safe Function

Now it's your turn! Create a `safe_float` function that converts text to a floating-point number:

```python
def safe_float(text):
    """
    Safely convert text to float, returning 0.0 if conversion fails.
    
    Args:
        text (str): The text to convert to a float
        
    Returns:
        float: The converted float or 0.0 if conversion failed
    """
    # Your code here
    ...
```

Test your function with:

```python
print(safe_float("3.14"))       # Should return 3.14
print(safe_float("pi"))         # Should return 0.0
```

**Challenge question:** Would a different default value than 0.0 ever be more appropriate? What situations might call for a different default?

## 📊 Part 6: Creating More Advanced Safe Functions

Let's build a few more useful safe functions:

### Safe Division

```python
def safe_divide(a, b):
    """
    Safely divide two numbers, returning 0 if division by zero would occur.
    
    Args:
        a (number): The dividend
        b (number): The divisor
        
    Returns:
        float: The result of a/b or 0 if b is 0
    """
    try:
        return a / b
    except ZeroDivisionError:
        return 0
```

### Safe List Access

```python
def safe_list_access(lst, index):
    """
    Safely access a list element, returning None if the index is out of range.
    
    Args:
        lst (list): The list to access
        index (int): The index to access
        
    Returns:
        Any: The element at lst[index] or None if index is out of range
    """
    try:
        return lst[index]
    except IndexError:
        return None
```

### Safe File Writer

```python
def safe_write_file(filename, content):
    """
    Safely write content to a file, returning True if successful, False otherwise.
    
    Args:
        filename (str): The path to the file to write
        content (str): The content to write to the file
        
    Returns:
        bool: True if writing was successful, False otherwise
    """
    try:
        with open(filename, "w", encoding="utf-8") as f:
            f.write(content)
        return True
    except Exception as e:
        print(f"Failed to write file: {e}")
        return False
```

## 🎯 Part 7: Create Your Safe Utils Module

Now let's organize all these functions into a reusable Python module. This is an important step as we transition from notebook-based learning to working with Python scripts and modules in the coming weeks.

### Creating Your First Python Module

1. Create a new file called `safe_utils.py`
2. Add all the safe functions we've created
3. Add proper docstrings and comments

Here's how your file should look:

```python
# safe_utils.py

import json

def safe_json_loads(text):
    """
    Safely parse JSON, returning an empty dict if parsing fails.
    
    Args:
        text (str): The JSON string to parse
        
    Returns:
        dict: The parsed JSON data or an empty dict if parsing failed
    """
    try:
        return json.loads(text)
    except json.JSONDecodeError:
        return {}

def safe_int(text):
    """
    Safely convert text to integer, returning 0 if conversion fails.
    
    Args:
        text (str): The text to convert to an integer
        
    Returns:
        int: The converted integer or 0 if conversion failed
    """
    try:
        return int(text)
    except ValueError:
        return 0

def safe_float(text):
    """
    Safely convert text to float, returning 0.0 if conversion fails.
    
    Args:
        text (str): The text to convert to a float
        
    Returns:
        float: The converted float or 0.0 if conversion failed
    """
    try:
        return float(text)
    except ValueError:
        return 0.0

def safe_read_file(filename):
    """
    Safely read a file, returning an empty string if reading fails.
    
    Args:
        filename (str): The path to the file to read
        
    Returns:
        str: The file content or an empty string if reading failed
    """
    try:
        with open(filename, "r", encoding="utf-8") as f:
            return f.read()
    except Exception as e:
        print(f"Could not read file: {e}")
        return ""

def safe_write_file(filename, content):
    """
    Safely write content to a file, returning True if successful, False otherwise.
    
    Args:
        filename (str): The path to the file to write
        content (str): The content to write to the file
        
    Returns:
        bool: True if writing was successful, False otherwise
    """
    try:
        with open(filename, "w", encoding="utf-8") as f:
            f.write(content)
        return True
    except Exception as e:
        print(f"Failed to write file: {e}")
        return False

def safe_divide(a, b):
    """
    Safely divide two numbers, returning 0 if division by zero would occur.
    
    Args:
        a (number): The dividend
        b (number): The divisor
        
    Returns:
        float: The result of a/b or 0 if b is 0
    """
    try:
        return a / b
    except ZeroDivisionError:
        return 0

def safe_list_access(lst, index):
    """
    Safely access a list element, returning None if the index is out of range.
    
    Args:
        lst (list): The list to access
        index (int): The index to access
        
    Returns:
        Any: The element at lst[index] or None if index is out of range
    """
    try:
        return lst[index]
    except IndexError:
        return None
```

### Creating Your Module in Colab

Since we've been using Google Colab all semester, here are options for creating and using your module:

1. **Generate the module file in Colab:**
   ```python
   %%writefile safe_utils.py
   # Copy the module code here
   ```

2. **Test importing your module:**
   ```python
   import safe_utils
   
   # Test a function
   print(safe_utils.safe_int("123"))  # Should display 123
   ```

3. **Download your module** for use in upcoming weeks when we begin working with local Python development.

## 🚀 Part 8: Using Your Module

### Testing in Colab

If you're working in Colab, you can test your module in the same notebook:

```python
# After creating safe_utils.py with %%writefile
import safe_utils

# Test all functions
print("Testing safe_json_loads:")
print(safe_utils.safe_json_loads('{"name": "Alice"}'))
print(safe_utils.safe_json_loads("Not JSON"))

print("\nTesting safe_int:")
print(safe_utils.safe_int("42"))
print(safe_utils.safe_int("banana"))

# Additional tests for other functions...
```

### Testing as a Script

For the upcoming weeks when we'll be working with Python scripts locally, you can create a test file called `test_safe_utils.py`:

```python
# test_safe_utils.py

import safe_utils

# Test all functions
print("Testing safe_json_loads:")
print(safe_utils.safe_json_loads('{"name": "Alice"}'))
print(safe_utils.safe_json_loads("Not JSON"))

print("\nTesting safe_int:")
print(safe_utils.safe_int("42"))
print(safe_utils.safe_int("banana"))

print("\nTesting safe_float:")
print(safe_utils.safe_float("3.14"))
print(safe_utils.safe_float("pi"))

print("\nTesting safe_divide:")
print(safe_utils.safe_divide(10, 2))
print(safe_utils.safe_divide(10, 0))

print("\nTesting safe_list_access:")
print(safe_utils.safe_list_access([1, 2, 3], 1))
print(safe_utils.safe_list_access([1, 2, 3], 10))

print("\nTesting safe_write_file:")
print(safe_utils.safe_write_file("test.txt", "Hello, world!"))

print("\nTesting safe_read_file:")
print(safe_utils.safe_read_file("test.txt"))
print(safe_utils.safe_read_file("nonexistent.txt"))
```

### Multiple Ways to Use Your Module

1. **In Colab (current environment):** 
   - Create the module using `%%writefile`
   - Import it directly in the same session

2. **Between Colab notebooks:**
   - Upload the .py file to Colab
   - Import it in any notebook

3. **In local Python (coming weeks):**
   - Download your module
   - Place it in the same directory as your script
   - Import it using `import safe_utils`

This project serves as a bridge between our notebook-based work and the upcoming weeks focused on local Python development and debugging.

## 🧠 Part 9: Extension Challenges

Choose one or more of these challenges to extend your module:

1. **Create a `safe_input_int` function** that keeps asking for input until valid integer is given:

```python
def safe_input_int(prompt):
    """
    Repeatedly ask for input until a valid integer is given.
    
    Args:
        prompt (str): The prompt to display to the user
        
    Returns:
        int: The valid integer input
    """
    while True:
        try:
            return int(input(prompt))
        except ValueError:
            print("Invalid input. Please enter a number.")
```

**Discussion Point:** How does this function compare to PyInputPlus's `inputInt()` function we learned about earlier? What advantages or disadvantages does each approach have?

2. **Create a `safe_dict_access` function** that safely gets a value from a dictionary:

```python
def safe_dict_access(d, key, default=None):
    """
    Safely access a dictionary value, returning a default if the key doesn't exist.
    
    Args:
        d (dict): The dictionary to access
        key: The key to look up
        default: The value to return if the key doesn't exist (default: None)
        
    Returns:
        Any: The value at d[key] or default if key doesn't exist
    """
    try:
        return d[key]
    except (KeyError, TypeError):
        return default
```

3. **Create a `safe_json_file` function** that combines reading a file and parsing JSON:

```python
def safe_json_file(filename):
    """
    Safely read a JSON file, returning an empty dict if reading or parsing fails.
    
    Args:
        filename (str): The path to the JSON file
        
    Returns:
        dict: The parsed JSON data or an empty dict if reading or parsing failed
    """
    content = safe_read_file(filename)
    return safe_json_loads(content)
```

**Discussion point:** This function demonstrates function composition - using simpler functions to build more complex ones. How does this compare to pandas' approach of having a `pd.read_json()` function? What are the advantages of each approach?

## 🌟 Part 10: Publish Your Module to GitHub

1. Create a GitHub repository
2. Upload your `safe_utils.py` file
3. Create a `README.md` file explaining your module
4. Add a `LICENSE` file (optional)
5. Share your module with classmates

## 🧠 Reflection Questions

1. Why is it important to handle errors in code?
2. When is it appropriate to use a `try`/`except` block?
3. What default values did you choose for your safe functions? Why?
4. When might it be better to let an error crash your program rather than handling it silently?
5. How could you improve your module to make it even more robust?
6. Compare creating your own safe functions versus using existing libraries like PyInputPlus or pandas. When would you choose each approach?

✍️ Write your reflections here:

```text
# Your thoughts...
```

## 🏆 Submission Requirements

1. Your completed `safe_utils.py` module
2. Your `test_safe_utils.py` test file
3. Answers to the reflection questions
4. Link to your GitHub repository (if created)
5. At least one additional safe function that you created on your own

## 📚 Resources

- [Python Exception Handling Tutorial](https://docs.python.org/3/tutorial/errors.html)
- [Python Module Documentation](https://docs.python.org/3/tutorial/modules.html)
- [GitHub Quickstart Guide](https://docs.github.com/en/get-started/quickstart)
- [PyInputPlus Documentation](https://pypi.org/project/PyInputPlus/)
- [pandas Documentation](https://pandas.pydata.org/docs/)

## 🤖 Learning with AI Guidance

As you work through this mini-project, you might consider using an AI assistant like Claude to help deepen your understanding. Here are some effective prompting strategies to maximize your learning:

### ✅ Effective Learning Prompts 

1. **Get conceptual explanations:** 
   "Explain the difference between catching specific exceptions vs. catching all exceptions in Python."

2. **Request step-by-step reasoning:**
   "Walk me through how I should decide what default value to return from a safe function."

3. **Ask for analogies:**
   "Can you provide an analogy that explains why exception handling is important in programming?"

4. **Get debugging help:**
   "My safe_json_loads function is returning None instead of an empty dictionary. What might be wrong?"

5. **Request implementation variations:**
   "How would you implement safe_read_file differently if you wanted to return the error message instead of an empty string?"

### ❌ Avoid These Approaches

1. **Don't copy-paste complete solutions:**
   Instead of "Write me a safe_dict_access function," try "What considerations should I keep in mind when designing a safe_dict_access function?"

2. **Don't request fully-written code without understanding it:**
   Instead of "Give me a complete safe_utils module," ask "How should I structure my safe_utils module and what functions should I include?"

3. **Don't skip reflection:**
   Take time to understand *why* certain approaches work better than others. Ask about tradeoffs and alternatives to deepen your understanding.

Remember: AI tools are most valuable when they help you understand concepts more deeply, not when they just provide answers!
---
title: "Mastering File Operations in Python"
subtitle: "Understanding the Basics and Advanced Techniques for Effective Data Management"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to File Operations

* Importance of file operations in programming
* Overview of file operations: Opening, reading, writing, and closing files
* Python's built-in functions for file handling

::: {.notes}
Welcome to our session on file operations in Python! File handling is a fundamental aspect of programming that involves reading from and writing to files. This is essential for data management in any software application. In Python, this can be achieved using several built-in functions that make it straightforward to handle various file operations. Today, we will explore these operations and understand how they can be used to manage data effectively.
:::

# The File Operation Workflow

```
┌────────┐      ┌───────────────┐      ┌────────┐
│  Open  │ ──▶  │ Read / Write  │ ──▶  │ Close  │
└────────┘      └───────────────┘      └────────┘
```

* A typical file operation follows this three-step process
* Each step has specific functions and best practices
* Errors can occur at any stage and should be handled properly

::: {.notes}
File operations typically follow a three-step workflow: opening the file, performing read or write operations, and then closing the file. Each step is critical and has specific functions in Python. It's important to understand that errors can occur at any of these stages, so proper error handling should be implemented throughout the process. This workflow forms the foundation of all file operations in Python.
:::

# Opening Files in Python

* Using `open()` function
* Modes of opening a file: 'r', 'w', 'a', 'r+', 'b'
* Importance of specifying the correct mode

```python
# Open a file for reading
file = open('example.txt', 'r')

# Open a file for writing (creates a new file or overwrites existing)
file = open('output.txt', 'w')

# Open a file for appending
file = open('log.txt', 'a')
```

::: {.notes}
To begin working with files in Python, you must first open them using the `open()` function. This function requires the name of the file and the mode as arguments. Modes include 'r' for reading, 'w' for writing (which creates a new file or overwrites existing content), 'a' for appending to existing content, 'r+' for both reading and writing, and 'b' for binary mode. It's crucial to choose the correct mode to prevent errors such as data loss or file corruption.
:::

# Reading Files

* Reading entire content using `read()`
* Reading line by line using `readline()` and `readlines()`
* Practical example: Reading a text file

```python
# Read entire file content
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)

# Read file line by line
with open('example.txt', 'r') as file:
    for line in file:
        print(line.strip())
```

::: {.notes}
Once a file is opened in read mode ('r'), you can extract its contents using `read()`, which reads the entire file, or `readline()` that reads the file line by line. The `readlines()` function returns a list of all lines in the file. Alternatively, you can iterate through the file object directly as shown in the example. This approach is memory-efficient for large files as it reads one line at a time.
:::

# Writing to Files

* Using `write()` and `writelines()`
* Differences between 'w' and 'a' modes
* Example: Writing to a log file

```python
# Write a single string to a file
with open('output.txt', 'w') as file:
    file.write('Hello, World!')

# Write multiple lines to a file
lines = ['Line 1\n', 'Line 2\n', 'Line 3\n']
with open('output.txt', 'w') as file:
    file.writelines(lines)
```

::: {.notes}
Writing to files in Python is handled by `write()` for individual strings or `writelines()` for a list of strings. It's important to understand the difference between 'w' (write) mode, which overwrites the existing file, and 'a' (append) mode, which adds to the end of the file. Notice that with `writelines()`, you need to explicitly include newline characters if you want each item to appear on a separate line in the file.
:::

# Context Managers: The `with` Statement

* Using `with` to automatically manage resources
* Ensures files are properly closed even if errors occur
* Best practice for file operations

```python
# Without context manager - requires explicit close
file = open('example.txt', 'r')
content = file.read()
file.close()  # Must remember to close!

# With context manager - automatically closes file
with open('example.txt', 'r') as file:
    content = file.read()
# File is automatically closed when we exit the block
```

::: {.notes}
The `with` statement in Python implements context management, which automatically handles resource cleanup. When working with files, this means the file is automatically closed when the block is exited, even if an exception occurs. This is considered a best practice as it prevents resource leaks and ensures files are properly closed in all scenarios. Always prefer the `with` statement when working with files in Python.
:::

# Working with File Paths

* Challenges with file paths across operating systems
* Using `os.path` or `pathlib` for platform-independent code
* Examples of path handling

```python
# Using os.path (older approach)
import os
file_path = os.path.join('data', 'files', 'example.txt')

# Using pathlib (modern approach, Python 3.4+)
from pathlib import Path
file_path = Path('data') / 'files' / 'example.txt'
with open(file_path, 'r') as file:
    content = file.read()
```

::: {.notes}
File paths can be a source of errors, especially when your code runs on different operating systems that use different path separators (backslash on Windows, forward slash on Unix-based systems). Python provides two main ways to handle this: the older `os.path` module and the newer `pathlib` module introduced in Python 3.4. `pathlib` offers an object-oriented approach to file paths and is generally recommended for modern Python code.
:::

# Error Handling in File Operations

* Common file errors: FileNotFoundError, PermissionError, IOError
* Using `try` and `except` blocks
* Example: Handling errors while reading a file

```python
try:
    with open('nonexistent.txt', 'r') as file:
        content = file.read()
except FileNotFoundError:
    print("Error: The file does not exist.")
except PermissionError:
    print("Error: You don't have permission to read this file.")
except IOError as e:
    print(f"An I/O error occurred: {e}")
```

::: {.notes}
File operations can sometimes lead to errors, such as `FileNotFoundError` when the file doesn't exist, `PermissionError` when you don't have the necessary permissions, or general `IOError` for other input/output issues. It is important to handle these errors gracefully using `try` and `except` blocks. This prevents the program from crashing and allows for more robust error management, providing a better user experience.
:::

# Understanding File Types

* Common file types: TXT, CSV, JSON, XML
* Binary vs. Text files
* Choosing the right file type for your data

::: {.notes}
Files can be broadly classified into text and binary types. Text files (like TXT, CSV, JSON, XML) are readable by humans and are often used for data storage that involves textual data. Binary files, however, are more suitable for images, audio, or other multimedia data. Choosing the correct file type is crucial for optimal data management and processing efficiency in your applications.
:::

# Handling CSV Data

* CSV (Comma-Separated Values) for tabular data
* Reading and writing CSV with the `csv` module
* Example: Processing a CSV file

```python
import csv

# Reading a CSV file
with open('data.csv', 'r', newline='') as file:
    reader = csv.reader(file)
    for row in reader:
        print(row)  # Each row is a list

# Writing to a CSV file
with open('output.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(['Name', 'Age', 'City'])  # Header
    writer.writerow(['Alice', '30', 'New York'])  # Data
```

::: {.notes}
CSV (Comma-Separated Values) files are commonly used for storing tabular data. Python's built-in `csv` module provides functionality to read from and write to CSV files easily. The `reader` object returns each row as a list, while the `writer` object allows you to write rows to the file. Note the use of `newline=''` parameter, which is recommended when working with CSV files to ensure consistent line endings across different platforms.
:::

# Handling JSON Data

* Why JSON is important in web applications
* Reading and writing JSON data with Python
* Practical example of JSON operations

```python
import json

# Writing JSON data
data = {'name': 'John', 'age': 30, 'city': 'New York'}
with open('data.json', 'w') as file:
    json.dump(data, file, indent=4)  # indent for pretty formatting

# Reading JSON data
with open('data.json', 'r') as file:
    loaded_data = json.load(file)
    print(loaded_data['name'])  # Access as a Python dictionary
```

::: {.notes}
JSON (JavaScript Object Notation) is a lightweight data interchange format that's easy to read and write for humans, and easy to parse and generate for machines. It is extensively used in web applications for data exchange. In Python, the `json` module provides methods like `dump()` to write Python objects as JSON to a file and `load()` to read JSON from a file into Python objects. The `indent` parameter in `json.dump()` creates a more readable, formatted JSON file.
:::

# Advanced Techniques: File Compression

* Benefits of file compression
* Using `gzip` and `zipfile` modules
* Example of compressing a file

```python
import gzip

# Compressing data
text = "This is a long string that will be compressed."
with gzip.open('file.txt.gz', 'wt') as f:
    f.write(text)

# Reading compressed data
with gzip.open('file.txt.gz', 'rt') as f:
    decompressed_text = f.read()
    print(decompressed_text)
```

::: {.notes}
File compression is a useful technique to reduce file size, making storage and transmission more efficient. Python provides built-in libraries such as `gzip` and `zipfile` for compressing and decompressing files. In this example, we use `gzip` to compress and later decompress text data. Note the use of 'wt' and 'rt' modes, which stand for "write text" and "read text" respectively, ensuring proper text encoding and decoding during the compression process.
:::

# Practical Exercise: Word Counter

Create a program that:
1. Reads a text file
2. Counts the frequency of each word
3. Writes the results to a new file
4. Handles potential errors appropriately

```python
# Starter code
def count_words(filename):
    try:
        # Your code here
        pass
    except FileNotFoundError:
        # Error handling
        pass
    
    return word_counts  # Dictionary of word frequencies
```

::: {.notes}
This exercise challenges you to apply the file operation concepts we've learned. You'll need to open and read a file, process its contents to count word frequencies, and then write the results to a new file. Make sure to implement proper error handling for scenarios like the file not existing. This practical exercise reinforces the file operation workflow and error handling techniques.
:::

# Looking Ahead: Building Safe Utilities

* In our upcoming mini-project, we'll combine file operations and exception handling
* You'll create reusable "safe" functions that handle errors gracefully
* Example: A function that safely reads a file and returns a default value if the operation fails

```python
def safe_read_file(filename, default=""):
    """Safely read a file, returning a default value if it fails."""
    try:
        with open(filename, 'r') as file:
            return file.read()
    except Exception as e:
        print(f"Error reading file: {e}")
        return default
```

::: {.notes}
Our upcoming mini-project will focus on creating "safe" utility functions that combine file operations with robust error handling. These functions will encapsulate common file operations while gracefully handling any errors that might occur. The example shown here is a simple safe file reading function that returns a default value if the file cannot be read for any reason. This approach makes your code more resilient and user-friendly by preventing crashes due to file operation errors.
:::

# Practical Applications of File Operations

* Data logging
* Configuration files management
* Reading and writing CSV files for data analysis
* Storing and retrieving application state

::: {.notes}
File operations are widely used in real-world applications such as data logging, managing configuration files, and handling CSV files for data analysis. They're also commonly used for storing and retrieving application state, allowing programs to remember settings or data between runs. Understanding these operations enhances your ability to manage data effectively in various programming scenarios, which is crucial for any software development project, especially in business and technology contexts.
:::

# Conclusion

* Recap of key points: Opening, reading, writing, and closing files
* Importance of using context managers with the `with` statement
* Value of proper error handling in file operations
* Best practices for working with different file types

::: {.notes}
Today, we covered the basic yet crucial aspects of file operations in Python, including how to open, read, write, and close files, along with the importance of handling errors efficiently. We emphasized the use of context managers with the `with` statement as a best practice for file handling. We also explored working with different file types like CSV and JSON, and advanced techniques like file compression. Remember, good file management practices are critical for efficient data handling and can significantly impact the performance and reliability of your applications.
:::

# Further Resources and Next Steps

* Official Python documentation on file operations:
  [Python File Handling](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files)
* Explore `pathlib` for modern file path handling:
  [pathlib — Object-oriented filesystem paths](https://docs.python.org/3/library/pathlib.html)
* Practice by developing your own file handling projects

::: {.notes}
For further learning, I recommend visiting the official Python documentation on file handling. The `pathlib` module documentation is especially useful for understanding modern approaches to file path handling. There are also numerous online resources and tutorials available that can provide additional examples and projects to practice these concepts. The best way to learn is by doing, so try to implement what you've learned today in your own projects!
:::

# Quick Check

Which of these is the recommended way to open and read a file in Python?

A. 
```python
file = open('data.txt', 'r')
content = file.read()
# No close statement
```

B. 
```python
file = open('data.txt', 'r')
content = file.read()
file.close()
```

C. 
```python
with open('data.txt', 'r') as file:
    content = file.read()
```

D. 
```python
content = read_file('data.txt')
```

::: {.notes}
The correct answer is C. Using the `with` statement is the recommended approach as it automatically handles closing the file, even if exceptions occur. Option A is problematic because it never closes the file, which can lead to resource leaks. Option B is better but doesn't handle exceptions well. Option D is not valid Python syntax for built-in functions.
:::
---
title: "Mastering Exception Management in Python"
subtitle: "Best Practices for Robust and Resilient Code"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to Exception Handling

* Understanding exceptions in Python
* Importance of error handling for program reliability
* Overview of today's key concepts

::: {.notes}
Welcome to our exploration of exception handling in Python! Today, we will delve into how Python handles errors and exceptions, which are critical for writing robust and user-friendly applications. Understanding this concept will not only help you debug programs but also allow you to anticipate and manage potential issues effectively. Let's start by defining what exceptions are and why they are fundamental in Python programming.
:::

# What are Exceptions?

* Exceptions: Events that disrupt normal program flow
* Difference between syntax errors and exceptions
* Why handling exceptions is important for program stability

::: {.notes}
In programming, an exception is an event that disrupts the normal flow of a program. It occurs whenever the program encounters an error during execution. While syntax errors are mistakes in the use of the programming language, which are caught before the execution of the program, exceptions can occur during execution. Without proper handling, exceptions will cause the program to crash. Understanding these differences is crucial for effective error handling and creating more resilient applications.
:::

# Python's Exception Hierarchy

```
BaseException
├── SystemExit
├── KeyboardInterrupt
├── Exception
│   ├── ArithmeticError
│   │   ├── ZeroDivisionError
│   │   └── OverflowError
│   ├── LookupError
│   │   ├── IndexError
│   │   └── KeyError
│   ├── TypeError
│   └── ValueError
└── ... (other exceptions)
```

* Python organizes exceptions in a hierarchical structure
* Most exceptions you'll handle derive from `Exception`
* Understanding the hierarchy helps with effective exception catching

::: {.notes}
Python organizes exceptions in a hierarchical structure. At the top of this hierarchy is the BaseException class, from which all other exceptions inherit. Directly under BaseException is the Exception class, which serves as the base for most exceptions you will typically handle. Examples of specific exceptions inheriting from Exception include ValueError, which is raised when a function receives an argument of the correct type but inappropriate value, TypeError, and IOError. By understanding this hierarchy, you can make informed decisions about which exceptions to catch and how to structure your error handling code.
:::

# Basic Exception Handling Syntax

* Using `try` and `except` blocks
* Basic syntax pattern
* Example of simple exception handling

```python
try:
    # Code that might raise an exception
    x = int(input("Enter a number: "))
    result = 10 / x
    print(f"10 divided by {x} is {result}")
except ValueError:
    # Handles invalid input
    print("That was not a valid number.")
except ZeroDivisionError:
    # Handles division by zero
    print("Cannot divide by zero.")
```

::: {.notes}
Exception handling in Python is primarily conducted using `try` and `except` blocks. You wrap the code that might cause an exception in a `try` block, and the code to execute if an exception occurs goes in an `except` block. You can have multiple `except` blocks to handle different types of exceptions differently. In this example, we're handling two specific exceptions: ValueError for invalid input conversion and ZeroDivisionError for division by zero. This targeted approach allows for more precise error responses.
:::

# Complete Exception Handling Structure

* The full `try`/`except`/`else`/`finally` structure
* When to use each clause
* Complete example

```python
try:
    # Code that might raise an exception
    x = int(input("Enter a number: "))
    result = 100 / x
except ValueError:
    # Handles invalid input
    print("That's not a valid number!")
except ZeroDivisionError:
    # Handles division by zero
    print("Cannot divide by zero!")
else:
    # Executes if no exceptions were raised
    print(f"100 divided by {x} is {result}")
finally:
    # Always executes, regardless of what happened
    print("Execution completed")
```

::: {.notes}
The complete exception handling structure in Python includes four components: `try`, `except`, `else`, and `finally`. The `try` block contains code that might raise exceptions. The `except` blocks handle specific exceptions. The `else` clause runs only if no exceptions were raised in the `try` block, making it a good place for code that should run only if the operation was successful. The `finally` clause contains code that will execute no matter what, whether an exception occurred or not, making it perfect for cleanup operations.
:::

# Catching Multiple Exceptions

* Different ways to handle multiple exception types
* Using tuple of exceptions
* Using Exception hierarchy for broader catching

```python
# Method 1: Multiple except blocks
try:
    # Risky code
    pass
except ValueError:
    # Handle ValueError
    pass
except TypeError:
    # Handle TypeError
    pass

# Method 2: Catching multiple exceptions in one block
try:
    # Risky code
    pass
except (ValueError, TypeError):
    # Handle either ValueError or TypeError
    pass

# Method 3: Catching parent exception
try:
    # Risky code
    pass
except Exception:
    # Handle any exception that inherits from Exception
    # Be careful with this approach!
    pass
```

::: {.notes}
Python offers several ways to handle multiple types of exceptions. You can use separate `except` blocks for each exception type, which allows for different handling logic for each. You can also catch multiple exception types in a single `except` block by specifying them as a tuple, which is useful when you want to handle different exceptions in the same way. Finally, you can catch a parent exception class to handle all its child exceptions, but this approach should be used carefully as it might catch unexpected exceptions and mask bugs.
:::

# Example: Handling File Errors

```python
try:
    with open('data.txt', 'r') as file:
        content = file.read()
        data = int(content)
except FileNotFoundError:
    print("Error: File does not exist.")
    data = 0
except ValueError:
    print("Error: File does not contain a valid number.")
    data = 0
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    data = 0
finally:
    print(f"Processing complete. Data value: {data}")
```

* Practical example of file error handling
* Handling specific file-related exceptions
* Using general exception as a fallback

::: {.notes}
Let's consider a practical example where we handle various exceptions that might occur when working with files. Here, we're trying to open a file, read its content, and convert it to an integer. Several things might go wrong: the file might not exist (FileNotFoundError), the content might not be a valid number (ValueError), or some other unexpected error might occur. We handle each specific case differently and use a generic Exception handler as a fallback. The finally block ensures we always print a completion message.
:::

# Raising Exceptions

* When to raise exceptions in your code
* Using `raise` to signal errors
* Re-raising exceptions after handling

```python
def validate_age(age):
    if not isinstance(age, int):
        raise TypeError("Age must be an integer")
    if age < 0:
        raise ValueError("Age cannot be negative")
    if age > 120:
        raise ValueError("Age is unrealistically high")
    return age

# Example of re-raising an exception
try:
    age = validate_age("twenty")
except TypeError as e:
    print(f"Error: {e}")
    print("Please enter a number instead.")
    # Re-raise if you want calling code to also handle it
    # raise
```

::: {.notes}
Sometimes you need to raise exceptions in your own code to signal error conditions. The `raise` statement allows you to trigger a specific exception when a condition occurs that should interrupt normal program flow. In this example, we've created a function that validates an age value, raising appropriate exceptions for different invalid inputs. Additionally, you can re-raise an exception after handling it partially, which allows the exception to propagate up the call stack while still performing some local error handling.
:::

# Exception Chaining

* Using `raise ... from ...` to indicate causality
* Preserving the exception stack
* Helps with debugging complex applications

```python
try:
    x = int("not a number")
except ValueError as e:
    # This creates a new exception while preserving the original cause
    raise RuntimeError("Processing failed") from e

# Example of implicit chaining
try:
    try:
        x = int("not a number")
    except ValueError:
        # This implicitly chains the exceptions
        # (Python remembers the original cause)
        raise RuntimeError("Processing failed")
except RuntimeError as e:
    print(f"Error: {e}")
    # Access the original cause
    print(f"Original cause: {e.__cause__}")
```

::: {.notes}
Exception chaining is a feature in Python 3 that allows you to indicate that one exception was caused by another. Using the syntax `raise new_exception from original_exception`, you explicitly link the two exceptions, which helps with debugging by preserving the full exception history. Python also supports implicit chaining when you raise a new exception inside an except block. This feature is especially valuable in complex applications where errors might propagate through multiple layers of code.
:::

# Creating Custom Exceptions

* Benefits of custom exception classes
* How to create your own exception types
* Example of using custom exceptions

```python
# Define custom exceptions
class NetworkError(Exception):
    """Exception raised for network-related errors."""
    pass

class DatabaseError(Exception):
    """Exception raised for database-related errors."""
    pass

# Using custom exceptions
def fetch_data(database_url):
    try:
        # Attempt to connect...
        if "database" not in database_url:
            raise DatabaseError(f"Invalid database URL: {database_url}")
        # More code...
    except ConnectionError:
        # Convert standard exception to our custom one
        raise NetworkError("Could not connect to the database") from ConnectionError
```

::: {.notes}
Creating custom exception classes allows you to define application-specific error types that provide more context about what went wrong. Custom exceptions typically inherit from the Exception class or one of its subclasses. They can be as simple as empty classes that just define a new type, or they can include additional attributes and methods to provide more information about the error. Using custom exceptions makes your code more readable and allows calling code to catch specific application-level exceptions.
:::

# Using Assertions

* Purpose of assertions in code
* When to use assertions vs. exceptions
* Example of effective assertion usage

```python
def calculate_average(numbers):
    # Assert that the input is a non-empty list
    assert isinstance(numbers, list), "Input must be a list"
    assert len(numbers) > 0, "List cannot be empty"
    
    total = sum(numbers)
    return total / len(numbers)

# Assertions can be disabled in production with -O flag
# Use exceptions for errors that should always be checked
```

::: {.notes}
Assertions are a debugging aid that tests a condition and triggers an error if the condition is false. Unlike regular exception handling, assertions are typically used to catch programming errors rather than runtime errors. They're often used to verify assumptions about your code's state or input values. It's important to note that assertions can be disabled in production code by running Python with the -O (optimize) flag, so you shouldn't rely on them for security or data validation that must always occur. For such checks, use regular exception handling instead.
:::

# Common Pitfalls in Exception Handling

* Overusing `try` blocks
* Catching too general exceptions
* Ignoring caught exceptions
* Silent failures

```python
# Bad: Too general, masks errors
try:
    # A lot of code...
    process_data()
    save_results()
except Exception:  # Catches everything!
    pass  # Silent failure!

# Better: Specific, informative
try:
    # Minimal code that might fail
    data = process_data()
except ValueError as e:
    print(f"Data processing error: {e}")
    log_error(e)  # Log for debugging
```

::: {.notes}
Several common pitfalls can reduce the effectiveness of exception handling. First, wrapping too much code in a single try block makes it harder to determine which part caused the error. Second, catching overly general exceptions like `Exception` might mask bugs by catching exceptions you didn't anticipate. Third, ignoring exceptions by using empty except blocks or just passing creates silent failures that are difficult to debug. Always include minimal code in try blocks, catch specific exceptions, and provide meaningful error messages or logging to help diagnose issues.
:::

# Common Exception Handling Patterns

* Retry pattern for transient failures
* Logging and re-raising for debugging
* Converting between exception types
* Default values for graceful degradation

```python
# Retry pattern
def retry_operation(max_attempts=3):
    attempts = 0
    while attempts < max_attempts:
        try:
            return perform_operation()  # Might fail
        except TransientError:
            attempts += 1
            if attempts == max_attempts:
                raise  # Re-raise after max attempts
            time.sleep(1)  # Wait before retrying

# Default value pattern
def get_config_value(key, default=None):
    try:
        return config[key]
    except KeyError:
        return default
```

::: {.notes}
Several exception handling patterns are commonly used in Python. The retry pattern attempts an operation multiple times before giving up, which is useful for transient errors like network timeouts. Logging and re-raising helps with debugging by recording the error but still allowing it to propagate. Converting between exception types helps abstract lower-level errors into application-specific ones. The default value pattern provides graceful degradation by substituting a sensible default when an operation fails, allowing the program to continue running with reduced functionality rather than crashing.
:::

# Real-World Application: Data Processing Pipeline

```python
def process_data_pipeline(input_file, output_file):
    try:
        # Step 1: Read input file
        with open(input_file, 'r') as f:
            data = f.read()
        
        # Step 2: Parse data
        try:
            parsed_data = json.loads(data)
        except json.JSONDecodeError:
            # Attempt CSV parsing as a fallback
            parsed_data = parse_csv(data)
        
        # Step 3: Transform data
        transformed_data = transform(parsed_data)
        
        # Step 4: Write output
        with open(output_file, 'w') as f:
            json.dump(transformed_data, f)
            
        return True
    except Exception as e:
        log_error(f"Pipeline failed: {e}")
        return False
```

* Exception handling in a multi-step process
* Using nested try-except blocks for specific steps
* Implementing fallback strategies

::: {.notes}
This real-world example shows exception handling in a data processing pipeline. We have an outer try-except block that catches any unhandled exceptions in the overall process, while inner try-except blocks handle specific steps that might fail. We also implement a fallback strategy: if JSON parsing fails, we try CSV parsing instead. This approach combines different exception handling patterns to create a robust pipeline that can deal with various error conditions while still attempting to complete the task. The function returns a boolean indicating success or failure, allowing calling code to take appropriate action.
:::

# Looking Ahead: Safe Utility Functions

* Combining exception handling with reusable functions
* Creating "safe" versions of operations that might fail
* Preview of our upcoming mini-project

```python
def safe_json_loads(text, default=None):
    """
    Safely parse JSON text, returning a default value if parsing fails.
    
    Args:
        text (str): The JSON string to parse
        default: Value to return if parsing fails (default: None)
        
    Returns:
        The parsed JSON data or the default value
    """
    if default is None:
        default = {}
        ---
title: "Staff Answer Guide: Introduction to Safe Utility Functions"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

## Overview
This guide provides instructors with implementation answers, discussion points, and teaching tips for the "Introduction to Safe Utility Functions" worksheet. The activity introduces students to the concept of error-resistant wrapper functions that handle exceptions internally and return sensible default values.

## Implementation Solutions

### Task: Create a Safe Integer Conversion Function

```python
def safe_int(text, default=0):
    """
    Safely convert text to an integer.
    
    Args:
        text (str): The text to convert
        default (int): Value to return if conversion fails
        
    Returns:
        int: The converted integer or the default value
    """
    try:
        return int(text)
    except ValueError:
        return default
```

Expected outputs:
- `safe_int("123")` → 123
- `safe_int("abc")` → 0
- `safe_int("abc", -1)` → -1

### Extension Function Solutions

#### Option 1: safe_float()
```python
def safe_float(text, default=0.0):
    """
    Safely convert text to a floating-point number.
    
    Args:
        text (str or number): The value to convert
        default (float): Value to return if conversion fails
        
    Returns:
        float: The converted float or the default value
    """
    try:
        return float(text)
    except (ValueError, TypeError):
        return default
```

#### Option 2: safe_divide()
```python
def safe_divide(numerator, denominator, default=0.0):
    """
    Safely divide two numbers, handling division by zero.
    
    Args:
        numerator (number): The dividend
        denominator (number): The divisor
        default (number): Value to return if division fails
        
    Returns:
        number: The result of division or the default value
    """
    try:
        return numerator / denominator
    except ZeroDivisionError:
        return default
```

#### Option 3: safe_read_file()
```python
def safe_read_file(filename, default=""):
    """
    Safely read a file, returning a default value if the file doesn't exist.
    
    Args:
        filename (str): Path to the file
        default (str): Value to return if file reading fails
        
    Returns:
        str: The contents of the file or the default value
    """
    try:
        with open(filename, 'r') as file:
            return file.read()
    except (FileNotFoundError, PermissionError, IOError):
        return default
```

## Teaching Notes

### Key Concepts to Emphasize
1. **Error Prevention vs. Error Handling**: Safe functions represent a proactive approach to dealing with potential errors.
2. **Abstraction of Error Handling**: Users of safe functions don't need to worry about try-except blocks in their code.
3. **Graceful Degradation**: Programs can continue functioning even when operations fail.

### Common Student Misconceptions
1. **All Errors Should Be Hidden**: Clarify that some errors should propagate (e.g., programming errors).
2. **Default Values Are Always Good**: Discuss how default values can sometimes mask real problems.
3. **Safe Functions Replace Exception Handling**: Explain that both approaches have their place.

### Discussion Question Guidance

#### Q1: How does your safe_int function compare to the built-in int() function?
**Key points to guide discussion:**
- The standard `int()` raises exceptions for invalid inputs
- `safe_int()` returns a default value instead of raising exceptions
- `safe_int()` has the same conversion behavior for valid inputs
- `safe_int()` may hide errors that could be important to know about

#### Q2: What are the advantages of returning a default value instead of raising an exception?
**Key points to guide discussion:**
- Simpler calling code without try-except blocks
- Programs continue running despite errors
- Reasonable fallback behavior for non-critical operations
- Better user experience for applications with casual users

#### Q3: Are there any disadvantages to hiding errors this way?
**Key points to guide discussion:**
- Errors might go unnoticed
- Debugging can become harder when errors are silently handled
- The program might continue with invalid data
- Default values might not be appropriate for all use cases

#### Q4: When might it be better to let exceptions propagate?
**Key points to guide discussion:**
- Critical operations where errors should not be ignored
- When detailed error information is needed
- During development and debugging
- When the calling code needs to handle the error specifically

### Reflection Question Guidance

#### How does creating "safe" versions of functions improve reliability?
**Key points to guide discussion:**
- Prevents crashes from unexpected inputs
- Allows for graceful degradation
- Simplifies error handling throughout the codebase
- Creates more predictable behavior

#### What considerations for choosing appropriate default values?
**Key points to guide discussion:**
- The default should be sensible within the domain context
- Ideally identifiable as a "default" and not a valid result
- Should not cause further errors down the line
- May need to be customizable for different contexts

#### How might students apply this concept to other operations?
**Key points to guide discussion:**
- Network operations that might time out
- Database queries that might fail
- User input validation
- JSON/data parsing functions

## Classroom Management Tips

1. **Live Coding**: Demonstrate the building of a safe function from scratch.
2. **Real-world Examples**: Show examples of safe functions in popular libraries.
3. **Pair Programming**: Have students work in pairs to implement different safe functions and then swap implementations.
4. **Error Challenge**: Create a challenge where students must identify scenarios where errors might occur in existing code.

## Assessment Guidelines

### What to Look For in Student Solutions

#### Correct Implementation (40%)
- Proper try-except structure
- Correct exception types being caught
- Appropriate use of the default parameter

#### Function Design (30%)
- Clear, descriptive function name
- Comprehensive docstring
- Sensible parameter names and default values

#### Error Handling Strategy (30%)
- Thoughtful consideration of which exceptions to catch
- Not catching overly broad exceptions without justification
- Appropriate error isolation

#### Bonus Points
- Additional error logging or reporting features
- Parameter validation
- Consideration of multiple error types

## Mini-Project Connection
Remind students that this activity is preparation for the Week 11 mini-project. You might want to have students start brainstorming what types of safe utility functions would be useful in their own programming projects.

## Conclusion
The concept of safe functions provides a powerful tool for creating more robust code. By learning to anticipate and handle errors gracefully, students are developing a key software engineering skill that will serve them throughout their programming careers.---
title: "Staff Answer Guide: Advanced Exception Handling Techniques"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


## Overview
This guide provides instructors with answers, explanations, and teaching notes for the "Advanced Exception Handling Techniques" worksheet. It includes solutions to all tasks, anticipated student questions, and suggestions for classroom delivery.

## Learning Objectives
- Implement multi-level exception handling for different error types
- Use the complete try-except-else-finally structure
- Analyze and improve code with robust exception handling

## Worksheet Structure
The worksheet progresses through:
1. Review of basic exception handling
2. Introduction to advanced techniques (multiple exception types, else, finally)
3. Code analysis and improvement activity
4. Extension activity with timeout handling
5. Reflection questions

## Task 1: Identify Issues in Code - Answer Key

Students should identify the following potential errors in the `process_data_file` function:

1. **FileNotFoundError**: If the file doesn't exist
2. **PermissionError**: If the file exists but can't be accessed
3. **IOError/OSError**: For other file I/O issues
4. **ValueError**: If any line can't be converted to an integer
5. **ZeroDivisionError**: If the file is empty, `len(numbers)` will be 0
6. **Resource Leak**: If an exception occurs, the file won't be closed properly
7. **UnicodeDecodeError**: If the file contains characters that can't be decoded

## Task 2: Improved Code - Answer Key

```python
def improved_process_data_file(filename):
    """
    Processes a file containing numbers and returns their average.
    Handles various potential errors gracefully.
    
    Args:
        filename (str): Name of the file to process
        
    Returns:
        float: Average of numbers in the file, or None if processing failed
    """
    file = None
    try:
        file = open(filename, 'r')
        lines = file.readlines()
        
        if not lines:
            print(f"Warning: File '{filename}' is empty.")
            return None
        
        numbers = []
        for i, line in enumerate(lines):
            try:
                numbers.append(int(line.strip()))
            except ValueError:
                print(f"Warning: Line {i+1} does not contain a valid number. Skipping.")
        
        if not numbers:
            print(f"Error: No valid numbers found in '{filename}'.")
            return None
            
        average = sum(numbers) / len(numbers)
        
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found.")
        return None
    except PermissionError:
        print(f"Error: No permission to read '{filename}'.")
        return None
    except Exception as e:
        print(f"Unexpected error processing '{filename}': {str(e)}")
        return None
    else:
        # This executes if no exceptions were raised in the try block
        print(f"Successfully processed {len(numbers)} numbers from '{filename}'.")
    finally:
        # This always executes, regardless of exceptions
        if file is not None and not file.closed:
            file.close()
            
    return average
```

Key improvements in this solution:
1. Uses `try-except-else-finally` structure
2. Handles multiple specific exception types
3. Provides informative error messages
4. Ensures the file is always closed with `finally`
5. Handles the case of empty files and non-numeric data
6. Returns `None` when processing fails
7. Uses specific exception handling for line parsing (nested try-except)

## Task 3: Testing - Expected Output

When testing with various files, students should see behavior similar to:

```
# For nonexistent.txt
Error: File 'nonexistent.txt' not found.
None

# For bad_data.txt
Warning: Line 3 does not contain a valid number. Skipping.
Successfully processed 3 numbers from 'bad_data.txt'.
2.3333333333333335

# For empty.txt
Warning: File 'empty.txt' is empty.
None

# For good_data.txt
Successfully processed 4 numbers from 'good_data.txt'.
25.0
```

## Extension: Timeout Handler - Sample Solution

```python
import signal
import time

class TimeoutError(Exception):
    pass

def timeout_handler(signum, frame):
    raise TimeoutError("Operation timed out")

def read_file_with_timeout(filename, timeout_seconds=5):
    """
    Attempts to read a file but gives up if it takes too long.
    
    Args:
        filename (str): The file to read
        timeout_seconds (int): Maximum seconds to wait
        
    Returns:
        str: File contents or error message
    """
    # Set the timeout signal handler
    signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(timeout_seconds)
    
    file = None
    try:
        file = open(filename, 'r')
        contents = file.read()
        signal.alarm(0)  # Cancel the alarm
        return contents
    except FileNotFoundError:
        return f"Error: File '{filename}' not found."
    except PermissionError:
        return f"Error: No permission to read '{filename}'."
    except TimeoutError:
        return f"Error: Reading '{filename}' timed out after {timeout_seconds} seconds."
    except Exception as e:
        return f"Unexpected error reading '{filename}': {str(e)}"
    finally:
        if file is not None and not file.closed:
            file.close()
        signal.alarm(0)  # Ensure alarm is canceled even if an exception occurred
```

**Note for instructors**: The timeout functionality may not work in all environments, particularly in Windows. Be prepared to discuss alternative timeout methods like threading if needed.

## Reflection Questions - Teaching Notes

1. **How does handling specific exceptions improve your code?**
   - Key points: Allows for specific responses to different error types
   - Avoids masking bugs with generic handlers
   - Provides more informative feedback to users
   - Creates more targeted recovery strategies

2. **When would you use the `else` clause?**
   - For code that should only run if no exceptions occurred
   - Separates "success path" code from error handling
   - Makes code logic clearer and prevents nesting
   - Example: processing results that only exist if earlier steps succeeded

3. **How could exception handling make programs more user-friendly?**
   - Prevents crashes and provides helpful error messages
   - Offers recovery options instead of simply failing
   - Preserves user data when errors occur
   - Logs useful diagnostic information for support

4. **How do these practices relate to the "Safe Utils Module" project?**
   - They form the foundation for creating robust utility functions
   - Encapsulate complex error handling behind a clean interface
   - Allow consistent error management across an application
   - Convert technical exceptions into meaningful user feedback

## Classroom Delivery Suggestions

1. **Start with a live demo** showing how basic code fails with various inputs
2. **Pair programming** for Task 2 works well - one student focusing on structure, the other on specific exceptions
3. **Create additional test cases** to challenge student solutions (files with mixed valid/invalid data, very large files, etc.)
4. **Relate to real applications** students might create (data analysis, web scraping, configuration handling)
5. **Discuss performance implications** of exception handling vs. checking conditions beforehand

## Common Student Questions

**Q: When should I catch a specific exception vs. using a general `except` clause?**
A: Catch specific exceptions when you can take a specific recovery action. Use a general clause only as a last resort to prevent crashes, preferably logging the unexpected error.

**Q: Why use `else` when I could just put that code after the try-except?**
A: The `else` clause only executes if no exceptions occurred AND no `return`/`break`/`continue` statements were hit in the try block, making program flow clearer.

**Q: Is there a way to catch multiple exception types with the same handler?**
A: Yes, use a tuple: `except (FileNotFoundError, PermissionError):` to handle both with the same code.

**Q: Why not just use context managers (with statements) instead of try-finally?**
A: Context managers are excellent for resource management (`with open() as f`), but try-except-else-finally gives you more control over the entire error handling process.

## Assessment Criteria

When evaluating student solutions for Task 2, look for:
1. **Correctness**: Handles all identified error cases
2. **Robustness**: Deals gracefully with unexpected situations
3. **Usability**: Provides clear, actionable error messages
4. **Efficiency**: Doesn't over-complicate the solution
5. **Resource management**: Properly closes files in all cases

## Extended Discussion Topics

* Exception handling performance implications
* Custom exception classes (when and how to create them)
* Python's error handling compared to other languages
* Balancing robust error handling with readable code
* Error logging best practices---
title:"Staff Answer Guide: Introduction to File Operations and Basic Error Handling"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


## Overview
This worksheet introduces students to essential file operations in Python and basic error handling techniques. The activities focus on opening, reading, writing, and closing files, as well as implementing try-except blocks to handle potential errors gracefully.

## Learning Objectives
- Apply basic file operations in Python
- Identify common errors in file operations
- Implement exception handling with try-except blocks
- Use context managers with the `with` statement

## Key Concepts Review

### File Operations
Students will learn:
- Opening files with different modes (`'r'`, `'w'`, `'a'`)
- Reading and writing file content
- Importance of properly closing files

### Exception Handling
Students will practice:
- Identifying errors that occur during file operations
- Using try-except blocks to catch specific exceptions
- Creating more robust programs that don't crash on common errors

## Expected Error Messages

When students run the code that attempts to open a nonexistent file, they should see an error like:
```
FileNotFoundError: [Errno 2] No such file or directory: 'nonexistent_file.txt'
```

## Solution to Task 1: Write the Basic Log Function

```python
from datetime import datetime

def add_log_entry(note):
    """
    Adds a timestamped entry to a log file.
    
    Args:
        note (str): The message to log
    """
    try:
        # Method 1: Without context manager
        # file = open('daily_log.txt', 'a')
        # current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        # file.write(f"[{current_time}] {note}\n")
        # file.close()
        
        # Method 2: With context manager (preferred)
        with open('daily_log.txt', 'a') as file:
            current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # Optional: Check if note is empty
            if not note.strip():
                note = "(Empty entry)"
                
            file.write(f"[{current_time}] {note}\n")
            
    except Exception as e:
        print(f"Error writing to log file: {e}")
```

## Solution to Task 2: Test Your Function

Key points to discuss with students:
- The function should handle empty strings
- Additional test cases might include:
  - Very long entries
  - Entries with special characters
  - Multiple entries in succession

```python
# Testing with valid input
add_log_entry("Started working on Python file operations assignment")

# Testing with empty input
add_log_entry("")

# Additional test cases
add_log_entry("Entry with special characters: !@#$%^&*()")
add_log_entry("A" * 1000)  # Very long entry
```

## Solution to Extension: Reading and Processing the Log

```python
def display_recent_logs(num_entries=5):
    """
    Displays the most recent log entries.
    
    Args:
        num_entries (int): Number of recent entries to display
    """
    try:
        with open('daily_log.txt', 'r') as file:
            # Read all lines and convert to a list
            lines = file.readlines()
            
            # Calculate how many entries to show
            entries_to_show = min(num_entries, len(lines))
            
            if entries_to_show == 0:
                print("No log entries found.")
                return
                
            print(f"Displaying the {entries_to_show} most recent log entries:")
            
            # Display the most recent entries (from the end of the file)
            for i in range(1, entries_to_show + 1):
                print(lines[-i].strip())
                
    except FileNotFoundError:
        print("Log file doesn't exist yet. Try adding some entries first.")
    except Exception as e:
        print(f"Error reading log file: {e}")
```

## Discussion Points for Reflection Questions

### 1. Benefits of try-except blocks
- Programs continue running instead of crashing
- Errors can be handled gracefully with user-friendly messages
- Allows for recovery strategies when operations fail
- Makes code more robust in unpredictable environments

### 2. Importance of closing files
- Prevents resource leaks (open file handles)
- Ensures all data is properly written (flushes buffers)
- Makes files available to other processes
- The `with` statement ensures files are closed even if exceptions occur

### 3. Other potential file errors to handle
- `PermissionError`: Insufficient permissions to read/write the file
- `IOError`: General input/output errors
- `IsADirectoryError`: Trying to open a directory as a file
- `DiskFullError`: No space left on the device
- `JSONDecodeError`: When working with JSON files
- `UnicodeDecodeError`: Issues with character encoding

## Teaching Tips

1. **Demonstrate Real-World Relevance**: Explain how proper file handling is crucial in professional applications (databases, log systems, data processing).

2. **Visualization**: Draw diagrams showing the flow of try-except blocks and how they change program execution.

3. **Common Pitfalls to Highlight**:
   - Forgetting to close files
   - Using bare `except:` without specifying exceptions
   - Not handling empty or malformed input

4. **Scaffolding**: 
   - For struggling students, provide a partially completed solution
   - For advanced students, challenge them to add features like:
     - Searching the log by keyword
     - Deleting old entries
     - Sorting or filtering entries

5. **Check for Understanding**:
   - Ask students to explain why the `with` statement is preferred
   - Have them predict what happens with different error scenarios

## Extension Activities

For students who finish early or want additional challenges:

1. **Log Parser**: Create a function that analyzes the log file to show statistics (e.g., entries per day)

2. **Categories**: Modify the log system to support different categories of entries (e.g., INFO, WARNING, ERROR)

3. **Multiple Log Files**: Extend the program to maintain separate log files for different users or purposes

4. **CSV Integration**: Convert the log to CSV format for easier data analysis

## Assessment Criteria

When reviewing student work, look for:

- Proper use of context managers (`with` statement)
- Appropriate exception handling
- Input validation
- Clear, well-formatted output
- Thoughtful reflection responsesCopyright © 2017-present, [Encode OSS Ltd](https://www.encode.io/).
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**This software is dual-licensed under the The University of Illinois/NCSA
Open Source License (NCSA) and The 3-Clause BSD License**

# NCSA Open Source License
**Copyright (c) 2019 Kevin Sheppard. All rights reserved.**

Developed by: Kevin Sheppard (<kevin.sheppard@economics.ox.ac.uk>,
<kevin.k.sheppard@gmail.com>)
[http://www.kevinsheppard.com](http://www.kevinsheppard.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal with
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimers.

Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimers in the documentation and/or
other materials provided with the distribution.

Neither the names of Kevin Sheppard, nor the names of any contributors may be
used to endorse or promote products derived from this Software without specific
prior written permission.

**THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH
THE SOFTWARE.**


# 3-Clause BSD License
**Copyright (c) 2019 Kevin Sheppard. All rights reserved.**

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
   may be used to endorse or promote products derived from this software
   without specific prior written permission.

**THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
THE POSSIBILITY OF SUCH DAMAGE.**

# Components

Many parts of this module have been derived from original sources, 
often the algorithm's designer. Component licenses are located with 
the component code.
Copyright © 2018, [Encode OSS Ltd](https://www.encode.io/).
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
Copyright © 2019, [Encode OSS Ltd](https://www.encode.io/).
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
Copyright © 2020, [Encode OSS Ltd](https://www.encode.io/).
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
MIT License

Copyright (c) 2018 - 2024 Isaac Muse <isaacmuse@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
Copyright (C) 2010-2019 Max-Planck-Society
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this
  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.
* Neither the name of the copyright holder nor the names of its contributors may
  be used to endorse or promote products derived from this software without
  specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
BSD 3-Clause License

Copyright (c) 2013-2024, Kim Davies and contributors.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---
title: "Staff Answer Guide: Web Scraping Basics"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

## Overview
This guide provides instructors with expected answers, common student challenges, and grading guidance for the "Web Scraping Basics: A Friendly Introduction for Beginners" notebook. The notebook introduces students to web scraping concepts and techniques using Python, BeautifulSoup, requests, and pandas.

## Learning Objectives Assessment

Students should demonstrate the ability to:
1. Understand web scraping concepts and ethical considerations
2. Use requests library to download web page content
3. Parse HTML using BeautifulSoup to extract specific data elements
4. Organize and clean scraped data using pandas
5. Perform basic data analysis on the collected information

## Expected Code Outputs & Solutions

### Section: Downloading a Web Page

**Expected code execution:**
```python
# Define your headers to identify yourself
headers = {
    'User-Agent': 'Mozilla/5.0 (Educational purpose scraper)',
    'Accept': 'text/html,application/xhtml+xml'
}

# URL of the page we want to scrape
url = 'http://books.toscrape.com/'

# Make a request to the website
response = requests.get(url, headers=headers)

# Check if the request was successful
if response.status_code == 200:
    print(f"Successfully downloaded the page! Content length: {len(response.text)} characters")
else:
    print(f"Failed to download the page. Status code: {response.status_code}")

# Let's see what the raw HTML looks like (just the first 500 characters)
print(response.text[:500])
```

**Expected output:** 
- Success message showing content length (varies, typically 50,000+ characters)
- First 500 characters of HTML code from the page

**Grading notes:**
- Students should include proper headers with a user agent
- The request should be made correctly with `requests.get()`
- Response status code should be checked to verify successful download
- Raw HTML preview should be shown for inspection

### Section: Parsing HTML with BeautifulSoup

**Expected code execution:**
```python
# Create a BeautifulSoup object
soup = BeautifulSoup(response.text, 'html.parser')

# Let's check the title of the page
page_title = soup.title.text
print(f"Page title: {page_title}")
```

**Expected output:**
- Page title: "All products | Books to Scrape - Sandbox"

**Grading notes:**
- Students should correctly create a BeautifulSoup object with appropriate parser
- Page title should be extracted using `.title.text`
- Print statement should display formatted output

### Section: Extracting Book Information

**Expected code execution:**
```python
# Find all book containers on the page
book_containers = soup.find_all('article', class_='product_pod')
print(f"Found {len(book_containers)} books on this page")

# Lists to store our data
titles = []
prices = []
ratings = []

# Extract information from each book container
for book in book_containers:
    # Extract title
    title = book.h3.a['title']
    titles.append(title)

    # Extract price
    price = book.find('p', class_='price_color').text
    prices.append(price)

    # Extract star rating (contained in the class name)
    star_rating = book.find('p', class_='star-rating')['class'][1]
    ratings.append(star_rating)

# Display the first 5 items from each list
for i in range(5):
    print(f"Book {i+1}: {titles[i]}, Price: {prices[i]}, Rating: {ratings[i]}")
```

**Expected output:**
- Message showing number of books found (typically 20 on the first page)
- List of 5 books with their titles, prices, and ratings

**Grading notes:**
- Students should correctly select book containers using `find_all()`
- Book properties should be extracted using appropriate BeautifulSoup methods
- All three data points should be stored in separate lists
- The first 5 entries should be displayed properly

### Section: Converting to a DataFrame

**Expected code execution:**
```python
# Create a DataFrame from the scraped data
books_data = {
    'Title': titles,
    'Price': prices,
    'Rating': ratings
}

books_df = pd.DataFrame(books_data)

# Show the DataFrame
books_df
```

**Expected output:**
- A pandas DataFrame with three columns (Title, Price, Rating) and approximately 20 rows

**Grading notes:**
- Data should be correctly organized into a dictionary structure
- DataFrame should be created properly with all three columns
- DataFrame should be displayed (implicit or explicit)

### Section: Cleaning and Processing Data

**Expected code execution:**
```python
# Clean the price column (remove £ symbol and convert to float)
books_df['Price'] = books_df['Price'].str.replace('£', '').astype(float)

# Convert ratings to numeric values
rating_mapping = {
    'One': 1,
    'Two': 2,
    'Three': 3,
    'Four': 4,
    'Five': 5
}
books_df['Rating'] = books_df['Rating'].map(rating_mapping)

# Show the updated DataFrame
books_df
```

**Expected output:**
- An updated DataFrame with:
  - Price column containing numeric values without £ symbol
  - Rating column converted to integers (1-5)

**Grading notes:**
- Price cleaning should use string replacement and type conversion
- Rating conversion should use a mapping dictionary
- Both columns should be properly overwritten in the DataFrame
- Updated DataFrame should be displayed

### Section: Analyzing the Scraped Data

**Expected code execution:**
```python
# Display basic statistics
books_df.describe()

# Calculate average price by rating
avg_price_by_rating = books_df.groupby('Rating')['Price'].mean().sort_index()
print("Average price by rating:")
avg_price_by_rating
```

**Expected output:**
- Statistical summary of the DataFrame columns
- Average price by rating level (grouped and sorted by rating)

**Grading notes:**
- Basic statistics should be displayed using `describe()`
- Groupby operation should be applied correctly
- Results should be sorted by rating index
- Output should be formatted with appropriate label

### Section: Challenge - Scrape Multiple Pages

**Expected code execution:** 
Students will implement their own solution to scrape multiple pages. A correct implementation should:

```python
all_titles = []
all_prices = []
all_ratings = []

# Loop through multiple pages
for page_num in range(1, 4):  # Pages 1, 2, and 3
    # Construct the URL for each page
    if page_num == 1:
        page_url = 'http://books.toscrape.com/'
    else:
        page_url = f'http://books.toscrape.com/catalogue/page-{page_num}.html'

    # Add a small delay to be polite
    time.sleep(1)

    # Make the request
    response = requests.get(page_url, headers=headers)

    # Check if successful
    if response.status_code == 200:
        print(f"Successfully scraped page {page_num}")

        # Parse the page
        soup = BeautifulSoup(response.text, 'html.parser')

        # Find all book containers on the page
        book_containers = soup.find_all('article', class_='product_pod')
        
        # Extract book information
        for book in book_containers:
            # Extract title
            title = book.h3.a['title']
            all_titles.append(title)

            # Extract price
            price = book.find('p', class_='price_color').text
            all_prices.append(price)

            # Extract star rating
            star_rating = book.find('p', class_='star-rating')['class'][1]
            all_ratings.append(star_rating)
    else:
        print(f"Failed to scrape page {page_num}")

# Create a DataFrame with all the collected data
all_books_df = pd.DataFrame({
    'Title': all_titles,
    'Price': all_prices,
    'Rating': all_ratings
})

# Clean the data
all_books_df['Price'] = all_books_df['Price'].str.replace('£', '').astype(float)
all_books_df['Rating'] = all_books_df['Rating'].map(rating_mapping)

# Display the result
print(f"Total books collected: {len(all_books_df)}")
all_books_df.head()
```

**Expected output:**
- Success messages for each page scraped
- DataFrame with approximately 60 books (20 from each page)
- Clean data with proper types

**Grading notes:**
- URL construction should handle the first page differently (base URL vs. pagination)
- Ethical scraping practices should be implemented (delay between requests)
- For loop should iterate through all three pages
- All data should be properly extracted and combined
- Final DataFrame should be created and data should be cleaned

### Section: Saving the Scraped Data

**Expected code execution:**
```python
# Save the DataFrame to a CSV file
books_df.to_csv('scraped_books.csv', index=False)
print("Data saved to 'scraped_books.csv'")
```

**Expected output:**
- Confirmation message that the file was saved

**Grading notes:**
- `.to_csv()` method should be used correctly
- `index=False` should be specified to avoid saving row numbers
- Appropriate filename should be used
- Success message should be displayed

## Common Student Mistakes and Troubleshooting

1. **Connection/HTTP errors**:
   - Problem: Website may block requests or connection issues may occur
   - Solution: Check headers, URL, and internet connection; try alternative sites if needed

2. **HTML structure misinterpretation**:
   - Problem: Students may misunderstand the structure of the HTML and use incorrect selectors
   - Solution: Encourage students to inspect the page source or use browser DevTools to verify selectors

3. **Missing error handling**:
   - Problem: Students often don't include checks for request success or error handling
   - Solution: Emphasize the importance of checking status codes and using try/except blocks

4. **Exceeding rate limits**:
   - Problem: Too many rapid requests without delays
   - Solution: Reinforce the ethical approach with time.sleep() between requests

5. **Incorrect data cleaning**:
   - Problem: Price conversion failures or rating mapping issues
   - Solution: Guide students to check data types and string formatting before conversion

6. **Challenge implementation issues**:
   - Problem: Pagination URLs constructed incorrectly
   - Solution: Provide hint about the different URL structure for page 1 vs. subsequent pages

## Additional Guidance Notes

### Ethical Web Scraping Emphasis

When reviewing student submissions, pay special attention to whether they've implemented ethical scraping practices:
- Appropriate delays between requests
- Proper headers identifying the purpose
- Checking robots.txt (mentioned in the notes)
- Only scraping necessary data

### Extension Ideas for Advanced Students

For students who complete the assignment early or are looking for more challenge:
1. Extract more detailed information (book descriptions, categories, availability)
2. Implement more robust error handling and retry mechanisms
3. Create data visualizations of the scraped information
4. Compare data across different book categories
5. Build a simple command-line interface for the scraper

### Assessment Rubric

| Criterion | Excellent (A) | Satisfactory (B-C) | Needs Improvement (D-F) |
|-----------|---------------|--------------------|-----------------------|
| Code Functionality | All sections work correctly, challenge implemented properly | Minor issues in implementation, challenge attempted | Major functionality issues, challenge not attempted |
| Web Scraping Technique | Correctly uses BeautifulSoup selectors, extracts all data properly | Basic extraction works, but some selectors could be improved | Incorrect selectors, fails to extract required information |
| Data Processing | Clean data transformation, proper handling of types | Basic cleaning implemented with minor issues | Missing or incorrect data cleaning |
| Ethical Practices | Implements all ethical considerations (headers, delays, etc.) | Basic ethical practices with some omissions | No consideration of ethical scraping practices |
| Code Quality | Well-organized, commented, efficient code | Functional code with minor inefficiencies | Poorly structured, inefficient, or uncommented code |

## Website Stability Note

The example website (books.toscrape.com) is a demonstration site designed for scraping practice. However, websites can change their structure or go offline. If students encounter issues with the site, here are some alternatives:
- quotes.toscrape.com (quotes and authors)
- www.scrapethissite.com (designed for practice)
- wikipedia.org (for stable, scrapable content)

## Resource Links for Students

Additional resources to share with students who need more help:
- BeautifulSoup documentation: https://www.crummy.com/software/BeautifulSoup/bs4/doc/
- Web Scraping Ethics Guide: https://towardsdatascience.com/ethics-in-web-scraping-b96b18136f01
- Pandas Data Cleaning Tutorial: https://pandas.pydata.org/pandas-docs/stable/user_guide/text.html
- HTML/CSS Introduction: https://www.w3schools.com/html/
---
title: "Staff Answer Guide: Worksheet 2 - Advanced API Techniques and Authentication"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


This guide provides expected outcomes, common issues, and tips for supporting students as they work through Worksheet 2 on advanced API techniques and authentication with OpenWeatherMap.

## Key Concepts Review

- **HTTP Requests**: Messages sent to servers to retrieve or send data. Students will use the `requests` library to make these directly.
- **JSON**: A standard data format used by most modern APIs that provides structured data.
- **API Keys**: Unique identifiers used to authenticate requests to an API, controlling access and usage limits.
- **Environment Variables**: A secure method for storing sensitive information like API keys.
- **Status Codes**: Numeric codes that indicate the result of an HTTP request (e.g., 200 for success, 404 for not found).

## Activity 1: Direct API Requests to wttr.in

### Expected Code Output Examples

Basic direct request:
```python
import requests

def get_weather_direct(location):
    url = f'https://wttr.in/{location}?format=3'
    response = requests.get(url)
    
    if response.status_code == 200:
        return response.text
    else:
        return f"Failed to fetch data: Status code {response.status_code}"

# Test output for London might look like:
# "London: ⛅️  +15°C"
```

JSON format request:
```python
def get_weather_json(location):
    url = f'https://wttr.in/{location}?format=j1'
    response = requests.get(url)
    
    if response.status_code == 200:
        weather_data = response.json()
        
        if 'current_condition' in weather_data and weather_data['current_condition']:
            current = weather_data['current_condition'][0]
            current_temp = current['temp_C']
            weather_desc = current['weatherDesc'][0]['value']
            humidity = current['humidity']
            
            print(f"Weather in {location}:")
            print(f"Temperature: {current_temp}°C")
            print(f"Conditions: {weather_desc}")
            print(f"Humidity: {humidity}%")
            
            return weather_data
        else:
            print("Weather data has an unexpected format.")
            return None
    else:
        print(f"Failed to fetch data: Status code {response.status_code}")
        return None

# Expected terminal output for Paris:
# Weather in Paris:
# Temperature: 14°C
# Conditions: Partly cloudy
# Humidity: 76%
```

Error checking implementation:
```python
def get_weather_with_error_checking(location):
    url = f'https://wttr.in/{location}?format=j1'
    
    headers = {
        'User-Agent': 'Learning Python Weather App'
    }
    
    try:
        response = requests.get(url, headers=headers, timeout=5)
        
        if response.status_code == 200:
            try:
                weather_data = response.json()
                
                if 'current_condition' in weather_data and weather_data['current_condition']:
                    return weather_data
                else:
                    return "Error: Weather data has an unexpected format."
            except ValueError:
                return "Error: Could not parse JSON response."
        else:
            return f"Error: Failed to fetch data. Status code {response.status_code}"
    except requests.exceptions.RequestException as e:
        return f"Error: Request failed. {str(e)}"

# Expected output for invalid location:
# "Error: Failed to fetch data. Status code 404"
```

### Common Issues
- **Network errors**: Students may encounter connection issues or timeouts.
- **JSON parsing**: Students might struggle with understanding nested JSON structure.
- **HTTP status codes**: Students may be unfamiliar with common status codes and their meanings.
- **Missing User-Agent header**: Some students might not add a User-Agent header, which can lead to rate limiting.

### Support Tips
- Emphasize the importance of checking `response.status_code` before trying to access response data.
- Recommend using `response.json()` for JSON responses instead of manual parsing.
- Suggest adding timeout parameters to prevent hanging on slow connections.
- Encourage exploring the response data structure with `print(json.dumps(data, indent=2))` for better visualization.
- Explain the purpose of headers, especially User-Agent, in making more professional API requests.

## Activity 2: Compare Package vs. Direct Requests

### Sample Performance Comparison Results
```
Time with fetch-my-weather: 0.7823 seconds
Time with direct requests: 0.6145 seconds

Comparison of approaches:
1. fetch-my-weather advantages:
   - Easier to use with simpler function calls
   - Built-in error handling (no exceptions)
   - Includes automatic caching to reduce API calls
   - Provides consistent output format

2. Direct requests advantages:
   - More control over the exact request parameters
   - Access to raw response data
   - Better understanding of the underlying process
   - No additional dependencies beyond requests
```

### Important Discussion Points
- The performance difference might vary depending on network conditions and whether caching is active.
- Trade-offs between ease-of-use (package) and flexibility/control (direct).
- The value of understanding what happens "under the hood," even when using convenience packages.

## Activity 3: Understanding API Authentication

### Key Teaching Points
- API keys should never be hardcoded in source code.
- API keys should never be committed to version control systems like Git.
- Environment variables provide a secure way to store and access sensitive information.
- The `.env` file should always be added to `.gitignore`.

### Sample `.env` File
```
OPENWEATHERMAP_API_KEY=a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
```

### Sample `.gitignore` File
```
# Environment variables
.env
.env.*

# Python
__pycache__/
*.py[cod]
*$py.class
```

## Activity 4: Using OpenWeatherMap API with Authentication

### Expected Implementation

```python
import os
import requests
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Get API key from environment variable
api_key = os.environ.get("OPENWEATHERMAP_API_KEY")

if not api_key:
    print("Error: No API key found. Please set the OPENWEATHERMAP_API_KEY environment variable.")
    exit(1)

def get_weather_openweathermap(city):
    # API endpoint for current weather
    url = f"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric"
    
    try:
        # Make the request
        response = requests.get(url, timeout=5)
        
        # Check if the request was successful
        if response.status_code == 200:
            # Parse the JSON response
            data = response.json()
            
            # Extract relevant weather information
            temp = data['main']['temp']
            weather_desc = data['weather'][0]['description']
            humidity = data['main']['humidity']
            wind_speed = data['wind']['speed']
            
            print(f"Weather in {city}:")
            print(f"Temperature: {temp}°C")
            print(f"Conditions: {weather_desc}")
            print(f"Humidity: {humidity}%")
            print(f"Wind Speed: {wind_speed} m/s")
            
            return data
        else:
            print(f"Failed to fetch data: Status code {response.status_code}")
            if response.status_code == 401:
                print("This might be due to an invalid API key.")
            elif response.status_code == 404:
                print(f"City '{city}' not found.")
            return None
    except requests.exceptions.RequestException as e:
        print(f"Request error: {str(e)}")
        return None

# Sample output for London:
# Weather in London:
# Temperature: 12.5°C
# Conditions: light rain
# Humidity: 82%
# Wind Speed: 4.12 m/s
```

### Common Issues
- **API key setup**: Students may struggle with creating and loading the `.env` file correctly.
- **OpenWeatherMap account creation**: Some students may have difficulties signing up or finding their API key.
- **API rate limits**: Students might hit rate limits if making too many requests.
- **Data structure differences**: OpenWeatherMap's JSON structure differs from wttr.in, causing confusion.

### Support Tips
- Provide step-by-step instructions for signing up for OpenWeatherMap and locating the API key.
- Emphasize the need to install the `python-dotenv` package (`pip install python-dotenv`).
- Help students understand the OpenWeatherMap response structure by printing it with `json.dumps(data, indent=2)`.
- Clarify common status codes they might encounter (401 for authentication issues, 404 for city not found).
- Remind students that free OpenWeatherMap accounts have rate limits (60 calls/minute).

## Extension Activities Guidance

### Extension 1: Weather Forecast with OpenWeatherMap

Key features to look for:
- Using the 5-day forecast endpoint (`/forecast`)
- Organizing forecast data by day or time periods
- Providing meaningful summary of forecast trends

Example implementation outline:
```python
def get_forecast_openweathermap(city):
    # 5-day forecast endpoint (returns forecast in 3-hour increments)
    url = f"https://api.openweathermap.org/data/2.5/forecast?q={city}&appid={api_key}&units=metric"
    
    # Make request and check status
    response = requests.get(url)
    if response.status_code != 200:
        return f"Error: {response.status_code}"
    
    data = response.json()
    
    # Group forecast data by day
    forecasts_by_day = {}
    for forecast in data['list']:
        # Extract date from timestamp (format: "2025-04-14")
        date = forecast['dt_txt'].split(' ')[0]
        
        if date not in forecasts_by_day:
            forecasts_by_day[date] = []
        
        forecasts_by_day[date].append(forecast)
    
    # Display forecast by day
    for date, forecasts in forecasts_by_day.items():
        print(f"\nForecast for {date}:")
        
        # Calculate daily averages
        temps = [f['main']['temp'] for f in forecasts]
        avg_temp = sum(temps) / len(temps)
        
        # Get most common weather condition
        conditions = [f['weather'][0]['description'] for f in forecasts]
        # (Implementation of finding most common condition)
        
        print(f"  Average temperature: {avg_temp:.1f}°C")
        print(f"  Conditions: {most_common_condition}")
```

### Extension 2: Compare Data from Multiple Weather APIs

Implementation considerations:
- Creating a function that calls both APIs for the same location
- Highlighting differences in temperature, conditions, and other data points
- Calculating and displaying the variance between services

Example structure:
```python
def compare_weather_apis(city):
    # Get data from wttr.in
    wttr_data = get_weather_json(city)
    
    # Get data from OpenWeatherMap
    openweather_data = get_weather_openweathermap(city)
    
    if wttr_data and openweather_data:
        # Extract key metrics for comparison
        wttr_temp = float(wttr_data['current_condition'][0]['temp_C'])
        ow_temp = openweather_data['main']['temp']
        
        wttr_cond = wttr_data['current_condition'][0]['weatherDesc'][0]['value']
        ow_cond = openweather_data['weather'][0]['description']
        
        # Compare and display differences
        print(f"\nAPI Comparison for {city}:")
        print(f"Temperature:")
        print(f"  wttr.in: {wttr_temp}°C")
        print(f"  OpenWeatherMap: {ow_temp}°C")
        print(f"  Difference: {abs(wttr_temp - ow_temp):.1f}°C")
        
        print(f"Weather Condition:")
        print(f"  wttr.in: {wttr_cond}")
        print(f"  OpenWeatherMap: {ow_cond}")
```

### Extension 3: Create a Weather Dashboard with Data from OpenWeatherMap

Key elements to include:
- Multi-city data display
- Meaningful organization of weather information
- Visual elements (even simple ASCII art or formatting)
- Interactive components (e.g., user can refresh data)

Example dashboard structure:
```python
def create_openweather_dashboard(cities):
    # Display header
    print("\n" + "="*60)
    print(f"OPENWEATHERMAP DASHBOARD - {datetime.now().strftime('%Y-%m-%d %H:%M')}")
    print("="*60)
    
    # Track temperature extremes
    warmest_city = {"name": "", "temp": -100}
    coldest_city = {"name": "", "temp": 100}
    
    # Get and display data for each city
    for city in cities:
        data = get_weather_openweathermap(city)
        
        if data:
            # Extract and format key information
            temp = data['main']['temp']
            feels_like = data['main']['feels_like']
            humidity = data['main']['humidity']
            wind_speed = data['wind']['speed']
            condition = data['weather'][0]['description']
            
            # Update temperature extremes
            if temp > warmest_city["temp"]:
                warmest_city = {"name": city, "temp": temp}
            if temp < coldest_city["temp"]:
                coldest_city = {"name": city, "temp": temp}
            
            # Display city weather with formatting
            print(f"\n{city.upper()}")
            print(f"  Temperature: {temp}°C (Feels like: {feels_like}°C)")
            print(f"  Conditions: {condition}")
            print(f"  Humidity: {humidity}%")
            print(f"  Wind: {wind_speed} m/s")
    
    # Display temperature extremes
    print("\n" + "-"*60)
    print(f"Warmest city: {warmest_city['name']} ({warmest_city['temp']}°C)")
    print(f"Coldest city: {coldest_city['name']} ({coldest_city['temp']}°C)")
```

## Reflection Questions - Sample Responses

### Challenges of direct API work:
*Sample response:* "Working directly with APIs required more detailed understanding of HTTP requests, response handling, and JSON parsing. Error handling became more complex as I needed to account for network errors, invalid responses, and unexpected data structures."

### Comparison of API data structures:
*Sample response:* "The wttr.in API returns more detailed forecast data by default and has a different JSON structure than OpenWeatherMap. OpenWeatherMap separates current weather and forecast into different endpoints, while wttr.in includes both in a single response. OpenWeatherMap's response structure is somewhat simpler but may require more API calls to get the same information."

### Thoughts on API security practices:
*Sample response:* "Securing API keys is crucial to prevent unauthorized usage that could result in rate limiting, billing charges, or data breaches. Using environment variables and .env files provides a good balance of security and convenience, keeping sensitive information out of the codebase while still making it accessible to the application."

### Advantages of different approaches:
*Sample response:* "The package approach is ideal for beginners or when rapid development is needed, as it abstracts away complexity. The direct API approach provides more flexibility, control, and understanding of what's happening behind the scenes. For production applications, direct API requests with proper error handling and customization would be preferable, while for quick prototypes or educational purposes, a package might be more suitable."

## Additional Teaching Tips

1. **API Documentation Exploration**: Encourage students to read the OpenWeatherMap API documentation to discover additional endpoints and parameters they could use.

2. **Status Code Reference**: Provide a quick reference of common HTTP status codes (200, 400, 401, 403, 404, 429, 500) and what they indicate.

3. **JSON Visualization**: Recommend tools like [JSON Formatter & Validator](https://jsonformatter.curiousconcept.com/) for better visualization of API responses.

4. **API Testing Tools**: Introduce students to API testing tools like Postman or Insomnia for exploring APIs before coding.

5. **Rate Limiting Discussion**: Explain rate limiting concepts and how to implement backoff strategies for handling rate limits.

6. **Error Handling Progression**: Show the progression from basic status code checking to more robust try/except patterns for handling various error scenarios.

7. **Security Considerations**: Discuss real-world implications of API key leaks and show examples of automated bots that scan GitHub for exposed API keys.

8. **Advanced Authentication Methods**: For interested students, introduce the concept of OAuth and other more complex authentication methods used by APIs.
---
title: "Staff Answer Guide: Extracting Web Tables with Pandas"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

## Overview

This guide provides instructors with expected answers, common student challenges, and grading guidance for the notebook "Extracting Web Tables with Pandas: A Simple Introduction." The notebook teaches students how to use pandas to extract and analyze tabular data from websites.

## Learning Objectives Assessment

Students should demonstrate the ability to:
1. Use `pd.read_html()` to extract HTML tables from web pages
2. Process and clean the extracted data appropriately
3. Perform basic data analysis on the extracted tables
4. Export the cleaned data to a CSV file

## Expected Code Outputs & Solutions

### Section: Using pandas.read_html()

**Expected code execution:**
```python
# URL of a Wikipedia page with tables
url = 'https://en.wikipedia.org/wiki/List_of_countries_by_population_(United_Nations)'

# Extract all tables from the web page
tables = pd.read_html(url)

# Check how many tables were found
print(f"Number of tables found on the page: {len(tables)}")
```

**Expected output:** The number of tables will vary based on the current Wikipedia page structure, but typically between 2-4 tables will be found.

**Grading notes:** 
- Students should correctly import pandas and use the `read_html()` function
- The URL should be properly formatted and enclosed in quotes
- They should store the result in a variable and check the number of tables found

### Section: Exploring the Extracted Tables

**Expected code execution:**
```python
# Let's look at the first table (index 0)
first_table = tables[0]

# Show the first few rows
first_table.head()
```

**Expected output:** A DataFrame display showing the first 5 rows of the first table from the Wikipedia page.

**Grading notes:**
- Students should correctly access the first element of the tables list
- They should use the `.head()` method to preview the data

### Section: Selecting the Right Table

**Expected code execution:**
```python
# Loop through all tables and print their shape (rows x columns)
for i, table in enumerate(tables):
    print(f"Table {i}: Shape = {table.shape} (rows × columns)")
    # Optional: display a small preview of each table
    print(f"Preview of columns: {table.columns.tolist()[:3]}...")
    print("-" * 50)
```

**Expected output:** For each table, information about its dimensions and a preview of column names.

**Grading notes:**
- Students should use enumeration to loop through the tables list
- They should correctly print the shape of each table
- Bonus points if they include additional information like column previews

### Section: Cleaning the Data

**Expected code execution:**
```python
# Make a copy to avoid changing the original
df = population_table.copy()

# Convert population to numeric (removing commas and other characters)
population_column = 'Population'  # Column name might vary
if population_column in df.columns:
    df[population_column] = df[population_column].astype(str).str.replace(',', '').str.extract('(\\d+)').astype(float)

# Show the cleaned table
df.head()
```

**Expected output:** A clean DataFrame with the population column converted to numeric values.

**Grading notes:**
- Students should create a copy of the DataFrame before modifying it
- They should correctly identify and clean the population column
- The cleaning should involve removing commas and converting to numeric data type
- They should handle the case where the expected column might not exist

### Section: Analyzing the Data

**Expected code execution:**
```python
# Get basic statistics
df.describe()

# Find the top 10 countries by population
top_10 = df.head(10)
print("Top 10 countries by population:")
top_10
```

**Expected output:** 
1. Statistical summary of the numeric columns
2. A DataFrame showing the top 10 countries by population

**Grading notes:**
- Students should use the `.describe()` method to generate summary statistics
- They should correctly extract the top 10 countries
- Note: If the table was already sorted by population, using `.head(10)` is sufficient; otherwise students should sort the data first

### Section: Saving the Results

**Expected code execution:**
```python
# Save the DataFrame to a CSV file
df.to_csv('country_populations.csv', index=False)
print("Data saved to 'country_populations.csv'")
```

**Expected output:** A confirmation message that the file was saved.

**Grading notes:**
- Students should use the `.to_csv()` method with the correct filename
- They should set `index=False` to avoid saving the DataFrame index
- No actual file will be created in most online notebook environments, so focus on correct syntax

## Challenge Section Assessment

For the challenge to extract a different table, assess:

1. **Table Selection:** Did the student choose an appropriate Wikipedia page with tabular data?
2. **Extraction Code:** Did they correctly implement `pd.read_html()`?
3. **Processing:** Did they identify and select the correct table from those extracted?
4. **Analysis:** Did they perform any meaningful analysis on the extracted data?

## Common Student Mistakes and Troubleshooting

1. **HTTP errors**: Students may encounter connection issues when accessing URLs
   - Suggestion: Verify the URL is accessible and correctly formatted

2. **Incorrect table indexing**: Students may select the wrong table from the extracted list
   - Suggestion: Emphasize the importance of exploring all tables before selecting one

3. **Data type conversion issues**: Problems with cleaning string-formatted numbers
   - Suggestion: Show examples of step-by-step conversion and error handling

4. **Column naming/access issues**: Wikipedia tables may have multi-level column headers
   - Suggestion: Demonstrate how to flatten or rename complex column structures

5. **Empty tables**: Some webpages may block automated scraping
   - Suggestion: Provide alternative URLs that are known to work with `read_html()`

## Additional Guidance Notes

### Ethical Considerations

Remind students about web scraping ethics:
- Check website's terms of service and robots.txt
- Implement reasonable request rates to avoid overloading servers
- Use data responsibly and cite sources

### Advanced Extensions

For students who finish early:
1. Suggest they try extracting tables from non-Wikipedia sources
2. Encourage them to create visualizations of the extracted data
3. Challenge them to automate the extraction of multiple tables from different pages

### Assessment Rubric

| Criterion | Excellent (A) | Satisfactory (B-C) | Needs Improvement (D-F) |
|-----------|---------------|--------------------|-----------------------|
| Table Extraction | Correctly extracts tables and selects appropriate ones | Extracts tables but may select wrong one | Unable to extract tables |
| Data Cleaning | Thoroughly cleans data, handles edge cases | Basic cleaning but misses some issues | Little/no data cleaning |
| Analysis | Performs meaningful analysis with insights | Basic analysis without deeper insights | Minimal or incorrect analysis |
| Code Quality | Well-organized, commented, efficient code | Functional code with minor inefficiencies | Poorly structured code with errors |
| Documentation | Clear explanation of process and findings | Basic documentation of steps | Little/no documentation |

## Support Resources for Students

Recommend these resources for students who need additional help:
- Pandas documentation on `read_html()`: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_html.html
- Data cleaning tutorials with pandas
- Web scraping ethics guidelines
---
title: "Staff Answer Guide: Worksheet 1 - Introduction to APIs with fetch-my-weather"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---



This guide provides expected outcomes, common issues, and tips for supporting students as they work through Worksheet 1 on API basics with the fetch-my-weather package.

## Key Concepts Review

- **API (Application Programming Interface)**: A set of rules allowing different software applications to communicate with each other. In this worksheet, students use a simplified API to access weather data.
- **fetch-my-weather**: A beginner-friendly Python package that wraps around the wttr.in weather service, providing simplified access to weather data.
- **Pseudocode**: A method for planning code logic without worrying about exact syntax, helping students organize their thoughts before implementation.

## Activity 1: Teaching an LLM About fetch-my-weather

### Expected Outcomes
- Students should successfully upload the documentation to an LLM and receive a coherent summary of the package.
- A good LLM response will cover:
  - Main functionality (weather data retrieval)
  - Key features (caching, error handling, different formats)
  - Basic usage examples

### Common Issues
- **Document upload problems**: Some students may have difficulty uploading documents to LLMs, especially if using free tiers with limited upload capabilities.
- **Poorly formulated prompts**: Students might not get useful responses if their prompts are too vague.

### Support Tips
- Encourage students to be specific in their prompts, asking about particular aspects of the package they're confused about.
- If upload isn't working, suggest they copy key parts of the documentation directly into their prompt.
- Remind students that they can iterate on prompts to get more precise information.

## Activity 2: Using the fetch-my-weather Package

### Expected Code Output Examples

Basic weather retrieval:
```python
import fetch_my_weather

# Get weather for London
london_weather = fetch_my_weather.get_weather(location="London")
print(london_weather)

# Expected output: A WeatherResponse Pydantic model containing weather data for London
```

Compact view:
```python
# Get weather with compact view
compact_weather = fetch_my_weather.get_weather(location="Paris", view_options="1")
print(compact_weather)

# Expected output: A more condensed weather report with fewer forecast days
```

Language options:
```python
# Get weather in Spanish
spanish_weather = fetch_my_weather.get_weather(location="Madrid", lang="es")
print(spanish_weather)

# Expected output: Weather data with text elements in Spanish
```

Moon phase:
```python
# Get moon phase information
moon_phase = fetch_my_weather.get_weather(is_moon=True)
print(moon_phase)

# Expected output: Current moon phase information
```

Error handling example:
```python
# Trying invalid location
result = fetch_my_weather.get_weather(location="NonExistentPlace12345")

# Check for error
if isinstance(result, str) and result.startswith("Error:"):
    print(f"Something went wrong: {result}")
else:
    print("Weather data retrieved successfully")

# Expected output: "Something went wrong: Error: [error message]"
```

### Common Issues
- **Installation problems**: Students may encounter pip installation issues, especially if they have Python environment conflicts.
- **String vs object confusion**: Students might be confused by the return type (Pydantic model by default, string if format="text").
- **Error handling misunderstanding**: Students might expect exceptions rather than error strings.

### Support Tips
- For installation issues, check Python version compatibility and suggest using a virtual environment.
- Explain that `get_weather()` returns different types based on the `format` parameter (default is a Pydantic model).
- Emphasize the beginner-friendly error handling that returns strings instead of raising exceptions.
- Encourage students to explore the structure of the returned data using `print()` and `dir()`.

## Activity 3: Create a Weather Dashboard

### Pseudocode Guidance
Good pseudocode should:
- Be clear and concise
- Show the logical flow of the program
- Handle potential errors
- Include necessary loops and conditions

### Working Implementation Example

```python
import fetch_my_weather
from datetime import datetime

def create_weather_dashboard(city_list):
    # Initialize empty list for storing weather data
    city_weather_data = []
    
    # Get weather data for each city
    for city in city_list:
        weather = fetch_my_weather.get_weather(location=city, format="text")
        
        # Check if we got valid weather data
        if isinstance(weather, str) and not weather.startswith("Error:"):
            city_weather_data.append({"city": city, "weather": weather})
        else:
            print(f"Could not get weather for {city}: {weather}")
    
    # Display the dashboard header
    print("\n" + "="*50)
    print(f"WEATHER DASHBOARD - {datetime.now().strftime('%Y-%m-%d %H:%M')}")
    print("="*50)
    
    # Display weather for each city
    for city_data in city_weather_data:
        print(f"\n{city_data['city'].upper()}")
        print(city_data['weather'])
        print("-"*50)

# Get cities from user
def main():
    print("Welcome to the Weather Dashboard!")
    city_input = input("Enter cities to check (comma-separated): ")
    cities = [city.strip() for city in city_input.split(",")]
    
    # Create the dashboard
    create_weather_dashboard(cities)

if __name__ == "__main__":
    main()
```

### Common Issues
- **Format confusion**: Students might mix JSON and text formats, causing display issues.
- **Error handling**: Students may not properly check for error messages.
- **Input validation**: Poor handling of user input (empty strings, special characters).
- **Parsing text output**: If not using `format="text"`, students might struggle to display the weather data nicely.

### Support Tips
- Suggest using `format="text"` for easy display in a simple dashboard.
- Remind students to check if the result is an error message using `isinstance()` and `startswith()`.
- Encourage good input validation (removing extra spaces, handling empty input).
- For advanced students, suggest using JSON format and accessing specific weather properties.

## Extension Activities Guidance

### Enhanced Weather Dashboard

Key features to look for:
- Color coding (using ANSI color codes or a package like `colorama`)
- Comparison functionality to identify warmest/coldest cities
- Interactive elements (user choice of view options)

Example implementation highlights:
```python
# Color coding example
from colorama import Fore, Style

# Function to get color based on temperature
def get_temp_color(temp):
    if temp < 0:
        return Fore.BLUE
    elif temp < 10:
        return Fore.CYAN
    elif temp < 20:
        return Fore.GREEN
    elif temp < 30:
        return Fore.YELLOW
    else:
        return Fore.RED

# Extract temperature and add color
current_temp = int(current['temp_C'])
colored_temp = f"{get_temp_color(current_temp)}{current_temp}°C{Style.RESET_ALL}"
```

### Weather-Based Recommendations

Example implementation approach:
```python
def suggest_activities(weather_data):
    # Extract current conditions
    current = weather_data.current_condition[0]
    temp = float(current.temp_C)
    weather_desc = current.weatherDesc[0].value.lower()
    
    # Outdoor activities
    if temp > 20 and "sun" in weather_desc:
        print("Perfect day for a picnic or hiking!")
    elif "rain" in weather_desc or "shower" in weather_desc:
        print("Indoor day! How about visiting a museum or watching a movie?")
    elif temp < 5:
        print("Very cold today. Stay warm with some indoor activities.")
    # More conditions...
```

## Reflection Questions - Sample Responses

### How did fetch-my-weather make it easier to work with weather data?
*Sample response:* "The fetch-my-weather package simplified access to weather data by handling the complexities of API requests, error handling, and data formatting. It allows beginners to focus on using the data rather than worrying about HTTP requests, status codes, and JSON parsing."

### Value of pseudocode planning:
*Sample response:* "Pseudocode planning helped organize the logical flow of the program before implementation, making the actual coding process smoother. It forced me to think through the necessary steps and potential issues before encountering them in code."

### Learning with LLM assistance:
*Sample response:* "The LLM helped explain complex concepts in simpler terms and provided targeted examples for specific questions. It was particularly helpful in explaining the structure of the returned weather data and suggesting ways to handle different formats."

### Future API interests:
*Sample response:* "After working with weather data, I'm interested in exploring APIs for news, financial data, or social media. I'd also like to learn about APIs that require authentication to access more personalized or restricted data."

## Additional Teaching Tips

1. **Vocabulary Building**: Help students become comfortable with API terminology by consistently using terms like "endpoint," "request," "response," and "parameters."

2. **Visual Explanations**: Use diagrams to show how data flows from the API to their program. A simple flowchart can help visual learners understand the process.

3. **Real-World Connections**: Discuss how APIs are used in mobile apps, websites, and other software students use daily.

4. **Debugging Strategy**: Teach the strategy of printing intermediate results to understand what data is being returned at each step.

5. **Promote Exploration**: Encourage students to experiment with different parameters and locations to see how the output changes.

6. **Error Message Analysis**: Help students understand how to interpret error messages and use them to debug their code.
---
title: "Worksheet 1: Introduction to APIs with fetch-my-weather"
subtitle: Learning API Basics with a Beginner-Friendly Package
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

## Learning Objectives
By the end of this worksheet, you will be able to:
- Understand what APIs are and how they provide access to data
- Use the fetch-my-weather package to retrieve weather information
- Work with an LLM to learn a new Python package
- Create a simple weather dashboard using API data
- Understand the basics of pseudocode and program planning

## Introduction
Web APIs are a foundational element of modern applications, providing a pathway to access data programmatically. In this activity, you'll learn how to fetch and display weather data using a beginner-friendly package called fetch-my-weather.

This first worksheet focuses on the basics of working with APIs through a simplified interface. In a later worksheet, we'll explore more advanced API concepts like authentication and direct API requests.

## Key Concepts
- **API (Application Programming Interface):** A set of rules that allows one piece of software to interact with another.
- **Weather API:** A service that provides weather data through an API.
- **Python Package:** A collection of modules that simplifies certain tasks.
- **LLM (Large Language Model):** AI systems like ChatGPT or Claude that can help explain concepts and assist with coding.

## Using AI Tools Ethically & Effectively
**Transparency:** Always state the use of AI in your work, detailing how and when you used it.

**Critical Evaluation:** AI outputs need to be critically assessed. They are not always correct and may require contextual adjustments.

**Learning Partner:** Utilise AI to deepen your understanding. For instance, you can ask, "Explain the JSON data structure in simple terms" or "Provide an example of how an API might send data."

## Activities

### Activity 1: Teaching an LLM About fetch-my-weather

First, we'll teach an LLM about the package we'll be using, which is a powerful technique for working with new libraries.

**Step 1:** Choose your preferred LLM (Claude, ChatGPT, etc.) and start a new conversation.

**Step 2:** Upload the fetch-my-weather documentation guide to the LLM.

**Step 3:** Ask the LLM to confirm it understands the package by asking it to summarize the key features.

**Example prompt:**
```
I've just shared documentation about the fetch-my-weather package. Could you:
1. Summarize the key features of this package
2. Explain how error handling works in this package
3. Provide a simple example of how to get weather for London
```

### Activity 2: Using the fetch-my-weather Package

Now let's use the package to fetch some weather data!

**Step 1:** Install the fetch-my-weather package.

```python
# Install the package (uncomment and run this once)
# !pip install fetch-my-weather
```

**Step 2:** Get weather for a specific location.

```python
import fetch_my_weather

# Get weather for London
london_weather = fetch_my_weather.get_weather(location="London")
print(london_weather)
```

**Step 3:** Explore different options and parameters.

```python
# Get weather with compact view (fewer forecast days)
compact_weather = fetch_my_weather.get_weather(location="Paris", view_options="1")
print(compact_weather)

# Get weather in a different language
spanish_weather = fetch_my_weather.get_weather(location="Madrid", lang="es")
print(spanish_weather)

# Get moon phase information
moon_phase = fetch_my_weather.get_weather(is_moon=True)
print(moon_phase)
```

**Step 4:** Check for errors without exception handling.

```python
# Try getting weather for an invalid location
result = fetch_my_weather.get_weather(location="NonExistentPlace12345")

# fetch-my-weather returns error messages as strings instead of raising exceptions
if isinstance(result, str) and result.startswith("Error:"):
    print(f"Something went wrong: {result}")
else:
    print("Weather data retrieved successfully")
```

### Activity 3: Create a Weather Dashboard

Let's create a simple weather dashboard for displaying information about multiple cities.

**Step 1:** First, plan your dashboard using pseudocode. Pseudocode is a way to plan your code without worrying about exact syntax.

```
PSEUDOCODE FOR WEATHER DASHBOARD:

FUNCTION CreateWeatherDashboard:
    Initialize empty list called CityWeatherData
    
    FOR EACH city in CityList:
        Request weather data for city
        IF weather data retrieval successful THEN
            Add weather data to CityWeatherData list
        ELSE
            Display error message for this city
        END IF
    END FOR
    
    Display header "WEATHER DASHBOARD"
    Display current date and time
    
    FOR EACH city in CityWeatherData:
        Display city name and weather information
        Add separator line
    END FOR
END FUNCTION

FUNCTION Main:
    Ask user for cities to check
    Call CreateWeatherDashboard
END FUNCTION
```

**Step 2:** Now implement the dashboard based on your pseudocode.

```python
import fetch_my_weather
from datetime import datetime

def create_weather_dashboard(city_list):
    # Initialize empty list for storing weather data
    city_weather_data = []
    
    # Get weather data for each city
    for city in city_list:
        weather = fetch_my_weather.get_weather(location=city, view_options="0")
        
        # Check if we got valid weather data
        if isinstance(weather, str) and not weather.startswith("Error:"):
            city_weather_data.append({"city": city, "weather": weather})
        else:
            print(f"Could not get weather for {city}")
    
    # Display the dashboard header
    print("\n" + "="*50)
    print(f"WEATHER DASHBOARD - {datetime.now().strftime('%Y-%m-%d %H:%M')}")
    print("="*50)
    
    # Display weather for each city
    for city_data in city_weather_data:
        print(f"\n{city_data['city'].upper()}")
        print(city_data['weather'])
        print("-"*50)

# Get cities from user
city_input = input("Enter cities to check (comma-separated): ")
cities = [city.strip() for city in city_input.split(",")]

# Create the dashboard
create_weather_dashboard(cities)
```

## 🧠 Intentional Prompting for Learning

If you're using an LLM to help with this worksheet, here are some tips for getting the most out of it:

### What Is Intentional Prompting?

**Intentional prompting** means you:
- Ask the AI to **explain** its reasoning, not just give solutions
- Ask questions that lead to deeper understanding of concepts
- Refine and adapt prompts when the first response isn't quite right
- Use the AI as a **thinking partner**, not just a code vending machine

### Examples of Good Prompts

**✅ Good prompt:** 
"I'm learning about the fetch-my-weather package. Could you explain how the caching feature works and why it's useful?"

**✅ Good prompt:** 
"I'm creating a weather dashboard using Python and the fetch-my-weather package. Could you help me understand how I might structure the code to display multiple cities and highlight the warmest one?"

### Your turn: Create an intentional prompt

Try writing your own intentional prompt to ask about something in this worksheet that you'd like to understand better.

*Your response:*
```
# Write your intentional prompt here
```

## Extension Activities

### Extension 1: Enhanced Weather Dashboard

Improve your weather dashboard to include more features:
- Add color coding for temperature ranges
- Display which city is warmest/coldest
- Allow the user to choose between different view options

```python
# Write your enhanced dashboard code here
```

### Extension 2: Weather-Based Recommendations

Create a simple program that recommends activities based on the weather:

```python
import fetch_my_weather

def suggest_activities(weather_data):
    # Add your recommendation logic here
    pass

# Get location from user
city = input("Enter your city: ")
weather = fetch_my_weather.get_weather(location=city)

# Get recommendations
suggest_activities(weather)
```

## Reflection
Consider how you might use what you've learned in your future projects:

- How did the fetch-my-weather package make it easier to work with weather data?
- What was the value of planning with pseudocode before writing the actual code?
- If you used an LLM, how did it help you understand the concepts better?
- What other types of APIs might you want to explore in the future?

*Your response:*
```markdown
# Your reflection here
- Experience with fetch-my-weather:
- Value of pseudocode planning:
- Learning with LLM assistance (if applicable):
- Future API interests:
```

This worksheet provides a gentle introduction to working with APIs through a beginner-friendly package. In the next worksheet, we'll explore making direct API requests and using authenticated APIs.
---
title: "Worksheet 2: Advanced API Techniques and Authentication"
subtitle: Direct API Requests and Working with API Keys
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

## Learning Objectives
By the end of this worksheet, you will be able to:
- Make direct HTTP requests to web APIs using the requests library
- Understand and parse JSON data from API responses
- Implement basic error checking for API calls
- Work with authenticated APIs using API keys
- Apply security best practices for handling API credentials

## Introduction
In Worksheet 1, we used the fetch-my-weather package to simplify accessing weather data. Now, we'll go "under the hood" to understand how APIs work directly. We'll also learn how to use APIs that require authentication with API keys, a common requirement for many professional services.

This worksheet builds on the foundational knowledge from Worksheet 1, taking you from using a simplified package to understanding the underlying mechanics of API requests.

## Key Concepts
- **HTTP Request:** A message sent to a server to retrieve or send data.
- **JSON (JavaScript Object Notation):** A standard data format used by most modern APIs.
- **API Key:** A unique identifier used to authenticate requests to an API.
- **Environment Variables:** A secure way to store sensitive information like API keys.
- **Status Codes:** Numeric codes that indicate the result of an HTTP request (e.g., 200 for success, 404 for not found).

## Activities

### Activity 1: Direct API Requests to wttr.in

First, let's see what happens "under the hood" by using the requests library to directly access the wttr.in API that fetch-my-weather is built on.

**Step 1:** Make a direct request to the wttr.in API.

```python
import requests

def get_weather_direct(location):
    # Construct the URL for the wttr.in API
    url = f'https://wttr.in/{location}?format=3'
    
    # Make the request
    response = requests.get(url)
    
    # Check if the request was successful using status code
    if response.status_code == 200:
        # Return the text content of the response
        return response.text
    else:
        return f"Failed to fetch data: Status code {response.status_code}"

# Test the function
city = "London"
weather = get_weather_direct(city)
print(weather)
```

**Step 2:** Access the JSON format for more structured data.

```python
import requests

def get_weather_json(location):
    # Request the weather data in JSON format
    url = f'https://wttr.in/{location}?format=j1'
    
    # Make the request
    response = requests.get(url)
    
    # Check if the request was successful
    if response.status_code == 200:
        # Parse the JSON response
        weather_data = response.json()
        
        # Check if the expected data is present
        if 'current_condition' in weather_data and weather_data['current_condition']:
            # Extract and display key information
            current = weather_data['current_condition'][0]
            current_temp = current['temp_C']
            weather_desc = current['weatherDesc'][0]['value']
            humidity = current['humidity']
            
            print(f"Weather in {location}:")
            print(f"Temperature: {current_temp}°C")
            print(f"Conditions: {weather_desc}")
            print(f"Humidity: {humidity}%")
            
            return weather_data
        else:
            print("Weather data has an unexpected format.")
            return None
    else:
        print(f"Failed to fetch data: Status code {response.status_code}")
        return None

# Test the function
city = "Paris"
weather_data = get_weather_json(city)
```

**Step 3:** Adding basic error checking.

```python
import requests

def get_weather_with_error_checking(location):
    # Construct the URL for the wttr.in API
    url = f'https://wttr.in/{location}?format=j1'
    
    # Add a user agent to be respectful to the API provider
    headers = {
        'User-Agent': 'Learning Python Weather App'
    }
    
    # Make the request with headers
    response = requests.get(url, headers=headers)
    
    # Check if the request was successful using status code
    if response.status_code == 200:
        # Try to parse the JSON response
        try:
            weather_data = response.json()
            
            # Check if the expected data is present
            if 'current_condition' in weather_data and weather_data['current_condition']:
                return weather_data
            else:
                return "Error: Weather data has an unexpected format."
        except ValueError:
            return "Error: Could not parse JSON response."
    else:
        return f"Error: Failed to fetch data. Status code {response.status_code}"

# Test with a valid location
valid_result = get_weather_with_error_checking("Tokyo")
if isinstance(valid_result, dict):
    print("Successfully retrieved weather data for Tokyo")
    
# Test with an invalid location
invalid_result = get_weather_with_error_checking("NonExistentPlace12345")
if isinstance(invalid_result, str) and invalid_result.startswith("Error:"):
    print(invalid_result)
```

::: {.callout-note}
**Looking Ahead:** In future modules, you'll learn about more advanced error handling using Python's try/except blocks. This approach allows for more robust handling of unexpected situations, including network errors, JSON parsing issues, and other exceptions that may occur. For advanced students interested in exploring this concept early, research "Python exception handling" and "try except blocks" to get a head start!
:::

### Activity 2: Compare Package vs. Direct Requests

Now that you've used both a third-party package (fetch-my-weather) and direct API requests, let's compare the two approaches:

```python
import time
import fetch_my_weather
import requests

def measure_performance():
    city = "London"
    
    # Measure time for fetch-my-weather
    start_time = time.time()
    fetch_my_weather.get_weather(location=city)
    package_time = time.time() - start_time
    
    # Measure time for direct request
    start_time = time.time()
    requests.get(f'https://wttr.in/{city}?format=j1')
    direct_request_time = time.time() - start_time
    
    print(f"Time with fetch-my-weather: {package_time:.4f} seconds")
    print(f"Time with direct requests: {direct_request_time:.4f} seconds")
    
    # Analyze the differences
    print("\nComparison of approaches:")
    print("1. fetch-my-weather advantages:")
    print("   - Easier to use with simpler function calls")
    print("   - Built-in error handling (no exceptions)")
    print("   - Includes automatic caching to reduce API calls")
    print("   - Provides consistent output format")
    
    print("\n2. Direct requests advantages:")
    print("   - More control over the exact request parameters")
    print("   - Access to raw response data")
    print("   - Better understanding of the underlying process")
    print("   - No additional dependencies beyond requests")

# Run the comparison
measure_performance()
```

### Activity 3: Understanding API Authentication

Many APIs require authentication to:
1. Identify who is making the request
2. Control access to data
3. Limit the number of requests (rate limiting)
4. Track usage for billing purposes

Let's learn about API keys and how to use them securely.

#### API Keys and Security Best Practices

API keys are sensitive credentials that should be protected:

- **Never hardcode API keys in your source code**
- **Never commit API keys to version control systems like Git**
- **Use environment variables** to store API keys
- Consider using dedicated secrets management tools for production systems

**Example of poor security practice:**
```python
# DON'T DO THIS
api_key = "1234567890abcdef"
response = requests.get(f"https://api.example.com/data?key={api_key}")
```

**Better approach:**
```python
# DO THIS INSTEAD
import os
from dotenv import load_dotenv

# Load API key from .env file (which is NOT committed to Git)
load_dotenv()
api_key = os.environ.get("WEATHER_API_KEY")

response = requests.get(f"https://api.example.com/data?key={api_key}")
```

#### Setting Up a `.env` File
1. Create a file named `.env` in your project directory
2. Add your API keys in the format: `VARIABLE_NAME=value`
3. Add `.env` to your `.gitignore` file to prevent it from being committed

**Example `.env` file:**
```
OPENWEATHERMAP_API_KEY=your_api_key_here
```

**Example `.gitignore` file:**
```
.env
__pycache__/
*.pyc
```

### Activity 4: Using OpenWeatherMap API with Authentication

Now let's apply what we've learned to access the OpenWeatherMap API, which requires an API key.

**Step 1:** Sign up for a free OpenWeatherMap API key:
1. Visit [OpenWeatherMap](https://openweathermap.org/api) and sign up for a free account
2. Retrieve your API key from your account dashboard

**Step 2:** Create a `.env` file to store your API key securely.

**Step 3:** Use the OpenWeatherMap API with your key:

```python
import os
import requests
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Get API key from environment variable
api_key = os.environ.get("OPENWEATHERMAP_API_KEY")

if not api_key:
    print("Error: No API key found. Please set the OPENWEATHERMAP_API_KEY environment variable.")
    exit(1)

def get_weather_openweathermap(city):
    # API endpoint for current weather
    url = f"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric"
    
    # Make the request
    response = requests.get(url)
    
    # Check if the request was successful
    if response.status_code == 200:
        # Parse the JSON response
        data = response.json()
        
        # Check if the expected data is present
        if 'main' in data and 'weather' in data and data['weather']:
            # Extract relevant weather information
            temp = data['main']['temp']
            weather_desc = data['weather'][0]['description']
            humidity = data['main']['humidity']
            wind_speed = data['wind']['speed']
            
            print(f"Weather in {city}:")
            print(f"Temperature: {temp}°C")
            print(f"Conditions: {weather_desc}")
            print(f"Humidity: {humidity}%")
            print(f"Wind Speed: {wind_speed} m/s")
            
            return data
        else:
            print("Weather data has an unexpected format.")
            return None
    else:
        print(f"Failed to fetch data: Status code {response.status_code}")
        if response.status_code == 401:
            print("This might be due to an invalid API key.")
        elif response.status_code == 404:
            print(f"City '{city}' not found.")
        return None

# Get city from user
city = input("Enter a city name: ")
weather_data = get_weather_openweathermap(city)
```

**Step 4:** Explore the API documentation to find other endpoints and parameters:
1. Look at the [OpenWeatherMap API documentation](https://openweathermap.org/api)
2. Find at least one other endpoint or parameter you can add to your request
3. Modify your code to use this new feature

## Extension Activities

### Extension 1: Weather Forecast with OpenWeatherMap

Extend your code to fetch a 5-day forecast instead of just the current weather.

```python
# Write your forecast code here using the OpenWeatherMap forecast endpoint
```

### Extension 2: Compare Data from Multiple Weather APIs

Create a script that compares weather data from both wttr.in and OpenWeatherMap for the same location.

```python
# Write your comparison code here
```

### Extension 3: Create a Weather Dashboard with Data from OpenWeatherMap

Build a more detailed weather dashboard that uses data from OpenWeatherMap.

```python
# Write your dashboard code here
```

## Reflection
Consider how the direct API approach differs from using a package:

- What challenges did you encounter when working directly with APIs?
- How does the OpenWeatherMap API differ from wttr.in in terms of data structure?
- Why is it important to secure API keys, and what methods did you learn to do this?
- What advantages does each approach (package vs. direct) offer for different situations?

*Your response:*
```markdown
# Your reflection here
- Challenges of direct API work:
- Comparison of API data structures:
- Thoughts on API security practices:
- Advantages of different approaches:
```

This worksheet has introduced you to more advanced API concepts, including direct requests and authentication. These skills form the foundation for working with a wide range of APIs in your future projects.
---
title: "Mastering Error Handling in Network Requests"
subtitle: "Ensuring Robust Applications through Effective Error Management"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to Error Handling

* Understanding the importance of error handling in network requests
* Common types of errors encountered during network communication
* The impact of unhandled errors on applications

::: {.notes}
In this presentation, we will explore the fundamental concepts of error handling in network requests. Error handling is crucial for building robust applications that can gracefully manage unexpected issues during network communication, such as timeouts or loss of connectivity. We'll look at common types of errors and discuss the negative impacts of unhandled errors, which can range from minor user frustration to complete application failure. This knowledge is essential for ensuring application reliability and a smooth user experience.
:::

# Types of Network Errors

* Timeout errors
* Connection errors
* HTTP status codes (400 and 500 series errors)
* DNS lookup failures

::: {.notes}
There are several types of network errors that can occur when your application tries to communicate over the internet. Timeout errors happen when a request takes too long to get a response. Connection errors may occur if the network is down or unstable. HTTP errors are represented by status codes; for example, 404 for 'Not Found' or 500 for 'Internal Server Error'. DNS lookup failures take place when the domain name cannot be resolved to an IP address. Understanding these errors is the first step in handling them effectively.
:::

# Basic Principles of Error Handling

* Preventing errors before they occur
* Catching and managing errors when they occur
* Logging errors for further analysis
* Informing users appropriately

::: {.notes}
Effective error handling involves several key principles. Firstly, prevent errors where possible by using validations and checks before making a request. If an error does occur, catch it programmatically to prevent the application from crashing and manage the error gracefully. Logging errors is crucial for diagnosing issues and improving the system. Finally, ensure that users are informed with clear, concise, and helpful messages about what went wrong and possibly how to resolve it or that it is being handled.
:::

# Implementing Error Handling in Python

* Using try-except blocks
* Handling specific exceptions
* Creating custom exceptions for better control
* Utilising libraries like Requests for simplified error management

```python
import requests
try:
    response = requests.get('https://api.example.com/data')
    response.raise_for_status()
except requests.exceptions.HTTPError as errh:
    print(f'HTTP Error: {errh}')
except requests.exceptions.ConnectionError as errc:
    print(f'Connection Error: {errc}')
except requests.exceptions.Timeout as errt:
    print(f'Timeout Error: {errt}')
except requests.exceptions.RequestException as err:
    print(f'Error: {err}')
```

::: {.notes}
In Python, error handling is typically managed using try-except blocks. This allows you to catch specific exceptions and handle them accordingly. For example, using the Requests library, you can manage different types of errors such as HTTP errors, connection problems, or timeouts. This code example demonstrates how to handle these errors separately to provide more targeted responses. Creating custom exceptions can also provide further control and clarity in your error management strategy.
:::

# Best Practices in Error Reporting

* Keep error messages informative but non-technical
* Use logging to capture detailed error information
* Provide users with guidance on next steps if applicable

::: {.notes}
When an error occurs, how it is reported can significantly affect the user experience. It is important to keep error messages clear and helpful without exposing technical details that could confuse the user or expose security vulnerabilities. Logging should be used to capture detailed error information which helps in debugging and improving the application. Where possible, provide users with guidance or actions they can take to recover from the error.
:::

# Handling Errors in Web Applications

* Server-side vs client-side error handling
* Implementing retries and fallbacks
* Designing for fault tolerance

::: {.notes}
In web applications, error handling should be considered both on the server-side and the client-side. On the server-side, you might implement retries or use fallback servers. On the client-side, you can design the user interface to be fault-tolerant, possibly showing cached data if new data can't be retrieved. Implementing these strategies ensures that your application can handle errors gracefully and maintain a good user experience even under suboptimal conditions.
:::

# Workshop: Simulating and Handling Errors

* Step-by-step guide to simulating common network errors
* Applying learned strategies to handle these errors
* Interactive discussion on error handling techniques

::: {.notes}
During our workshop, we will simulate common network errors and apply the error handling strategies we've discussed. This hands-on approach helps in understanding how to implement these techniques in real-world scenarios. Participants will also have the opportunity to discuss and share their approaches to error handling, fostering a deeper understanding of best practices and innovative strategies.
:::

# Conclusion and Further Resources

* Recap of key points on error handling
* Importance of continuous learning and improvement in error management
* Additional resources for deeper learning

::: {.notes}
In conclusion, effective error handling is essential for developing robust applications. We've covered the types of errors you might encounter, basic principles for managing these errors, and specific techniques using Python. Remember, the landscape of network communication is ever-evolving, and continuous learning is key to staying ahead. For further reading, refer to the Python Requests Library Documentation and other resources provided in this course.
:::---
title: "Navigating JSON in Python: A Beginner's Guide"
subtitle: "Understanding and Utilising JSON for Web Data in Python"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


# Introduction to JSON and Python

* What is JSON and why is it important?
* Basics of JSON structure: Objects and Arrays
* How Python interacts with JSON

::: {.notes}
JSON, which stands for JavaScript Object Notation, is a lightweight data-interchange format that is easy for humans to read and write, and easy for machines to parse and generate. It is commonly used to transmit data between a server and web applications. Python provides built-in libraries for parsing JSON, allowing developers to easily manipulate data, which is crucial for tasks such as data analysis, web scraping, and API interactions. This slide introduces the fundamental aspects of JSON and its significance in web development and data exchange.
:::

# JSON Syntax Overview

* JSON Objects: Key-value pairs enclosed by curly braces
* JSON Arrays: Ordered list of values enclosed by square brackets
* Data types in JSON: string, number, object, array, boolean, null

::: {.notes}
JSON syntax closely resembles the way objects are built in JavaScript. However, it is language-independent and can be used with many programming languages, including Python. Understanding the syntax is the first step to mastering JSON usage in Python. This slide explains the different components of JSON, such as objects and arrays, and the types of data that JSON can hold. This foundational knowledge will help in parsing and generating JSON data effectively.
:::

# Working with JSON in Python

* Using the `json` module
* Reading JSON data with `json.load()` and `json.loads()`
* Writing JSON data with `json.dump()` and `json.dumps()`

::: {.notes}
Python's `json` module is a part of the standard library and provides a simple way to encode and decode JSON data. Specifically, `json.loads()` parses JSON from a string format, while `json.load()` parses JSON from a file. Conversely, `json.dumps()` converts Python objects into a JSON string, and `json.dump()` writes Python objects to a file in JSON format. This slide provides practical code examples to demonstrate how to use these functions, which will be critical for any tasks involving JSON data manipulation.
:::

# Practical Example: Parsing JSON from a Web API

* Fetching JSON data from an API using the `requests` library
* Parsing JSON data to Python objects
* Example: Accessing weather data from an online API

::: {.notes}
This slide shows a practical example of how to use Python to fetch and parse JSON data from a web API—an essential skill in many development tasks, especially in web and mobile applications. We use the `requests` library to send a request to a web API, which returns data in JSON format that we then parse into Python objects using the `json` module. This example will focus on fetching real-time weather data, aligning with our course project.
:::

# Handling JSON Data in Python Applications

* Common use cases: Config files, data storage, API interaction
* Tips for working efficiently with JSON in Python
* Security considerations when handling JSON data

::: {.notes}
JSON is widely used in various applications, from serving as configuration files in software applications to storing data in databases and interacting with web APIs. This slide discusses how to handle JSON data efficiently in Python, including best practices and security considerations, such as validating and sanitising JSON data to prevent security vulnerabilities like injection attacks.
:::

# Error Handling and Debugging

* Common JSON parsing errors in Python
* Using try-except blocks for robust error handling
* Debugging tips for working with JSON data

::: {.notes}
Error handling is crucial when working with external data formats like JSON. This slide covers common errors such as misformatted JSON strings and how to use Python's try-except blocks to handle these errors gracefully, ensuring the application remains robust and user-friendly. We'll also provide some debugging tips that can help beginners troubleshoot issues when working with JSON data.
:::

# Best Practices and Performance Tips

* Efficient parsing of large JSON files
* When to use `json.load()` vs. `json.loads()`
* Performance considerations: Memory usage and speed

::: {.notes}
As developers often deal with large volumes of data, understanding how to parse large JSON files efficiently is important. This slide provides best practices and performance tips, including choosing the right function for the task, considerations for memory usage, and techniques to enhance the speed of reading and writing JSON data. These tips are crucial for optimising performance in real-world Python applications.
:::

# Conclusion: Mastering JSON in Python

* Recap of key points: JSON structure, parsing, error handling
* Further learning resources and next steps
* Encouragement to explore and experiment with JSON in Python projects

::: {.notes}
In conclusion, we've covered the essential aspects of working with JSON in Python, from basic syntax and parsing methods to error handling and performance optimisation. Encouraging further exploration and experimentation, attendees are reminded to utilise the resources provided and to engage with the community for continued learning. This understanding is not only vital for personal development but also for contributing effectively to any future projects involving web data.
:::

# Questions and Discussion

* Open floor for questions
* Discussion on potential project ideas involving JSON
* Feedback on the presentation

::: {.notes}
This final slide provides an opportunity for interaction and feedback. It allows attendees to ask questions to clarify any doubts and discuss potential project ideas that involve using JSON. This interaction is crucial for reinforcing learning and encouraging practical application of the concepts covered in the presentation.
:::---
title: "Unlocking the Digital Universe: APIs and Web Scraping"
subtitle: "A Beginner's Guide to Accessing Online Data Efficiently"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


# Introduction to APIs and Web Scraping

* Understanding APIs and Web Scraping
* Importance in digital data retrieval
* Overview of today's session

::: {.notes}
Welcome to your introduction to APIs and Web Scraping! Today, we will explore how these tools allow us to harness vast amounts of data from the internet efficiently. APIs (Application Programming Interfaces) and web scraping are fundamental for anyone looking to retrieve, analyse, and use web data effectively. This session will cover the basics, setting the stage for more advanced topics.
:::

# What is an API?

* Definition: A set of rules that allows programs to communicate with each other
* Examples: Social media APIs, weather data APIs
* Uses: Data retrieval, automation, integration

::: {.notes}
An API, or Application Programming Interface, acts like a bridge between different software applications, allowing them to interact without user intervention. For instance, when you use a weather app, it retrieves data from a weather API to provide you with real-time updates. APIs are ubiquitous in software development, enabling functionalities such as pulling live data into applications or automating tasks.
:::

# Introduction to Web Scraping

* Definition: Extracting data from websites
* Tools: Python libraries like BeautifulSoup, Scrapy
* Legal and ethical considerations

::: {.notes}
Web scraping involves programmatically gathering data from the internet, specifically from web pages. Tools like BeautifulSoup and Scrapy in Python make this process accessible even for beginners. However, it's crucial to consider legal and ethical implications, such as respecting copyright and terms of service of websites, to avoid potential legal issues.
:::

# How APIs Work

* Sending requests from your application
* Receiving responses in formats like JSON, XML
* Common protocols: REST, SOAP

::: {.notes}
APIs work by processing requests and sending back responses. When you request data, such as the latest weather updates, the weather API processes this request and sends back data, often in JSON or XML format. Most modern APIs use the REST protocol due to its simplicity and effectiveness over the web.
:::

# Basic Web Scraping Example

* Python code to scrape data
* Simple example using BeautifulSoup

```python
from bs4 import BeautifulSoup
import requests

url = 'http://example.com/'
response = requests.get(url)
soup = BeautifulSoup(response.text, 'html.parser')

print(soup.find('h1').text)
```

::: {.notes}
Here's a basic example of web scraping using Python. We use the BeautifulSoup library to parse HTML data. After sending a request to the website, we receive HTML content, which BeautifulSoup helps us navigate to extract specific pieces like headings, paragraphs, etc. This example simply prints the text inside the first heading tag (`<h1>`) of the webpage.
:::

# Comparing APIs and Web Scraping

* When to use each method
* Advantages and limitations
* Ethical considerations

::: {.notes}
Choosing between APIs and web scraping depends on your needs and the availability of data. APIs are preferred when available, as they are more stable and efficient. Web scraping is a good alternative when no API is available but requires careful handling to ensure it does not violate terms of service or copyright laws.
:::

# Practical Applications

* Real-time data integration in apps
* Automating repetitive tasks
* Enhancing data-driven decision making

::: {.notes}
Both APIs and web scraping have practical applications in various fields. For example, integrating real-time weather data into a travel app enhances user experience by providing current conditions. They also automate repetitive tasks, such as daily reports of stock prices, freeing up time for more complex analyses.
:::

# Conclusion

* Recap of key points
* Encouragement to explore further
* Resources for deeper learning

::: {.notes}
Today, we've covered the basics of APIs and web scraping, essential tools for modern data retrieval and application integration. I encourage you to explore these technologies further. Delve into the provided resources and experiment with building small projects to grasp their power and potential fully.
:::

# Further Resources

* [Python Requests Library Documentation](https://requests.readthedocs.io/en/latest/)
* [JSON Data in Python: A Practical Introduction](https://realpython.com/python-json/)
* [Understanding APIs for Beginners](https://www.smashingmagazine.com/2018/01/understanding-using-rest-api/)

::: {.notes}
For those eager to learn more, these resources are excellent starting points. They provide in-depth tutorials and explanations that can help reinforce today’s topics and expand your understanding and skills in working with APIs and web scraping.
:::---
title: "Securing API Access: A Beginner's Guide"
subtitle: "Understanding Authentication Mechanisms for Web APIs"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


# Introduction to API Security

* Importance of securing APIs
* Overview of authentication and authorisation
* What you'll learn in this presentation

::: {.notes}
Welcome to our session on securing API access! As APIs become a critical part of web and mobile applications, ensuring that these interfaces are secure is paramount. This presentation will explore the fundamental concepts of authentication and authorisation, focusing on how they help protect data and systems from unauthorised access. By the end, you'll understand the various mechanisms available to secure API access and why they are critical in today's digital landscape.
:::

# What is an API?

* Definition of API (Application Programming Interface)
* Role of APIs in modern software
* Examples of API usage

::: {.notes}
API stands for Application Programming Interface, a set of rules that allows different software entities to communicate with each other. APIs play a crucial role in modern software development by enabling applications to interact seamlessly, whether retrieving data from a server or sending data to be processed. Common examples include pulling real-time data from weather services or integrating with social media platforms to post updates directly from an app.
:::

# Why Secure an API?

* Protect sensitive data
* Ensure data integrity
* Prevent unauthorised access

::: {.notes}
Securing an API is essential for several reasons. Primarily, it helps protect sensitive data from being exposed to unauthorised users. Furthermore, security measures ensure the integrity of the data being exchanged, preventing malicious actors from altering it. Lastly, robust security prevents unauthorised access, ensuring that only legitimate users can interact with the API, thus maintaining the overall system's reliability and trustworthiness.
:::

# Basic Authentication

* Simplest form of API authentication
* Utilises a username and password
* Suitable for less critical data

::: {.notes}
Basic Authentication is the simplest form of securing an API. It works by sending a username and password with each API request, usually encoded in Base64. While this method is easy to implement, it is less secure compared to other methods and is generally recommended for scenarios where security demands are lower, such as accessing non-sensitive data.
:::

# Token-Based Authentication

* More secure than basic authentication
* Uses access tokens
* Example: OAuth 2.0

::: {.notes}
Token-based authentication is a more secure alternative to basic authentication. In this method, the user first logs in using their credentials to receive a token. This token is then used for subsequent requests to the API. OAuth 2.0 is a popular framework that utilises tokens, providing robust security for accessing resources. This method is widely used due to its scalability and security features, especially in applications that require handling sensitive data.
:::

# API Keys

* Simple way to control access
* Unique to each user or application
* Limitations: potential for leakage

::: {.notes}
API keys are another common method for authenticating API requests. Each key is unique to a user or application and is included in the request to authenticate the user. While API keys are simple to use and implement, they must be kept secure. If an API key is leaked, it can provide an attacker access to the API, potentially leading to data breaches.
:::

# Best Practices for API Security

* Use HTTPS for secure communication
* Regularly rotate and manage credentials
* Implement rate limiting to prevent abuse

::: {.notes}
To enhance API security, it is crucial to follow best practices. Always use HTTPS to encrypt data transmitted between the client and the server, ensuring that sensitive information is protected from interceptors. Regularly rotating and managing credentials, such as passwords and API keys, helps mitigate the risk of unauthorised access. Additionally, implementing rate limiting on your API can prevent abuse and help manage the load on your infrastructure.
:::

# Conclusion

* Importance of robust API security
* Review of authentication methods
* Encouragement to implement best practices

::: {.notes}
We've covered the critical aspects of API security and discussed various authentication methods to protect your data and systems. Remember, implementing robust security measures is not just a technical requirement but a crucial element in maintaining trust and reliability in your applications. I encourage you to use these practices to ensure your APIs are secure and efficient.
:::

# Further Resources

* [Python Requests Library Documentation](https://requests.readthedocs.io/en/latest/)
* [Understanding APIs for Beginners](https://www.smashingmagazine.com/2018/01/understanding-using-rest-api/)
* [OAuth 2.0 Authorization Framework](https://oauth.net/2/)

::: {.notes}
For those interested in diving deeper into API security or needing specific guidance on implementing these concepts in Python, these resources will be invaluable. They provide detailed documentation and tutorials that can help you better understand and implement secure API strategies in your projects.
:::---
title: "Mastering Debugging: Human Insight, AI Assistance"
subtitle: "Navigating Complex Code with Confidence in the AI Era"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


# Introduction

* Debugging in the Age of AI
* Understanding the importance of debugging
* Overview of advanced debugging techniques

::: {.notes}

Welcome! Debugging is an essential skill for every developer – it's the art of being a code detective. In this session, we'll explore advanced debugging techniques. But more importantly, we'll discuss how your human intuition and analytical skills, when combined with the capabilities of modern AI tools, can make you exceptionally effective at pinpointing and resolving even the most complex software issues. We're moving beyond basic fixes to understand root causes, with AI as a powerful investigative partner.
:::



# What is Debugging in the Age of AI?**

* **Core Definition:** Still the process of identifying, analysing, and resolving defects in software.
* **New Challenges & Opportunities:**
    * AI can generate code (and bugs!) rapidly.
    * AI can suggest fixes, but are they superficial or foundational?
* **Human's Role is Elevated:** From just fixing to *deeply understanding* why bugs occur and ensuring robust solutions, even when AI assists.
* **Basic vs. Advanced Debugging (AI Context):**
    * Basic: Quick fixes, perhaps AI-suggested, for obvious errors.
    * Advanced: Systematic investigation of complex issues, using tools and critical thinking, with AI providing targeted support (e.g., explaining complex tracebacks, suggesting hypotheses).

::: {.notes}
Debugging is still about finding and fixing bugs. However, the landscape is changing with AI.
* AI can generate vast amounts of code, which means more potential for bugs, but also more opportunities for AI to *help find* them.
* AI tools can often propose quick fixes. The challenge for you, the developer, is to determine if an AI's suggestion truly solves the root problem or just patches a symptom.
* This elevates your role. It's not just about making the error message go away; it's about deep understanding. Advanced debugging, therefore, involves a systematic, human-led investigation where AI acts as a knowledgeable assistant, perhaps explaining an obscure error message or helping you understand a complex piece of code before you even start the debugger.
:::



# Key Advanced Debugging Techniques

* **Strategic `print()` Statements & Logging:** Still your first line of detailed inquiry.
    * *AI Assist:* "Based on this error and code, where would `print()` statements be most effective for tracing variable `x`?"
* **Breakpoints & Stepping Through Code (Debuggers):** Pause execution, inspect state, understand flow line-by-line.
    * *AI Assist:* "At this breakpoint, variable `foo` is `None`. What are common reasons for this in such a function?" or "Explain this section of the call stack."
* **Conditional Breakpoints:** Pause only when specific conditions are met (e.g., `loop_counter > 1000`).
    * *AI Assist:* "Help me formulate a condition for a breakpoint that triggers if this list ever becomes empty."
* **Watch Expressions & Call Stack Navigation:** Track specific variables; understand the path to the current error.
    * *AI Assist:* "Explain the role of function `bar()` in this call stack leading to the error."
* **Code Profiling & Performance Analysis:** Identify bottlenecks or excessive resource usage that might indicate or cause bugs.
    * *AI Assist:* "This function is unexpectedly slow. What are common performance pitfalls I should look for using a profiler?"

::: {.notes}
Let's look at some powerful techniques. Remember, AI doesn't replace these; it can make you more effective when using them.
* **Strategic `print()`/Logging:** Before even launching a full debugger, targeted print statements can give you quick insights. You can even ask AI where the most informative print statements might go.
* **Debuggers (Breakpoints & Stepping):** This is where you truly become a code detective, stopping time to examine the crime scene. Set a breakpoint, run your code, and when it pauses, inspect variable values. Step through line by line. If you see a variable with an unexpected value at a breakpoint, you can ask an AI to brainstorm reasons why that might happen in that specific code context. Or, if the call stack (the list of functions that led to this point) is confusing, AI can help explain it.
* **Conditional Breakpoints:** Super useful for bugs that only appear after many iterations or under specific circumstances. AI can help you think through the logic for these conditions.
* **Watch Expressions & Call Stack:** Modern debuggers let you 'watch' specific variables or expressions as they change. Understanding the call stack is vital, and AI can help decipher complex ones.
* **Profilers:** Sometimes bugs aren't just errors but performance issues that break functionality (e.g., a timeout). Profilers help find slow code. AI can suggest what to look for.
Your human insight guides where to look; AI can help interpret what you find or suggest avenues for investigation.
:::



# Tools for Advanced Debugging (AI Integration)**

* **Integrated Development Environments (IDEs):** PyCharm, VS Code, etc., offer powerful built-in debuggers.
    * Features: Breakpoint management, variable inspection, step controls, call stack view.
* **AI-Integrated IDEs/Tools:**
    * **Inline Code Explanation/Suggestions:** AI like GitHub Copilot can explain selected code or suggest fixes *within* your editor.
    * **AI-Powered Error Analysis:** Tools that analyse tracebacks and offer more sophisticated explanations or troubleshooting steps.
    * **AI Chat for Debugging:** Dedicated AI chat interfaces where you can paste code/errors and ask for debugging help.
* **Choosing the Right Combination:** Leverage your IDE's debugger for control, and AI tools for insights and suggestions.

::: {.notes}

Your IDE (like PyCharm, VS Code, Spyder, etc.) is your primary debugging command center, with its built-in debugger offering fine-grained control.
* **AI Integration is Key:** Many IDEs are now integrating AI directly. GitHub Copilot, for example, can explain code snippets or even suggest fixes as you type. Other tools might offer more detailed AI analysis of error messages. You might use an AI chat interface side-by-side with your debugger, feeding it information from your debugging session to get hypotheses or explanations. The goal is to use these tools in concert: the IDE debugger for control and detailed inspection, and AI for accelerating understanding and idea generation.
:::



# A Case Study (AI-Assisted Workflow)**

* **Scenario:** (Use a slightly more complex but still understandable example than just `a+b` vs `a*b`. Perhaps a list processing error, an off-by-one, or a simple state-related bug).

* **Step-by-Step (Illustrative):**
    1. **The Bug Appears:** Program produces unexpected output or crashes with a traceback.
    2. **Initial Human Analysis:** Read error. Form initial thoughts.
    3. **AI for Error Explanation:** "Explain this `IndexError` and traceback in the context of my list processing function `[code snippet]`."
    4. **Strategic `print()`/Logging (Human + AI):** "Where should I add prints to see the list's state before the error?"
    5. **Debugger Time (Human Control):** Set breakpoints based on insights. Step through.
    6. **AI for Hypothesis at Breakpoint:** "At this breakpoint, `my_list` is `[1,2]` but I expected `[1,2,3]`. What could have removed an element before this line in my function `[code snippet]`?"
    7. **AI for Solution Brainstorming:** "I think the bug is related to `[specific line/logic]`. Can you suggest ways to fix this potential off-by-one error?"
    8. **Human Implements & Verifies:** Critically review AI's idea, implement a fix, and *test thoroughly* (ideally with pre-existing unit tests, or write a new one).
* **Lessons:** AI speeds up understanding and idea generation, but human controls the process and validates the outcome.

::: {.notes}

Let's walk through a hypothetical debugging session. Imagine a function that's supposed to process a list of items but sometimes misses the last item or throws an error.
1.  You run it, and it either crashes or gives the wrong result.
2.  You look at the error (if any) or the incorrect output.
3.  You could paste the error and relevant code into an AI and ask for an explanation of what the error *means* generally, or what it might mean in *your specific code*.
4.  Based on this, or your own intuition, you add `print` statements. Or ask AI, "Where are good places to print the list and loop index to understand what's happening?"
5.  The prints narrow it down, so you fire up the debugger, setting a breakpoint just before the suspected problematic line.
6.  You step through. At a breakpoint, you see the state isn't what you expect. You could describe this state and the code to an AI and ask for potential reasons *why* it's in that state.
7.  Once you have a strong hypothesis (e.g., "I think my loop condition is wrong"), you can ask AI to suggest fixes for *that specific kind of problem*.
8.  Crucially, you evaluate AI's suggestions. Does it make sense? Does it address the root cause? You implement the fix, and then you *test it thoroughly*, ideally with unit tests we discussed in Module 1. This AI-assisted workflow allows you to combine your analytical skills with AI's rapid information processing and pattern matching.
:::



# Debugging Best Practices (for the AI Era)**

* **Systematic Approach:** Don't just guess. Form hypotheses (use AI to help brainstorm), test them (with `print`, debugger, or by asking AI to evaluate a hypothesis against the code), and iterate.
* **Understand, Don't Just Swap Code:** If AI suggests a fix, understand *why* it works before applying it.
* **Reproduce the Bug Consistently:** Before fixing, know how to make it happen reliably.
    * *AI Assist:* "Help me identify the conditions or inputs that might be causing this intermittent bug."
* **Keep a Log (Physical or Digital):** Note what you've tried, your theories, AI prompts, and AI's useful (or not useful) responses. This prevents going in circles.
* **Write a Test for the Bug:** Once found and fixed, write a test case that *would have caught this bug*. This prevents regressions.
    * *AI Assist:* "I fixed this bug `[describe bug and fix]`. Help me write a `pytest` test case that specifically targets this scenario."
* **Regular Code Reviews (Human + AI?):** Humans discuss logic. AI can spot potential issues or suggest areas for clarification.

::: {.notes}

Effective debugging relies on good habits:
* **Systematic Approach:** Avoid randomly changing code. Develop a theory about the bug, then test that theory. AI can help you develop theories by explaining parts of the code or suggesting potential causes for an observed behavior.
* **Understand the Fix:** If an AI gives you a code snippet that fixes the bug, don't just paste it in. Figure out *why* it's the correct solution. This is how you learn.
* **Reproduce Consistently:** It's hard to fix a bug you can't reliably trigger. AI might help you brainstorm conditions or inputs that lead to an intermittent bug.
* **Keep a Log:** Debugging complex issues can take time. Jot down what you've tried, what you observed, and even key AI interactions.
* **Test for the Bug:** This is crucial. Once you've fixed a bug, add a test that specifically covers that scenario. AI can be very helpful here: "I found a bug where X happened. I fixed it by doing Y. Can you help me write a unit test that would have failed before my fix and passes now?"
* **Code Reviews:** Having another human look at your code is invaluable. AI tools are also emerging that can provide automated code review feedback, spotting potential issues or areas for improvement.
:::



# Common Pitfalls in Debugging (AI Edition)**

* **Fixing Symptoms, Not Root Causes:**
    * *AI Risk:* AI might suggest a narrow fix that handles a specific case but misses the underlying systemic issue. Human critical thinking is needed to ask "why?" repeatedly.
* **Overlooking Simple Solutions:** Sometimes it *is* just a typo! Don't jump to complex AI queries immediately.
* **Not Replicating the Environment:** Bug appears in production but not locally. (AI less helpful here, more about environment setup).
* **Misinterpreting AI Suggestions:** Applying AI advice without fully understanding its implications for your specific codebase.
* **"Black Box" AI Fixes:** Accepting an AI fix that works but you don't understand. This creates unmaintainable code.
* **Ignoring Version Control:** Not using branches for debugging attempts; makes it hard to revert changes (AI or human-made).

::: {.notes}

Even with AI, pitfalls await:
* **Symptom vs. Root Cause:** This is a big one with AI. An AI might see an error and suggest a way to prevent *that specific error instance* (e.g., adding a null check) without addressing *why* the value is null in the first place. Your job is to dig deeper for the root cause.
* **Overlooking the Obvious:** Before crafting a complex AI prompt, double-check for simple typos or basic logical errors yourself!
* **Environment Mismatches:** A classic. AI can't easily solve this; it requires careful comparison of environments.
* **Misinterpreting AI:** AI communicates in language, but its "understanding" of code isn't human. Ensure its suggestions make sense in *your* full context.
* **"Black Box" Fixes:** If AI fixes something and you don't know why the fix works, you've learned little, and that part of the code is now a mystery to you. This is technical debt.
* **Version Control:** Always use Git or similar. Create branches for experimental fixes (whether suggested by AI or your own). If it doesn't work, you can easily revert.
:::



# Integrating Debugging with Testing (Synergy with AI)**

* **Effective Testing Minimises Debugging:** Fewer bugs escape to later stages.
* **Tests Help Reproduce Bugs:** A failing test *is* a reproducible bug.
* **Test-Driven Debugging (TDD style):**
    1. Identify a bug.
    2. Write a test that *fails* because of this bug. (AI can help draft this test: "Write a test that demonstrates bug X in function Y.")
    3. Debug and fix the code until the test passes.
* **AI for Post-Fix Test Generation:** "I fixed bug X by changing Y. Help me write tests to ensure this fix works and doesn't break other things."
* **Debugging Informs Future Tests:** Understanding a bug helps you write better tests to prevent similar issues. AI can help generalise from a specific bug to broader test case ideas.

::: {.notes}

Debugging and testing are two sides of the same quality coin.
* Good tests, as we discussed in Module 1, catch many bugs early, reducing the time you spend in complex debugging sessions.
* When a bug *does* occur, a failing test is the best way to reproduce it consistently.
* Consider "Test-Driven Debugging": When you find a bug, first write a test that specifically triggers it and fails. Then, debug your code until that new test (and all others) pass. AI can assist in drafting that initial failing test: "I have a bug where my function `process_items` fails if the input list is empty. Can you help me write a `pytest` test that shows this failure?"
* After you've fixed a bug (with or without AI's help in finding the fix), ask AI to help you write robust tests around that fix to prevent it from recurring (regression testing).
Understanding why a bug occurred often gives you insights into what other kinds of tests you should be writing. AI can help you take a specific bug instance and brainstorm related test scenarios.
:::



# Conclusion: Becoming a Code Detective in the AI Era

* Advanced debugging is about deep investigation and understanding, not just quick fixes.
* AI tools are powerful *assistants*, not replacements for your analytical skills and critical judgment.
* Master traditional techniques (`print`, debuggers) to effectively guide and verify AI suggestions.
* **Practice the Human-AI Workflow:** Investigate -> Hypothesise (with AI) -> Verify (with tools) -> Implement (with understanding) -> Test.
* Continuous learning in both debugging techniques and effective AI interaction is key.
* **Call to Action:** Embrace debugging as a challenging but rewarding part of development. Use every tool, including your brain and AI, to master it!

::: {.notes}

In conclusion, mastering advanced debugging in this AI era means becoming a skilled investigator who knows how to use every tool at their disposal – including powerful AI assistants.
* It's about the deep dive, the root cause analysis. AI can help you get there faster, explain complexities, and offer ideas, but your critical thinking steers the ship.
* Your proficiency with fundamental techniques like `print` statements and interactive debuggers actually makes you *better* at using AI, because you can provide it with more precise information and better evaluate its responses.
* Focus on practicing that collaborative workflow: your initial investigation, using AI to explore possibilities or explain roadblocks, using debuggers to confirm, understanding and implementing solutions, and finally, testing your fixes.
Debugging will always be part of software development. By combining your growing expertise with the evolving capabilities of AI, you'll be well-equipped to tackle any bug that comes your way.
:::
---
title: "Strategic Test Design: Guiding Quality in AI-Assisted Development"
subtitle: "Ensuring Software Reliability Through Human Insight and AI Collaboration"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction

* Test Design with AI
* What is a Test Case
* Effective Test Design
* Common Pitfalls
* Tools and Resources
* Strategic Design in an AI World

::: {.notes}

Welcome! In our previous modules, we explored testing frameworks and debugging, increasingly seeing AI as a powerful assistant. Now, we focus on a critical human skill: **strategic test design**. Even if AI can help write code or even draft test cases, *you* define what success looks like. This session is about how to thoughtfully design effective test cases that ensure software quality, especially when collaborating with AI tools. We'll learn how your strategic thinking guides the entire quality assurance process.
:::



# The Power of Test Design in the AI Era

* **Why Test Design Matters:** Defines "correctness" for both human and AI-generated code.
* **Human as the Strategist:** You decide *what* to test, *why* it's important, and *how thoroughly*.
* **AI as the Tactical Assistant:** AI can help generate test ideas, data, or boilerplate, but your design guides its efforts.
* **Effective test cases:** Ensure AI modifications are actual improvements, not just changes.

::: {.notes}

In an era where AI can generate code and even suggest tests, the human role of **designing** those tests becomes paramount.
* A well-designed test case is a clear specification of expected behavior. This is crucial whether a human or an AI wrote the underlying code.
* As the developer, you bring the domain knowledge and understanding of user needs. You are the strategist who decides what aspects of the software are critical to test and what constitutes a meaningful test.
* AI can then act as a powerful tactical assistant, helping you flesh out these strategies by generating test scenarios, suggesting edge cases, or even drafting initial test code based on your design.
* Ultimately, your test design is what validates that any changes, whether human or AI-driven, truly meet the quality bar. Today, we'll cover how to design these vital test cases, integrating AI as a collaborative tool.
:::



# What is a Test Case? (AI Context)

* **Definition:** A set of inputs, execution conditions, test steps, and expected results developed for a particular objective (e.g., to verify compliance with a specific requirement).
* **Core Components:**
    * Test Case ID / Name
    * Preconditions / Setup
    * Test Steps (Actions)
    * Test Data (Inputs)
    * **Expected Results** (Crucial for defining success)
    * Actual Results & Status (Pass/Fail)
    * Postconditions / Teardown
* **AI Assistance in Component Generation:**
    * AI can help draft initial test steps based on a feature description.
    * AI can suggest varied test data (valid, invalid, edge cases).
    * **Human role:** Critically review and refine AI suggestions, especially expected results.

::: {.notes}

A test case is essentially a formal recipe for verifying a piece of functionality. It specifies everything needed to run a test and determine if the software behaves as expected.
* The **expected result** is perhaps the most critical component you define – it’s your assertion of what "correct" means.
* While the core components remain the same, AI can now assist in their creation. For instance, given a user story or a function signature, you could ask an AI: "Suggest test steps and typical test data for a function that does X." Or, "What are some edge case inputs for a feature that validates email addresses?"
* Your crucial role is to then take these AI-generated suggestions, critically review them, refine them (especially the expected results to ensure they align perfectly with requirements), and ensure they form a coherent and effective test.
:::



# Principles of Effective Test Design (Human-Guided, AI-Refined)

* **Clear, Concise, Unambiguous:** Easy to understand and execute by anyone (or any automated tool).
    * *AI Assist:* "Can you make these AI-generated test steps clearer and more concise?"
* **Traceable to Requirements:** Each test case should clearly map to a specific requirement or user story.
    * *AI Assist (Conceptual):* AI might help identify which requirements lack test case ideas (though this is more advanced).
* **Repeatable & Consistent:** Produces the same results every time if the software hasn't changed.
* **Independent & Isolated:** One test case failure shouldn't cascade or affect others unnecessarily.
    * *AI Assist:* "Review this set of test cases. Are there any obvious dependencies between them that I should try to remove?"
* **Covers Likely Failure Points & Edge Cases:** Goes beyond the "happy path."
    * *AI Assist:* "What are common failure points or edge cases for a [type of feature, e.g., 'file upload'] feature?"
* **Maintainable:** Easy to update as the software evolves.
    * *AI Assist:* Help refactor test cases when underlying code changes, but human confirms logic.

::: {.notes}

Effective test cases aren't just thrown together; they follow key principles.
* **Clear and Unambiguous:** If AI generates draft test steps, review them. Are they easy for another human (or you, in six months) to understand? You can even ask another AI instance to "rephrase these test steps for maximum clarity."
* **Traceable:** This ensures you're testing what matters.
* **Repeatable:** Essential for reliable automation.
* **Independent:** This helps pinpoint exactly where a failure lies. AI might help spot potential dependencies if you ask it to review a test suite description.
* **Covers Failure Points/Edge Cases:** This is where AI can shine as a brainstorming partner. Prompt it: "For a user registration form, what are some typical edge cases or invalid inputs I should design test cases for?"
* **Maintainable:** As your software changes, your tests will need to change. AI can help with the mechanical aspects of refactoring tests, but you must ensure the *logic* of the updated test remains sound.
:::



# A Spectrum of Tests: Types & AI Brainstorming

* **Functional Test Cases:** Verify specific actions/functions of the software.
    * *AI Assist:* "For a 'shopping cart checkout' feature, list key functional test cases."
* **User Interface (UI) Test Cases:** Ensure UI elements look and work correctly.
    * *AI Assist:* "What are common UI test cases for a web login form?" (May lead to more specialised UI testing tools).
* **Performance Test Cases:** Evaluate speed, responsiveness, stability under load.
    * *AI Assist (Conceptual):* "What aspects of this [architecture description] should be performance tested?"
* **Security Test Cases:** Assess vulnerabilities and protection.
    * *AI Assist (Conceptual):* "What are common security vulnerabilities I should design test cases for related to user authentication?"
* **Usability Test Cases:** How easy and intuitive is the system to use?
    * *AI Assist:* Can AI analyse a UI description and suggest usability heuristic violations to test for? (Emerging area)
* **Choosing the right types:** Your strategy dictates the mix, AI can help explore options.

::: {.notes}

There are many different types of tests, each focused on a different aspect of quality.
* **Functional tests** are often the most common – does the feature do what it's supposed to do? AI can be great at generating a list of functional scenarios based on a feature description.
* **UI tests** focus on the visual and interactive aspects. AI might help list common UI elements to check on a given screen type.
* **Performance and Security testing** are specialised domains. While AI might not design these complex tests end-to-end for a beginner, it can certainly help you brainstorm *what aspects* to consider testing based on your application's nature. For example, "What are typical performance metrics to test for a real-time data dashboard?"
* **Usability testing** is about the user experience. Emerging AI capabilities might even analyse UI mockups for potential usability issues that you could then design tests around.
Your understanding of the project's risks and priorities will determine which types of tests are most important. AI can then assist in brainstorming specific cases within those types.
:::



# Test Case Design: A Human-AI Collaborative Workflow

1. **Identify Testable Requirements/Scenarios (Human Lead):** What feature or behavior needs testing? Understand the core goal.
2. **Define Test Objectives (Human Lead):** What specific aspect of the requirement will this test case verify?
3. **Brainstorm with AI (Collaborative):**
    * "Given this feature `[description]`, suggest different test scenarios (happy path, negative paths, edge cases)."
    * "What are important preconditions for testing `[feature]`?"
4. **Detail Test Steps (AI Drafts, Human Refines):**
    * Prompt AI: "For the scenario `[specific scenario]`, draft the test steps."
    * Human: Review for clarity, completeness, accuracy. Add necessary detail.
5. **Specify Test Data (AI Suggests, Human Validates):**
    * Prompt AI: "Suggest valid and invalid input data for these test steps."
    * Human: Select appropriate data, ensure it covers boundaries and edge cases.
6. **Define Expected Outcomes (Human Critical, AI can Verify Consistency):**
    * Human: Based on requirements, *you* define the precise expected outcome. This is critical.
    * AI Assist: "If I input X according to these steps, and the requirement is Y, what should the expected outcome be?" (Use AI to check your logic or for simple cases).
7. **Review and Refine (Human Lead):** Does the complete test case meet all principles of effectiveness? Is it unambiguous?

::: {.notes}

Let's look at a practical, AI-augmented workflow for designing a test case:
1.  **You start by identifying what needs to be tested** based on project requirements or user stories. You understand the *why*.
2.  **You define the specific objective** for a particular test case. What single thing is it trying to prove?
3.  **Now, bring in your AI partner for brainstorming.** Describe the feature and ask for different test scenarios – happy paths, what happens if things go wrong, what are the tricky edge cases. Ask about necessary preconditions.
4.  **For a chosen scenario, ask AI to draft the sequence of test steps.** Then, *you* review, edit, and refine these steps. Are they logical? Complete? Easy to follow?
5.  **Need test data? AI can suggest a range of inputs.** "For these steps, give me examples of valid inputs, invalid inputs that should cause an error, and boundary values." You then curate and select the most relevant data.
6.  **Defining the expected outcome is largely a human task, rooted in the requirements.** However, for straightforward logic, you might describe the input and steps to an AI and ask, "Given these inputs and steps, and assuming the function should calculate a 5% discount, what should the output be?" This can act as a sanity check.
7.  **Finally, you review the entire test case.** Is it clear? Does it meet all the principles we discussed? This iterative process, with AI handling some of the generation and you providing the strategic oversight and critical evaluation, can be very powerful.
:::



# Example: Weather Dashboard Test Design with AI
* **Scenario:** Checking weather updates for a user-entered location.
* **AI-Assisted Design Steps:**
    * **Human Objective:** Verify correct real-time weather is shown for a valid city, and graceful error for an invalid city.
    * **AI Brainstorm Scenarios:**
        * Prompt: "Suggest test scenarios for a weather dashboard's location search."
        * *AI Output (example):* Valid city, misspelled city, non-existent city, city with special characters, empty input.
    * **Human Selects Scenario:** "Test with a valid, known city."
    * **AI Drafts Test Steps:**
        * Prompt: "Draft test steps for searching 'Perth, Australia' on a weather dashboard and verifying the temperature."
    * **Human Refines Steps & Expected Result:**
        1. Navigate to dashboard.
        2. Enter "Perth, Australia" in search.
        3. Click "Search."
        4. **Expected:** Weather details for Perth displayed. Temperature shown is within +/- 2 degrees of actual current Perth temperature (requires external check or mock for automation).
    * **AI Suggests Edge Case Data:**
        * Prompt: "Suggest invalid city names that might cause errors."
        * *AI Output (example):* "Xys123", "   ", "!@#$"
    * **Human Designs Negative Test:** Test with "Xys123", expect "City not found" message.

::: {.notes}

Let's apply this to our weather dashboard example.
* Our objective is to check that it shows correct weather for real cities and handles bad input well.
* We could ask an AI: "What are different test scenarios I should consider for the location search feature of a weather dashboard?" The AI might suggest testing with valid cities, misspelled ones, completely fake names, empty inputs, etc.
* We pick a scenario: "Display weather for Perth, Australia." We can ask the AI to "Draft the test steps to search for 'Perth, Australia' and verify the displayed temperature."
* The AI might give us basic steps. We then refine them and, importantly, define a precise expected result. For real-time data like weather, the expected result might be "Temperature displayed is within an acceptable range of the *actual* current temperature," which for automated tests often involves more advanced techniques like mocking or service virtualisation, or a manual check.
* Then we might ask AI for examples of invalid city names. We'd use these to design negative test cases, defining the expected error message like "City not found." This shows how AI can help explore the test space more thoroughly.
:::



# Common Pitfalls in Test Design (AI Era Perspective)**
* **Traditional Pitfalls:**
    * Overly complex test cases (hard to maintain).
    * Testing multiple features in one test (hard to isolate faults).
    * Ambiguity in expected outcomes (leads to incorrect pass/fail).
* **New AI-Related Pitfalls:**
    * **Over-reliance on AI-Generated Scenarios:** AI might miss nuanced business logic or critical-but-unobvious edge cases if not prompted with enough context.
    * **Superficial Test Cases:** AI might generate many "shallow" tests that hit lines of code but don't deeply validate behavior or complex interactions.
    * **Bias in AI Suggestions:** AI's training data might lead it to suggest tests that reflect common patterns but miss unique aspects of *your* application.
    * **Lack of Critical Review:** Accepting AI-generated test cases without thorough human validation of their relevance, steps, and *especially expected outcomes*.
    * **"Quantity over Quality" Illusion:** AI can generate many tests quickly, but if they aren't well-designed and meaningful, they provide false confidence.

::: {.notes}

While AI helps, some classic pitfalls remain, and new ones emerge.
* Traditional issues like overly complex tests or ambiguous expected results still apply. Clear, focused human design is the antidote.
* **AI-Specific Pitfalls:**
    * **Over-reliance:** Don't assume AI will think of everything. If your application has very specific or unusual business rules, you need to guide the AI or design those test cases yourself.
    * **Superficial Tests:** AI might generate tests that seem to cover the code but don't actually verify the critical logic paths or interactions. Your deep understanding is needed to ensure tests have substance.
    * **Bias:** An AI is trained on vast amounts of data. If your problem is unique, the AI's "common" suggestions might not be the best fit.
    * **Lack of Critical Review:** This is the biggest risk. If you blindly accept AI-generated test cases, especially their expected results, you could be institutionalising misunderstandings or even testing for the wrong thing.
    * **Quantity over Quality:** AI can churn out test ideas. Your job is to curate these into a *high-quality, effective* set, not just a large one.
:::



# Tools and Resources (AI Included)**
* **Your Brain!** (Critical thinking, domain knowledge, strategic planning)
* **Requirements Documents / User Stories:** The source of truth for what to test.
* **Diagramming/Flowchart Tools:** To visualise complex logic and identify test paths.
* **Python Testing Frameworks:** `doctest`, `unittest`, `pytest` (to implement the designed tests).
* **Test Case Management Tools:** (e.g., TestRail, sephyr, Jira with plugins) for larger projects.
* **AI Development Assistants:**
    * **LLMs (ChatGPT, Claude, Gemini, etc.):** For brainstorming scenarios, drafting steps, suggesting data, explaining concepts.
    * **IDE-Integrated AI (e.g., GitHub Copilot):** For inline suggestions and explanations during test code implementation.
* **Further Reading & Communities:** Blogs, forums, testing certifications.

::: {.notes}

Your primary tool for test design is your own analytical ability and understanding of the project.
* Requirements are your foundation.
* Visual tools can help map out complex logic.
* The frameworks we discussed (Module 1) are where you'll implement these designs.
* For larger scale efforts, dedicated test management tools help organise and track test cases.
* **And now, AI tools are a significant resource.** Use LLMs for brainstorming, getting initial drafts, or understanding complex requirements. Use AI integrated into your IDE to help as you write the actual test code.
* And, as always, continuous learning from online resources and communities is key.
:::



#  Conclusion: You Are the Test Strategist
* Effective test case design is a critical human skill, amplified by AI.
* Your strategic thinking ensures that AI's tactical assistance is directed effectively.
* Well-designed tests are the ultimate verifier of quality for both human and AI-generated code.
* **Embrace the Human-AI Collaboration:** Use AI to explore more scenarios, generate drafts faster, and learn, but *you* own the design and quality.
* **Encouragement:** Practice strategic test design. The more you do it, the better you'll become at guiding AI and ensuring truly robust software.

::: {.notes}

To conclude, while AI offers exciting new capabilities for assisting in test generation, the role of the human as the **test strategist and designer** is more critical than ever.
* It's your understanding of the requirements, the user, and the potential risks that shapes an effective testing strategy.
* AI can help you execute parts of that strategy much faster, explore more ground, and even overcome writer's block when thinking of test scenarios.
* But the ultimate responsibility for ensuring that tests are meaningful, comprehensive, and correctly define "quality" rests with you. Well-designed tests are your best tool for ensuring that all code, no matter its origin, meets the mark.
So, practice designing test cases thoughtfully. Experiment with how AI can assist you, and always remember that your critical judgment is the most valuable asset in the pursuit of software quality. Happy designing!
:::---
title: "Python Testing Frameworks: Your Quality Toolkit in the Age of AI"
subtitle: "Building Reliable Code with Human Insight and AI Assistance"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Focus of Today's Presentation:
    * Core concepts of Python testing frameworks (`doctest`, `unittest`, `pytest`).
    * How to leverage AI as your testing assistant.
    * Building a foundation for writing reliable code.

::: {.notes}
Welcome! AI tools are becoming powerful assistants in software development, you might wonder about the role of traditional practices like testing. This session introduces Python testing frameworks, not just as historical tools, but as essential components of your modern development toolkit. We'll explore how these frameworks, combined with your critical thinking and AI assistance, help you build reliable, maintainable, and high-quality Python applications. Our focus will be on understanding foundational concepts and how they are *amplified*, not replaced, by AI.

Today, we'll explore foundational Python testing frameworks like `doctest` for simple, documentation-based tests, and the more structured `unittest` and `pytest`. Crucially, we'll discuss how you can intelligently partner with AI to make your testing efforts more effective and efficient.

:::



# The "Why Test?" in the Age of AI**

* AI generates code, but who verifies its correctness and intent? **You do, with tests!**
* Testing provides the "ground truth" for AI-assisted refactoring and modifications.
* AI can *help write tests faster*, increasing your ability to build a safety net.
* Understanding testing fundamentals makes you a better collaborator with AI tools.

::: {.notes}

You've probably seen AI tools that can write code, suggest bug fixes, and even explain complex algorithms. So, why dedicate time to learning about testing frameworks? The answer is crucial: AI is a powerful assistant, but it's not infallible.
* When AI generates code, tests are what confirm it actually does what's intended and doesn't have subtle bugs.
* If you ask AI to refactor code, how do you know the new code still works? A solid test suite provides that confidence.
* AI can significantly speed up the process of writing tests, but *you* still need to understand what makes a good test and what needs to be tested.
:::



# Why Testing *Still* Matters (Enhanced)**

  * **Ensures Reliability & Quality:** Catches bugs before users (or AI-generated code) introduce them widely.
  * **Facilitates Safer Changes:** Refactor code (yours or AI's) with confidence, knowing tests guard against regressions.
  * **Acts as Living Documentation:** Tests clearly show how code is intended to be used – invaluable for human and AI understanding.
  * **Provides a Safety Net:** AI-driven development can be fast; tests ensure speed doesn't compromise stability.
  * **Reduces Debugging Time:** Well-tested code leads to fewer, easier-to-diagnose bugs.

::: {.notes}

The fundamental benefits of testing haven't disappeared with AI; they've become even more pronounced.
* **Reliability and Quality:** Whether code is written by a human or an AI, it can have bugs. Tests are your first line of defense.
* **Safer Changes:** Imagine AI suggests a major refactor. Without tests, deploying that change is a high-risk gamble. With tests, it's a calculated, verifiable step.
* **Living Documentation:** Well-written tests, especially `doctests`, clearly demonstrate how your functions are supposed to work. This is vital for team members and even for AI tools trying to understand or modify your code later.
* **Safety Net:** As development cycles potentially speed up with AI assistance, having a robust test suite ensures you're not just moving fast but also maintaining stability. AI can even help *build* this safety net faster.
* **Reduced Debugging:** Fewer bugs make it into later stages, and when they do, tests often help pinpoint the cause much quicker.
:::



# Introduction to `doctest` – Simple, Integrated Testing**

* Write tests directly in your function's docstrings.
* Examples look like interactive Python sessions.
* Excellent for simple functions and ensuring documentation is accurate.
* **AI Assistance:**
    * Prompt AI: "Generate `doctest` examples for this Python function, including edge cases."
    * AI can help ensure your documented examples are also effective tests.

::: {.notes}

Our first stop is `doctest`, a wonderfully simple way to integrate tests directly into your code's documentation. The tests are written as if you're typing them into a Python interpreter right in the docstring. This not only tests your code but also provides clear, executable examples of how to use it.
:::

# Doctest Example:
    ```python
    def add(a, b):
        """
        Adds two numbers.
        >>> add(2, 3)
        5
        >>> add(-1, 1)
        0
        """
        return a + b

import doctest
doctest.testmod()
```

::: {.notes}
* **AI Power-Up:** If you have a function, you can ask an AI, "Can you write some `doctest` examples for this function that cover typical usage and a couple of edge cases?" The AI can help you quickly populate your docstrings with useful tests. Always review these suggestions to ensure they accurately reflect the function's intent and cover meaningful scenarios. This is a great way to ensure your documentation is always up-to-date and correct because it *is* the test!
:::



# Introduction to `unittest`**

* Part of Python's standard library.
* Organises tests into classes and methods.
* Supports test automation, setup/teardown for tests.
* Follows xUnit style (familiar if you've seen JUnit, NUnit).
* **AI Assistance:**
    * Prompt AI: "Write `unittest` test cases for this Python function."
    * AI can help generate the class structure and assertion methods.

::: {.notes}

Next is `unittest`, Python's built-in framework that provides a more formal structure for your tests. It's an "xUnit" style framework, meaning tests are organised into classes that inherit from `unittest.TestCase`, and individual test scenarios are methods within those classes that typically start with `test_`. This structure is great for managing larger test suites and for tests that require setup (e.g., creating a temporary database) or cleanup after they run.
:::

# unittest example
    ```python
    import unittest

    class TestSum(unittest.TestCase):
        def test_sum(self):
            self.assertEqual(sum([1, 2, 3]), 6, "Should be 6")

    if __name__ == '__main__':
        unittest.main()
    ```

::: {.notes}
* **AI Power-Up:** Provide your function to an AI and ask, "Write `unittest` test cases for this function." AI can help generate the boilerplate `TestClass` structure, suggest appropriate `self.assert...` methods (like `assertEqual`, `assertTrue`, etc.), and even propose different test methods for various scenarios. Remember to critically review the generated tests: Do they cover the right conditions? Are the assertions meaningful?
:::



# Introduction to `pytest`**

* Popular third-party framework (install via `pip install pytest`).
* Simple, less verbose syntax (often just functions).
* Powerful features: fixtures, rich plugin ecosystem, detailed reporting.
* Easier to start with for many; scales well.
* **AI Assistance:**
    * Prompt AI: "Write `pytest` tests for this Python function."
    * AI can generate concise test functions and suggest fixture usage.

::: {.notes}
`pytest` is a widely adopted third-party testing framework loved for its simplicity and power. It often requires less boilerplate code than `unittest` – you can frequently write tests as simple functions. `pytest` has a very expressive way of handling test setup and dependencies using "fixtures," and its plugin architecture allows for extensive customisation and integration with other tools.

:::

# pytest example

    ```python
    # import pytest # Not needed if pytest runs the file

    def test_sum():
        assert sum([1, 2, 3]) == 6, "Should be 6"
    ```

::: {.notes}
* **AI Power-Up:** As with `unittest`, you can ask an AI, "Write `pytest` tests for this Python function." AI tools are generally good at generating the straightforward `assert` statements that `pytest` favors. You might also ask, "Can you show me how to use a `pytest` fixture to provide test data for this function?" This helps you learn more advanced features with AI guidance. Always ensure the AI-suggested tests align with your function's logic and cover necessary cases.
:::



# Comparing `doctest`, `unittest`, and `pytest` (AI Lens)**

* **`doctest`:**
    * Pros: Simple, in-documentation, great for examples.
    * Cons: Less suited for complex tests or setup/teardown.
    * *AI Fit:* Excellent for AI to quickly populate docstrings with verifiable examples.
* **`unittest`:**
    * Pros: Standard library, xUnit structure, good for complex scenarios.
    * Cons: Can be verbose.
    * *AI Fit:* AI can generate boilerplate, suggest assertion methods, and help structure test classes.
* **`pytest`:**
    * Pros: Concise, powerful fixtures, rich ecosystem, less boilerplate.
    * Cons: Third-party (needs install).
    * *AI Fit:* AI excels at generating simple `assert` style tests; can help introduce fixture concepts.
* **Your Choice:** Depends on project, team, and complexity. AI can help you get started with *any* of them.

::: {.notes}

So, `doctest`, `unittest`, or `pytest`?
* **`doctest`** is fantastic for simple functions where tests also serve as clear documentation. AI can rapidly generate these examples for you.
* **`unittest`** is robust, part of Python itself, and its structured approach is beneficial for larger projects or when you need sophisticated setup/teardown. AI can lessen the burden of its verbosity by generating initial test structures.
* **`pytest`** often hits a sweet spot with its concise syntax and powerful features like fixtures, making it a favorite for many. AI can easily generate basic `pytest` tests and help you explore more advanced features.
The choice often comes down to the project's needs and team preference. The good news is that AI can assist you in writing tests regardless of the framework, lowering the barrier to entry for all of them. You might even use `doctest` for simple examples and `pytest` or `unittest` for more complex integration tests within the same project.
:::



# Writing Effective Test Cases (AI-Enhanced)**

* **Keep Tests Small & Focused:** One distinct behavior or scenario per test.
    * *AI Assist:* "Break down testing for this complex function into smaller, focused test cases."
* **Use Descriptive Names:** Clearly state what's being tested and the expected outcome.
    * *AI Assist:* "Suggest descriptive names for these `pytest` test functions based on what they test."
* **Test Positive & Negative Scenarios:** Verify correct behavior with valid inputs AND graceful handling of invalid inputs/errors.
    * *AI Assist:* "For this function, suggest `doctest` examples for both valid inputs and common error-inducing inputs."
* **Focus on Behavior, Not Implementation:** Test *what* the code does, not *how* it internally does it (makes tests less brittle).
    * *AI Assist (with caution):* "Write tests for the public API of this class, focusing on its observable behavior." (Requires careful prompting).
* **Human Review is Crucial:** AI generates; you validate, refine, and ensure tests are meaningful.

::: {.notes}

Regardless of the framework, effective tests share common qualities. And AI can help achieve them!
* **Small & Focused:** Each test should ideally check one specific thing. If a test fails, you'll know exactly where the problem lies. You can ask AI to help decompose testing for a complex piece of code.
* **Descriptive Names:** Good names make your test suite readable. AI can suggest names if you provide the test code or its purpose.
* **Positive & Negative Tests:** Don't just test the "happy path." What happens with bad data? Or edge cases? AI is great at brainstorming these: "What are some edge cases or invalid inputs I should test for this login function?"
* **Behavior, Not Implementation:** Test the "contract" of your function – given these inputs, expect these outputs or side effects. Avoid testing internal private methods directly, as this makes your tests fragile if you refactor. Prompt AI carefully here.
* **Always, always review AI-generated tests.** Does it actually test what you intend? Is it clear? Is it robust? You are the final arbiter of test quality.
:::



# Navigating Pitfalls in Testing (Even with AI)
* **Testing Internal Implementation:** (As mentioned) Makes tests brittle.
    * *AI Risk:* AI might do this if not prompted to focus on public interfaces/behavior.
* **Skipping "Simple" Functions/Code:** "Obvious" code can still have bugs.
    * *AI Solution:* AI can generate tests for simple code so quickly, there's less reason to skip!
* **Non-Isolated Tests (Flaky Tests):** Tests that depend on each other or shared state.
    * *AI Risk:* AI might not automatically ensure isolation; human design of test structure and fixtures (for `pytest`/`unittest`) is key.
* **Ignoring Edge Cases:** Focusing only on typical inputs.
    * *AI Solution:* Actively prompt AI: "What are the edge cases for this function that I should test?"
* **Blindly Trusting AI Output:** Generated tests might be incomplete, incorrect, or test the wrong thing. **Critical human review is essential.**

::: {.notes}

While testing is powerful, there are common traps.
* **Testing Internals:** If you change how a function works internally (refactor) but its external behavior remains the same, tests focused on internals will break unnecessarily.
* **Skipping "Simple" Code:** Famous last words! AI can help by making it trivial to generate basic tests for these, removing the excuse.
* **Flaky Tests:** These are tests that sometimes pass and sometimes fail without code changes, often due to external dependencies or shared state. Designing for test isolation is a human skill, though AI might help refactor to improve it if asked specifically.
* **Ignoring Edge Cases:** These are the unusual inputs – empty lists, seros, maximum values – where bugs often hide. AI can be a great partner in brainstorming these.
* **The Biggest AI-Era Pitfall: Blind Trust.** Never assume AI-generated tests are perfect. They are a starting point. You must understand them, review them, and ensure they meet your quality standards and truly validate your code's intended behavior. Your critical thinking is the most important part of the process.
:::



# The Human-AI Partnership in Testing
* **You (the Developer):**
    * Understand requirements and intended behavior.
    * Design the overall testing strategy.
    * Critically evaluate and refine AI-generated tests.
    * Ensure tests are meaningful and maintainable.
    * Own the quality.
* **AI (the Assistant):**
    * Generates initial test code/examples rapidly.
    * Suggests edge cases and scenarios.
    * Helps explain framework syntax or concepts.
    * Can refactor tests for clarity (under your guidance).
    * Handles boilerplate.
* **Goal:** Leverage AI to do more thorough testing, faster, allowing you to focus on high-level design and critical thinking.

::: {.notes}

So, what does this all mean for you? Testing in the AI era is a partnership.
* You bring the deep understanding of what the software *should* do, the context, and the critical judgment. You design the strategy – what needs testing and how thoroughly.
* AI brings speed, the ability to handle repetitive tasks like generating boilerplate test code, and a knack for suggesting things (like edge cases) you might have overlooked.
When you effectively combine your strengths with AI's capabilities, you can achieve a higher level of software quality and a more efficient testing process. You're still in the driver's seat; AI is your co-pilot.
:::



# Conclusion: Embarking on Your AI-Assisted Testing Journey
* Testing is more crucial than ever for verifying human *and* AI-generated code.
* Mastering a testing framework (`doctest`, `unittest`, `pytest`) is a key skill.
* Learn to prompt AI effectively to assist in your testing workflow.
* **Practice is key:** Write tests for your projects, experiment with AI assistance, and critically review the results.
* Explore further: Test-Driven Development (TDD), Behavior-Driven Development (BDD), advanced fixture usage, coverage tools (topics for future learning!).
* **Call to Action:** Start integrating testing, with AI as your partner, *early and often* in your development.

::: {.notes}

To wrap up, the core message is this: in an era where AI can generate and modify code at an unprecedented rate, the ability to write and understand tests is not just relevant – it's a cornerstone of responsible and effective software development.
* Frameworks like `doctest`, `unittest`, and `pytest` provide the tools. Your intellect provides the strategy. AI provides the acceleration.
* The key is to practice. Take the functions you write and try to test them. Use `doctest` for simple cases. Experiment with `pytest` or `unittest`. Ask an AI to help you generate tests, then critically review and improve them.
* There's always more to learn – concepts like Test-Driven Development, where you write tests *before* code, or tools for measuring test coverage, are exciting next steps.
But for now, focus on integrating these foundational testing practices, augmented by thoughtful AI collaboration, into your work. This will make you a stronger, more confident Python developer.
:::
---
title: "Supercharge Your Functions with Data"
subtitle: "Using Parameters, Arguments, and Defaults to Create Dynamic Code"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Passing Information to Functions

Welcome to Module 2! In this module, we'll learn how to send data into your functions. This allows you to make your functions more dynamic and flexible.

::: {.notes}
Passing information to functions is a fundamental concept in programming. Functions can accept input values, known as arguments, which are used within the function to perform specific tasks or calculations. These arguments are defined as parameters in the function definition, specifying the expected input values.

When calling a function, you provide the necessary arguments, which can be literals, variables, or expressions. The arguments are passed to the corresponding parameters in the function, allowing the function to operate on the provided values. By utilising parameters and arguments effectively, you can create reusable and modular code that can be easily customised for different scenarios.
:::

# Objectives

- Understand the difference between parameters and arguments.
- Learn how positional arguments work.
- Discover how to assign default values to parameters.

::: {.notes}
Presenter notes for "Objectives" slide:

This slide outlines the key learning objectives for the section on passing information to functions. Firstly, we'll clarify the distinction between parameters and arguments, which are often used interchangeably but have different meanings. Parameters are the variables defined in a function's definition, whereas arguments are the actual values passed to the function when it's called. Understanding this difference is crucial for working effectively with functions.

Next, we'll explore how positional arguments work. In Python, the order in which arguments are passed matters, and this is determined by the position of the corresponding parameters in the function definition. We'll look at examples to illustrate this concept. Lastly, we'll learn how to assign default values to parameters, which allows us to provide a fallback value if an argument isn't passed. This can make our functions more flexible and easier to use in different contexts.
:::

# Parameters vs. Arguments

- **Parameters:**  
  These are placeholders in your function definition. They represent the data your function needs.
- **Arguments:**  
  These are the actual values you pass into your function when you call it.
  
For example, in:
  
```python
def add_numbers(a, b):
    result = a + b
    print("The sum is", result)
```

`a` and `b` are parameters. When you call `add_numbers(3, 4)`, 3 and 4 are arguments.

::: {.notes}
Parameters are variables defined in a function declaration that receive values when the function is called. They act as placeholders for the values that will be passed to the function, allowing it to work with different data each time it is invoked. Parameters are specified within the parentheses of the function declaration, and they can have default values assigned to them.

Arguments, on the other hand, are the actual values passed to a function when it is called. These values are supplied within the parentheses of the function call and are used to replace the corresponding parameters in the function definition. The number and order of arguments must match the number and order of parameters in the function declaration unless default values are provided for the parameters.
:::

# Positional Arguments

- Arguments are passed into functions based on their order.
- The first argument goes to the first parameter, the second to the second parameter, and so on.
- This is why it is important to keep the order consistent when calling your function.

::: {.notes}
Positional arguments are passed into functions based on their order. The first argument corresponds to the first parameter, the second argument to the second parameter, and so forth. It is crucial to maintain consistency in the order of arguments when calling a function to ensure the intended behaviour and avoid unexpected results.

When using positional arguments, the position of each argument determines which parameter it is assigned to within the function. This means that if the order of the arguments is changed when calling the function, the values will be assigned to different parameters, potentially leading to errors or incorrect outputs. Therefore, it is important to be mindful of the order and provide the arguments in the same sequence as the function's parameter list.
:::

# Default Parameter Values

- You can assign a default value to a parameter in your function definition.
- This allows the function to be called even if one or more arguments are missing.
- Example:
  
```python
def describe_person(name, age=18):
    print(name + " is " + str(age) + " years old.")
```

In this function, if you don't provide an age, it defaults to 18.

::: {.notes}
Default parameter values allow functions to be called even when one or more arguments are not provided. In the function definition, a default value can be assigned to a parameter, which will be used if the corresponding argument is missing when the function is called. This provides flexibility and convenience, as it eliminates the need to specify every argument if some have suitable default values.

Here's an example to illustrate the concept: def greet(name, greeting="Hello"): print(f"{greeting}, {name}!") In this function, the "greeting" parameter has a default value of "Hello". If the function is called with only one argument, like greet("Alice"), the default value will be used, and the output will be "Hello, Alice!". However, if both arguments are provided, such as greet("Bob", "Hi"), the specified value will override the default, resulting in "Hi, Bob!".
:::

# Activity: Create Your Own Function

**Task:**  
Create a function named `describe_person` that takes two parameters: `name` and `age`.  
- Set the default value of `age` to 18.
- Inside the function, print a message that says, for example, "Alice is 18 years old."  
- Experiment by calling the function with both one and two arguments.

Take a moment to write your own version of `describe_person`.

::: {.notes}
In this activity, you will create your own function and experiment with passing arguments to it. Set the default value of the `age` parameter to 18, so that if no age is provided when calling the function, it will use 18 as the default. Inside the function, print a message that includes the name and age, such as "Alice is 18 years old."

After creating your function, call it with both one and two arguments to observe the difference in behaviour. First, call the function with just a name argument, and notice that the default age of 18 is used. Then, call the function again with both a name and an age argument, and see how the function uses the provided age instead of the default value. This practice will help solidify your understanding of how default parameter values work in functions.
:::

# Example Answer

Here's one way to write the function:

```python
def describe_person(name, age=18):
    print(name + " is " + str(age) + " years old.")

# Calling the function with both arguments
describe_person("Alice", 25)

# Calling the function with just the name; age defaults to 18
describe_person("Bob")
```

When you run this code, you'll see personalised messages based on the arguments you provide.

Happy coding, and enjoy exploring how passing information to functions can make your code more powerful!

::: {.notes}
The example answer demonstrates a basic function that takes two parameters, num1 and num2, and returns their sum. The function uses positional arguments, where the order of the arguments matters when calling the function. To use the function, you simply call it with two numbers, like add_numbers(5, 3), and it will return the result 8.

The example also shows how to set default parameter values. In this case, num2 has a default value of 10. This means that if you call the function with only one argument, like add_numbers(7), it will assume num2 is 10 and return 17. Default parameter values provide flexibility and allow the function to be called with fewer arguments when needed.
:::

---
title: "Unlocking Results with Returning Values"
subtitle: "How Your Functions Share Their Results with Your Code"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Unlocking Results with Returning Values

Welcome to Module 3! In this module, you'll learn how functions process data and send results back to your programme using the `return` statement.

::: {.notes}
The "Unlocking Results with Returning Values" slide serves as an introduction to the concept of using return statements in functions to produce output. It sets the stage for the subsequent slides, which will delve into the specifics of how the return statement works and provide examples to illustrate its usage.

The slide is part of a larger presentation that covers the fundamentals of returning values from functions. The other slides in the presentation include "The return Statement", which explains the syntax and purpose of the return statement; "Simple Arithmetic Example", which demonstrates how to use the return statement in a basic arithmetic function; "Activity: Calculate the Area of a Circle", which provides a hands-on exercise for learners to practice using the return statement; and "Recap", which summarises the key points covered in the presentation.
:::

# The return Statement

- **Purpose:**  
  The `return` statement sends a value back to the part of your code that called the function.
- **Why use it?**  
  Instead of printing a result immediately, returning a value lets you store and use that result later.
- **Key Difference:**  
  - **Printing:** Displays a value on the screen.  
  - **Returning:** Provides a value that can be used elsewhere in your code.

::: {.notes}
The return statement serves two main purposes in programming. It allows you to exit a function and optionally send a value back to the caller. Using return is beneficial when you need to terminate a function's execution early or when you want to provide a result that can be utilised in other parts of your code.

It's important to distinguish between printing and returning values. Printing simply displays a value on the screen for informational purposes. In contrast, returning a value using the return statement makes it available for further use and processing within your program, enabling more flexible and modular code design.
:::

# Simple Arithmetic Example

Consider a function that adds two numbers:

```python
def add_numbers(a, b):
    return a + b

result = add_numbers(5, 3)
print("The sum is", result)
```

- Here, `add_numbers` processes the numbers and returns the sum.
- We then store this result in the variable `result` and print it.

::: {.notes}
The slide "Simple Arithmetic Example" demonstrates how the `add_numbers` function processes the input numbers and returns their sum. This returned value is then assigned to the variable `result`, allowing us to store and utilise the computed sum for further operations or output.

By printing the `result` variable, we can display the sum of the numbers to the user, showcasing the successful execution of the `add_numbers` function and the returned value. This example highlights the importance of returning values from functions, enabling us to capture and work with the results of computations performed within the function's scope.
:::

# Activity: Calculate the Area of a Circle

**Your Task:**

- Create a function named `calculate_area` that:
  - Accepts one parameter: `radius`.
  - Calculates the area of a circle using the formula:  
    _Area = π × radius²_  
    (You can use 3.14 as an approximation for π.)
  - Returns the calculated area.
- Call your function and print the result.

**Example:**

```python
def calculate_area(radius):
    area = 3.14 * radius * radius
    return area

circle_area = calculate_area(5)
print("The area of the circle is", circle_area)
```

- Experiment with different radii to see how the area changes.

::: {.notes}
In this activity, you will create a function called `calculate_area` that takes the radius of a circle as a parameter. The function will use the well-known formula for calculating the area of a circle, which is πr², where π (pi) is approximately 3.14159 and r is the radius. Once the area is calculated, the function will return the result.

To test your function, call it with different radii and print the returned values. This will allow you to observe how the area changes as the radius is altered. By experimenting with various radii, you will gain a better understanding of the relationship between the radius and the area of a circle.
:::

# Recap

- The `return` statement lets a function send data back to the calling code.
- This technique allows you to use the results of a function in other parts of your programme.
- Practice writing functions that return values to become more confident in your coding skills.

Happy coding, and enjoy exploring the power of returning values from your functions!

::: {.notes}
In this slide, we recap the key points about returning values from functions. The `return` statement allows a function to send data back to the calling code, enabling you to use the results of the function in other parts of your programme. This is a powerful technique that can make your code more modular and reusable.

To become more confident in your coding skills, it's recommended that you practise writing functions that return values. By doing so, you'll gain a better grasp of how to structure your code and how to pass data between different parts of your programme. With time and practice, you'll find that using functions with return values becomes second nature and greatly improves the efficiency and readability of your code.
:::

---
title: "Unlock the Power of Functions"
subtitle: "Your First Step to Organised Python Code"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Welcome to Functions in Python

Welcome to our introduction to functions! In this module, you'll learn how functions help make your Python code more organised and easier to manage.

::: {.notes}
Welcome to Functions in Python! Functions are a fundamental concept in programming that allow you to organise your code into reusable blocks. By defining a function, you can encapsulate a specific task or computation, making your code more modular, readable, and maintainable.

In this presentation, we will explore what functions are, why they are useful, and how to define and call them in Python. We will cover the syntax for defining a function, including the def keyword, function name, parameters, and return values. Additionally, we will discuss how to call a function and pass arguments to it. By the end of this presentation, you will have a solid foundation in working with functions in Python.
:::

# What is a Function?

- A function is a reusable block of code that performs a specific task.
- Think of it like a mini-program that you can call whenever you need it.
- Using functions helps you avoid writing the same code over and over.

::: {.notes}
A function is a reusable block of code that performs a specific task, like a mini-program that you can call whenever you need it. By using functions, you can avoid writing the same code repeatedly, making your programs more efficient and easier to maintain.

Functions are a fundamental concept in programming and are essential for writing modular, reusable code. In this presentation, we'll explore why functions are useful, how to define and call them in Python, and see some examples of how they can be used to streamline your code.
:::

# Why Use Functions?

- **Organisation:** Break your code into manageable pieces.
- **Reusability:** Write a piece of code once and use it many times.
- **Clarity:** Make your programme easier to read and understand.

::: {.notes}
Functions are an essential tool for organising code into manageable pieces, making it more readable and understandable. By breaking down a programme into smaller, self-contained functions, each responsible for a specific task, the overall structure becomes clearer and easier to follow. This modular approach helps to reduce complexity and makes the code more maintainable, as changes can be made to individual functions without affecting the rest of the programme.

Functions also promote code reusability, allowing a piece of code to be written once and used multiple times throughout the programme. This eliminates the need for duplicating code, saving time and effort, and reducing the likelihood of errors. By encapsulating a specific task within a function, it can be called whenever that functionality is needed, leading to more efficient and streamlined code. Additionally, well-defined functions with clear input and output parameters make the code more self-explanatory and easier for other developers to understand and collaborate on.
:::

# Defining a Function

- Functions are defined with the keyword `def`.
- The basic syntax is:
  ```python
  def function_name():
      # code goes here
  ```
- Remember: The code inside the function must be indented.

::: {.notes}
Here are the presenter notes for the "Defining a Function" slide:

To define a function in Python, we use the `def` keyword followed by the function name and parentheses. Inside the parentheses, we can specify parameters that the function accepts. After the parentheses, we add a colon to indicate the start of the function block. The basic syntax is shown on the slide, where `function_name` is a descriptive name for the function and `parameter1`, `parameter2`, etc. are optional parameters that the function can receive.

It's crucial to remember that the code inside the function must be indented. Python uses indentation to define code blocks, so all the statements that are part of the function must be indented consistently, typically with four spaces or a tab. This indentation distinguishes the function body from the rest of the code. Failing to indent properly will result in syntax errors.
:::

# Calling a Function

- After you define a function, you need to call it to make it run.
- Example:
  ```python
  def say_hello():
      print("Hello, everyone!")
  
  say_hello()  # This line calls the function
  ```
- **Note:** The function definition must appear before you call the function.

::: {.notes}
After defining a function in Python, you must call it to execute the code within the function. The function call instructs Python to run the code inside the function, allowing you to utilise the function's functionality. For example, if you have defined a function named `greet()`, you can call it by simply writing `greet()` in your Python script.

It is crucial to remember that the function definition must appear before the function call in your Python script. Python reads the script from top to bottom, so if you attempt to call a function before it has been defined, you will encounter an error. By ensuring that your functions are defined before they are called, your script will execute smoothly and without issues.
:::

# Recap

- A function is a way to bundle code that performs a task.
- Defining and calling functions makes your code less repetitive and more organised.
- In your upcoming lab, you'll get hands-on experience writing and using functions!

Take a moment to review these ideas, and get ready to explore functions in our lab session. Happy coding!

::: {.notes}
Here are the presenter notes for the "Recap" slide:

Functions are a fundamental concept in Python programming that allow you to encapsulate code performing a specific task into a reusable unit. By defining functions, you can avoid repetition in your code and improve its overall structure and readability. Functions also promote modular design, as you can break down complex problems into smaller, more manageable parts.

In the upcoming lab, you will gain practical experience in defining and invoking functions. This hands-on practice will reinforce your understanding of how functions work and how they can be effectively used to solve problems. By writing and using functions yourself, you will develop a deeper appreciation for their benefits and learn how to incorporate them into your own Python programs.
:::

# Activity: Create Your Own Greeting Function

Try writing your very own function! Remember our early "Personalise Greeting" from labs? Now, lets make it a function?.  

**Task:**  
- Write a function named `greet()` that:
  - Uses the `input()` function to ask the user for their name.
  - Prints a personalised greeting message (for example, "Hello, [name]!").

Take a few minutes to try it out!

::: {.notes}
In this activity, you will create your own personalised greeting function called `greet()`. The function will use the built-in `input()` function to prompt the user to enter their name. Once the user has provided their name, the function will store it in a variable for further use.

After obtaining the user's name, the `greet()` function will print a customised greeting message. The message will incorporate the user's name, creating a personalised experience. For instance, if the user enters "Alice" as their name, the function will output "Hello, Alice!" or a similar greeting tailored to the user.
:::

# Answer: A Personalised Greeting Function

Here's one way to write the `greet()` function using the `input()` function inside it:

```python
def greet():
    name = input("Enter your name: ")
    print("Hello, " + name + "!")
    
greet()  # Calling the function to see it in action
```

In this solution, when you call `greet()`, the programme asks for your name and then prints a greeting just for you. Enjoy experimenting with your own greetings!

::: {.notes}
To create a personalised greeting function, we can modify the simple greeting function to accept a name parameter. Inside the function, we concatenate the "Hello" string with the provided name to create a customised greeting message. Finally, we print this personalised message when the function is called.

When calling the personalised greeting function, we pass in the desired name as an argument. This allows us to reuse the function with different names, generating unique greetings for each person. By utilising parameters, we can create flexible and reusable functions that adapt their behaviour based on the input provided.
:::

---
title: "Broaden Your Horizons with Modules"
subtitle: "Using External Libraries to Elevate Your Python Programmes"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Expanding Your Code with Modules

Welcome to Module 4! In this module, you'll learn how to import and use external modules to extend the capabilities of your code. For business information students, using modules like `datetime` can be very practical.

::: {.notes}
Modules are an essential part of expanding your code in Python. They allow you to access pre-written code and functionality, saving you time and effort. By importing modules, you can leverage the work of other developers and avoid reinventing the wheel. Modules also help keep your code organised and maintainable, as you can separate different parts of your program into distinct modules.

In this slide, we'll explore the basics of importing modules and discuss why they are so useful. We'll also look at a simple demonstration using the datetime module to show how easy it is to start using modules in your own code. By the end of this section, you'll have a good understanding of how to use modules to expand the capabilities of your Python programs.
:::

# Objectives

- Understand what modules are and why they are useful.
- Learn the basics of import syntax.
- See how pre-written libraries can simplify your coding tasks.

::: {.notes}
Modules are self-contained units of code that can be imported into your Python programs to provide additional functionality. By breaking code into modules, you can make your programs more organised, easier to understand, and simpler to maintain. Modules also allow you to reuse code across multiple projects, saving time and effort.

In this presentation, we will cover the basics of import syntax, which is how you bring modules into your code. We will also explore how using pre-written libraries can simplify coding tasks and help you avoid reinventing the wheel. By the end of this presentation, you should have a solid understanding of what modules are, how to import them, and why they are such a valuable tool for Python programmers.
:::

# Import Syntax Basics

- **Using `import module`:**  
  This imports the entire module.  
  Example:
  ```python
  import datetime
  now = datetime.datetime.now()
  print("Current date and time:", now)
  ```
- **Using `from module import function`:**  
  This imports only the specific function you need.  
  Example:
  ```python
  from datetime import datetime
  now = datetime.now()
  print("Current date and time:", now)
  ```
- Choose the method based on your needs and the size of the module.

::: {.notes}
There are two main methods for importing modules in Python. The first method is using the `import module` syntax, which imports the entire module and requires you to prefix each function or variable with the module name when using them. The second method is using the `from module import function` syntax, which allows you to import specific functions or variables from a module directly into your namespace, so you can use them without the module prefix.

When deciding which method to use, consider the size of the module and your specific needs. If you only require a few functions from a large module, it may be more efficient to import them individually using the `from module import function` syntax. However, if you need to use many functions or variables from a module, or if you want to avoid potential naming conflicts, it may be better to use the `import module` syntax and prefix each function or variable with the module name.
:::

# Why Import Modules?

- **Reusability:**  
  Use pre-written, well-tested code to perform common tasks.
- **Organisation:**  
  Keep your code clean by separating functionality into different modules.
- **Efficiency:**  
  Save time by leveraging libraries that handle complex tasks for you.
- **Business Relevance:**  
  Modules like `datetime` are essential for tasks such as time-stamping transactions or scheduling.

::: {.notes}
Importing modules in Python allows for reusability of code, enabling developers to leverage pre-existing functions and classes without having to write everything from scratch. This promotes organisation by keeping code modular and easy to maintain, as related functionality can be grouped together in separate modules. Efficiency is also improved, as importing modules reduces development time and allows for the use of optimised code written by experienced programmers.

From a business perspective, importing modules is highly relevant as it enables rapid development of robust, maintainable applications. By leveraging existing code, businesses can save time and resources, allowing them to focus on their core competencies and deliver value to their customers more quickly. Additionally, using well-established modules can help ensure the reliability and security of the application, which is crucial for businesses operating in today's digital landscape.
:::

# Simple Demonstration with the Datetime Module

Let's see a simple example using the `datetime` module:

```python
from datetime import datetime

# Get the current date and time
current_time = datetime.now()
print("Current date and time:", current_time)
```

This code snippet imports the `datetime` function from the datetime module, gets the current date and time, and prints it out. This can be very useful in business applications where tracking the current time is essential.

::: {.notes}
This slide demonstrates how to use the datetime module in Python to work with dates and times. The datetime module provides classes for manipulating dates and times, allowing you to perform operations such as formatting dates, calculating time differences, and handling time zones.

By importing the datetime module, you can easily create datetime objects representing specific dates and times. You can then use the various methods and attributes provided by the datetime classes to extract information like the year, month, day, hour, minute, and second from these objects. The datetime module also supports arithmetic operations on dates and times, enabling you to add or subtract time intervals and compare dates.
:::

# Activity: Explore a Module

**Your Task:**

- Write a small script that imports the `datetime` module.
- Use it to display:
  - The current date.
  - The current time.
- Experiment with formatting the output using the module's features (for example, displaying just the date or time).

Take some time to explore how modules can make your code more powerful and applicable to real-world business scenarios.

Happy coding, and enjoy expanding your Python skills with modules!

::: {.notes}
In this activity, you will explore the `datetime` module by writing a small script that imports it. The script should use the module to display the current date and time. Experiment with formatting the output using the module's features, such as displaying just the date or time.

The `datetime` module is a powerful tool for working with dates and times in Python. By learning how to use this module, you will be able to incorporate date and time functionality into your programs, which can be useful for a wide range of applications, such as scheduling, logging, and data analysis.
:::

---
title: "First Command: print()"
subtitle: "Displaying Output on the Screen"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# In this module, you will learn

  - How to display output using print()
  - Common mistakes to avoid
  - Best practices for using print()

::: {.notes}
This module will cover the fundamentals of displaying output using the `print()` function in Python. You will learn how to effectively use `print()` to show results, messages, and other information to users, which is a critical skill for any Python programmer.

The module will also discuss common mistakes to avoid when working with `print()`, such as forgetting to include parentheses or quotation marks, or using incompatible data types. Additionally, you will learn best practices for using `print()`, including how to format output, use escape characters, and print multiple items efficiently.
:::

# Introduction to `print()`

- `print()` is used to display output on the screen.
- Basic syntax: `print("Hello, World!")`
- Always use **parentheses** with `print()`.
- **Strings** must be enclosed in quotation marks.

::: {.notes}
`print()` is a fundamental function in Python used to display output on the screen. Its basic syntax is `print("Hello, World!")`, where the desired output is enclosed in parentheses and surrounded by quotation marks if it is a string. It is crucial to always use parentheses with `print()`, as failing to do so will result in an error.

When working with `print()`, it is important to keep in mind that strings must be enclosed in either single or double quotation marks. Forgetting to include quotation marks or mismatching them is a common error that can prevent the code from running correctly. By following these basic guidelines and being mindful of syntax, you can effectively use `print()` to display output and communicate information to the user.
:::

# Why `print()` is Important

- Helps check if your code is working.
- Debugging tool: find mistakes and track errors.
- Outputs text to the screen for user interaction.

::: {.notes}
print() is a fundamental function in Python that helps developers check if their code is working as expected. It serves as a valuable debugging tool, allowing programmers to identify mistakes, track errors, and gain visibility into the execution flow of their programs. By strategically placing print() statements throughout the code, developers can output relevant information and variable values, making it easier to pinpoint issues and resolve them efficiently.

Moreover, print() plays a crucial role in facilitating user interaction by outputting text to the screen. Whether it's displaying prompts, results, or messages, print() enables effective communication between the program and the user. By leveraging print() to provide meaningful output, developers can create interactive and user-friendly applications that engage and inform users throughout the execution process.
:::

# Common Errors with `print()`

1. **Missing Parentheses**
   - ❌ `print "Hello"`
   - ✅ `print("Hello")`
2. **Missing Quotation Marks**
   - ❌ `print(Hello)`
   - ✅ `print("Hello")`
3. **Case Sensitivity**
   - ❌ `Print("hello")`
   - ✅ `print("hello")`
4. **Misspellings**
   - ❌ `pint("Hello")`
   - ✅ `print("Hello")`
5. **Indentation Errors**
   - ❌ `    print("Hello")` (extra spaces)
   - ✅ `print("Hello")` (no extra spaces)

::: {.notes}
This slide  highlights several mistakes that programmers often make when using the `print()` function in Python. These errors include forgetting to use parentheses, omitting quotation marks around string literals, capitalising the function name, misspelling `print()`, and adding extra spaces before the function call. Each incorrect example is marked with a cross emoji, while the correct usage is indicated with a tick emoji.

To avoid these common pitfalls, programmers should pay close attention to the syntax of the `print()` function. The function name should be written in lowercase letters, followed by a set of parentheses containing the value or variable to be printed. String literals must be enclosed in either single or double quotation marks. Proper indentation is also crucial in Python, so any leading spaces before the `print()` function call should be removed. By keeping these guidelines in mind, programmers can ensure that their `print()` statements work as intended and produce the desired output.
:::

# Fix the Errors

- Identify and correct common mistakes in the following lines:
  ```python
  PRINT("Hello")
  print(Hello)
  pint("Hello")
  print("Missing parenthesis"
      print("Indentation error!")
  ```
- What errors do you see?
- Correct and run the fixed code.

::: {.notes}
This slide, focuses on identifying and correcting common mistakes in the provided lines of code. The presenter should guide the audience through the process of analysing the code snippets, encouraging them to spot the errors independently before revealing the solutions.

After discussing the errors and their potential fixes, the presenter should demonstrate running the corrected code to showcase the expected output. This hands-on approach will help reinforce the importance of attention to detail and the impact of even small errors on the functionality of the code.
:::

# Best Practices for `print()`

- Always use **parentheses** with `print()`.
- Enclose text in **quotation marks**.
- Watch out for **indentation errors**.
- **Spell `print` correctly** (avoid typos like `pint`).
- Keep your code **clean and readable**.

::: {.notes}
Always use parentheses when calling the `print()` function in Python. This is the correct syntax and ensures your code will run without errors. Enclose the text you want to print in quotation marks, either single or double quotes. Be careful with indentation, as incorrect indentation can lead to errors in Python. Remember, consistent indentation is crucial for defining code blocks.

Watch out for common typos when writing `print()`, such as `pint()`. These mistakes can cause frustrating errors that are easily avoided by double-checking your code. Aim to write clean and readable code by using clear variable names, adding comments where necessary, and following Python's style guidelines (PEP 8). This will make your code easier to understand and maintain, both for yourself and others who may work with your code in the future.
:::

# Key Takeaways: Working with print()

**Remember These Core Points**:
- print() displays output on your screen
- Always use parentheses and correct quotation marks
- Case sensitivity matters: print(), not Print()

**Next Steps**:
- Practice identifying and fixing common errors
- Start using print() in your own code
- Build confidence with this fundamental command

::: {.notes}
print() is a fundamental command in Python that displays output on the screen. To use it effectively, always include parentheses and the correct quotation marks around the text or variables you want to display. Python is case-sensitive, so make sure to write print() and not Print(). As you start incorporating print() into your own code, take the time to practice identifying and fixing common errors, such as missing parentheses or quotation marks.

Building confidence with print() is key to progressing in Python. Once you understand how to use this command correctly, you'll be able to display useful information for debugging and communicating with users. Don't be afraid to experiment with print() in your code, as it's a valuable tool for understanding what your program is doing at each step. With practice, you'll soon be using print() with ease and reaping the benefits of this essential Python command.
:::

---
title: "Setting Up Your Tools"
subtitle: "Colab Noteboooks & GitHub"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# In this module

- Learn essential tools for Python development
- Master Google Colab for cloud-based coding
- Understand GitHub for version control
- Discover how AI can accelerate your learning
- Get hands-on practice with real examples

::: {.notes}
In this module, you'll gain essential skills for Python development using powerful tools like Google Colab and GitHub. You'll learn how to create and run Python code in the cloud with Colab, and how to use GitHub for version control and collaboration. By the end of this module, you'll have hands-on experience with real-world examples and be ready to apply these tools to your own projects.

Throughout the module, we'll explore how AI can accelerate your Python learning journey. You'll discover practical examples of integrating AI into your workflow, and learn about AI tools specifically designed for Python development and learning. By leveraging these cutting-edge technologies, you'll be well-equipped to tackle complex problems and build innovative solutions with Python.
:::

# What is Google Colab?

- Cloud-based Jupyter Notebook environment
- No installation required
- Free GPU access for AI projects
- Ideal for learning Python in a browser

::: {.notes}
Google Colab is a cloud-based Jupyter Notebook environment that allows users to write and execute Python code directly in their web browser, without the need for any local installation. This makes it an ideal platform for learning Python, as users can start coding immediately without worrying about setting up a development environment. Additionally, Google Colab offers free access to GPUs, which is particularly useful for AI and machine learning projects that require significant computational power.

One of the key advantages of using Google Colab is its simplicity and accessibility. Users only need a Google account to get started, and they can create, save, and access their notebooks from anywhere with an internet connection. This makes it easy for learners to collaborate on projects, share their work, and learn from others in the community. Furthermore, Google Colab integrates seamlessly with other Google services, such as Google Drive and Google Sheets, allowing users to import and export data easily.
:::

# Getting Started - Google Account Required

- A **Google Account** is required to use Google Colab.
- Sign in at [colab.research.google.com](https://colab.research.google.com).
- Notebooks are stored in Google Drive.
- Can be shared and collaborated on in real-time.

::: {.notes}
To use Google Colab, you must have a Google Account. Sign in at colab.research.google.com to access the platform. Once you're signed in, your notebooks will be stored in your Google Drive, making it easy to access them from anywhere.

One of the great features of Google Colab is its collaborative capabilities. You can share your notebooks with others and work on them together in real-time, just like you would with a Google Doc. This makes it an excellent tool for team projects and group learning.
:::

# Creating Your First Notebook

- Go to Google Colab.
- Click **File > New Notebook**.
- A new notebook with a code cell will appear.
- Start writing Python code!

::: {.notes}
To create your first notebook in Google Colab, simply navigate to the Google Colab website and click on "File" in the top menu, then select "New Notebook". This will open a fresh notebook with a code cell ready for you to start writing Python code straight away.

The process of creating a new notebook in Google Colab is quick and easy, allowing you to dive right into coding without any setup or installation required. With the notebook open, you can immediately begin experimenting with Python code, exploring libraries, and building your projects in a user-friendly, cloud-based environment.
:::

# Running Your First Python Code

- Click inside a code cell.
- Type: `print("Hello, World!")`
- Press **Shift + Enter** to execute the code.
- See the output immediately!

::: {.notes}
Running your first Python code in Google Colab is straightforward. Simply click inside a code cell and type the line `print("Hello, World!")`. Once you've entered the code, press **Shift + Enter** to execute it. The output will appear immediately below the code cell, allowing you to see the results of your code instantly.

Google Colab provides an intuitive and user-friendly environment for running Python code. With the ability to execute code directly in the browser, you can quickly test and iterate on your Python scripts without the need for any additional setup. This makes it an ideal platform for beginners learning Python or for experienced developers who want to prototype ideas rapidly.
:::

# Saving and Accessing Notebooks

- Notebooks are auto-saved in **Google Drive**.
- Download as `.ipynb` or `.py` for offline use.
- Shareable via link for collaboration.
- We will be using GitHub

::: {.notes}
Google Colab notebooks are automatically saved in Google Drive, providing a convenient and secure storage solution. Users have the option to download the notebooks in either `.ipynb` or `.py` format for offline use, allowing for flexibility in working environments. The notebooks can also be easily shared with others via a shareable link, facilitating seamless collaboration among team members.

While Google Colab offers built-in saving and sharing features, the course will also utilise GitHub as an additional platform for notebook management. GitHub provides version control and collaborative features that complement Google Colab's functionality. By integrating GitHub into the workflow, users can effectively track changes, manage multiple versions of their notebooks, and collaborate with others on a larger scale.
:::

# Why Use GitHub?

- **Version control** – Keep track of code changes over time.
- **Collaboration** – Work with peers and instructors.
- **Backup & Accessibility** – Access notebooks from any device.
- **Integration with Google Colab** – Save directly from Colab to GitHub.

::: {.notes}
GitHub is an essential tool for version control, collaboration, backup, and accessibility when working with code. It allows you to keep track of changes to your code over time, ensuring that you can easily revert to previous versions if needed. GitHub also facilitates seamless collaboration with peers and instructors, enabling you to work together on projects and share your code with others.

In addition to its version control and collaboration features, GitHub provides a reliable backup solution for your code and notebooks. By storing your work on GitHub, you can access your notebooks from any device with an internet connection, giving you the flexibility to work from anywhere. Furthermore, GitHub integrates seamlessly with Google Colab, allowing you to save your notebooks directly from Colab to your GitHub repository, streamlining your workflow and ensuring that your work is always up to date.
:::

# Setting Up GitHub in Google Colab

- A **GitHub account** is required ([Sign up](https://github.com/))
- Authorize **Google Colab** to access GitHub.
- Create a new **repository** or use an existing one.

::: {.notes}
Setting up GitHub in Google Colab is a straightforward process that requires a GitHub account. If you don't have one, you can easily sign up on the GitHub website. Once you have an account, you need to authorise Google Colab to access your GitHub repositories. This allows seamless integration between the two platforms, enabling you to save and manage your Colab notebooks using version control.

After linking your GitHub account, you can either create a new repository or use an existing one to store your Colab notebooks. Creating a dedicated repository for your Colab projects helps keep your work organised and easily accessible. With GitHub set up, you're ready to start saving, sharing, and collaborating on your Colab notebooks, leveraging the power of version control and the convenience of cloud-based development.
:::

# Connecting Google Colab to GitHub

- Open **Google Colab**.
- Click **File > Save a Copy in GitHub**.
- Select a repository and add a commit message.
- Click **OK** to upload.

::: {.notes}
To connect Google Colab to GitHub, start by opening Google Colab in your web browser. Once the Colab interface loads, click on the "File" menu and select "Save a Copy in GitHub" from the dropdown options. This will initiate the process of linking your Colab notebook to a GitHub repository.

After selecting "Save a Copy in GitHub", a new window will appear prompting you to choose a repository where you want to save your notebook. Select the desired repository from the list and enter a commit message to describe the changes you're making. Once you've chosen the repository and added a commit message, click the "OK" button to finalise the upload process and establish the connection between your Colab notebook and the selected GitHub repository.
:::

# Retrieving and Updating Notebooks from GitHub

- Open a **GitHub repository**.
- Click on the **notebook file (.ipynb)**.
- Click **Open in Colab** to edit.
- After modifications, **save back to GitHub**.

::: {.notes}
To retrieve and update notebooks from GitHub, start by opening the GitHub repository containing your notebook files. Locate the specific notebook you wish to edit, identifiable by the .ipynb file extension, and click on it. GitHub will display a preview of the notebook's contents. To make changes, click the "Open in Colab" button, which will launch the notebook in Google Colab, a cloud-based Python development environment.

Once you've made the necessary modifications to your notebook in Google Colab, save the changes by clicking the "File" menu and selecting "Save a copy in GitHub". This action will commit the updated notebook back to your GitHub repository, ensuring that the latest version is accessible for future reference or collaboration. By following these steps, you can seamlessly retrieve notebooks from GitHub, make edits in Google Colab, and push the changes back to the repository, streamlining your workflow and facilitating effective version control.
:::

# Best Practices for Saving Notebooks

- Write **clear commit messages** (e.g., "Updated data analysis section").
- Regularly **push updates** to GitHub to prevent data loss.
- Use **branches** for experimental changes before merging into the main repository.
- Keep notebooks **organized** within folders in your repository.

::: {.notes}
When saving notebooks in Google Colab, it's important to follow best practices to ensure your work is organised, secure, and easily accessible. Write clear commit messages that concisely describe the changes you've made, such as "Updated data analysis section", to help you and your collaborators understand the progress of your project. Regularly push updates to GitHub to prevent data loss and maintain a backup of your work in case of any unexpected issues with Google Colab.

To keep your repository clean and manageable, use branches for experimental changes before merging them into the main repository. This allows you to test new ideas without affecting the main codebase. Additionally, keep your notebooks organised within folders in your repository, making it easier to navigate and find specific files when needed. By following these best practices, you'll create a more efficient and productive workflow while collaborating with others on your Google Colab projects.
:::

# Common Issues and Fixes

- **Can't access Google Colab?** Check if you're logged into a Google Account.
- **Code not running?** Check for syntax errors in your Python code.
- **Authorization errors** – Ensure Google Colab has GitHub access.
- **Repository not showing?** – Refresh Colab or check GitHub permissions.
- **Failed to save?** – Check internet connection or re-authenticate.

::: {.notes}
This slide covers common issues you may encounter when working with Google Colab and GitHub, along with their respective solutions. If you can't access Google Colab, the first step is to ensure you're logged into a valid Google Account. Code not running is often due to syntax errors in your Python code, so double-check for any mistakes. Authorization errors can be resolved by granting Google Colab access to your GitHub account. If your repository isn't showing up, try refreshing Colab or verifying your GitHub permissions.

Lastly, if you're unable to save your work, check your internet connection and re-authenticate if necessary. These troubleshooting tips should help you overcome the most frequent obstacles and maintain a smooth workflow between Google Colab and GitHub. Don't hesitate to refer back to this slide if you run into any of these issues during your hands-on practice session or future projects.
:::

# Hands-on Practice

- Save a sample notebook to GitHub.
- Retrieve and modify it from GitHub.
- Commit changes with a clear message.
- Open your updated notebook in Colab.

::: {.notes}
Save a sample notebook to your GitHub repository, then retrieve and modify it from GitHub. When committing changes, use a clear and descriptive message to document the modifications made. Once the changes are committed, open the updated notebook in Google Colab to confirm the changes have been successfully applied.

This hands-on practice reinforces the concepts covered in the previous slides, such as setting up GitHub in Google Colab, connecting Google Colab to GitHub, and retrieving and updating notebooks from GitHub. By following best practices for saving notebooks and providing clear commit messages, you can effectively manage your notebooks and collaborate with others on your Python projects.
:::

# How AI Can Accelerate Your Python Learning

- **AI-Powered Code Suggestions:**  
  Tools like GitHub Copilot and ChatGPT offer real-time code completions and ideas.
  
- **Instant Explanations & Debugging:**  
  Use AI to explain error messages, clarify complex code segments, and suggest fixes.
  
- **Generate & Refactor Code:**  
  Let AI propose code samples or refactor existing code to improve efficiency.
  
- **Access to Summarized Documentation:**  
  Quickly get overviews of Python libraries and algorithms to enhance understanding.


---

::: {.notes}
* AI can provide intelligent code suggestions as you type, helping you write Python code faster and more efficiently. It can recommend relevant libraries, functions, and syntax based on your context, reducing the need for manual lookups and speeding up your coding process.

* AI can explain code snippets, identify potential bugs, and suggest fixes, saving you time in debugging. It can generate and refactor code based on your requirements, handle repetitive tasks, and provide summarized documentation, making it easier to understand and use new libraries or frameworks in your Python projects.
:::

# Practical Examples: Integrating AI in Your Workflow

- **Debugging Assistance:**  
  Paste error messages into ChatGPT for step-by-step debugging help.
  
- **Real-Time Code Suggestions:**  
  Use GitHub Copilot in Google Colab to get instant code completions and alternative approaches.
  
- **Learning New Libraries:**  
  Ask AI for concise summaries and usage examples when exploring unfamiliar Python libraries.
  
- **Interactive Q&A Sessions:**  
  Engage with AI to answer questions about Python syntax, logic, and best practices during your coding sessions.

::: {.notes}
Practical examples of integrating AI into your Python workflow include debugging assistance, where AI can help identify and fix errors in your code, saving you time and frustration. AI can also provide real-time code suggestions, offering intelligent recommendations as you type, which can improve your coding efficiency and help you discover new ways to solve problems. When learning new libraries, AI can quickly provide relevant documentation, usage examples, and answers to your questions, accelerating your learning process. Interactive Q&A sessions with AI allow you to dive deeper into Python concepts, clarify doubts, and receive personalised explanations tailored to your level of understanding.

By leveraging these AI-powered tools and techniques, you can streamline your Python development process, overcome challenges more easily, and expand your knowledge at a faster pace. Whether you're a beginner or an experienced programmer, integrating AI into your workflow can help you write better code, learn new concepts efficiently, and solve complex problems with greater ease. As you continue to explore the possibilities of AI in Python development, you'll find even more ways to enhance your productivity and take your skills to the next level.
:::

# AI Tools for Python & Learning

| AI Tool | Coding (Python) | Setup Difficulty |
|---|---|---|
| ChatGPT (OpenAI) | Excellent | Easiest (Sign up) |
| Gemini (Google) | Good | Easiest (Google account) |
| LLaMA (Meta AI) | Good | Medium (Technical setup) |
| Claude (Anthropic) | Good | Easiest (Sign up) |
| GitHub Copilot | Excellent | Easy (Extension install) |
| Perplexity.ai | Good | Easiest (Web access) |
| Bing (Microsoft) | Good | Easiest (Built-in) | 
| Leo (Brave) | Basic | Easiest (Built-in) |
| Bard (Google) | Good | Easiest (Google account) |
| Hugging Face | Varies | Medium (Technical knowledge) |
| DeepSeek AI | Excellent | Medium (Technical knowledge) |
| Phi (Microsoft) | Good | Medium (Technical knowledge) |

**Disclaimer:** This infographic is for informational purposes only.  The AI landscape is constantly changing.  Verify the information and consider your specific needs before choosing an AI model or tool.  This is not an exhaustive list, and other excellent AI models and tools are available.  Always review the terms of service and privacy policies of the respective providers.

::: {.notes}
AI tools like ChatGPT can accelerate your Python learning by providing instant explanations, code examples, and troubleshooting help. These AI assistants can answer your Python questions, clarify concepts, and even help you write and debug code. They're like having a personal Python tutor available 24/7.

Integrating AI into your Python workflow can boost your productivity and capabilities. For example, you can use AI to auto-generate boilerplate code, refactor existing code, and even get AI-powered code suggestions and completions as you type. AI can also help with tasks like data analysis, visualisation, and machine learning in Python.
:::

# Key Takeaways

  - Google Colab for cloud-based Python development
  - GitHub for version control and collaboration
  - Saving and retrieving work from GitHub
  - Access to powerful AI coding assistants
  - Enhanced learning through AI-powered tools
  - Faster development with intelligent suggestions

::: {.notes}
In this slide, we've highlighted the key takeaways from our exploration of using Google Colab and GitHub for Python development. Google Colab provides a cloud-based platform that allows you to write and run Python code without the need for local setup, while GitHub enables version control and collaboration, making it easy to save, retrieve, and share your work with others. By leveraging these tools, you can access powerful AI coding assistants that offer intelligent suggestions and help accelerate your development process.

Moreover, we've discussed how AI-powered tools can enhance your learning experience by providing tailored guidance and real-time feedback. These tools can help you grasp complex concepts more quickly and efficiently, enabling you to focus on applying your knowledge to practical projects. As you continue your Python journey, remember to take advantage of these resources to streamline your workflow and unlock new possibilities in your programming endeavours.
:::

# Next Steps

Start practising with these tools by creating your first notebook and connecting it to GitHub. Remember that mastering these foundational tools will accelerate your Python learning journey.

::: {.notes}
- Explore the wealth of resources available, such as online tutorials, coding challenges, and open-source projects to continue honing your Python skills and expanding your knowledge of AI applications
- Consider joining coding communities, attending workshops or conferences, and collaborating with others to stay motivated, learn from shared experiences, and discover new opportunities to apply your skills in real-world projects
:::

---
title: "Introduction to AI-First Python"
subtitle: "Build real-world business projects with AI-assisted learning!"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# In this module, you will learn

- Learn Python with AI-powered assistance
- Focus on practical, hands-on coding
- Build real business applications
- Master essential development tools
- Make learning efficient and engaging

::: {.notes}
In this module, you'll learn Python through AI-powered assistance that focuses on practical, hands-on coding. You'll build real business applications while mastering essential development tools, making the learning process efficient and engaging.

The AI-first approach will guide you in applying Python to solve real-world problems, providing support and feedback along the way. By working on concrete projects, you'll gain valuable experience and a deep understanding of Python's capabilities in a business context.
:::

# AI-First Python: Build real-world business projects with AI-assisted learning!

- Learn Python efficiently and effectively
- Build long-term programming skills
- Engage in hands-on coding
- Make learning fun and interactive

::: {.notes}
Learn Python programming efficiently and effectively through our AI-assisted course, designed to help you build long-term coding skills for real-world business applications. Our hands-on approach ensures you actively engage in the learning process, making it both fun and interactive.

This course employs a flipped classroom methodology, providing you with the tools and best practices needed to study, practice, and master Python programming. With AI as your coding assistant, you'll develop the knowledge and skills required to tackle complex business projects, while our focus on active learning ensures lasting results.
:::

# Why Python?!

- **Easy to learn** – Simple syntax, beginner-friendly
- **Powerful** – Used in data science, web dev, AI, etc.
- **Widely used** – Popular in industry and academia

::: {.notes}
Python is an excellent language for beginners and experienced programmers alike. Its simple, intuitive syntax makes it easy to learn, even for those with no prior coding experience. Despite its beginner-friendly nature, Python is a powerful language used in various domains such as data science, web development, and artificial intelligence, demonstrating its versatility and robustness.

Python's widespread popularity in both industry and academia is a testament to its usefulness and practicality. Many leading companies and educational institutions have adopted Python, ensuring that skills acquired in this language are highly sought-after in the job market. Python's extensive library ecosystem and supportive community further contribute to its appeal, providing developers with a wealth of resources and tools to tackle diverse challenges efficiently.
:::

# Python for Business Applications

- Automate repetitive tasks (e.g., sending emails to customers)
- Process and analyse data
- Build AI-powered business tools

::: {.notes}
Python is a versatile language that can be used to automate repetitive tasks in business, such as sending emails to customers, saving time and reducing errors. It also provides powerful libraries for processing and analysing data, enabling businesses to gain valuable insights and make data-driven decisions.

Furthermore, Python can be used to build AI-powered business tools, such as chatbots and recommendation systems, which can improve customer experience and streamline operations. With its simplicity, flexibility, and extensive ecosystem, Python is an excellent choice for developing business applications that leverage the power of AI.
:::

# Course Projects & Expectations

- Hands-on projects from Day 1
- Build real-world Python applications (e.g., a program to analyse sales data)
- Learn through practical problem-solving

::: {.notes}
In this module, you'll engage in practical projects from the very beginning, enabling you to apply your Python skills to real-world business scenarios. For instance, you might develop a program to analyse sales data, allowing you to gain valuable insights while honing your coding abilities through hands-on experience.

By focusing on practical problem-solving, you'll acquire a deep, lasting understanding of Python and its applications in a business context. This approach will equip you with the confidence and expertise to tackle a wide range of challenges in your professional life, as you'll have the opportunity to learn by doing and see the tangible results of your efforts.
:::

# A Flipped Classroom Approach!

- Watch short tutorials before class
- Code during class with guidance
- Collaborate with peers
- Immediate feedback for better learning

::: {.notes}
In this flipped classroom approach, students watch short tutorial videos before class to gain a foundational understanding of the concepts. Class time is then dedicated to coding practice with guidance from the instructor, allowing for immediate feedback and clarification of any questions. This active learning approach promotes better retention and application of the material.

Collaboration with peers is also encouraged in this flipped classroom model. Students work together during class to solve problems and share insights, fostering a supportive learning environment. The combination of self-paced tutorials, hands-on coding practice, and peer collaboration creates a well-rounded learning experience that caters to different learning styles and provides immediate feedback for optimal growth.
:::

# Tools You'll Use

- **Google Colab** – Cloud-based Python coding
- **GitHub** – Version control & collaboration (track changes, work together)
- **Class Resources** – Guides, videos, and exercises

::: {.notes}
In this slide, we will introduce the key tools you'll be using throughout the course. Google Colab is a cloud-based Python coding environment that allows you to write and run Python code directly in your web browser, making it easy to get started without the need for local setup. GitHub is a version control and collaboration platform that enables you to track changes to your code, work together with others on projects, and manage your codebase effectively.

Finally, we'll provide you with a range of class resources, including guides, videos, and exercises, to support your learning journey. These resources are designed to help you grasp the concepts, apply them in practice, and reinforce your understanding of Python programming for business applications.
:::

# Active Learning for Lasting Results

- Hands-on learning boosts retention
- Read less, do more
- Build confidence, not frustration

::: {.notes}
Active learning is a powerful approach that emphasises hands-on engagement and practical application, resulting in improved retention of knowledge. By prioritising active participation over passive reading, learners develop a deeper understanding of the subject matter and build confidence in their abilities. This approach minimises frustration by providing opportunities for practical experience and real-world problem-solving.

Incorporating active learning strategies, such as hands-on projects, coding exercises, and collaborative activities, creates a dynamic and engaging learning environment. Learners are encouraged to apply their knowledge in meaningful ways, reinforcing key concepts and developing practical skills. By focusing on active participation, learners are better equipped to tackle real-world challenges and develop a strong foundation in the subject matter.
:::

# AI as Your Coding Assistant

- AI can help you generate and refine code (e.g., suggest better ways to write your code)
- Use AI for debugging and optimisation (e.g., help you find and fix errors)
- AI-assisted learning boosts efficiency

::: {.notes}
AI can help you write better code, find and fix errors, and boost your efficiency as a programmer. It can suggest improvements to your code, assist with debugging, and provide optimisation recommendations.

Leveraging AI as your coding assistant is a powerful way to accelerate your learning and development process. By using AI-powered tools, you can get real-time feedback, quickly identify and resolve issues, and ultimately write higher-quality code in less time.
:::

# Best Practices for Learning

- Use a **physical keyboard** (not mobile devices)
- Pay attention to **syntax and formatting** (e.g., proper indentation makes your code easier to read)
- Follow industry standards for clean code

::: {.notes}
Using a physical keyboard, rather than mobile devices, can significantly improve your coding experience and productivity. A full-size keyboard allows for faster and more accurate typing, which is crucial when working with complex code structures. Additionally, using a physical keyboard reduces the likelihood of making errors caused by small screen sizes and touch input on mobile devices.

Paying attention to syntax and formatting, such as proper indentation, is essential for writing clean and readable code. Following industry standards for code formatting not only makes your code easier to understand for yourself but also for other developers who may work with your code in the future. Well-formatted code is more maintainable, reduces the likelihood of errors, and demonstrates professionalism in your work.
:::

# Study, Practice, Rest!

- Study a topic for 5-10 min
- Practise coding for 10-15 min
- Take breaks to absorb learning

::: {.notes}
To maximise your learning effectiveness, employ a structured approach of focused study sessions, coding practice, and rest breaks. Begin by dedicating 5-10 minutes to studying a specific topic, ensuring you grasp the fundamental concepts and principles. Follow this with 10-15 minutes of hands-on coding practice, applying the knowledge you've just acquired to solidify your understanding through practical implementation.

Equally important to the study and practice sessions are the breaks in between. These intervals allow your brain to process and absorb the new information, facilitating the transfer of knowledge from short-term to long-term memory. By striking a balance between focused learning and restorative rest, you optimise your cognitive performance and enhance your overall learning outcomes.
:::

# Let's Get Started!

- Start coding from Day 1
- Ask questions, collaborate, and experiment
- Learning is a journey—enjoy it!

::: {.notes}
Let's dive into the exciting world of coding with an AI-first approach to learning Python! From day one, you'll be hands-on, writing code and building real-world business projects. Don't be afraid to ask questions, collaborate with your peers, and experiment with different solutions. Remember, making mistakes is a natural part of the learning process.

Learning to code is a lifelong journey, and this course is just the beginning. Embrace the challenges, celebrate your successes, and most importantly, have fun along the way! With the power of AI-assisted learning, you'll be amazed at how quickly you can progress from a beginner to a confident Python programmer. Get ready to unlock a world of possibilities and embark on an unforgettable learning adventure!
:::

# Key Takeaways: AI-First Python Course

- Learn Python through hands-on coding with AI assistance
- Use modern tools including Google Colab for cloud coding and GitHub for version control
- Follow a flipped classroom model: watch short tutorials before class, code during sessions with instructor guidance
- Practice in short, focused sessions (5-10 min study + 10-15 min coding) for optimal learning
- Leverage AI assistance for code generation, debugging, and optimisation to accelerate your learning journey

::: {.notes}
This slide highlights the key elements of the AI-First Python course, which focuses on hands-on coding with AI assistance using modern tools like Google Colab and GitHub. The course follows a flipped classroom model, where students watch short tutorials before class and then code during sessions with instructor guidance.

For optimal learning, the course encourages students to practice in short, focused sessions of 5-10 minutes of study followed by 10-15 minutes of coding. AI assistance is leveraged for code generation, debugging, and optimisation, accelerating the learning journey.
:::

---
title: "Week 1 FAQ"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

1. What is the core philosophy of the AI-First Python course?
The AI-First Python course focuses on building real-world business projects through hands-on coding and AI-assisted learning. The aim is to develop long-term programming skills in an efficient and engaging manner, moving away from passive learning towards active problem-solving. It ensures you’re not just memorising concepts but applying them practically from day one.

2. Why should I learn Python?
Python is an excellent choice because it is easy to learn with its simple syntax and beginner-friendly nature. It is also a powerful and versatile language used in data science, web development, and artificial intelligence. Its widespread use in both industry and academia ensures a strong community, abundant resources, and plentiful job opportunities.

3. How will this course prepare me for real-world applications?
This course emphasizes real-world business applications, covering areas such as automating repetitive tasks (e.g., email automation), processing and analysing data, and building AI-powered business tools. You’ll work on projects that directly align with business needs, ensuring the skills learned are immediately applicable in a professional setting. For instance, you might build a program to analyse sales data.

4. What is the "Flipped Classroom" approach used in this course?
The flipped classroom model involves watching short tutorials before class and then using class time for hands-on coding exercises with guidance from the instructor and collaboration with peers. This approach allows for immediate feedback and a more interactive learning experience, enabling you to apply what you've learned through practical challenges. It allows you to come to class prepared with questions and ready to apply your knowledge.

5. What tools will I be using in this course?
You will primarily use Google Colab for cloud-based Python coding, which eliminates the need for local installations. GitHub will be used for version control and collaborative coding, helping you track changes and work effectively in teams. You'll also be provided with comprehensive course resources, including guides, videos, and exercises.

6. How does AI assist in learning within this course?
AI is integrated to help generate and refine code, providing suggestions for improvement, and to assist in debugging and optimisation by identifying and helping fix errors. This AI-assisted learning boosts efficiency by providing personalised feedback and adapting to your learning pace.

7. What strategies should I adopt to maximise my learning in this course?
Adopting a structured approach which includes using a physical keyboard for accurate input, paying close attention to syntax and formatting for readable code, and adhering to industry standards for clean code. It’s beneficial to study in short bursts (5-10 minutes), followed by coding practice (10-15 minutes), and taking regular breaks to absorb the learning effectively.

8. What if I get stuck or have questions during the course?
This course encourages active participation through asking questions, collaborating with peers, and experimenting with different approaches. You're encouraged to start coding from day one and not hesitate to seek help or advice from instructors or classmates. The learning process is viewed as a journey, and support will be available throughout.

9. What are Google Colab and GitHub, and why are they useful for Python development?
Google Colab is a cloud-based Jupyter Notebook environment, allowing you to write and run Python code in your browser without requiring any local installation. It even offers free GPU access, which is particularly helpful for AI and machine learning projects. GitHub is a version control and collaboration platform, essential for tracking code changes over time, working with others, backing up your work, and accessing your projects from anywhere. Using these tools together provides a powerful, accessible, and collaborative environment for learning and developing Python.

10. How do I get started with Google Colab?
You need a Google Account to use Google Colab. Simply sign in at colab.research.google.com. Once logged in, your notebooks are automatically stored in Google Drive, making them accessible from any device. To create a new notebook, click "File" then "New Notebook." A code cell will appear, ready for you to start writing Python code.

11. How do I run Python code in Google Colab?
Click inside a code cell, type your Python code (e.g., print("Hello, World!")), and press Shift + Enter to execute the code. The output will appear directly below the code cell. This makes testing and iterating on your code quick and easy.

12. How do I save my Google Colab notebooks and access them later?
Google Colab notebooks are automatically saved in your Google Drive. You can also download them as .ipynb or .py files for offline use. Furthermore, you can save a copy directly to GitHub for version control and collaboration.

13. How do I connect Google Colab to GitHub?
First, you need a GitHub account. Then, in Google Colab, click "File" > "Save a Copy in GitHub." You'll be prompted to authorise Google Colab to access your GitHub account. Select the desired repository and add a commit message, then click "OK" to upload the notebook.

14. How do I retrieve and update notebooks from GitHub using Google Colab?
Open the GitHub repository containing the notebook. Click on the .ipynb file you want to edit. On the GitHub page, click "Open in Colab". This will open the notebook in Google Colab. After making changes, save the updated notebook back to GitHub by going to "File" and selecting "Save a copy in GitHub." Remember to include a descriptive commit message.

15. What are some best practices for saving notebooks to GitHub from Google Colab?
Write clear and concise commit messages to describe the changes you've made. Regularly push updates to GitHub to prevent data loss. Use branches for experimental changes before merging them into the main repository. Keep notebooks organised within folders in your repository for easy navigation.

16. How can AI tools accelerate my Python learning and development process?
AI tools like ChatGPT and GitHub Copilot can provide real-time code suggestions, instant explanations of code and errors, and generate/refactor code to improve efficiency. They can also provide summaries of Python libraries and algorithms, helping you quickly understand complex concepts. By integrating AI into your workflow, you can write code faster, debug more efficiently, and learn new concepts more easily.


17. What is the primary function of print() in Python?
The print() function is primarily used to display output on the screen. This could be text, the value of a variable, or the result of a calculation. It's a fundamental way for your Python code to communicate information to the user or to you, the programmer.

18. What is the correct syntax for using the print() function?
The correct syntax is print(), with parentheses. If you want to display text, it should be enclosed in quotation marks (either single or double) inside the parentheses, for example, print("Hello, World!"). It is also possible to insert a variable name or names between the parenthesis to print out the value of the specified variable.

19. Why is the print() function considered important for programmers?
The print() function is important for several reasons. It helps in checking if your code is working as expected, it is a debugging tool to find mistakes and track errors by displaying variable values at different stages, and it outputs text to the screen, facilitating user interaction by displaying prompts, results, or messages.

20. What are some common errors to avoid when using print()?
Common errors include: forgetting parentheses (e.g., print "Hello" instead of print("Hello")), missing quotation marks around strings (e.g., print(Hello) instead of print("Hello")), incorrect capitalisation (e.g., Print("Hello") instead of print("Hello")), misspelling the function name (e.g., pint("Hello") instead of print("Hello")), and unintended indentation.

21. How does case sensitivity affect the use of print()?
Python is case-sensitive. Therefore, print() must be written in lowercase. Using Print(), PRINT(), or any other variation will result in an error.

22. Are there any specific formatting techniques or best practices when using print()?
Yes, always use parentheses, enclose text in quotation marks, watch out for indentation errors (especially leading spaces), and spell print correctly. Additionally, aim for clean and readable code by using clear variable names and following style guidelines.

23. Why is using parentheses important with print()?
Using parentheses with print() is crucial as it's part of the correct function syntax in Python 3. Forgetting them will lead to a SyntaxError. The parentheses enclose the arguments or values you want to display.

24. What are the next steps to take after understanding the basics of print()?
Practice identifying and fixing common errors when using print(), begin incorporating print() statements into your own code for debugging and displaying information, and continue building confidence with this fundamental command through consistent practice.
### **🚀 How to Create a Free Google Gemini (Formerly Bard) Account**  
Google Gemini is an AI-powered chatbot similar to ChatGPT, and it's free to use with a Google account.

---

### **📌 Step 1: Go to the Google Gemini Website**  
1. Open your web browser and go to **[https://gemini.google.com](https://gemini.google.com)**.  
2. Click **“Sign In”** (top right corner).

---

### **📌 Step 2: Sign in with Your Google Account**  
✅ If you already have a **Gmail account**, simply log in.  
✅ If you **don’t have a Google account**, click **“Create account”** and follow the instructions.

---

### **📌 Step 3: Agree to the Terms of Use**  
1. Read Google's **terms & conditions** for using Gemini.  
2. Click **“Agree & Continue”** to proceed.

---

### **📌 Step 4: Start Using Google Gemini**  
1. After signing in, you’ll be directed to **Gemini’s chat interface**.  
2. Type your **question or prompt** in the text box and hit **Enter**.  
3. Google Gemini will generate a response—ask follow-up questions to refine your results.

---

### **📌 Optional: Use Gemini on Mobile**  
- Gemini is available in the **Google app** (iOS & Android).  
- You can access it by searching for **Gemini** in Google Assistant.

---

### **🚀 Tips for Using Google Gemini Effectively**  
✅ **Use clear prompts:** _"Explain CSS Grid vs. Flexbox with examples."_  
✅ **Ask for improvements:** _"Make this JavaScript function more efficient."_  
✅ **Use it for coding help, explanations, and brainstorming ideas.**  
✅ **Compare outputs with ChatGPT** for different AI perspectives.

---

### **🚀 Need Help?**  
If you have trouble accessing Gemini:  
- **Ensure your Google account is active.**  
- **Some regions may not support Gemini yet.**  
- **Use a VPN** if Gemini is unavailable in your country.  
# 🚀 AI Models & Tools Comparison: Infographic Guide (v1.1 - *Illustrative Example - Subject to Change*)

**📌 Overview**

This infographic provides a side-by-side comparison of major AI models and tools to help users understand their strengths, weaknesses, and best use cases.  **Note:** The AI landscape is rapidly evolving.  This information is for illustrative purposes and should be verified before making decisions.

---

## 📌 AI Models Comparison

| AI Model/Tool | Description | Text Gen. (Creative) | Text Gen. (Factual) | Coding (Python) | Context Window | Multimodal | Cost (API) | Data Privacy | Example Use Cases |
|---|---|---|---|---|---|---|---|---|---|
| ChatGPT (OpenAI) | Large language model accessible via web interface and API. | High | High | Excellent | 8,192 tokens (GPT-3.5) / 32,768 tokens (GPT-4) | No (GPT-3.5) / Yes (GPT-4) | Varies (usage-based) | OpenAI data policies | Creative writing, chatbots, code generation, translation |
| Claude (Anthropic) | Large language model focused on helpful and harmless responses. | Medium | High | Good | 100,000 tokens | No | Varies (usage-based) | Anthropic data policies | Summarization, long-form content, legal documents, customer support |
| Gemini (Google) | Multimodal large language model integrated with Google services. | Medium | Very High | Good | Varies | Yes (text, images, code) | Varies (usage-based) | Google data policies | Fact-checking, research, image analysis, Google Docs integration |
| LLaMA (Meta AI) | Open-source large language model for research and development. | Medium | Medium | Good | Varies (model size dependent) | No | N/A (base model) | User-controlled (local) | Custom AI model development, research, fine-tuning |
| Phi (Microsoft) | Lightweight large language model designed for efficiency. | Medium | Medium | Good | Varies | No | N/A (base model) | User-controlled (local) | Edge AI applications, resource-constrained devices |
| Groq AI | Focuses on low-latency AI inference. | N/A | High (for specific tasks) | Limited | N/A | No | Varies (usage-based) | Groq data policies | Fast Q&A, API integrations, real-time applications |
| DeepSeek AI | Designed for research and complex problem-solving. | Medium | Very High (for specific domains) | Excellent | Varies | No | Varies (usage-based) | DeepSeek data policies | Scientific research, technical analysis, complex reasoning |

**Key Considerations:**

* **Context Window:**  Indicates how much previous text the model can consider. Larger windows enable better understanding of long conversations or documents.
* **Multimodal:**  Indicates the ability to process different data types (text, images, code).
* **Cost (API):**  Refers to the pricing for accessing the model via API.  Pricing models vary.
* **Data Privacy:**  Refers to the data handling practices of the provider.  Review their privacy policies.
* **LLaMA and Phi:** These are base models, not end-user applications.  They require technical expertise to use.  Ollama is a tool that helps run these models locally.

---

## 📌 AI Tool Setup & Performance Comparison

| AI Tool | Setup Difficulty | Performance Speed | Best Feature | Best For |
|---|---|---|---|---|
| ChatGPT (Web) | ✅ Easiest (Sign up) | ⚡ Medium | Coding assistance, general-purpose AI | Learning, coding, research, general tasks |
| ChatGPT (API) | ⚠️ Medium (API key required) | ⚡ Fast | Integration into applications | Custom applications, automation |
| Claude (Web) | ✅ Easiest (Sign up) | ⚡ Medium | Long context window | Writing, summarization, legal applications |
| Claude (API) | ⚠️ Medium (API key required) | ⚡ Fast | Integration into applications | Custom applications, long-form content processing |
| Gemini (Web) | ✅ Easiest (Google account) | ⚡ Medium | Google integration, multimodal | Research, fact-checking, multimodal tasks |
| Gemini (API) | ⚠️ Medium (API key required) | ⚡ Fast | Integration into applications | Custom applications, multimodal processing |
| Groq AI | ✅ Easiest (Web-based) | 🚀 Ultra-fast | Low-latency inference | Real-time applications, fast Q&A |
| LLaMA (Local - Ollama) | ⚠️ Medium (Technical setup) | ⚡ Fast (with GPU) | Runs offline, customizable | AI research, custom model development |
| Phi (Local - Ollama) | ⚠️ Medium (Technical setup) | ⚡ Fast (with GPU) | Lightweight, efficient | Edge AI, low-power devices |
| DeepSeek AI (API) | ⚠️ Medium (Technical setup) | ⚡ Fast | Research-focused, deep reasoning | Scientific research, technical analysis |

---

## 🚀 Final Takeaways: Which AI Should You Use? (Illustrative Examples)

* **Need AI for coding/debugging?** → ChatGPT
* **Want AI for social media/chat apps?** →  (Consider specific features within social media platforms.  No single "Meta AI" tool.)
* **Need AI for long-form writing/summaries?** → Claude
* **Looking for fact-checking & research?** → Gemini
* **Need ultra-fast AI responses?** → Groq AI
* **Want a customizable offline AI?** → LLaMA (requires technical expertise) or Phi (requires technical expertise)
* **Best AI for research?** → DeepSeek AI, LLaMA (for custom models)

**Disclaimer:** This infographic is for informational purposes only.  The AI landscape is constantly changing.  Verify the information and consider your specific needs before choosing an AI model or tool.  This is not an exhaustive list, and other excellent AI models and tools are available.  Always review the terms of service and privacy policies of the respective providers.### **🚀 How to Create and Use Groq AI Chatbot**  

**Groq AI** is an ultra-fast AI chatbot designed for **real-time responses, coding assistance, and AI-powered research**. It utilizes **LLama-based AI models (Meta’s LLaMA)** for efficient text generation.

---

### **📌 Step 1: Access Groq AI**  
You can use Groq AI via:  
✅ **Web App**: Visit **[https://chat.groq.com](https://chat.groq.com/)**.  
✅ **API Access**: Available for developers via **Groq API** (may require setup).  

---

### **📌 Step 2: Sign Up for a Free Account**  
1. Go to **[https://chat.groq.com](https://chat.groq.com/)**.  
2. Click **"Sign Up"** or **"Sign In"**.  
3. Choose to sign in using:  
   - **Google Account**  
   - **Email & Password**  
4. Verify your email (if required) and log in.  

---

### **📌 Step 3: Start Chatting with Groq AI**  
Once logged in, **enter a prompt** in the chat window and start interacting.

✅ **Example Prompts:**  
- _"Explain how CSS media queries work for responsive design."_  
- _"Generate an optimized JavaScript function for sorting an array."_  
- _"What are the benefits of using headless WordPress?"_  

---

### **📌 Step 4: Using Groq AI for Web Development**  
✅ **Code Generation:** _"Write a React component for a dynamic contact form."_  
✅ **Debugging Assistance:** _"Why is my Python Flask app throwing a 500 error?"_  
✅ **AI Code Comparison:** _"Compare AI-generated code vs. human-written code for efficiency."_  
✅ **AI-Enhanced Research:** _"Summarize the differences between GraphQL and REST APIs."_  

---

### **📌 Step 5: Optional – Groq API for Developers**  
For **developers**, Groq AI offers API integration:  
1. Visit **[https://groq.com](https://groq.com/)**.  
2. Sign up for API access.  
3. Use API keys to integrate AI-powered text generation into applications.  

---

### **🚀 Tips for Using Groq AI Effectively**  
✅ **Use detailed prompts** (_e.g., “Explain CSS Grid with a real-world example”_).  
✅ **Ask for code optimization** (_e.g., “Improve the efficiency of this JavaScript function”_).  
✅ **Use it as a debugging assistant** to fix errors in web development projects.  

---

### **📌 Troubleshooting Access Issues**  
- **Ensure Groq AI is available in your region** (some AI tools have restricted access).  
- **Try different browsers** if the chat interface is slow.  
- **Clear cache & cookies** if login issues occur.  
---
title: "GitHub Account Creation and Sign-In Process"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## # [GitHub](https://github.com/)


### 1. Click on Sign up

Go to https://github.com

![Step 1 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/47a79e8c-9093-48ec-868a-feab89e37873/f7344edd-7bfc-4691-8049-1b6081288248.png?crop=focalpoint&fit=crop&fp-x=0.9376&fp-y=0.0902&fp-z=2.8881&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=877&mark-y=148&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTImaD0xMDImZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 2. Type "student@student.curtin.edu.au"

Type in your email

![Step 2 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/4c24dd5d-150c-425d-8b14-c2a8149ac8f5/2afef3d7-b4cc-4359-a172-73d543ca500c.png?crop=focalpoint&fit=crop&fp-x=0.7504&fp-y=0.2156&fp-z=2.3838&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=114&mark-y=334&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz05NzImaD05OSZmaXQ9Y3JvcCZjb3JuZXItcmFkaXVzPTEw)


### 3. Type password
![Step 3 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/aabf347a-f761-41b9-9b21-05557f107fd0/e6dcf7e8-3ea8-40ee-8994-2031d92f7165.png?crop=focalpoint&fit=crop&fp-x=0.7504&fp-y=0.3075&fp-z=2.3838&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=114&mark-y=335&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz05NzImaD05NyZmaXQ9Y3JvcCZjb3JuZXItcmFkaXVzPTEw)


### 4. Type in your username
![Step 4 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/5ad4edfa-0b93-4fec-8fe7-f768917efde1/d2608ae5-7aac-4ddf-8480-771de8b03d92.png?crop=focalpoint&fit=crop&fp-x=0.7504&fp-y=0.4451&fp-z=2.3838&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=114&mark-y=335&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz05NzImaD05NyZmaXQ9Y3JvcCZjb3JuZXItcmFkaXVzPTEw)


### 5. Click on "Continue"
![Step 5 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/cb701707-920d-47a4-b735-b7c5929094c8/51cc2806-f36e-4df3-8e44-afa1934673c3.png?crop=focalpoint&fit=crop&fp-x=0.7504&fp-y=0.5595&fp-z=2.3838&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=114&mark-y=324&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz05NzImaD0xMTgmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 6. Choose way to verify human
![Step 6 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/e99a80f7-b9f0-4ce6-9418-75cebc4f1b75/9b3ca3d0-3dcf-40c8-a6ce-da2ee7a48eb1.png?crop=focalpoint&fit=crop&fp-x=0.7504&fp-y=0.2405&fp-z=2.3880&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=115&mark-y=328&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz05NjkmaD0xMTAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 7. Solve each puzzle and click on "Submit"
![Step 7 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/9a3f1091-101c-4bb0-aa16-bac87b5353e1/3bd5ba5f-759d-4259-a7b0-a2853622c39b.png?crop=focalpoint&fit=crop&fp-x=0.5000&fp-y=0.5000&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=697&mark-y=377&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTMlMkNGRjc0NDImdz00MDYmaD00NiZmaXQ9Y3JvcCZjb3JuZXItcmFkaXVzPTEw)


### 8. Paste verification code into input

Check your email for a verification code sent from GitHub

![Step 8 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/77890b81-5b1b-4500-bc34-550fafc196c5/36cab33b-c6a3-49b8-98b8-daced862a933.png?crop=focalpoint&fit=crop&fp-x=0.5000&fp-y=0.5000&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=697&mark-y=174&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTMlMkNGRjc0NDImdz01NCZoPTYzJmZpdD1jcm9wJmNvcm5lci1yYWRpdXM9MTA%3D)


### 9. Account verified, now sign in.
![Step 9 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/26ffa374-82e5-4dc7-bf46-a6a2c7aa3044/6a4ca10b-c2ea-483e-84ac-615ae0d958eb.png?crop=focalpoint&fit=crop&fp-x=0.5000&fp-y=0.3850&fp-z=2.0263&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=365&mark-y=347&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz00NzEmaD03MiZmaXQ9Y3JvcCZjb3JuZXItcmFkaXVzPTEw)

<br/>

***
Created with [Tango.ai](https://tango.ai?utm_source=markdown&utm_medium=markdown&utm_campaign=workflow%20export%20links)---
title: "Creating a Google Account and Using Google Colab"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## # [Google Workspace](https://workspace.google.com/intl/en-US/gmail/)


### 1. Click on Create an account
![Step 1 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/27d53aa6-d468-49f6-9eb0-b38822043b61/60e32f47-4d46-4545-acca-9c90719a96ad.png?crop=focalpoint&fit=crop&fp-x=0.9114&fp-y=0.0358&fp-z=2.7948&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=655&mark-y=15&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz00OTUmaD0xMjQmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 2. Click on For my personal use
![Step 2 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/43d403c5-7c25-4caf-b4ef-5942093656b9/78a81256-c7f2-4a42-94c0-29a0eeb92103.png?crop=focalpoint&fit=crop&fp-x=0.9125&fp-y=0.0844&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=659&mark-y=122&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz00OTEmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


## # [Create your Google Account](https://accounts.google.com/lifecycle/steps/signup/name?continue=https://mail.google.com/mail/&ddm=1&dsh=S-1090162785:1740322070569541&ec=asw-gmail-globalnav-create&flowEntry=SignUp&flowName=GlifWebSignIn&service=mail&theme=glif&TL=ADgdZ7Qa5W0h1tXCNUsZcbnrZzmN2uwKRxytYYs7s_lT8EAM_ez81VGJ9gR8xMrl)


### 3. Type First Name & Last Name
![Step 3 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/2c0f9ac7-a8ae-4750-bcb7-86becefae6e8/fdfd7203-5eda-4fc5-b40a-3b67ed27ce83.png?crop=focalpoint&fit=crop&fp-x=0.6717&fp-y=0.4081&fp-z=2.0672&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=214&mark-y=328&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NzEmaD0xMTAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 4. Click on Next
![Step 4 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/cd77bedf-e83c-415c-9678-33177e3c1243/9c33494f-2cdc-4996-8585-8f829b70bdba.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6208&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 5. Type "BorckPython"
![Step 5 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/da0106d5-457d-406b-a36b-43ebe3a45855/215029b1-2470-4d03-8421-8d778da160a4.png?crop=focalpoint&fit=crop&fp-x=0.6717&fp-y=0.4879&fp-z=2.0672&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=214&mark-y=328&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NzEmaD0xMTAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 6. Click on Next
![Step 6 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/a77d8e02-789d-4851-8470-5ffd93be0d53/283fae06-2eef-4021-b9da-55ca1e2b5b18.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6335&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 7. Enter Date of Birth
![Step 7 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/f2f20489-9d9a-4061-9add-7ea552486a7d/2003125e-1f7d-4ff4-a126-84064367d92a.png?crop=focalpoint&fit=crop&fp-x=0.7784&fp-y=0.3965&fp-z=2.7074&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=442&mark-y=311&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0zMTcmaD0xNDQmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 8. Select Male from Gender
![Step 8 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/4ecb120b-4b21-4991-a163-179886f17fc2/d45d5104-9c59-43d5-b0e9-73f4088d659b.png?crop=focalpoint&fit=crop&fp-x=0.6717&fp-y=0.4798&fp-z=2.0609&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=212&mark-y=325&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NzYmaD0xMTcmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 9. Click on Next
![Step 9 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/5025d1e5-4c70-4813-bdf2-4d6440e9cddc/c6ff37e0-fb25-49a6-9210-1323a0e67554.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6312&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 10. Select preferred Gmail email
![Step 10 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/2e82d4de-82c2-4e89-9cc9-07327a118066/f2f045a6-6ae6-470d-b317-6a010406db64.png?crop=focalpoint&fit=crop&fp-x=0.5266&fp-y=0.4497&fp-z=3.0087&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=563&mark-y=346&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NSZoPTc1JmZpdD1jcm9wJmNvcm5lci1yYWRpdXM9MTA%3D)


### 11. Click on Next
![Step 11 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/c9558428-78c4-4b24-8bfe-5847cd43943a/c24f118e-1c0b-46a1-974f-a8c827bc0a65.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6347&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 12. Create your password
![Step 12 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/1cfefb37-b241-46f6-8771-78da3376f768/b00768fe-3be0-4f64-93f7-46684f309ee2.png?crop=focalpoint&fit=crop&fp-x=0.6717&fp-y=0.3873&fp-z=2.0672&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=214&mark-y=328&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NzEmaD0xMTAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 13. Type password
![Step 13 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/ee980eea-d41a-462b-bc20-285950c75224/a002d396-62f6-4318-9a34-fffc227ce832.png?crop=focalpoint&fit=crop&fp-x=0.6717&fp-y=0.4798&fp-z=2.0672&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=214&mark-y=328&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NzEmaD0xMTAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 14. Click on Next
![Step 14 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/2fdb68f3-89cb-4c0e-a16c-fc87b0a64805/5e153823-7ace-4174-b8e2-904b8bd8b69b.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6405&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 15. Type Type phone number
![Step 15 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/cac10587-d034-4632-87bf-8e40370bd32b/1c477aa1-7a9d-4280-892b-42f6aece956c.png?crop=focalpoint&fit=crop&fp-x=0.6924&fp-y=0.4445&fp-z=2.3713&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=275&mark-y=315&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz02NDkmaD0xMzcmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 16. Click on Next
![Step 16 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/b01a40a7-fd1b-4abd-a902-23836ae57216/9ad04491-c2b9-4305-a68f-90ea4074f932.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6208&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 17. Type verification code received on phone
![Step 17 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/1608afd8-096e-4eb1-addc-7646a1a82e81/d3121b38-e113-4945-8704-0a64906b51de.png?crop=focalpoint&fit=crop&fp-x=0.6876&fp-y=0.4671&fp-z=2.2124&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=229&mark-y=324&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NDEmaD0xMTgmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 18. Click on Next
![Step 18 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/9ac0d391-0375-4a84-ba25-d86d2dd566c8/d65e5287-aca8-4b2f-9950-a0d98d90a050.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6208&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 19. Type recovery email
![Step 19 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/8a28b067-d41d-4425-805d-dc5d9703ac38/ecdd3412-bdce-4da6-8ae8-1ac5c8d903b6.png?crop=focalpoint&fit=crop&fp-x=0.6717&fp-y=0.4081&fp-z=2.0672&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=214&mark-y=328&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NzEmaD0xMTAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 20. Click on Next
![Step 20 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/17897263-54b2-4027-9a02-59612abe1846/5ca37222-cf31-40ae-bb2e-1184ee3bcde4.png?crop=focalpoint&fit=crop&fp-x=0.7515&fp-y=0.6208&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=337&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz01MjYmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 21. Click on Next
![Step 21 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/0052447b-cedf-490e-be0a-07d67f51643f/c56fb416-f16b-4a28-8294-c91539f0fab5.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6197&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 22. Click on I agree
![Step 22 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/3ec7ffb3-d7e1-41bc-8130-368e7a18a4a9/a045950d-a54c-4cc3-9f10-5e937e35b46c.png?crop=focalpoint&fit=crop&fp-x=0.7799&fp-y=0.8058&fp-z=3.8797&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=425&mark-y=301&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0zNTEmaD0xNjUmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


## # [Brave Search](https://search.brave.com/search?q=google+colab&source=desktop)


### 23. Check working, visit Google Colab.  Search for Google Colab
![Step 23 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/0aff7d2d-8321-444a-8730-aec343a66e8c/2e6f70c2-e576-4e03-941f-d998ca06926f.png?crop=focalpoint&fit=crop&fp-x=0.3796&fp-y=0.2110&fp-z=1.3042&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=229&mark-y=168&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03MzAmaD04NyZmaXQ9Y3JvcCZjb3JuZXItcmFkaXVzPTEw)


## # [Welcome To Colab - Colab](https://colab.research.google.com/)


### 24. Click on highlight
![Step 24 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/37b07b60-2994-4fec-a6f4-77029e6a42dd/5ab7819b-1d11-4954-bd43-2f9a6923f055.png?crop=focalpoint&fit=crop&fp-x=0.2570&fp-y=0.8260&fp-z=2.6129&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=470&mark-y=389&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTYlMkNGRjc0NDImdz0yNTkmaD01OCZmaXQ9Y3JvcCZjb3JuZXItcmFkaXVzPTEw)

<br/>

***
Created with [Tango.ai](https://tango.ai?utm_source=markdown&utm_medium=markdown&utm_campaign=workflow%20export%20links)**🚀 Beginner’s Guide to Setting Up Local AI Models**

### **📌 Introduction**
Running AI models locally allows you to use powerful language models without relying on cloud services like ChatGPT or Gemini. However, local AI models require **dedicated software and sometimes hardware optimizations** to run efficiently on consumer-grade computers.

---

## **1️⃣ Understanding Local AI Models**
Unlike cloud-based models, local AI models require:
✅ A **model file** (LLaMA, Phi, DeepSeek, etc.).  
✅ An **inference engine** to run the model locally.  
✅ Optional **quantization** to reduce memory usage on lower-end hardware.  

Popular models you can run locally include:
- **LLaMA (Meta AI)** – Open-source alternative to GPT-4.
- **Phi (Microsoft)** – Small-scale efficient AI.
- **DeepSeek AI** – Optimized for technical research.

---

## **2️⃣ Software Required to Run Local AI Models**
### **🔹 Option 1: Ollama (Easiest Setup) – Mac, Linux, Windows**
**Ollama** is an easy-to-use tool for running local AI models with a simple command-line interface.

**Installation Steps:**
1. Download **Ollama** from: [https://ollama.com](https://ollama.com)
2. Install it and open a terminal.
3. Run a model by typing:
   ```sh
   ollama run llama2
   ```
4. You can also install other models:
   ```sh
   ollama pull phi
   ```
5. Start chatting locally!

**Pros:** ✅ Simple, works on all platforms. ✅ Automatically downloads models.
**Cons:** ❌ Limited UI, mostly command-line-based.

---

### **🔹 Option 2: LM Studio (GUI-Based) – Mac & Windows**
If you prefer a graphical interface, **LM Studio** is an excellent tool for running local AI models with an easy-to-use UI.

**Installation Steps:**
1. Download LM Studio: [https://lmstudio.ai](https://lmstudio.ai)
2. Install and open it.
3. Choose a **LLaMA-compatible model** and click **Download**.
4. Run the model and chat with it directly.

**Pros:** ✅ Easy-to-use UI. ✅ Works without the command line.
**Cons:** ❌ Limited advanced features compared to CLI tools.

---

### **🔹 Option 3: Text-Generation-WebUI (Advanced Users) – Windows, Linux**
For those who want **maximum customization**, Text-Generation-WebUI provides a **web interface** to run multiple AI models.

**Installation Steps:**
1. Install Python (3.10+) and Git.
2. Clone the repository:
   ```sh
   git clone https://github.com/oobabooga/text-generation-webui.git
   ```
3. Navigate to the directory:
   ```sh
   cd text-generation-webui
   ```
4. Install dependencies:
   ```sh
   pip install -r requirements.txt
   ```
5. Run the server:
   ```sh
   python server.py
   ```
6. Open **localhost:5000** in your browser and start chatting.

**Pros:** ✅ Full control over settings. ✅ Supports many AI models.
**Cons:** ❌ Harder to set up. ❌ Requires Python & command-line experience.

---

## **3️⃣ Optimizing Models for Lower-End Hardware (Quantization)**
Running large AI models on **consumer hardware** can be challenging. **Quantization** helps reduce RAM and VRAM requirements.

### **🔹 How to Use Quantized Models**
1. Download a **quantized version** of a model from [Hugging Face](https://huggingface.co/).
2. Use tools like **GGUF format** (Ollama, LM Studio) to load the smaller model.
3. Example command to run a quantized LLaMA model:
   ```sh
   ollama run llama2-7b-gguf
   ```

### **🔹 Recommended Quantized Models**
- **LLaMA 2 7B GGUF** (Fits on 16GB RAM machines)
- **Phi-2 4-bit GGUF** (Efficient on lower-end laptops)
- **DeepSeek Lite GGUF** (Optimized for research use)

---

## **4️⃣ Troubleshooting Common Issues**
### **🔹 My model is too slow!**
- Try a **smaller model size** (7B instead of 13B/30B).
- Use a **quantized model (GGUF, GPTQ, 4-bit)**.
- Ensure **GPU acceleration is enabled** if available.

### **🔹 The model is running out of memory!**
- Use **GGUF models** to reduce RAM usage.
- Close other background applications.
- Upgrade RAM if frequently using large models.

### **🔹 I need an easier solution!**
- Use **Ollama or LM Studio** instead of command-line tools.

---

## **5️⃣ Final Recommendations: Which Tool Should You Use?**
| **User Type** | **Recommended Tool** |
|--------------|--------------------|
| **Beginners (No coding required)** | **LM Studio (GUI-based)** |
| **Casual users (Command-line only)** | **Ollama** |
| **Advanced users (Full control over settings)** | **Text-Generation-WebUI** |
| **Developers & AI researchers** | **Manual setup with Hugging Face models** |

---

### **🚀 Next Steps**
✅ Install a tool like **Ollama or LM Studio**.
✅ Download an **optimized AI model** (LLaMA, Phi, DeepSeek).
✅ Start experimenting with **local AI without cloud dependency**!

Would you like a **quick-reference cheat sheet** for running AI models locally? 🚀

### **🚀 How to Create and Use Meta AI Chatbot (Meta.ai)**  

Meta AI is an AI-powered chatbot available through **Facebook, Instagram, Messenger, and WhatsApp**. It integrates into Meta’s ecosystem and allows users to ask questions, generate text, and get assistance.

---

### **📌 Step 1: Access Meta AI**  
There are **multiple ways** to use Meta AI:

✅ **Facebook**: Open **Facebook Messenger** and search for **Meta AI**.  
✅ **Instagram**: Open your DMs and search for **Meta AI**.  
✅ **WhatsApp**: Available in some regions—search for **Meta AI** in chats.  
✅ **Meta Website**: Go to **[https://about.fb.com/technology/meta-ai/](https://about.fb.com/technology/meta-ai/)** for more details.

---

### **📌 Step 2: Log in with Your Meta Account**  
1. Open **Messenger, Instagram, or WhatsApp**.  
2. **Search for "Meta AI"** in the chat search bar.  
3. **Start a conversation** by typing a message.  

**Note:** If Meta AI is not available in your country, you may need to wait for wider rollout.

---

### **📌 Step 3: Ask a Question**  
- Type any question or request, such as:  
  _"Explain how CSS Flexbox works."_  
  _"Generate a JavaScript function to fetch API data."_  
- Meta AI will provide an instant response, and you can refine the query by asking follow-up questions.

---

### **📌 Step 4: Use Meta AI for Web Development Help**  
✅ **Get coding assistance:** _"Write a responsive navbar in HTML/CSS."_  
✅ **Debugging:** _"Why is my JavaScript function not working?"_  
✅ **AI-powered research:** _"Explain the differences between WordPress and static site generators."_  

---

### **📌 Step 5: Optional – Enable Meta AI in Chats (If Available)**  
Meta AI can be **enabled in group chats** on Messenger & WhatsApp:  
1. Start a new chat or group.  
2. Type `@Meta AI` to tag the chatbot in a conversation.  
3. Ask for information, summaries, or assistance.  

---

### **🚀 Tips for Using Meta AI Effectively**  
✅ **Use clear, specific prompts** (_e.g., “Explain JavaScript closures with examples”_).  
✅ **Ask for real-world use cases** (_e.g., “How do businesses use AI for marketing?”_).  
✅ **Experiment with follow-up questions** to refine responses.  

---

### **📌 Troubleshooting Access Issues**  
- If **Meta AI is not showing up**, it may not be available in your region yet.  
- **Try updating your Messenger/Instagram app** to see if the feature is available.  
- Check Meta’s official announcements for updates: **[https://about.fb.com/technology/meta-ai/](https://about.fb.com/technology/meta-ai/)**.  
# How to Create a GitHub Account

Creating a GitHub account is essential for storing, managing, and collaborating on your Python projects. Follow these step-by-step instructions to set up your account.

---

## Step 1: Go to the GitHub Sign-Up Page
1. Open your web browser and go to [GitHub Sign-Up](https://github.com/join).
2. You will see a form asking for personal details.

---

## Step 2: Enter Your Information
1. **Username** – Choose a unique GitHub username. This will be your public identity.
2. **Email Address** – Enter a valid email address.
3. **Password** – Create a strong password (at least 8 characters, including letters, numbers, and symbols).
4. Click **Continue** to proceed.

---

## Step 3: Verify Your Account
1. You may need to solve a simple puzzle to prove you’re human.
2. Once verified, click **Create Account**.

---

## Step 4: Customize Your GitHub Experience
1. Choose whether you want to receive **product updates and announcements**.
2. Click **Continue** to proceed.

---

## Step 5: Verify Your Email Address
1. Open your email inbox and look for a **GitHub verification email**.
2. Click the **Verify Email** button in the email.
3. Your account is now confirmed!

---

## Step 6: Set Up Your GitHub Profile
1. After verifying your email, you will be taken to your GitHub homepage.
2. Click on your **profile picture (top-right corner)** > **Settings**.
3. Add a **profile picture, bio, and location** (optional but recommended).
4. Set your **visibility preferences**.

---

## Step 7: Create Your First Repository (Optional, but Recommended)
1. Click on the **New Repository** button.
2. Give your repository a **name** (e.g., `my-first-repo`).
3. Choose the visibility:
   - **Public** (anyone can see it).
   - **Private** (only you and invited collaborators can see it).
4. Check **Add a README file** (recommended for project descriptions).
5. Click **Create Repository**.

---

## Step 8: Install Git (Optional, for Advanced Users)
1. If you plan to use Git locally, download and install Git from [git-scm.com](https://git-scm.com/).
2. Configure Git on your computer:
   ```bash
   git config --global user.name "Your Name"
   git config --global user.email "your-email@example.com"
   ```
3. Now you can **clone**, **push**, and **pull** repositories using Git commands.

---

## Next Steps
Now that you have a GitHub account, you can:
- Create and manage repositories.
- Collaborate with others on coding projects.
- Use GitHub to submit assignments or track your progress.

You’re all set! 🚀 Happy coding!

# How to Create a Google Account

Creating a Google Account is necessary to access Google Colab, Google Drive, and other services required for this course. Follow these step-by-step instructions to set up your account.

---

## Step 1: Go to the Google Account Sign-Up Page
1. Open your web browser and go to [accounts.google.com/signup](https://accounts.google.com/signup).
2. You will see a form asking for personal details.

---

## Step 2: Enter Your Information
1. **First Name & Last Name** – Enter your real or preferred name.
2. **Username** – Choose a unique email address (e.g., `yourname@gmail.com`).
   - If your preferred username is taken, try adding numbers or variations.
3. **Password** – Create a strong password (at least 8 characters, a mix of letters, numbers, and symbols).
4. **Confirm Password** – Re-enter the password to verify.
5. Click **Next** to continue.

---

## Step 3: Verify Your Identity
1. **Phone Number (Optional, but Recommended)** – Enter your phone number for account recovery.
2. **Recovery Email (Optional, but Recommended)** – If you have another email, add it to help recover your account if needed.
3. **Date of Birth** – Select your birthdate.
4. **Gender** – Choose your gender or select "Rather not say."
5. Click **Next** to proceed.

---

## Step 4: Agree to Google’s Terms
1. Read Google’s Privacy Policy and Terms of Service.
2. Scroll down and click **I Agree** to accept the terms.

---

## Step 5: Verify Your Email (If Required)
1. If you entered a phone number, Google may send a verification code.
2. Check your text messages and enter the **6-digit code** sent by Google.
3. Click **Verify**.

---

## Step 6: Access Your New Google Account
1. Once verified, you’ll be taken to your new Google Account homepage.
2. From here, you can access **Google Drive, Google Colab, and Gmail**.
3. To confirm your account is active, go to [Google.com](https://www.google.com) and click your profile icon in the top-right corner.

---

## Next Steps
Now that you have a Google Account, you can:
- Log in to **Google Colab** at [colab.research.google.com](https://colab.research.google.com).
- Store files in **Google Drive** at [drive.google.com](https://drive.google.com).
- Use **Gmail** for email communication.

Congratulations! 🎉 You’re ready to start using Google’s services for your learning journey!

### **🚀 How to Create and Use Anthropic's Claude AI Chatbot**  

Claude AI, developed by **Anthropic**, is an advanced AI assistant similar to ChatGPT and Google Gemini. It is designed for **natural conversations, research, and coding assistance**.

---

### **📌 Step 1: Access Claude AI**  
Claude is available via:  
✅ **Web App**: Go to **[https://claude.ai](https://claude.ai/)**.  
✅ **Slack Integration**: Available as a chatbot in **Slack workspaces** (if enabled).  
✅ **API Access**: Developers can integrate Claude via API (**paid access**).  

---

### **📌 Step 2: Sign Up for a Free Account**  
1. Go to **[https://claude.ai](https://claude.ai/)**.  
2. Click **“Sign Up”** and enter your **email address**.  
3. Choose a **strong password** and confirm your email.  

✅ **Alternative:** If your workspace uses Claude in **Slack**, you may be able to access it directly within a Slack chat.

---

### **📌 Step 3: Start Using Claude AI**  
Once logged in, you can **start a chat session** by entering a question or request.  

✅ **Example Prompts:**  
- _"Explain how CSS Grid works."_  
- _"Write a Python script to scrape a webpage."_  
- _"Compare SQL vs. NoSQL databases."_  

---

### **📌 Step 4: Using Claude AI for Web Development**  
✅ **Code Generation:** _"Create a responsive navbar using HTML, CSS, and JavaScript."_  
✅ **Debugging Help:** _"Why is my JavaScript fetch request returning an error?"_  
✅ **AI Code Comparison:** _"Compare the efficiency of this AI-generated function vs. my manually written version."_  
✅ **Learning & Documentation:** _"Summarize the main differences between React and Vue.js."_  

---

### **📌 Step 5: Optional – Claude AI API (For Developers)**  
Claude AI also provides an API for integration into applications.  
1. Visit **[Anthropic’s API Docs](https://www.anthropic.com/)**.  
2. Sign up for API access (**may require payment**).  
3. Use API keys to integrate Claude into your own projects.  

---

### **🚀 Tips for Using Claude AI Effectively**  
✅ **Use detailed prompts** (_e.g., “Explain CSS Flexbox with a real-world example”_).  
✅ **Ask for structured responses** (_e.g., "List the pros and cons of using Tailwind CSS"_).  
✅ **Experiment with follow-up questions** to refine AI-generated responses.  

---

### **📌 Troubleshooting Access Issues**  
- **Claude may not be available in all regions**—check [Claude.ai](https://claude.ai/) for availability.  
- If **Claude is slow or unavailable**, try accessing it during off-peak hours.  
- Ensure your **browser is updated** for the best experience.  
### **🚀 How to Create a Free OpenAI ChatGPT Account**
You can create a free OpenAI ChatGPT account to access AI-powered text generation, coding assistance, and learning support. Follow these steps:

---

### **📌 Step 1: Visit OpenAI's Website**
1. Open your web browser and go to **[https://openai.com](https://openai.com)**.  
2. Click on **“Sign Up”** (top right corner).

---

### **📌 Step 2: Register Your Account**
You can sign up using:
- **Email Address**
- **Google Account**
- **Microsoft Account**
- **Apple ID**

✅ **Recommended:** Using Google/Microsoft makes login faster.

1. If signing up with an **email**, enter your email address and click **Continue**.
2. Choose a **strong password** and click **Continue**.
3. Open your email and click the **verification link** sent by OpenAI.

---

### **📌 Step 3: Verify Your Phone Number**
1. Enter a **valid phone number** (this is required for security).
2. OpenAI will send you a **verification code via SMS**.
3. Enter the code to confirm your identity.

✅ **Tip:** Use a personal number (Google Voice or VoIP numbers may not work).

---

### **📌 Step 4: Access Free ChatGPT**
1. Once verified, you’ll be directed to **ChatGPT’s main page**.
2. You can now start using **ChatGPT Free (GPT-3.5)**.
3. Click **“New Chat”** and enter your question or prompt.

---

### **📌 Optional: Upgrade to GPT-4 (Paid)**
- OpenAI offers **ChatGPT Plus ($20/month)** for **GPT-4 access**.
- This is **not required** but provides **better responses**.

---

### **📌 Step 5: Start Using ChatGPT**
✅ Ask coding questions, generate text, debug code, and more!  
✅ Save **useful responses** in notes or documents.  
✅ Experiment with **different prompts** to get the best results.

---

### **🚀 Need Help?**
- If you encounter issues, visit OpenAI’s **[Support Page](https://help.openai.com/)**.
- Some regions may **block OpenAI** (use a VPN if needed).

Would you like **sample AI prompts** to help students get started with ChatGPT? 🚀---
title: "Tutor Guide – Course Overview"
subtitle: "Empowering Students to Build Strong Python Foundations"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## Introduction & Purpose

This guide provides an overview of the course structure, expectations, and key workflows to support tutors in effectively guiding students through the learning process. It outlines:

- The **pedagogical approach** (flipped classroom, AI-assisted learning, and progressive difficulty).
- **Key workflows**, including Google Colab and GitHub usage.
- **AI expectations**, ensuring students engage meaningfully with AI tools.
- **Assessment structure**, including quizzes and project submissions.
- **Support resources** for tutors and students.

By following this guide, tutors can provide a consistent learning experience that helps students build a strong Python foundation while adapting to modern AI-assisted development workflows.

## Slow Start & Increasing Task Difficulty

The first three to four weeks of the course progress very slowly, which may feel frustrating for students with some programming experience. I’ll acknowledge this in class and apologise in advance to those students.

However, it’s crucial to establish a habit of engaging with the notebooks early. The first two to three weeks focus on sequence, selection, repetition, variables, and data types. While AI could generate answers for everything, students need to develop the discipline to use AI as a learning tool rather than just a shortcut to solutions.

Once we move beyond the basics, task difficulty will increase significantly. At that stage, students who have engaged consistently with the notebooks will have a more intuitive understanding of AI-generated code, making it easier to refine and apply in meaningful ways. This will be critical for success later in the course.

## Google Colab & GitHub Workflow
Students should follow this process to set up their workflow:

1. **Log into GitHub first.**
2. **Open the provided Colab notebook** (linked from the public GitHub repository).
3. **Use the “Open in Colab” button** to launch the notebook in their browser.
4. **Save a copy to their GitHub repository.** (Some students may need to run a cell before saving.)
5. **Confirm that their changes are properly saved in GitHub.**

This workflow will be used throughout the semester, so it’s crucial to establish it early.

## AI Usage & Expectations
AI is encouraged throughout the course, but students must demonstrate understanding rather than just copying AI-generated code. The primary goal is **learning and comprehension**, not just producing a working solution.

### AI Use in Assessments
- **Final projects allocate only 10-15% of marks to working code.**
- The majority of marks come from:
  - Proper use of GitHub.
  - Clear understanding of concepts.
  - Adherence to best practices in coding.
- **Copying AI-generated code without modifications is a baseline fail.** Students must refine AI output, ensuring it aligns with course standards.

AI usage guidelines are embedded throughout the course materials, and students will receive structured support on how to use AI effectively.

## Course Structure & Materials
This unit follows a **flipped classroom model** with AI-assisted learning. Weekly content is released progressively to keep materials aligned with the course pace and student engagement.

### Lecture & Lab Materials
- **Students engage with flipped content before labs.**
- Weekly lecture content is available in multiple formats:
  - **HTML** (with a table of contents for easy navigation).
  - **PowerPoint & PDF** (downloadable for offline use).
  - **Audio & Video** (Google NotebookLM generates a podcast version; a video version will follow).
- Students can choose the format that best suits their learning style.

### Traditional Lectures vs. Flipped Model
- If you are running a **traditional lecture**, use the **“Before the Lab”** materials.
- This content is designed to function as a **mini-lecture split into 2-4 sections** for better engagement.

## Tutor Notes & Weekly Quizzes
- **Tutor notes** for each week are uploaded to the STAFF-MATERIAL section on Blackboard.
- If anything is unclear or missing, please let me know.

### Lab Exit Quizzes
- **Required for the first eight weeks.**
- **Access:** The quiz activates at the end of the scheduled lab session.
- **Restrictions:**
  - Access is controlled via Blackboard groups.
  - IP filtering ensures students complete it in their designated lab.
  - (For the first few weeks, quizzes may remain open for longer to resolve technical issues.)
- **Encourage students to complete the quiz independently**, using AI if needed.
- Quizzes can be attempted multiple times.

## Project & Notebook Submission
- **Students do not submit weekly notebooks.**
- Notebooks are for **learning purposes** but contribute to the final project.
- **Lab sessions introduce notebooks,** but students are expected to complete unfinished work independently.

**Expected Weekly Time Commitment:**
- **Total: ~10 hours per unit per week.**
  - **Contact Hours:** ~3 hours (labs + support).
  - **Independent Study:** ~7 hours (review, practice, and research).

Encourage students to **pace themselves and engage actively** with the material, rather than just focusing on task completion.
---
title: "Tutor Guide – Week 1: Python Fundamentals and Chatbot Project"
subtitle: "Empowering Students to Build Strong Python Foundations"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

### Introduction for Tutors

Welcome to your tutor guide for Week 1! The purpose of these notes is to provide you with background information, key learning outcomes, and a suggested timeline for delivering the material. Please note that, for this week, the tasks are very basic, and the instructions provided in the student notebooks are detailed and self-explanatory. As such, a separate staff version of the notebooks has not been created. Your role is to support and facilitate student learning, ensuring that everyone builds a solid foundation in Python fundamentals.

### Background & Preparation

- **Accounts Setup:**  
  Ensure all students have created both a Google account and a GitHub account prior to the lab. These accounts are **critical** for accessing course materials and submitting assignments throughout the course.

- **Flipped Content Overview:**  
  Normally, students are expected to complete the flipped content before coming to lab. Since this is the first week, dedicate the first **5 minutes** of the session to explain the flipped learning model and emphasise that, from Week 2 onward, pre-lab preparation is mandatory.

- **Pacing:**  
  The first 3–4 weeks are intentionally slow-paced to establish a strong grasp of fundamental programming concepts, such as:
  - **Sequence:** The order in which code executes.
  - **Selection:** The use of conditional statements (if-elif-else).
  - **Repetition:** Looping constructs (e.g., while loops).
  - **Data and Values:** Understanding basic data types in Python.



### Learning Outcomes

By the end of this session, students should be able to:
- Use the Python `print()` function to produce output.
- Identify and fix basic syntax and formatting errors in Python code.
- Write clean, readable code by effectively using formatting, blank lines, and comments.
- Modify a simple AI Chatbot script to personalise its responses.
- Appreciate the evolution from static output (using `print()`) to more interactive programming approaches.



### Two-Hour Lab Session – Suggested Timings

1. **Introduction & Flipped Content Overview (5 minutes):**  
   - Explain the flipped classroom model.
   - Stress that all subsequent weeks require pre-lab content completion.

2. **Accounts Check (10 minutes):**  
   - Verify that all students have set up their Google and GitHub accounts.

3. **Worksheet 1: Hello Python (15 minutes):**  
   - Walk through the "Hello Python" notebook.
   - Demonstrate code execution and address any questions.

4. **Worksheet 2: Fixing Mistakes (15 minutes):**  
   - Guide students in identifying and correcting errors.
   - Emphasise reading error messages and using AI for clarifications if needed.

5. **Worksheet 3: Making Code Clear and Readable (15 minutes):**  
   - Highlight the importance of formatting and commenting.
   - Allow time for students to experiment with different formatting options.

6. **Project: Simple AI Chatbot (20 minutes):**  
   - Introduce the starter code and review the conversation flow.
   - Discuss modification tasks, encouraging creativity and personalisation.
   - Remind students that the focus is on mastering the `print()` function and building a strong foundation.

7. **Optional Extension Activity (Optional, 5 minutes):**  
   - Briefly present the advanced extension section.
   - Stress that this section is entirely optional and intended for those curious about more advanced concepts.
   - Reiterate that the fundamentals must be mastered first.
   - complete in own time as required

8. **Wrap-Up & Q&A & Quiz (10 minutes):**  
   - Summarise key concepts covered in the session.
   - Open the floor for questions and clarifications.
   - Remind students to complete the flipped content before the next lab session.
   - **Lab Exit Quiz (5 mins)**
      - Active in the last 30 mins of the sessison (maybe discuss earlier)
      - log in and Complete the Quiz
      - Work Independently (using AI is ok)
      - Submit on Time
      - Can redo the quiz as many times as they like




### Additional Notes for Tutors

- **Emphasise Fundamentals:**  
  Although the tasks are simple, the goal is to build a solid understanding of the basics. Encourage students to work through problems on their own before relying on AI for answers.

- **Friendly and Supportive Tone:**  
  Use humour and relatable examples to keep the session engaging. Reinforce that making mistakes is a natural part of learning.

- **Pacing and Interaction:**  
  Monitor student progress carefully. Some may require more time on certain sections, so be prepared to revisit concepts as needed. Encourage active participation and discussion.

- **Extension Activity Caution:**  
  Remind students that the optional extension activity is only for those who are curious about more advanced topics. Make it clear that the primary focus is on mastering the fundamentals through the basic exercises.

- **Lab Exit Quiz**
  During the final 30 minutes of the lab session, the lab exit quiz will become active. This is a multiple-choice quiz designed to assess the students' understanding of the material covered in today's session. Please instruct the students to:

  - Log in and Complete the Quiz: Ensure they have access to the quiz platform (via their Google/GitHub accounts if applicable) and that they complete all the questions before the lab ends.
  - Work Independently: Remind students that the quiz is an individual assessment. Encourage them to rely on their understanding of the concepts rather than external help during this time.
  - Submit on Time: Emphasise that the quiz is timed and must be submitted before the session concludes.
  - Redo the quiz as many time as they like

By following these guidelines, you'll help ensure that students build a robust foundation in Python programming while staying engaged and motivated for future, more challenging tasks.

Happy teaching!---
title: "GitHub Repository Setup Guide for Python Course"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


## **Step 1: Create a GitHub Repository**
1. **Go to GitHub**: [https://github.com](https://github.com) and log in.
2. Click the **"+" (plus icon)** at the top-right and select **"New repository"**.
3. **Repository Name**: Choose a meaningful name, e.g., `python-beginners-course`.
4. **Description** (Optional): "This repository contains materials for the beginner's Python course."
5. **Visibility**:
   - Public (if you want anyone to access it).
   - Private (if it's for enrolled students only).
6. **Initialize the repository**:
   - Check **"Add a README file"** (recommended for an overview).
   - Check **".gitignore"** and select **"Python"** (prevents unnecessary files from being tracked).
7. Click **"Create repository"**.

---

## **Step 2: Clone the Repository (For Local Use)**
(If students want to work locally before pushing to GitHub)

1. **Copy the Repository URL**: On the repository page, click the **"Code"** button and copy the HTTPS or SSH link.
2. **Open Terminal or Git Bash** (on Windows/Mac/Linux).
3. Run:
   ```bash
   git clone <repository_url>
   cd python-beginners-course
   ```

---

## **Step 3: Connect Google Colab to GitHub**
1. **Open Google Colab**: [https://colab.research.google.com](https://colab.research.google.com/)
2. **Sign in** with your Google account.
3. Click **"File" > "Open Notebook"**.
4. Select the **GitHub tab** and authorize Colab to access your GitHub account.
5. Choose the repository and the notebook file you want to work on.
6. Click **"Open"** to start editing.

---

## **Step 4: Save Colab Notebooks to GitHub**
1. In Google Colab, after making changes, go to:
   - **File > Save a copy in GitHub**.
2. Select the correct repository and branch.
3. Add a commit message (e.g., "Added loops lesson").
4. Click **OK** to push the changes.

---

## **Step 5: Commit & Push Changes (Command Line)**
(For those who cloned the repository and made local changes)

1. Open Terminal or Git Bash in the repo folder.
2. Add files to staging:
   ```bash
   git add .
   ```
3. Commit changes with a message:
   ```bash
   git commit -m "Added week 1 exercises"
   ```
4. Push changes to GitHub:
   ```bash
   git push origin main
   ```

---

## **Step 6: Pull Changes (To Sync with the Latest Version)**
If changes were made remotely (e.g., by the instructor), students should **pull** updates before making new edits:

```bash
git pull origin main
```

---

## **Bonus: Create Student Submission Folders (Optional)**
If students are required to submit assignments:
- **Option 1**: Each student forks the main repo and submits a pull request.
- **Option 2**: Create a `submissions/` folder where students upload their `.ipynb` files.

---

### ✅ **Now your GitHub repository is ready for use with Google Colab!**  
