---
title: "Introduction to Safe Utility Functions"
subtitle: "Laying the Foundation for Error-Resistant Code"
format: jupyter-notebook
jupyter: python3
---


# Activity 3: Introduction to Safe Utility Functions

## Learning Objectives
- Understand the concept of "safe" wrapper functions
- Create a basic safe function that handles errors internally
- Analyze the benefits and tradeoffs of error-handling strategies

## Key Concepts
- **Wrapper Functions:** Functions that add features (like safety) to existing operations
- **Error Tolerance:** Creating code that continues to run despite encountering errors
- **Default Return Values:** Providing sensible fallback values when operations fail

## The Concept of "Safe" Functions

In programming, a "safe" function is one that:
1. Performs an operation that might fail
2. Handles errors internally so they don't crash the program
3. Returns a reasonable default value if the operation fails

This creates a protective layer between potentially risky operations and the rest of your application.

## Example: A Simple Safe Function

Here's an example of a standard function compared to its "safe" version:

### Standard Version (Unsafe)
```{python}
def get_value_at_index(my_list, index):
    """Get a value from a list at the specified index."""
    return my_list[index]

# If the index is out of range, this will crash the program
try:
    value = get_value_at_index([1, 2, 3], 10)  # IndexError!
except IndexError:
    print("The program would crash here without the try-except")
```

### Safe Version
```{python}
def safe_get_value_at_index(my_list, index, default=None):
    """
    Safely get a value from a list at the specified index.
    Returns default value if index is out of range.
    """
    try:
        return my_list[index]
    except IndexError:
        return default

# This will not crash the program
value = safe_get_value_at_index([1, 2, 3], 10)  # Returns None
print(f"Value: {value}")

# You can specify a different default value
value = safe_get_value_at_index([1, 2, 3], 10, default=-1)  # Returns -1
print(f"Value with custom default: {value}")
```

## Activity: Creating a Basic Safe Function

### Task: Create a Safe Integer Conversion Function

The built-in `int()` function raises a `ValueError` if it can't convert a string to an integer. Create a safe version:

```{python}
def safe_int(text, default=0):
    """
    Safely convert text to an integer.
    
    Args:
        text (str): The text to convert
        default (int): Value to return if conversion fails
        
    Returns:
        int: The converted integer or the default value
    """
    # Your implementation here
    pass

# Test your function
print(safe_int("123"))      # Should return: 123
print(safe_int("abc"))      # Should return: 0
print(safe_int("abc", -1))  # Should return: -1
```

### Discussion Questions

After implementing your function, consider these questions:

1. How does your `safe_int` function compare to the built-in `int()` function?
2. What are the advantages of having your function return a default value instead of raising an exception?
3. Are there any disadvantages to hiding errors this way?
4. In what situations might it be better to let the exception propagate instead of handling it inside the function?

**ðŸ’¡ AI Tip:** Ask an AI: "What are the pros and cons of silent error handling with default values versus letting exceptions propagate?" Compare its response with your own thoughts.

## Extension: Applying the Safe Function Concept

Now, apply the safe function concept to one of the following:

1. **safe_float()**: Create a function that safely converts text to a floating-point number
2. **safe_divide()**: Create a function that safely divides two numbers, handling division by zero
3. **safe_read_file()**: Create a function that safely reads a file, returning a default value if the file doesn't exist

Choose ONE of these to implement:

```{python}
# Your implementation of one of the extension functions here
```

## Reflection

1. How does creating "safe" versions of functions improve the reliability of your code?
2. What considerations should you make when choosing an appropriate default value?
3. How might you apply this "safe function" concept to other operations in your programs?

## Looking Ahead to the Mini-Project

In the upcoming Week 11 mini-project, "Building Your Safe Utils Module," you'll expand on this concept to create an entire module of safe utility functions. You'll develop:

- Multiple safe functions for different operations (file handling, data conversion, etc.)
- A cohesive module structure with proper documentation
- Testing procedures to verify your functions work correctly

The concept you've learned todayâ€”creating functions that gracefully handle errors and return sensible defaultsâ€”will be the foundation of that project.
