---
title: "Introduction to File Operations and Basic Error Handling"
subtitle: "Building Blocks for Reliable Programming"
format: jupyter-notebook
jupyter: python3
---


# Activity 1: Introduction to File Operations and Basic Error Handling

## Learning Objectives
- Apply basic file operations (open, read, write, close) in Python
- Identify common errors that can occur during file operations
- Implement basic exception handling with try-except blocks

## Key Concepts
- **File Operations:** Opening, reading, writing, and properly closing files
- **Basic Exception Handling:** Using try-except blocks to prevent program crashes
- **Context Managers:** Using `with` statements for automatic resource management

## Understanding File Operations

File operations are fundamental to programming, allowing us to read from and write to files. In this activity, you'll learn how these operations can fail and how to handle those failures gracefully.

```{python}
# Basic file operations review
# Opening a file
file = open('example.txt', 'w')  # Opens for writing, creates if doesn't exist

# Writing to a file
file.write('Hello, World!\n')
file.write('This is a test file.')

# Closing a file (IMPORTANT!)
file.close()

# Reading a file
file = open('example.txt', 'r')  # Opens for reading
content = file.read()
print(content)
file.close()
```

### What Can Go Wrong?

Try running this code:

```{python}
file = open('nonexistent_file.txt', 'r')
content = file.read()
print(content)
file.close()
```

‚úçÔ∏è **What error message do you see?**

```
# Your answer here
```

## Introducing Exception Handling

When we know an operation might fail, we can use a `try-except` block to handle the error:

```{python}
try:
    # Code that might cause an error
    file = open('nonexistent_file.txt', 'r')
    content = file.read()
    print(content)
    file.close()
except FileNotFoundError:
    # What to do if the file isn't found
    print("Sorry, that file doesn't exist!")
```

### Better File Handling with Context Managers

The `with` statement automatically takes care of closing files, even if errors occur:

```{python}
try:
    with open('example.txt', 'r') as file:
        content = file.read()
        print(content)
    # File is automatically closed when the with block exits
except FileNotFoundError:
    print("Sorry, that file doesn't exist!")
```

## Activity: Creating a Daily Log System

**Scenario:** You're creating a simple application that maintains a daily log file. Each entry should include the current date and a user-provided note.

### Task 1: Write the Basic Log Function

Complete this function to add entries to a log file:

```{python}
from datetime import datetime

def add_log_entry(note):
    """
    Adds a timestamped entry to a log file.
    
    Args:
        note (str): The message to log
    """
    # Your code here:
    # 1. Open a file named "daily_log.txt" in append mode
    # 2. Write the current date/time and the note
    # 3. Make sure to handle any potential errors
    # 4. Ensure the file is properly closed
    pass
```

### Task 2: Test Your Function

Write code to test your function with both valid and invalid inputs:

```{python}
# Testing with valid input
add_log_entry("Started working on Python file operations assignment")

# Testing with empty input - how should your function handle this?
add_log_entry("")

# Add your own test case(s)
```

**üí° AI Tip:** Stuck on formatting the log entries? Ask an AI: "Show me examples of timestamp formats for log entries in Python" or "How can I format dates in Python for a log file?"

## Extension: Reading and Processing the Log

Now that you can write to a log file, implement a function to read and display its contents:

```{python}
def display_recent_logs(num_entries=5):
    """
    Displays the most recent log entries.
    
    Args:
        num_entries (int): Number of recent entries to display
    """
    # Your code here:
    # 1. Open and read the log file
    # 2. Display the most recent 'num_entries' entries
    # 3. Handle the case where the file doesn't exist yet
    # 4. Handle other potential errors
    pass
```

## Reflection Questions

1. How does using `try-except` blocks improve your program compared to not using them?
2. Why is it important to close files after you're done with them? How does the `with` statement help with this?
3. What other types of errors might occur when working with files that you should handle?

## Looking Ahead

In the next activity, we'll explore more advanced exception handling techniques and learn how to handle multiple types of exceptions. The skills you're developing now will be essential for the upcoming "Safe Utils Module" mini-project in Week 11, where you'll create reusable utility functions for common operations.
