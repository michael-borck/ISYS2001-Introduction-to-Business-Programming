---
title: "ðŸ§  Effective AI Prompts for Programming Concepts"
subtitle: "Organised by the Six Core Programming Foundations"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

This guide provides targeted prompts for each of the six programming foundations from the handout. Each section includes:

- ðŸŽ¯ Concept Exploration Prompts: For understanding the concept
- ðŸ› ï¸ Implementation Prompts: For applying the concept
- ðŸ” Debugging Prompts: For fixing issues
- ðŸš€ Challenge Prompts: For extending your learning

> **Important Note to Students**: This document demonstrates the *approach* to intentional prompting, not specific prompts to copy. Your project will have unique requirements and challenges that will require your own thoughtful prompts. Simply copying these example prompts will not result in the best solution for your specific implementation, and will not demonstrate your personal understanding and engagement with the AI. The assessment focuses on your ability to craft effective prompts specific to your project's needs - not on reproducing this example. Use this as inspiration for your own authentic conversations with AI, where you identify problems, ask clarifying questions, challenge initial solutions, and guide the AI toward better outcomes for your particular implementation.

---

## 1ï¸âƒ£ INPUT: Getting Data Into Your Program

### ðŸŽ¯ Concept Exploration Prompts
- "What are the different ways to get user input in Python?"
- "What's the difference between input() and command-line arguments?"
- "How should I validate user input to ensure it's the right type?"
- "When should I use try/except blocks with user input?"

### ðŸ› ï¸ Implementation Prompts
- "Can you show me how to get a number from the user and validate it's a positive integer?"
- "How do I prompt for a password without showing the characters?"
- "What's the best way to get a yes/no response from a user?"
- "How can I create a menu system for user input choices?"

### ðŸ” Debugging Prompts
- "My input() function is returning strings when I need numbers. How do I fix this?"
- "Users keep entering invalid data. How can I create a loop that repeats until they enter valid input?"
- "How can I handle the case where a user just presses Enter without typing anything?"

### ðŸš€ Challenge Prompts
- "Can you show me how to create a robust input system that handles different types (int, float, string) with appropriate validation?"
- "How would I implement tab-completion for user input?"
- "Can you demonstrate reading input from a file versus interactively from a user?"

---

## 2ï¸âƒ£ OUTPUT: Displaying Results

### ðŸŽ¯ Concept Exploration Prompts
- "What's the difference between print() and return in Python?"
- "How can I format numbers to show specific decimal places?"
- "What are f-strings and how do they improve output formatting?"
- "When should I write output to a file instead of the console?"

### ðŸ› ï¸ Implementation Prompts
- "How can I create a nicely formatted table of data in the console?"
- "What's the best way to show progress during a long-running operation?"
- "Can you show me how to use color in terminal output?"
- "How do I align text to the right when printing?"

### ðŸ” Debugging Prompts
- "Why does my print statement show 'None' after printing my value?"
- "My floating-point numbers are displaying too many decimal places. How do I fix this?"
- "I'm getting TypeError when using f-strings. What might I be doing wrong?"

### ðŸš€ Challenge Prompts
- "Can you show me how to create a custom progress bar for console applications?"
- "How would I implement a simple logging system instead of using print statements?"
- "Can you demonstrate creating a formatted report that could be output to console or saved to a file?"

---

## 3ï¸âƒ£ STORE: Variable Management and Data Structures

### ðŸŽ¯ Concept Exploration Prompts
- "When should I use a list versus a dictionary in Python?"
- "What's the difference between mutable and immutable data types?"
- "How do variable references work in Python compared to other languages?"
- "What is the scope of variables in functions versus global scope?"

### ðŸ› ï¸ Implementation Prompts
- "How can I store a collection of unique items in order of insertion?"
- "What's the best way to represent a grid or 2D structure in Python?"
- "Can you show me how to create a nested dictionary for hierarchical data?"
- "How do I efficiently check if an item exists in a collection?"

### ðŸ” Debugging Prompts
- "Why does my function modify the list even though I don't return it?"
- "I'm getting 'UnboundLocalError' when trying to modify a variable inside a function. Why?"
- "My dictionary keys aren't working as expected. What might be wrong?"
- "How can I find memory leaks or inefficient data storage in my code?"

### ðŸš€ Challenge Prompts
- "Can you show me how to implement a custom cache using dictionaries?"
- "How would I create a data structure to represent a family tree?"
- "Can you demonstrate when using classes would be better than dictionaries for storing complex data?"

---

## 4ï¸âƒ£ CALCULATE: Operations and Expressions

### ðŸŽ¯ Concept Exploration Prompts
- "What's the difference between `==` and `is` in Python?"
- "How do operator precedence rules work in complex expressions?"
- "When should I use bitwise operators versus logical operators?"
- "What are the performance implications of different mathematical operations?"

### ðŸ› ï¸ Implementation Prompts
- "Can you show me how to calculate the average of a list of numbers?"
- "What's the most efficient way to check if a string contains any of several substrings?"
- "How do I implement a custom sorting key for complex objects?"
- "Can you demonstrate using lambda functions for calculations?"

### ðŸ” Debugging Prompts
- "Why is my floating-point comparison not working as expected?"
- "My boolean logic seems backwards. How can I troubleshoot complex conditions?"
- "I'm getting integer division when I want float division. What's happening?"
- "How can I fix 'TypeError: unsupported operand type' errors?"

### ðŸš€ Challenge Prompts
- "Can you show me how to implement a simple calculator that evaluates expressions entered as strings?"
- "How would I create a function that finds all prime numbers below n using the Sieve of Eratosthenes?"
- "Can you demonstrate implementing a basic statistical analysis library (mean, median, mode, std dev)?"

---

## 5ï¸âƒ£ DECISIONS: Flow Control and Conditionals

### ðŸŽ¯ Concept Exploration Prompts
- "What's the difference between 'if-elif-else' and multiple 'if' statements?"
- "How does short-circuit evaluation work in logical expressions?"
- "When should I use a ternary operator versus a full if statement?"
- "What are good practices for nested conditionals to maintain readability?"

### ðŸ› ï¸ Implementation Prompts
- "Can you show me how to implement a state machine using if statements?"
- "What's the best way to handle multiple conditions that might all be true?"
- "How do I check if a value is in a specific range efficiently?"
- "Can you demonstrate using dictionary mappings instead of long if-elif chains?"

### ðŸ” Debugging Prompts
- "My if statement isn't being triggered even though the condition seems true. How can I debug this?"
- "I have deeply nested if statements that are hard to follow. How can I refactor this?"
- "Why does my code enter this branch when I expected it to skip it?"
- "How can I trace the execution path through complex conditional logic?"

### ðŸš€ Challenge Prompts
- "Can you show me how to implement a decision tree for a simple classification problem?"
- "How would I create a rules engine that evaluates complex business rules?"
- "Can you demonstrate building a simple expert system with conditional logic?"

---

## 6ï¸âƒ£ REPEAT: Loops and Iteration

### ðŸŽ¯ Concept Exploration Prompts
- "When should I use a for loop versus a while loop?"
- "What are list comprehensions and how do they compare to traditional loops?"
- "How do break, continue, and else clauses work in loops?"
- "What are the efficiency considerations for different iteration methods?"

### ðŸ› ï¸ Implementation Prompts
- "Can you show me how to iterate through nested data structures?"
- "What's the best way to process items in batches instead of one by one?"
- "How do I iterate through multiple lists in parallel?"
- "Can you demonstrate using generators for memory-efficient iteration?"

### ðŸ” Debugging Prompts
- "My loop seems to run forever. How can I debug infinite loops?"
- "I'm getting 'RuntimeError: dictionary changed sise during iteration'. What's happening?"
- "Why is my loop skipping certain elements?"
- "How can I optimise this loop that's running too slowly?"

### ðŸš€ Challenge Prompts
- "Can you show me how to implement a custom iterator class?"
- "How would I create a paginated data processor that works on very large datasets?"
- "Can you demonstrate using parallel processing to speed up a loop operation?"

---

## ðŸ”„ Integration Prompts: Combining Concepts

These prompts help students see how the six foundations connect:

1. **Simple Integration**:
   - "Can you show me a program that gets user input, validates it, performs calculations, and displays formatted results?"
   - "How would I create a loop that asks for input until the user enters valid data?"

2. **Intermediate Integration**:
   - "Can you demonstrate a data processing pipeline that reads data, transforms it through multiple stages, and outputs analysis?"
   - "How would I implement a command-line interface with different operations on stored data?"

3. **Advanced Integration**:
   - "Can you show me how to build a text-based game that uses all six programming foundations?"
   - "How would I implement a simple database-like system with CRUD operations?"

---

## ðŸ§  Meta-Prompts About Prompting

These help students improve their prompting skills:

1. "If I wanted to learn about [concept], what would be the most effective way to prompt you?"
2. "Which parts of my prompt were clear, and which parts could be improved?"

---
*This document was co-authored with Claude, an AI assistant by Anthropic, to demonstrate effective human-AI collaboration in instructional design.*Based on the assignment specification, here's a list of all files, handouts, templates, and other resources you need to provide to students:
Core Files

Assignment Specification Document - The complete, detailed requirements
One-Page Summary - The condensed version of the specification
GitHub Template Repository - Including:

README.md - Overview and instructions
PROMPTING.md - Template for documenting AI interactions
CHECKLIST.md - Requirements checklist
weather_advisor_starter.ipynb - The minimal starter notebook



Supporting Resources

Weather Data Resources:

WeatherWrapper Module (for those choosing that implementation option)
Documentation/examples for wttr.in API access


NLP Handout:

Weather Question Parser handout with different NLP strategies


Worksheets:

Weather API worksheet (first mini-project)
Parser worksheet (second mini-project)


Testing Service:

Assessment script (for the optional testing service)
Instructions for using the testing service


Submission Instructions:

Specific instructions for GitHub repository setup
Guidelines for ZIP file submission to LMS


Example Documentation:

Sample AI conversation with annotations (to show expected format)
Example of "before/after" documentation



This comprehensive set of materials will provide students with everything they need to understand the requirements, structure their work, and successfully complete the project.---
title: "TEMPLATE IDEA: Intentional Prompting Documentation"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

This file documents my process of working with AI tools to develop the Weather Advisor application. Below, I'll demonstrate how I used intentional prompting techniques to guide AI assistance throughout the project.

## Table of Contents
1. [Six-Step Methodology Example](#six-step-methodology-example)
2. [Weather Data Component](#weather-data-component)
3. [Visualisation Component](#visualisation-component)
4. [Natural Language Processing](#natural-language-processing)
5. [User Interface](#user-interface)
6. [Before/After Examples](#beforeafter-examples)

---

## Six-Step Methodology Example

For the [component name], I applied the six-step programming methodology with AI assistance:

### 1. Restate the Problem
I restated the problem in my own words:
```
[Your problem restatement here]
```

### 2. Identify Input/Output Requirements
I identified the following requirements:
- Inputs: 
  - [List inputs]
- Outputs: 
  - [List outputs]

### 3. Work Through Example by Hand
I worked through a simplified example:
```
[Your example walkthrough]
```

### 4. Write Pseudocode
I developed this pseudocode:
```
[Your pseudocode]
```

### 5. Convert to Python
I converted the pseudocode to Python with AI assistance (see Conversation X).

### 6. Test with Data
I tested with various inputs including:
- [Test case 1]
- [Test case 2]
- [Edge case: empty data]

---

## Weather Data Component

### Initial Prompt
```
[Your initial prompt to the AI]
```

### AI Response
```
[Summary or excerpt of AI's response]
```

### My Evaluation
I evaluated the AI's response and identified these issues:
- [Issue 1]
- [Issue 2]
- [Strength 1]

### Refined Prompt
```
[Your follow-up prompt]
```

### Final Implementation
After several iterations, here's the final implementation with my modifications:

```python
# Your final code here
```

---

## Visualisation Component

[Similar structure to above]

---

## Natural Language Processing

[Similar structure to above]

---

## User Interface

[Similar structure to above]

---

## Before/After Examples

### Example 1: [Component Name]

#### Before: Initial AI-Generated Code
```python
# Initial code generated by AI
```

#### My Prompting Strategy
```
I asked the AI to improve the code by [your strategy]. Specifically, I pointed out [issues].
```

#### After: Improved Implementation
```python
# Improved code after my directed prompting
```

#### Why This Approach Worked
This approach was effective because:
- [Reason 1]
- [Reason 2]

### Example 2: [Component Name]

[Similar structure to above]

### Example 3: [Component Name]

[Similar structure to above]

---

## Reflections on AI Collaboration

[Your thoughts on the process, what worked well, what you'd do differently, etc.]
# Weather Advisor Project

## Overview

This repository contains the starter template for the Weather Advisor project. You'll build a Python application that combines weather data access with conversational AI capabilities, demonstrating your programming skills and ability to work effectively with AI tools.

## Getting Started

1. **Setup Your Repository**
   - You're already here if you've used the template! If not, click "Use this template" to create your own repository.
   - Clone your repository to your local machine or connect directly to Google Colab.

2. **Open the Notebook**
   - The main file is `weather_advisor.ipynb` - open this in Google Colab.
   - Use Colab's GitHub integration to save your work directly to your repository.

3. **Review the Requirements**
   - Read the full assignment specification in the `ASSIGNMENT.md` file.
   - Check the `CHECKLIST.md` file for a list of requirements to complete.

## Repository Structure

- `weather_advisor.ipynb`: Main Colab notebook for your project
- `PROMPTING.md`: Template for documenting your AI interactions
- `CHECKLIST.md`: Requirements checklist to track your progress
- `README.md`: This file
- `conversation1.txt`, etc.: Where you'll save your AI conversation logs

## Suggested Timeline

This project has a 5-week timeline. Here's a suggested breakdown of tasks:

### Week 1: Setup and Basic Functionality
- Set up repository and familiarize yourself with the template
- Implement basic weather data retrieval functions
- Test API connectivity and basic data processing

### Week 2: Visualization and UI Framework
- Create initial data visualization functions
- Design and implement the menu system
- Develop basic user interface components

### Week 3: Natural Language Interface
- Implement question parsing functionality
- Create response generation system
- Connect natural language processing to weather data

### Week 4: Integration and Feature Completion
- Integrate all components (data, visualization, NLP)
- Refine user experience and interface
- Implement additional features and error handling

### Week 5: Testing and Documentation
- Perform comprehensive testing with various inputs
- Complete AI conversation documentation
- Finalize your submission materials
- Review against the checklist and assignment requirements

## Requirements Summary

Your Weather Advisor application must include:

1. **Weather Data Component**
   - Retrieve weather data for user-specified locations
   - Display current conditions and forecasts
   - Include at least 2 different data visualizations

2. **Natural Language Interface**
   - Allow users to ask weather-related questions in plain English
   - Parse these questions to determine the weather information needed
   - Provide natural-language responses

3. **User Experience**
   - Implement an intuitive menu system using pyinputplus
   - Include clear instructions and error handling
   - Provide a clean, organized display of information

Additionally, you must document your intentional prompting process with AI assistants.

## Documentation Requirements

Remember to document your AI interactions in the following ways:

1. **PROMPTING.md file**: Document your intentional prompting process
2. **Conversation logs**: Save your AI conversations as text files
3. **Before/After examples**: Show how you improved AI-generated code

## Resources

- [Weather API Documentation (wttr.in)](https://github.com/chubin/wttr.in)
- [Matplotlib Documentation](https://matplotlib.org/stable/index.html)
- [pyinputplus Documentation](https://pyinputplus.readthedocs.io/en/latest/)

## Getting Help

If you encounter issues or have questions:
- Check the course discussion board
- Attend office hours
- Email your instructor with specific questions

## Submission

Submit your completed project by:
1. Ensuring your GitHub repository is up to date
2. Inviting your instructor to your repository (GitHub username: michael-adci)
3. Submitting the repository link through the course submission system

Good luck with your Weather Advisor project!
# Examples: Documenting GitHub Copilot Interactions

Below are examples showing how students might document their interactions with GitHub Copilot or similar inline coding assistants in a way that demonstrates intentional prompting.

## Example 1: Function Development with Comments as Prompts

```
# Interaction: Creating a Weather Data Retrieval Function
# Date: 2025-04-02

## My Initial Guidance to Copilot
I wrote the following comment to guide Copilot:

```python
# Function to retrieve weather data from wttr.in API
# Parameters:
#   location: string - name of city or location
#   forecast_days: int - number of days to forecast (1-5)
# Returns:
#   dictionary containing current weather and forecast
# Should handle connection errors and invalid inputs
def get_weather_data(
```

## Copilot's Suggestion
Copilot completed the function signature and provided this implementation:

```python
def get_weather_data(location, forecast_days=5):
    """
    Retrieve weather data for a location
    
    Args:
        location (str): City or location name
        forecast_days (int): Number of days to forecast (1-5)
        
    Returns:
        dict: Weather data including current conditions and forecast
    """
    import requests
    
    # Clean up the location string
    location = location.strip().replace(" ", "+")
    
    try:
        # Make request to wttr.in API
        url = f"https://wttr.in/{location}?format=j1"
        response = requests.get(url, timeout=5)
        response.raise_for_status()
        
        # Parse JSON response
        data = response.json()
        
        # Extract and structure the data
        result = {
            "location": location.replace("+", " "),
            "current": {
                "temperature": int(data["current_condition"][0]["temp_C"]),
                "condition": data["current_condition"][0]["weatherDesc"][0]["value"]
            },
            "forecast": []
        }
        
        # Add forecast data
        for i in range(min(forecast_days, len(data["weather"]))):
            day = data["weather"][i]
            result["forecast"].append({
                "date": day["date"],
                "max_temp": int(day["maxtempC"]),
                "min_temp": int(day["mintempC"]),
                "condition": day["hourly"][4]["weatherDesc"][0]["value"]
            })
        
        return result
        
    except Exception as e:
        print(f"Error retrieving weather data: {e}")
        return None
```

## My Evaluation and Refinement
I noticed several issues with the generated code:
1. The error handling just prints the error instead of allowing the caller to handle it
2. The data extraction was too simple and missed important fields
3. No validation of forecast_days parameter

I added this comment to guide refinement:

```python
# Need better error handling - should return error info in the result
# Also need to extract more weather data fields:
# - wind speed and direction
# - humidity
# - precipitation amount and chance
# - validate forecast_days is between 1-5
```

## Copilot's Refined Implementation
Based on my guidance, Copilot updated the function with these improvements:

[Content omitted for brevity - would include the improved function]

## My Final Implementation
After several iterations and testing, here's my final version with additional error handling and comprehensive data extraction:

[Final implementation code would be included here]
```

## Example 2: Manual Documentation of Multi-Step Development

```
# Interaction: Creating a Natural Language Parser for Weather Questions
# Date: 2025-04-03

This interaction happened over several steps as I refined the function with Copilot.

## Step 1: Function Definition

I started by defining the function purpose with a detailed comment:

```python
# Parse a weather question to extract:
# - location (city name)
# - time period (today, tomorrow, this weekend)
# - weather attribute (temperature, rain, clothing recommendation)
# Example inputs:
# - "Will it rain tomorrow in Sydney?"
# - "Do I need a jacket in Paris today?"
# - "What's the temperature in Tokyo this weekend?"
def parse_weather_question(
```

Copilot suggested a basic function structure with regex patterns for location extraction and simple keyword matching.

## Step 2: Improving Location Extraction

I wasn't satisfied with the location extraction, so I added:

```python
# The location extraction needs to be more robust
# Should find location names that follow prepositions like "in", "for", "at"
# Also handle when location is at the beginning: "Sydney weather tomorrow?"
```

Copilot suggested more complex regex patterns and a fallback mechanism.

## Step 3: Adding Time Period Extraction

After testing location extraction, I guided Copilot to improve time parsing:

```python
# Add support for more time expressions:
# - Next Monday, Tuesday, etc.
# - In two days
# - This evening/morning/afternoon
```

Copilot added a more comprehensive time expression detection system.

## Step 4: Final Integration

After several iterations, I integrated all the components and added my own improvements:

[Final code would be shown here]

## Design Decisions and AI Contribution

Throughout this process, I used Copilot as a pair programmer by:
1. Providing detailed comments that served as specifications
2. Breaking down the problem into manageable steps
3. Evaluating and refining each suggestion
4. Adding my own improvements when Copilot's suggestions weren't optimal

The most valuable aspect was how Copilot helped generate regex patterns and provided a starting structure, while I focused on the overall design and edge case handling.
```

## Example 3: Screen Recording Documentation Template

```
# Weather Visualization Development with Copilot
# Date: 2025-04-04

I've submitted a screen recording (visualization_development.mp4) showing my interaction with Copilot to develop the temperature visualization function. 

In the recording (timestamp references included):

## Initial Function Structure (0:00-1:15)
- I started by writing comments describing the visualization requirements
- Demonstrated how I used specific comments to guide Copilot's suggestions
- Showed my evaluation of the initial code suggestion

## Refining the Visualization (1:16-2:45)
- I identified issues with axis labels and color choices
- Added specific comments to guide improvements
- Showed how I merged Copilot's suggestions with my own ideas

## Testing and Final Implementation (2:46-4:30)
- Demonstrated testing with sample data
- Final adjustments to improve readability
- Explained my thought process throughout

## Key Takeaways
The recording demonstrates my intentional prompting approach by showing how I:
1. Used descriptive comments to guide Copilot's suggestions
2. Evaluated and refined suggestions rather than accepting them blindly
3. Broke down the problem into manageable parts
4. Maintained control of the design decisions while leveraging Copilot's coding assistance
```

# Guidance for Documentation Approaches

## Effective Comment-Based Prompting for Copilot

When using GitHub Copilot or similar tools, these strategies help document intentional prompting:

1. **Write descriptive comments before asking for code**:
   ```python
   # Function to parse user weather questions
   # Should extract: location, time period, and weather attribute
   # Handle questions like: "Will it rain in London tomorrow?"
   # Return a dictionary with the extracted information
   ```

2. **Create docstring templates**:
   ```python
   def process_weather_data(data, location):
       """
       Process raw weather data for a location
       
       Args:
           data: The raw weather data from the API
           location: The user's requested location
           
       Returns:
           Processed data with only the relevant information
       """
       # Copilot will suggest implementation here
   ```

3. **Use TODOs to guide implementation**:
   ```python
   def visualize_temperature(weather_data):
       # TODO: Create a line chart of 5-day temperature forecast
       # TODO: Show both high and low temperatures
       # TODO: Add proper labels and a title with the location
       # TODO: Use a color scheme that indicates temperature ranges
   ```

4. **Examples with expected outputs**:
   ```python
   # Example:
   # Input: "Will it rain tomorrow in Sydney?"
   # Output: {"location": "Sydney", "time": "tomorrow", "condition": "rain"}
   ```
# ðŸ—£ï¸ Understanding Weather Questions: NLP Strategies

> This handout explores different approaches to parsing natural language weather questions in Python, from beginner-friendly techniques to more advanced solutions.

## The Challenge

Converting questions like "Will it rain tomorrow in Sydney?" into structured data that identifies:
- **Location**: Sydney
- **Time Period**: tomorrow
- **Weather Attribute**: rain

## Strategy 1: Keyword Matching with Regular Expressions

Perfect for beginners with no external dependencies.

```python
import re

def parse_weather_question(question):
    """Extract location, time, and weather attribute from a question."""
    result = {
        "location": None,
        "time_period": "today",  # Default
        "weather_attribute": "general"  # Default
    }
    
    # Extract location (look for words after "in" or "for")
    location_pattern = r'(?:in|for|at)\s+([A-Za-z\s]+)(?:\?|$|\s)'
    location_match = re.search(location_pattern, question)
    if location_match:
        result["location"] = location_match.group(1).strip()
    
    # Extract time period
    time_keywords = {
        "today": ["today", "now", "current"],
        "tomorrow": ["tomorrow", "next day"],
        "weekend": ["weekend", "this weekend"]
    }
    
    for period, keywords in time_keywords.items():
        if any(keyword in question.lower() for keyword in keywords):
            result["time_period"] = period
            break
    
    # Extract weather attribute
    weather_attributes = {
        "rain": ["rain", "raining", "rainy", "umbrella", "wet"],
        "temperature": ["temperature", "hot", "cold", "warm", "cool"],
        "wind": ["wind", "windy", "breeze", "gust"],
        "sunshine": ["sun", "sunny", "sunshine", "bright", "clear"]
    }
    
    for attr, keywords in weather_attributes.items():
        if any(keyword in question.lower() for keyword in keywords):
            result["weather_attribute"] = attr
            break
            
    return result

# Example usage
question = "Will it rain tomorrow in Sydney?"
result = parse_weather_question(question)
print(f"Location: {result['location']}")
print(f"Time: {result['time_period']}")
print(f"Weather attribute: {result['weather_attribute']}")
```

**Pros**: Simple, no dependencies, easy to understand and extend  
**Cons**: Limited accuracy, struggles with complex phrasing

## Strategy 2: Template Matching

Good for beginners who want more structure.

```python
def parse_with_templates(question):
    """Match question against common templates to extract information."""
    # Define templates with placeholders
    templates = [
        {"template": "Will it [WEATHER] in [LOCATION] [TIME]?",
         "weather_index": 2, "location_index": 4, "time_index": 5},
        {"template": "Is it going to [WEATHER] in [LOCATION]?",
         "weather_index": 3, "location_index": 5, "time_index": None},
        {"template": "Do I need [ITEM] in [LOCATION] [TIME]?",
         "item_index": 3, "location_index": 5, "time_index": 6}
    ]
    
    # Normalize question
    question = question.lower().strip()
    if not question.endswith("?"):
        question += "?"
    
    # Try to match against templates
    words = question.split()
    
    for template in templates:
        template_parts = template["template"].lower().split()
        
        # Simple template matching (could be improved)
        if len(words) == len(template_parts):
            match = True
            for i, part in enumerate(template_parts):
                if part.startswith("[") and part.endswith("]"):
                    # This is a placeholder, no need to match exactly
                    continue
                if words[i] != part:
                    match = False
                    break
            
            if match:
                # Extract information based on template
                result = {"location": None, "time_period": "today", "weather_attribute": "general"}
                
                if "location_index" in template and template["location_index"] is not None:
                    result["location"] = words[template["location_index"]]
                
                if "time_index" in template and template["time_index"] is not None:
                    time_word = words[template["time_index"]]
                    # Map time word to period
                    if time_word in ["tomorrow"]:
                        result["time_period"] = "tomorrow"
                    elif time_word in ["weekend", "saturday", "sunday"]:
                        result["time_period"] = "weekend"
                
                if "weather_index" in template and template["weather_index"] is not None:
                    weather_word = words[template["weather_index"]]
                    # Map weather word to attribute
                    weather_mapping = {
                        "rain": "rain", "raining": "rain", "rainy": "rain",
                        "snow": "snow", "snowing": "snow", "snowy": "snow",
                        "hot": "temperature", "cold": "temperature", "warm": "temperature"
                    }
                    result["weather_attribute"] = weather_mapping.get(weather_word, "general")
                    
                if "item_index" in template and template["item_index"] is not None:
                    item_word = words[template["item_index"]]
                    # Map items to weather attributes
                    item_mapping = {
                        "umbrella": "rain", "jacket": "temperature", 
                        "sunglasses": "sunshine", "coat": "temperature"
                    }
                    result["weather_attribute"] = item_mapping.get(item_word, "general")
                
                return result
    
    # If no template matches, fall back to regex approach
    return parse_weather_question(question)
```

**Pros**: More structured, handles common patterns well  
**Cons**: Less flexible with varied phrasing, requires manual template creation

## Strategy 3: External LLM Integration

Great for intermediate students comfortable with APIs.

```python
import requests
import json
import os

def parse_with_llm(question):
    """Use an external LLM to parse the weather question."""
    # For demonstration - you would use your actual API endpoint
    # This example uses a simplified approach
    
    API_KEY = os.environ.get("LLM_API_KEY")  # Never hardcode API keys
    
    # Construct the prompt
    prompt = f"""
    Extract the following information from this weather-related question:
    Question: "{question}"
    
    Please respond with a JSON object containing:
    - location: The city or place being asked about (null if not specified)
    - time_period: When they're asking about (today, tomorrow, weekend, etc.)
    - weather_attribute: What aspect of weather they're asking about (rain, temperature, etc.)
    
    Return ONLY the JSON object without any explanation.
    """
    
    # Make the API request
    try:
        response = requests.post(
            "https://api.example.com/v1/completions",  # Replace with actual API endpoint
            headers={
                "Authorization": f"Bearer {API_KEY}",
                "Content-Type": "application/json"
            },
            json={
                "prompt": prompt,
                "max_tokens": 150,
                "temperature": 0.1  # Low temperature for more predictable outputs
            }
        )
        
        # Parse the JSON response
        result = json.loads(response.json()["choices"][0]["text"])
        
        # Validate and provide defaults
        if "location" not in result or result["location"] is None:
            result["location"] = None
        if "time_period" not in result or result["time_period"] is None:
            result["time_period"] = "today"
        if "weather_attribute" not in result or result["weather_attribute"] is None:
            result["weather_attribute"] = "general"
            
        return result
        
    except Exception as e:
        print(f"Error using LLM API: {e}")
        # Fall back to regex approach if API fails
        return parse_weather_question(question)
```

**Pros**: High accuracy, handles complex phrasing, minimal code  
**Cons**: Requires API key, external dependency, potential cost

## Strategy 4: NLTK Named Entity Recognition

Good for intermediate students interested in traditional NLP.

```python
import nltk
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
from nltk.chunk import ne_chunk

# Uncomment these lines the first time you run this
# nltk.download('punkt')
# nltk.download('averaged_perceptron_tagger')
# nltk.download('maxent_ne_chunker')
# nltk.download('words')

def parse_with_nltk(question):
    """Use NLTK to extract named entities and analyze the question."""
    result = {
        "location": None,
        "time_period": "today",  # Default
        "weather_attribute": "general"  # Default
    }
    
    # Tokenize and tag parts of speech
    tokens = word_tokenize(question)
    pos_tags = pos_tag(tokens)
    
    # Extract named entities
    named_entities = ne_chunk(pos_tags)
    
    # Find locations (GPE = Geo-Political Entity)
    for entity in named_entities:
        if hasattr(entity, 'label') and entity.label() == 'GPE':
            result["location"] = ' '.join([word for word, tag in entity.leaves()])
            break
    
    # Check for time expressions
    time_mapping = {
        "today": ["today", "now", "current", "currently"],
        "tomorrow": ["tomorrow", "next day"],
        "weekend": ["weekend", "this weekend", "saturday", "sunday"]
    }
    
    for time_period, keywords in time_mapping.items():
        if any(keyword in [word.lower() for word, _ in pos_tags] for keyword in keywords):
            result["time_period"] = time_period
            break
    
    # Check for weather attributes
    weather_attributes = {
        "rain": ["rain", "raining", "rainy", "umbrella", "wet", "precipitation"],
        "temperature": ["temperature", "temp", "hot", "cold", "warm", "cool", "degrees"],
        "wind": ["wind", "windy", "breeze", "gust", "breezy"],
        "snow": ["snow", "snowy", "snowing", "snowfall"]
    }
    
    for attr, keywords in weather_attributes.items():
        if any(keyword in [word.lower() for word, _ in pos_tags] for keyword in keywords):
            result["weather_attribute"] = attr
            break
    
    return result
```

**Pros**: More accurate than regex, no external API needed, good learning experience  
**Cons**: Requires installing NLTK and models, more complex to understand

## Strategy 5: Pydantic Models with LLM (Advanced)

For students with more programming experience.

```python
from pydantic import BaseModel, Field
from typing import Optional
import requests
import json
import os

class WeatherQuery(BaseModel):
    """Model for structured weather query information."""
    location: Optional[str] = Field(None, description="The city or place being asked about")
    time_period: str = Field("today", description="When they're asking about (today, tomorrow, weekend)")
    weather_attribute: str = Field("general", description="Weather aspect (rain, temperature, wind, etc.)")

def parse_with_pydantic_llm(question):
    """Use an LLM with Pydantic validation to parse the weather question."""
    
    API_KEY = os.environ.get("LLM_API_KEY")  # Never hardcode API keys
    
    # Schema description
    schema = {
        "type": "object",
        "properties": {
            "location": {"type": ["string", "null"], "description": "City or place name"},
            "time_period": {"type": "string", "description": "Time period (today, tomorrow, weekend)"},
            "weather_attribute": {"type": "string", "description": "Weather aspect (rain, temperature, etc.)"}
        },
        "required": ["time_period", "weather_attribute"]
    }
    
    # Construct the prompt
    prompt = f"""
    Extract structured information from this weather question: "{question}"
    
    Follow this JSON schema exactly:
    {json.dumps(schema, indent=2)}
    
    Return ONLY the JSON object without any explanation.
    """
    
    try:
        # Make the API request
        response = requests.post(
            "https://api.example.com/v1/completions",  # Replace with actual API endpoint
            headers={
                "Authorization": f"Bearer {API_KEY}",
                "Content-Type": "application/json"
            },
            json={
                "prompt": prompt,
                "max_tokens": 150,
                "temperature": 0.1
            }
        )
        
        # Parse the JSON response
        llm_result = json.loads(response.json()["choices"][0]["text"])
        
        # Validate with Pydantic
        query = WeatherQuery(**llm_result)
        
        # Return as dictionary
        return query.dict()
        
    except Exception as e:
        print(f"Error using LLM with Pydantic: {e}")
        # Fall back to simpler approach
        return parse_weather_question(question)
```

**Pros**: Structured output, validation, handles complex queries, modern approach  
**Cons**: More complex, requires understanding of Pydantic, external API dependency

## Choosing the Right Approach

| Strategy | Complexity | Dependencies | Accuracy | Good For |
|----------|------------|--------------|----------|----------|
| Regex | Low | None | Moderate | Beginners focusing on Python basics |
| Templates | Low-Medium | None | Moderate | Those who want more structure |
| External LLM | Medium | API access | High | Students comfortable with APIs |
| NLTK | Medium-High | NLTK package | Good | NLP enthusiasts |
| Pydantic+LLM | High | Pydantic, API | Excellent | Advanced programmers |

---

## Mini-Project: Build a Weather Question Parser

### Task
Create a function that extracts location, time period, and weather attribute from natural language questions about weather.

### Steps
1. Choose one of the strategies above based on your comfort level
2. Implement the parsing function
3. Test with at least 5 different weather questions
4. Add error handling for unexpected inputs
5. (Optional) Implement a fallback strategy if your primary method fails

### Example Questions for Testing
- "Will it rain tomorrow in Sydney?"
- "What's the temperature in Tokyo today?"
- "Do I need an umbrella in London this weekend?"
- "Is it going to be windy in Chicago?"
- "How cold will it be in New York tomorrow?"

### Extension
Combine your parser with a weather data API to create a complete system that can answer weather questions in natural language!
# Implementation Guide: Weather Advisor Project

This guide provides implementation suggestions and prompting examples to help you get started with your Weather Advisor project.

## Getting Started

### Setting Up Your Repository

1. Create a new GitHub repository named `weather-advisor-project`
2. Create a new Google Colab notebook
3. Connect your Colab notebook to your GitHub repository
4. Create initial files:
   - `README.md`
   - `PROMPTING.md`

### Project Structure

Consider structuring your Colab notebook with these sections:

```
# Weather Advisor
## Setup & Configuration
## User Interface
## Weather Data Retrieval
## Data Processing & Analysis
## Visualization Functions
## Natural Language Processing
## Main Application Logic
```

## Step-by-Step Implementation Approach

### 1. Weather Data Component

Start by implementing basic weather data retrieval. Here's a sample intentional prompting sequence:

**Initial Prompt:**
```
I'm building a weather application in Python that needs to retrieve current weather and forecast data for a given city. I'd like to use the wttr.in API. Can you show me how to make a request and parse the JSON response?
```

**Evaluation:** The initial response might give you basic code but likely won't handle errors or edge cases.

**Refined Prompt:**
```
That's helpful, but I need to make my weather data retrieval more robust. Can you improve the function to:
1. Handle connection errors
2. Validate the city name input
3. Cache results to avoid excessive API calls
4. Return a structured dictionary with only the data I need (current temp, conditions, forecast)
```

As you implement this component, use the 6-step methodology:
1. Restate the problem (get weather data)
2. Identify input/output (city name â†’ weather data)
3. Work a simple example manually
4. Request pseudocode
5. Convert to Python
6. Test with different inputs

### 2. Visualization Component

Once you have weather data, you'll need to visualize it.

**Sample Prompt:**
```
I have a Python dictionary containing weather forecast data for the next 5 days. Each day has temperature (high/low), precipitation chance, and weather condition. What are 3 different ways I could visualize this data using matplotlib that would be most helpful for users? For each visualization, explain why it would be useful.
```

**Follow-up Prompt:**
```
I like the temperature trend line chart idea. Can you provide code for this visualization? The dictionary structure is:
{
  'day1': {'date': '2025-04-11', 'temp_high': 72, 'temp_low': 58, 'precip': 20, 'condition': 'Partly Cloudy'},
  'day2': {'date': '2025-04-12', 'temp_high': 75, 'temp_low': 60, 'precip': 10, 'condition': 'Sunny'},
  ...and so on
}
```

### 3. Natural Language Interface

This is where you'll leverage the hands-on-ai package and your experience with chatbots.

**Initial Prompt:**
```
I want to create a function that takes a user's question about weather (e.g., "Will it rain tomorrow in Sydney?") and determines:
1. The location they're asking about
2. The time period (today, tomorrow, this weekend)
3. The weather condition they're interested in (rain, temperature, etc.)

Can you help me write a function that parses a question and extracts these elements?
```

**Refinement Prompt:**
```
That's a good start, but I want to improve the natural language understanding. Can you revise the function to:
1. Handle more variations of time expressions (e.g., "next Tuesday", "in 3 days")
2. Handle compound questions ("Will it be sunny and warm?")
3. Return default values when elements aren't specified
```

### 4. Integration and User Interface

Finally, you'll need to integrate all components and create a user interface.

**Sample Prompt:**
```
I want to create a menu-driven interface using pyinputplus that gives users these options:
1. Get current weather for a location
2. See 5-day forecast with visualizations
3. Ask a weather-related question in natural language
4. Exit

Can you provide the code structure for this menu system?
```

## Examples of Intentional Prompting

### Example 1: Requesting Logic Explanation

**Prompt:**
```
I notice your code uses list comprehension here instead of a for loop. Can you explain why that approach is better in this context?
```

### Example 2: Critiquing Implementation

**Prompt:**
```
Your solution for parsing the weather condition works, but I'm concerned it might break with unusual inputs. What edge cases should I be concerned about, and how would you modify the code to handle them?
```

### Example 3: Requesting Modular Design

**Prompt:**
```
I think this visualization code would be clearer if broken into smaller functions. Can you refactor it into a more modular design with separate functions for data preparation and plotting?
```

## Using hands-on-ai Package

The hands-on-ai package provides several components that could be useful for your project:

1. **Conversation Management**
   - Track conversation history
   - Maintain context across multiple user queries

2. **Natural Language Understanding**
   - Entity extraction (locations, dates, weather conditions)
   - Intent classification for weather questions

Here's a sample prompt for integrating hands-on-ai:

```
I want to use the hands-on-ai package to enhance my weather advisor's natural language capabilities. Specifically, I'd like to use its conversation management features to remember previous queries. Can you show me how to integrate it with my existing parse_question function?
```

## Documentation Requirements

Remember to document your AI interactions thoroughly in `PROMPTING.md`:

```markdown
## Weather Data Retrieval Component

### Initial Prompt
I asked the AI: "..."

### AI Response
The AI suggested: "..."

### My Evaluation
The response had these strengths and weaknesses:
- Strength: Good error handling
- Weakness: No caching to prevent excessive API calls

### Refined Prompt
I then asked: "..."

### Final Implementation
After several iterations, here's my final implementation with comments explaining my choices:

```python
def get_weather(city):
    # Code here
    # ...
```

## Common Pitfalls to Avoid

1. **Overly broad prompts** - Be specific about what you need
2. **Accepting first responses** - Always evaluate and refine
3. **Not testing edge cases** - Ask AI to help you identify boundary conditions
4. **Forgetting to document** - Update your prompting journal as you go

Good luck with your Weather Advisor project!
---
title: "Optional: Formalising AI Interactions with Architecture Decision Records (ADRs)"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Optional: Formalising AI Interactions with Architecture Decision Records (ADRs)

> **Please Note:** The following information is **entirely optional** and is not a requirement for the "WeatherWise: Intelligent Weather Analysis & Advisory System" assignment. It is offered as an additional resource, primarily for those students who may be interested in more advanced software development practices or for your own reference in future projects should you wish to take your programming journey further.
>
> Consider this a supplementary technique for formalising your thought processes and the key decisions derived from your interactions with AI tools, which can be valuable in more complex projects or team environments.

---

In software development, including projects like your "WeatherWise" assignment, you'll often make design and implementation choices. AI tools (like ChatGPT, GitHub Copilot, Claude, etc.) can be incredibly helpful for exploring options, understanding concepts, and generating initial code.

While the "WeatherWise" assignment requires you to document your AI interactions through conversation logs and before/after examples, another structured approach used in the industry is Architecture Decision Records (ADRs).

## **What are Architecture Decision Records (ADRs)?**

An ADR is a short document that captures a significant design or architectural decision made during a project. Each ADR typically describes:
* The **context** of the decision (the problem you were trying to solve).
* The **decision** itself.
* The **alternatives considered** (perhaps with AI's help).
* The **rationale** (why you chose that option) and the consequences.

Think of ADRs as a way to create a clear history of *why* certain choices were made, which can be invaluable for future understanding, especially as projects evolve or if you revisit them later.

## **How This Relates to Your AI Conversations:**

Your AI conversations for the "WeatherWise" assignment are a form of discovery and decision-making documentation. If you were to use ADRs in a future project, the process might look like this:

1.  **Exploration with AI:** You'd use AI to explore solutions to a problem (e.g., "What are different ways to structure my Python application for fetching and displaying weather data?").
2.  **Critical Evaluation & Decision:** You'd analyse AI's suggestions and make a deliberate choice.
3.  **Documenting with an ADR:** You'd then create a brief ADR to formalise that decision, outlining the context, your choice, other options AI might have presented, and why you picked your final approach. This would complement, or in some professional settings, even structure the insights gained from your AI interactions.

## **Why Consider This for the Future?**

* **Deeper Understanding:** Explaining *why* a choice was made (a core part of an ADR) solidifies your understanding.
* **Structured Record:** Provides a more formal and standardised way to record key decisions beyond conversational logs.
* **Professional Practice:** ADRs are a recognised practice in many software engineering teams.

For the "WeatherWise" assignment, the specified AI conversation documentation (text files, before/after examples, demonstrating intentional prompting) is what you need to focus on. However, being aware of ADRs can provide you with an additional tool for your developer toolkit as you progress in your studies or career, offering a structured way to document how AI (and other research) informs your critical project decisions.

You would typically store ADRs in a dedicated folder (e.g., `docs/adr`) within your project repository.

Again, this is **not a requirement for your current assignment** but an insight into further practices you might find useful later on. Your primary focus should remain on fulfilling the AI documentation requirements as detailed in the "WeatherWise: Intelligent Weather Analysis & Advisory System" assignment specification.---
title: "Sample Intentional Prompting Journey"
subtitle: "Weather Dashboard Project"
format:
  pdf:
    toc: false
    number-sections: false
    colorlinks: true
  docx:
    toc: false
    number-sections: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

This document demonstrates how a student might approach the Weather Dashboard project using intentional prompting techniques. It follows the 6-step programming methodology and showcases a variety of prompt types.

> **Important Note to Students**: This document demonstrates the *approach* to intentional prompting, not specific prompts to copy. Your project will have unique requirements and challenges that will require your own thoughtful prompts. Simply copying these example prompts will not result in the best solution for your specific implementation, and will not demonstrate your personal understanding and engagement with the AI. The assessment focuses on your ability to craft effective prompts specific to your project's needs - not on reproducing this example. Use this as inspiration for your own authentic conversations with AI, where you identify problems, ask clarifying questions, challenge initial solutions, and guide the AI toward better outcomes for your particular implementation.

---

## Step 1: Restate the Problem (Foundation Prompts)

### ðŸ—£ï¸ Initial Prompt
```
I need to create a weather dashboard in Python that uses a provided module to access weather data and displays it in a user-friendly interface. Can you help me restate this problem more clearly to ensure I understand all requirements?
```

### ðŸ¤– AI Response (partial)
> This problem involves creating a Python application that:
> 1. Utilises an existing weather data module to retrieve weather information
> 2. Processes that data appropriately
> 3. Presents the information in a clear, user-friendly interface
> 4. Allows users to interact with the dashboard to view different weather metrics
>
> The key components you'll need to develop are:
> - Functions to retrieve and process data from the provided module
> - A display system (likely console-based) to show weather information
> - User interaction components to allow navigation and selection
> - Visualisation elements for presenting weather data graphically

### ðŸ—£ï¸ Follow-up Prompt (Clarification)
```
That's helpful. Could you help me understand what types of weather data are typically available through weather APIs, and what visualisations might be most useful for users? This will help me plan my dashboard layout.
```

### ðŸ¤– AI Response (partial)
> Typical weather data available through APIs includes:
> - Current temperature (actual, feels like)
> - Temperature range (high/low)
> - Humidity percentage
> - Wind speed and direction
> - Precipitation probability and amount
> - Atmospheric pressure
> - UV index
> - Visibility distance
> - Weather conditions (sunny, cloudy, rainy, etc.)
> - Forecasts (hourly, daily)
>
> For visualisations, these are particularly useful:
> - Line graphs for temperature trends over time
> - Bar charts for comparing high/low temperatures
> - Gauge charts for humidity, UV index
> - Wind direction indicators (compass or arrow)
> - Icons for weather conditions
> - Radar maps for precipitation (if mapping capabilities are available)

## Step 2: Identify Input/Output Requirements

### ðŸ—£ï¸ Requirement Gathering Prompt
```
Based on our discussion, let me identify the specific inputs and outputs for my weather dashboard:

Inputs:
- Location information (city name or coordinates)
- Type of weather data requested (current, forecast)
- Time period for forecast data

Outputs:
- Current weather conditions display
- Visual representations of temperature, humidity, etc.
- Forecast for upcoming days
- User navigation menu

Does this cover the essential inputs and outputs? Is there anything important I'm missing?
```

### ðŸ¤– AI Response
> Your input/output identification is strong! A few additional considerations:
>
> Additional inputs to consider:
> - User preferences for temperature units (Celsius/Fahrenheit)
> - Display preferences (text-only vs. graphical visualisation)
> - Refresh rate for data updates
>
> Additional outputs to consider:
> - Error messages for handling unavailable data or connection issues
> - Status indicators for data freshness
> - Historical data comparisons (if available)
> - Weather alerts or warnings
>
> Also, since you mentioned a provided module, you'll need to understand:
> - What function calls are available in the module
> - What data format it returns
> - Any authentication or rate limiting requirements

## Step 3: Work Problem by Hand

### ðŸ—£ï¸ Manual Solution Prompt
```
Before we start coding, I want to sketch out the user interaction flow for the dashboard:

1. User starts program
2. Program displays welcome and prompts for location
3. User enters location
4. Program fetches current weather data
5. Program displays main dashboard with:
   - Current temperature and conditions
   - Today's high/low
   - Humidity and wind
   - Simple 3-day forecast
6. Program shows menu options:
   - View detailed forecast
   - View temperature graph
   - Change location
   - Exit
7. User selects option
8. Program displays selected information
9. Return to menu (step 6)

Does this flow make sense? Would you structure the user experience differently?
```

### ðŸ¤– AI Response
> Your flow makes excellent sense and covers the core user journey! Here are some refinements to consider:
>
> 1. Add an initial option to select temperature units (C/F) or use a default
> 2. Consider adding a "refresh data" option in your menu
> 3. You might want to include error handling flows:
>    - What happens if location isn't found?
>    - What if the weather service is unavailable?
>    - How to handle invalid user input?
>
> For the dashboard display, consider:
> - Using ASCII art for simple visualisation in console
> - Having a "summary view" and "detailed view"
> - Including timestamps to show when data was last updated
>
> The overall structure is logical and user-friendly!

## Step 4: Request Pseudocode

### ðŸ—£ï¸ Pseudocode Prompt

```text
Now that we have a clear understanding of the problem and user flow, could you help me write pseudocode for this weather dashboard? I want to focus on creating a modular design with separate functions for data retrieval, display, and user interaction.
```

### ðŸ¤– AI Response
```python
# Main program structure
function main():
    display_welcome()
    location = get_location_from_user()
    units = get_preferred_units()
    
    while True:
        weather_data = fetch_weather_data(location, units)
        display_dashboard(weather_data)
        choice = display_menu()
        
        if choice == "forecast":
            display_detailed_forecast(weather_data)
        else if choice == "graph":
            display_temperature_graph(weather_data)
        else if choice == "location":
            location = get_location_from_user()
        else if choice == "refresh":
            continue  # Will loop back and refresh data
        else if choice == "exit":
            break

# Data functions
function fetch_weather_data(location, units):
    # Use provided weather module to get data
    current_weather = weather_module.get_current(location, units)
    forecast = weather_module.get_forecast(location, units)
    return {current: current_weather, forecast: forecast}

# Display functions
function display_dashboard(weather_data):
    clear_screen()
    display_current_conditions(weather_data["current"])
    display_simple_forecast(weather_data["forecast"])

function display_detailed_forecast(weather_data):
    clear_screen()
    for day in weather_data["forecast"]:
        display_day_forecast(day)
    wait_for_user()

function display_temperature_graph(weather_data):
    clear_screen()
    temperatures = extract_temperatures(weather_data["forecast"])
    dates = extract_dates(weather_data["forecast"])
    create_line_graph(dates, temperatures)
    wait_for_user()

# User interaction functions
function display_menu():
    print menu options
    return get_valid_choice()

function get_location_from_user():
    prompt for location
    validate location
    return location
```

### ðŸ—£ï¸ Follow-up Prompt (Challenge)
```
The pseudocode looks good overall. I noticed that error handling isn't explicitly included. Could you expand the pseudocode to include error handling for:

1. Invalid location input
2. Weather service connection failures
3. Handling missing data in the weather response

Also, how would you structure the functions to make testing easier?
```

## Step 5: Convert to Python Code

### ðŸ—£ï¸ Initial Implementation Prompt
```
Let's start converting this to Python code. First, could you implement the main() function and the user interaction functions? Assume the weather module is imported as 'weather_api' and has functions:

- weather_api.get_current(location, units) - returns current weather
- weather_api.get_forecast(location, units, days=3) - returns forecast

I'll be using pyinputplus for user input validation and matplotlib for any visualisations.
```

### ðŸ¤– AI Response (partial code)
```python
import pyinputplus as pyip
import matplotlib.pyplot as plt
import weather_api
import os
import time

def main():
    """Main function to run the weather dashboard."""
    display_welcome()
    location = get_location_from_user()
    units = get_preferred_units()
    
    while True:
        try:
            weather_data = fetch_weather_data(location, units)
            display_dashboard(weather_data)
            choice = display_menu()
            
            if choice == "forecast":
                display_detailed_forecast(weather_data)
            elif choice == "graph":
                display_temperature_graph(weather_data)
            elif choice == "location":
                location = get_location_from_user()
            elif choice == "refresh":
                continue  # Will loop back and refresh data
            elif choice == "exit":
                print("Thank you for using the Weather Dashboard!")
                break
        except ConnectionError:
            print("Unable to connect to weather service. Please check your internet connection.")
            time.sleep(2)
        except Exception as e:
            print(f"An error occurred: {e}")
            time.sleep(2)

def display_welcome():
    """Display welcome message."""
    clear_screen()
    print("=" * 60)
    print("               WEATHER DASHBOARD")
    print("=" * 60)
    print("\nWelcome to the Weather Dashboard!")
    print("This application provides current weather and forecasts.")
    print("\nPress Enter to continue...")
    input()

def get_location_from_user():
    """Get and validate location from user."""
    while True:
        clear_screen()
        print("Location Entry")
        print("-" * 60)
        try:
            location = pyip.inputStr("Enter city name (e.g., 'New York'): ")
            # Here we would typically validate the location by making a test API call
            # For now, we'll just check if it's not empty
            if location.strip():
                return location
            print("Please enter a valid location.")
        except KeyboardInterrupt:
            print("\nOperation cancelled.")
            exit()

def get_preferred_units():
    """Get user's preferred temperature units."""
    clear_screen()
    print("Temperature Units")
    print("-" * 60)
    units_choice = pyip.inputMenu(["Celsius", "Fahrenheit"], 
                                 numbered=True,
                                 prompt="Select your preferred temperature units:\n")
    return "metric" if units_choice == "Celsius" else "imperial"

def display_menu():
    """Display and handle main menu."""
    options = ["View detailed forecast", 
               "View temperature graph",
               "Change location",
               "Refresh data",
               "Exit"]
    
    choice = pyip.inputMenu(options, 
                          numbered=True,
                          prompt="\nWhat would you like to do?\n")
    
    # Convert menu choice to internal command
    if choice == "View detailed forecast":
        return "forecast"
    elif choice == "View temperature graph":
        return "graph"
    elif choice == "Change location":
        return "location"
    elif choice == "Refresh data":
        return "refresh"
    else:
        return "exit"

def clear_screen():
    """Clear the terminal screen."""
    os.system('cls' if os.name == 'nt' else 'clear')

def wait_for_user():
    """Wait for user to press Enter to continue."""
    print("\nPress Enter to return to the main menu...")
    input()
```

### ðŸ—£ï¸ Refinement Prompt

```
This looks good as a starting point. Now I need to implement the data functions and display functions. Can you help me implement:

1. fetch_weather_data()
2. display_dashboard()
3. display_detailed_forecast()
4. display_temperature_graph()

For the graph, I want to show a line graph of temperatures (high/low) for the forecast days. Please add appropriate error handling for API connection issues.
```

### ðŸ¤– AI Response (partial code)
```python
def fetch_weather_data(location, units):
    """
    Fetch weather data from API.
    
    Args:
        location: City name or location
        units: 'metric' or 'imperial'
        
    Returns:
        Dictionary containing current weather and forecast
        
    Raises:
        ConnectionError: If unable to connect to weather service
        ValueError: If location is invalid
    """
    try:
        # Attempt to get current weather
        current_weather = weather_api.get_current(location, units)
        
        # Attempt to get forecast
        forecast = weather_api.get_forecast(location, units, days=5)
        
        # Basic validation of returned data
        if not current_weather or 'temperature' not in current_weather:
            raise ValueError(f"Invalid data received for location: {location}")
        
        return {"current": current_weather, "forecast": forecast}
    
    except ConnectionError:
        raise ConnectionError("Failed to connect to weather service")
    except Exception as e:
        # Convert any other exceptions from the API to something we can handle
        raise Exception(f"Error fetching weather data: {str(e)}")

def display_dashboard(weather_data):
    """
    Display the main weather dashboard.
    
    Args:
        weather_data: Dictionary containing current weather and forecast
    """
    clear_screen()
    current = weather_data["current"]
    forecast = weather_data["forecast"]
    
    # Display header and current conditions
    print("=" * 60)
    print(f"  WEATHER DASHBOARD - {current['location'].upper()}")
    print("=" * 60)
    print(f"\nCurrent Conditions as of {current['timestamp']}")
    print(f"Temperature: {current['temperature']}Â°{'C' if current['units'] == 'metric' else 'F'}")
    print(f"Feels Like: {current['feels_like']}Â°{'C' if current['units'] == 'metric' else 'F'}")
    print(f"Condition: {current['condition']}")
    print(f"Humidity: {current['humidity']}%")
    print(f"Wind: {current['wind_speed']} {'km/h' if current['units'] == 'metric' else 'mph'} from {current['wind_direction']}")
    
    # Display simplified forecast
    print("\n3-DAY FORECAST")
    print("-" * 60)
    
    for i, day in enumerate(forecast[:3]):
        day_label = "Today" if i == 0 else "Tomorrow" if i == 1 else day['date']
        print(f"{day_label}: High {day['high']}Â° | Low {day['low']}Â° | {day['condition']}")
```

### ðŸ—£ï¸ Integration Prompt
```
I need to complete the remaining display functions and integrate everything. Could you provide the code for:

1. display_detailed_forecast()
2. display_temperature_graph()

Also, I'm not seeing where the error handling for invalid locations is implemented. Could you improve the get_location_from_user() function to attempt validation through the weather API before accepting the input?
```

## Step 6: Test with Data

### ðŸ—£ï¸ Testing Prompt
```
Now I want to test this code with some sample data. Can you provide a sample data structure that would be returned by:

1. weather_api.get_current()
2. weather_api.get_forecast()

Also, what test cases should I consider to ensure my dashboard handles all possible scenarios correctly?
```

### ðŸ¤– AI Response (partial)
> Here are sample data structures that might be returned by the weather API:
>
> ```python
> # Sample current weather data
> sample_current = {
>     'location': 'New York',
>     'timestamp': '2023-09-15 14:30',
>     'temperature': 22,
>     'feels_like': 24,
>     'condition': 'Partly Cloudy',
>     'humidity': 65,
>     'wind_speed': 8,
>     'wind_direction': 'NE',
>     'pressure': 1012,
>     'visibility': 10,
>     'uv_index': 5,
>     'units': 'metric'
> }
>
> # Sample forecast data (list of days)
> sample_forecast = [
>     {
>         'date': '2023-09-15',
>         'day_of_week': 'Friday',
>         'high': 24,
>         'low': 18,
>         'condition': 'Partly Cloudy',
>         'precipitation_chance': 20,
>         'humidity': 65,
>         'wind_speed': 8,
>         'wind_direction': 'NE',
>         'units': 'metric'
>     },
>     # Additional days would follow...
> ]
> ```
>
> Test cases to consider:
>
> 1. **Happy path**:
>    - Valid location with complete weather data
>    - Multiple days of forecast
>
> 2. **Data issues**:
>    - Missing fields in current weather
>    - Partial forecast data available
>    - Empty forecast list
>
> 3. **Connection issues**:
>    - API timeout
>    - Service unavailable
>
> 4. **User input scenarios**:
>    - Invalid location name
>    - Empty input
>    - Special characters in location name
>
> 5. **Display edge cases**:
>    - Very long location names
>    - Extreme temperature values
>    - Very long condition descriptions

### ðŸ—£ï¸ Edge Case Prompt
```
I'd like to specifically focus on handling the case where the weather service returns incomplete data. Could you show me how to modify the display_dashboard() function to gracefully handle missing fields in the weather data?

Also, the current implementation assumes a specific format for the weather data. How can I make it more robust to handle variations in the API response?
```

---

## Final Iteration and Before/After Example

### Before: Initial Data Retrieval Function
```python
def fetch_weather_data(location, units):
    """Fetch weather data from API."""
    current_weather = weather_api.get_current(location, units)
    forecast = weather_api.get_forecast(location, units, days=5)
    return {"current": current_weather, "forecast": forecast}
```

### ðŸ—£ï¸ Refinement Process Prompt
```
The fetch_weather_data() function needs improvement. It doesn't handle errors or validate the data. How can I make it more robust to:

1. Handle connection errors
2. Validate returned data structure
3. Handle missing or incomplete data
4. Provide meaningful error messages to the user
```

### After: Improved Data Retrieval Function
```python
def fetch_weather_data(location, units):
    """
    Fetch weather data from API with comprehensive error handling.
    
    Args:
        location: City name or location
        units: 'metric' or 'imperial'
        
    Returns:
        Dictionary containing current weather and forecast
        
    Raises:
        ConnectionError: If unable to connect to weather service
        ValueError: If location is invalid or data is incomplete
    """
    try:
        # Attempt to get current weather
        current_weather = weather_api.get_current(location, units)
        
        # Validate current weather data
        required_current_fields = ['temperature', 'condition', 'humidity', 'wind_speed']
        missing_fields = [field for field in required_current_fields if field not in current_weather]
        
        if missing_fields:
            # Handle missing fields by providing defaults
            for field in missing_fields:
                current_weather[field] = "N/A"
            
            # Log the issue but don't fail completely
            print(f"Warning: Some current weather data is unavailable: {', '.join(missing_fields)}")
        
        # Attempt to get forecast with retry mechanism
        max_retries = 3
        retry_count = 0
        forecast = None
        
        while retry_count < max_retries and forecast is None:
            try:
                forecast = weather_api.get_forecast(location, units, days=5)
                break
            except Exception as e:
                retry_count += 1
                if retry_count >= max_retries:
                    print(f"Warning: Could not retrieve forecast data. Using current conditions only.")
                    forecast = []  # Empty forecast as fallback
                else:
                    time.sleep(1)  # Wait before retrying
        
        # Ensure forecast is a list (even if empty)
        if not isinstance(forecast, list):
            forecast = []
            
        return {
            "current": current_weather, 
            "forecast": forecast,
            "location": location,
            "units": units,
            "timestamp": time.strftime("%Y-%m-%d %H:%M")
        }
    
    except ConnectionError:
        raise ConnectionError("Failed to connect to weather service. Please check your internet connection.")
    except ValueError as e:
        raise ValueError(f"Invalid location: {location}. Please check spelling and try again.")
    except Exception as e:
        # Convert any other exceptions from the API to something we can handle
        raise Exception(f"Error fetching weather data: {str(e)}")
```

### Explanation
The improved function demonstrates:

1. **Comprehensive error handling** with specific error types
2. **Data validation** to check for required fields
3. **Graceful degradation** by providing defaults for missing data
4. **Retry mechanism** for transient failures
5. **Defensive programming** by ensuring forecast is always a list
6. **Informative error messages** for better user experience
7. **Additional metadata** (timestamp, location) for context

This improvement resulted from intentional prompting that specifically challenged the AI to address potential failure modes and edge cases, rather than accepting the initial implementation.
---
title: "WeatherWise: Intelligent Weather Analysis & Advisory System"
subtitle: "Harnessing Python and AI to Create Intuitive Weather Applications"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

## Overview

In this assignment, you will develop a Python application called "Weather Advisor" that combines weather data access with conversational AI capabilities. This project brings together several key concepts you've learnt throughout the course, including modular programming, data visualisation, user interfaces, andâ€”cruciallyâ€”intentional prompting techniques when working with AI.

Your solution should demonstrate both your technical Python skills and your ability to effectively direct AI tools as part of your development workflow. This project will challenge you to apply your skills creatively, and you'll end up with a practical application you can be proud of.

> **Note on Assignment Length**: This specification is comprehensive to accommodate various workflows and AI tools. Don't be intimidated by its lengthâ€”it's designed to provide clarity and flexibility for all students, regardless of which AI tools you prefer to use. The detailed requirements help you understand how to demonstrate your process of working with AI, which is a key component of this assignment.

> **Embracing the Challenge**: This project may initially seem ambitious, but remember that you've already learnt all the fundamental techniques needed to succeed. The weekly activities and mini-projects have prepared you with the building blocksâ€”from working with APIs to creating chatbots to visualising data. This assignment brings these pieces together into something greater than the sum of its parts. The satisfaction of overcoming this challenge and creating something genuinely useful will be well worth the effort!

## Learning Objectives

By completing this assignment, you will:

- Implement a complete, functional Python application with modular design
- Apply data visualisation techniques to weather information
- Create intuitive user interfaces using console-based menus or widgets
- Demonstrate your ability to use intentional prompting with AI tools
- Practice version control using GitHub
- Document your development process and AI interactions
- Apply critical thinking when evaluating and improving AI-generated code

## Project Requirements

### Core Features (Required)

Your Weather Advisor application must include:

1. **Weather Data Component**
   - Retrieve weather data for user-specified locations
   - Display current conditions and forecasts
   - Include at least 2 different data visualisations (e.g., temperature trends, precipitation chances)

2. **Natural Language Interface**
   - Allow users to ask weather-related questions in plain English
   - Parse these questions to determine the weather information needed
   - Provide natural-language responses that answer the user's question

3. **User Experience**
   - Implement an intuitive menu system using pyinputplus
   - Include clear instructions and error handling
   - Provide a clean, organised display of information

### Technical Requirements

Your implementation must demonstrate:

1. **Modular Design**
   - Break your program into logical functions and modules
   - Use appropriate naming conventions
   - Include docstrings and comments

2. **Core Functions**
   - Your application should implement these functions (provided as stubs in the starter notebook):
   
   ```python
   def get_weather_data(location, forecast_days=5):
       """
       Retrieve weather data for a specified location.
       
       Args:
           location (str): City or location name
           forecast_days (int): Number of days to forecast (1-5)
           
       Returns:
           dict: Weather data including current conditions and forecast
       """
       pass
       
   def parse_weather_question(question):
       """
       Parse a natural language weather question.
       
       Args:
           question (str): User's weather-related question
           
       Returns:
           dict: Extracted information including location, time period, and weather attribute
       """
       pass
       
   def generate_weather_response(parsed_question, weather_data):
       """
       Generate a natural language response to a weather question.
       
       Args:
           parsed_question (dict): Parsed question data
           weather_data (dict): Weather data
           
       Returns:
           str: Natural language response
       """
       pass
       
   def create_temperature_visualisation(weather_data, output_type='display'):
       """
       Create visualisation of temperature data.
       
       Args:
           weather_data (dict): The processed weather data
           output_type (str): Either 'display' to show in notebook or 'figure' to return the figure
           
       Returns:
           If output_type is 'figure', returns the matplotlib figure object
           Otherwise, displays the visualisation in the notebook
       """
       pass
       
   def create_precipitation_visualisation(weather_data, output_type='display'):
       """
       Create visualisation of precipitation data.
       
       Args:
           weather_data (dict): The processed weather data
           output_type (str): Either 'display' to show in notebook or 'figure' to return the figure
           
       Returns:
           If output_type is 'figure', returns the matplotlib figure object
           Otherwise, displays the visualisation in the notebook
       """
       pass
   ```

3. **User Interface Flexibility**
   - You may implement your user interface using either:
     - Console-based menus with pyinputplus
     - Interactive widgets using ipywidgets
     - A hybrid approach combining both
   - Your UI should call the core functions rather than duplicating their functionality
   - Choose the approach that best showcases your application

4. **Data Handling**
   - Retrieve and process weather data
   - Store relevant information for use in the application
   - Handle edge cases (e.g., invalid locations, missing data)

5. **Visualisation**
   - Create at least 2 different types of visualisations
   - Ensure visualisations are properly labelled and clear
   - Make visualisations relevant to the user's query when possible

### Weather Data Source Options

You have three options for implementing the weather data component. All options can earn full marks for the core requirements, but more advanced implementations may qualify for bonus points.

1. **Foundation Option**: Use the provided fetch-my-weather package
   - A simplified interface to wttr.in weather services that handles API complexities
   - Provides consistent data structures and error handling
   - Allows you to focus on application logic and other components
   - *Perfect for getting started and meeting core requirements*

2. **Standard Option**: Use the wttr.in service API directly
   - Example: `https://wttr.in/London?format=j1` returns JSON data
   - Documentation: https://github.com/chubin/wttr.in
   - Requires implementing your own request handling and data processing
   - *Demonstrates API interaction skills and offers more customisation*

3. **Extension Option**: Implement your own solution with OpenWeatherMap or similar
   - Requires obtaining and securely handling an API key
   - Offers access to more detailed weather data
   - Provides experience with commercial API integration
   - *Eligible for bonus points if well-implemented with proper error handling*

**Note on Bonus Points**: Students who implement their own weather data retrieval (options 2 or 3) with additional features beyond basic requirements may receive bonus consideration (up to 5% extra). Examples of bonus-worthy features include:
- Robust caching to minimise API calls
- Comprehensive error handling with informative user feedback
- Support for multiple weather data sources with a consistent interface
- Advanced data processing that enhances the user experience

Remember that your choice should align with your comfort level and project goals. All options can achieve full marks for the core requirements when implemented correctly, so choose the approach that you feel most confident with!

## Development Process Requirements

### GitHub Integration

- Create a GitHub repository for your project
- Make regular, meaningful commits throughout development
- Your final submission should have at least 15 commits that show progression
- Include a clear README.md file with instructions for running your application

### Intentional Prompting Documentation

A critical component of this assignment is documenting your use of AI tools:

1. **Implementation Options Exploration**
   - Include an initial AI conversation where you explore and compare the three implementation options
   - This conversation should demonstrate your analytical thinking about the project requirements and should go deeper than simply asking which option is best
   - Show how you evaluated the technical considerations, design implications, and alignment with your skills for each option
   - Your conversation should reflect a thoughtful decision-making process that led to your final choice

2. **Required Prompting Techniques**
   You must demonstrate at least 5 of the following intentional prompting techniques:
   
   - **Restate the problem** in your own words to the AI
   - **Identify input/output requirements** through targeted prompts
   - **Request pseudocode** before asking for implementation
   - **Challenge edge cases** in AI-generated code
   - **Request modular design** improvements
   - **Ask for code explanations** to ensure understanding
   - **Request iterative improvements** to initial solutions
   - **Query design trade-offs** for different implementation options

3. **Before/After Examples**
   - Include at least 3 clear examples showing:
     - Initial AI-generated code from your prompt
     - Your specific follow-up prompts that led to improvements
     - The improved code that resulted from your intentional prompting
     - Explanation of why your prompting strategy was effective

### AI Conversation Documentation Requirements

You must document your AI interactions using the following format:

1. **File Format**
   - Save conversations as plain text files (`.txt`)
   - Name files sequentially: `conversation1.txt`, `conversation2.txt`, etc.
   - Submit at least 5 significant conversations that demonstrate different aspects of your development process

2. **Content Requirements**
   - Include a brief header for each conversation (e.g., "Conversation about weather data retrieval")
   - Clearly indicate who is speaking (e.g., "Me:", "AI:")
   - Include the full conversation with both your prompts and the AI's responses
   - Add brief comments or notes where relevant to highlight important points

3. **Important Guidelines**
   - Copy conversations directly from the chat interface
   - Include complete interactions, not just selected snippets
   - Do not submit screenshots or images of conversations
   - If a conversation is very long, you may focus on the most relevant sections, but indicate where content has been omitted
   - Include at least one conversation showing how you handled an incorrect or problematic AI response

### Documentation for Alternative AI Tools

If you use tools like GitHub Copilot, Cursor, Whisper, Claude-Code, or other coding assistants that don't provide traditional conversation logs:

1. **Screen Recording Option**
   - You may submit brief screen recordings (2-5 minutes each) showing your interaction with these tools
   - The recordings should clearly show both your inputs and the AI's suggestions
   - Include a brief narration or text overlay explaining what you're doing and how you're directing the AI

2. **Manual Documentation Option**
   - Create a log that approximates the conversation by documenting:
     - What you asked or prompted (partial code, comments, etc.)
     - What the AI suggested (completions, alternatives, etc.)
     - How you evaluated and refined those suggestions
   - Structure this as a series of exchanges, similar to a chat conversation
   - Include screenshots of the interaction where helpful, but these should supplement text, not replace it

3. **Tool-Specific Requirements**
   - **GitHub Copilot**: Document your use of comments to guide suggestions and how you refined them
   - **Cursor**: You may use the chat sidebar for more conversational interactions and submit those logs
   - **Whisper or voice-based tools**: Transcribe key voice commands and responses
   - **Claude-Code and similar tools**: Capture the prompts and responses

4. **Multilingual Considerations**
   - If English is not your first language, you may conduct initial AI conversations in your preferred language
   - Submit both the original conversation in your language and an English translation
   - All code, comments, documentation, and final submission materials must be in English
   - Consider using the six-step methodology in your native language for planning, then translate when implementing

Regardless of the AI tool you use, you must still demonstrate intentional prompting by showing how you guided the tool to help you solve problems rather than accepting its first suggestions. All students must include the required "before/after" examples regardless of which AI tools they use.

Conversations must be submitted as searchable text (or as described above for alternative tools), not images. Submissions that use screenshots or non-text formats for conversations will receive significant reduced marks for that component.

## Project Implementation Options

You may structure your project in one of the following ways:

### Option 1: Advanced Weather Dashboard
- Create a comprehensive weather dashboard with multiple visualisation types
- Allow filtering by time periods and weather attributes
- Include a chat interface for natural language queries about displayed data

### Option 2: Weather-Aware Chatbot
- Focus on the conversational interface as the primary interaction method
- Retrieve and display weather information based on natural language analysis
- Use visualisations to supplement text responses when appropriate

### Option 3: Hybrid Approach (Recommended)
- Implement both dashboard and conversational features
- Allow users to switch between interaction modes
- Ensure visualisation and chat components are well-integrated

## Notebook Organisation Requirements

Your Google Colab notebook should demonstrate clear organisation through a cell-based modular approach:

### Cell-Based Structure
- Organise your notebook into clearly labelled sections using markdown cells
- Group related functionality together in dedicated sections
- Include a table of contents at the top of the notebook

### Required Sections
Your notebook should include at least these labelled sections:
1. **Setup and Configuration** - Imports and initial setup
2. **Weather Data Functions** - Functions for retrieving and processing weather data
3. **Visualisation Functions** - Code for creating data visualisations
4. **Natural Language Processing** - Functions for handling user questions
5. **User Interface** - Menu system and display functions
6. **Main Application Logic** - Core functionality that ties everything together
7. **Testing and Examples** - Demonstrations of key features

### Modular Design
- Define general-purpose functions that can be reused
- Minimise code duplication
- Keep functions focused on single responsibilities
- Include appropriate comments and docstrings

The organisation of your notebook will be part of your assessment, with particular attention to:
- Logical grouping of related functionality
- Clear section headings and descriptions
- Appropriate separation of concerns
- Documentation quality


### Weather Data API Testing

When testing your application, we will use mock versions of the weather API services. To ensure compatibility:

1. Your `get_weather_data()` function should follow the provided signature
2. If using OpenWeatherMap, access the API key via: `os.environ.get("OPENWEATHER_API_KEY")`
3. Your code should handle cases where the API returns incomplete data
4. For testing, we will simulate various weather conditions and error cases
5. Ensure your code can handle both successful and failed API calls gracefully
6. Use the `requests` library for API calls, and ensure you handle exceptions properly


## Submission Requirements

Your submission should include:

1. **GitHub Repository**
   - All project files must be uploaded to your GitHub repository
   - Invite your instructor to your repository (GitHub username: michael-borck)
   - Your repository should include:
     - Google Colab notebook (.ipynb file)
     - README.md with project overview and setup instructions
     - AI conversation text files (conversation1.txt, conversation2.txt, etc.)
     - Any additional supporting documentation you wish to include
   - Ensure the repository is properly organised and complete

2. **LMS Submission**
   - Download a ZIP file of your entire GitHub repository
   - Submit this ZIP file to the course LMS by the due date
   - Ensure all files are included and the ZIP can be extracted properly

3. **Required Files**
   - Google Colab notebook with your complete, working application
   - Documentation files as specified above
   - Text files of AI conversations
   - A brief reflection document (300-500 words) on your development process

4. **Code Quality**
   - Well-commented code with docstrings
   - Consistent naming conventions
   - Proper error handling

5. **Testing Resource**
   - A preliminary version of your notebook can be submitted to the course testing service
   - The testing service will check basic functionality and notebook structure
   - Submission to the testing service is optional but recommended to identify issues early

**Note**: Submitting both to GitHub and the LMS ensures we have access to your work even if there are technical issues with either platform.

## Assessment Criteria

| Criterion | Weighting | Description |
|-----------|-----------|-------------|
| **Functionality** | 15% | Application works as expected; features are complete (demonstrate development process in AI conversations) |
| **Code Quality** | 10% | Well-structured, readable code with proper documentation (show code refinement through AI conversations) |
| **Notebook Organisation** | 10% | Logical cell-based structure; clear section organisation (reflect planning discussions in AI conversations) |
| **User Experience** | 10% | Interface is intuitive and information is clearly presented (show UI design iterations in AI conversations) |
| **Intentional Prompting** | 30% | Documentation of AI interactions; evidence of strategic prompting techniques that improved your implementation |
| **AI Conversation Quality** | 15% | Comprehensive conversation documentation showing problem-solving journey and thoughtful interactions |
| **Technical Implementation** | 10% | Appropriate use of libraries and efficient implementation (demonstrate technical decision-making in AI conversations) |

Remember, this project is your opportunity to showcase everything you've learnt in this course. We're excited to see your creative solutions!

## Extensions (Optional for Higher Grades)

By completing the core requirements, you'll demonstrate solid mastery of the course material. If you're looking for additional challenges, consider these extensions:

- Historical weather data analysis with more advanced visualisations
- Location-based recommendations (e.g., "Is tomorrow good for hiking?")
- Integration with calendar or event planning features
- Advanced error handling and input validation
- Custom themes or visualisation styles

## Support Resources

- Weather API documentation (links to be provided)
- hands-on-ai package documentation
- Sample code for basic weather data retrieval
- Office hours for technical questions

## Due Date

Submit your completed assignment by 23:59 on Friday 23rd May 2025.

## Notes on Academic Integrity

While you are encouraged to use AI tools as part of your development process, your submission must represent your own understanding and effort. You must be able to explain all aspects of your code, including any AI-generated portions. The intentional prompting documentation is a critical component that demonstrates your engagement with the material.

This assignment assesses not just the final product, but your process and interaction with AI tools. The detailed documentation requirements ensure that your unique contribution is visible regardless of which AI tools you use. Remember that effectively guiding AI tools is a skill itself that requires critical thinking and domain knowledge.

Good luck, and enjoy building your Weather Advisor application!
---
title: "ðŸ§  Effective AI Prompts for Programming Concepts"
subtitle: "Organised by the Six Core Programming Foundations"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

This guide provides targeted prompts for each of the six programming foundations from the handout. Each section includes:

- ðŸŽ¯ Concept Exploration Prompts: For understanding the concept
- ðŸ› ï¸ Implementation Prompts: For applying the concept
- ðŸ” Debugging Prompts: For fixing issues
- ðŸš€ Challenge Prompts: For extending your learning

> **Important Note to Students**: This document demonstrates the *approach* to intentional prompting, not specific prompts to copy. Your project will have unique requirements and challenges that will require your own thoughtful prompts. Simply copying these example prompts will not result in the best solution for your specific implementation, and will not demonstrate your personal understanding and engagement with the AI. The assessment focuses on your ability to craft effective prompts specific to your project's needs - not on reproducing this example. Use this as inspiration for your own authentic conversations with AI, where you identify problems, ask clarifying questions, challenge initial solutions, and guide the AI toward better outcomes for your particular implementation.

---

## 1ï¸âƒ£ INPUT: Getting Data Into Your Program

### ðŸŽ¯ Concept Exploration Prompts
- "What are the different ways to get user input in Python?"
- "What's the difference between input() and command-line arguments?"
- "How should I validate user input to ensure it's the right type?"
- "When should I use try/except blocks with user input?"

### ðŸ› ï¸ Implementation Prompts
- "Can you show me how to get a number from the user and validate it's a positive integer?"
- "How do I prompt for a password without showing the characters?"
- "What's the best way to get a yes/no response from a user?"
- "How can I create a menu system for user input choices?"

### ðŸ” Debugging Prompts
- "My input() function is returning strings when I need numbers. How do I fix this?"
- "Users keep entering invalid data. How can I create a loop that repeats until they enter valid input?"
- "How can I handle the case where a user just presses Enter without typing anything?"

### ðŸš€ Challenge Prompts
- "Can you show me how to create a robust input system that handles different types (int, float, string) with appropriate validation?"
- "How would I implement tab-completion for user input?"
- "Can you demonstrate reading input from a file versus interactively from a user?"

---

## 2ï¸âƒ£ OUTPUT: Displaying Results

### ðŸŽ¯ Concept Exploration Prompts
- "What's the difference between print() and return in Python?"
- "How can I format numbers to show specific decimal places?"
- "What are f-strings and how do they improve output formatting?"
- "When should I write output to a file instead of the console?"

### ðŸ› ï¸ Implementation Prompts
- "How can I create a nicely formatted table of data in the console?"
- "What's the best way to show progress during a long-running operation?"
- "Can you show me how to use color in terminal output?"
- "How do I align text to the right when printing?"

### ðŸ” Debugging Prompts
- "Why does my print statement show 'None' after printing my value?"
- "My floating-point numbers are displaying too many decimal places. How do I fix this?"
- "I'm getting TypeError when using f-strings. What might I be doing wrong?"

### ðŸš€ Challenge Prompts
- "Can you show me how to create a custom progress bar for console applications?"
- "How would I implement a simple logging system instead of using print statements?"
- "Can you demonstrate creating a formatted report that could be output to console or saved to a file?"

---

## 3ï¸âƒ£ STORE: Variable Management and Data Structures

### ðŸŽ¯ Concept Exploration Prompts
- "When should I use a list versus a dictionary in Python?"
- "What's the difference between mutable and immutable data types?"
- "How do variable references work in Python compared to other languages?"
- "What is the scope of variables in functions versus global scope?"

### ðŸ› ï¸ Implementation Prompts
- "How can I store a collection of unique items in order of insertion?"
- "What's the best way to represent a grid or 2D structure in Python?"
- "Can you show me how to create a nested dictionary for hierarchical data?"
- "How do I efficiently check if an item exists in a collection?"

### ðŸ” Debugging Prompts
- "Why does my function modify the list even though I don't return it?"
- "I'm getting 'UnboundLocalError' when trying to modify a variable inside a function. Why?"
- "My dictionary keys aren't working as expected. What might be wrong?"
- "How can I find memory leaks or inefficient data storage in my code?"

### ðŸš€ Challenge Prompts
- "Can you show me how to implement a custom cache using dictionaries?"
- "How would I create a data structure to represent a family tree?"
- "Can you demonstrate when using classes would be better than dictionaries for storing complex data?"

---

## 4ï¸âƒ£ CALCULATE: Operations and Expressions

### ðŸŽ¯ Concept Exploration Prompts
- "What's the difference between `==` and `is` in Python?"
- "How do operator precedence rules work in complex expressions?"
- "When should I use bitwise operators versus logical operators?"
- "What are the performance implications of different mathematical operations?"

### ðŸ› ï¸ Implementation Prompts
- "Can you show me how to calculate the average of a list of numbers?"
- "What's the most efficient way to check if a string contains any of several substrings?"
- "How do I implement a custom sorting key for complex objects?"
- "Can you demonstrate using lambda functions for calculations?"

### ðŸ” Debugging Prompts
- "Why is my floating-point comparison not working as expected?"
- "My boolean logic seems backwards. How can I troubleshoot complex conditions?"
- "I'm getting integer division when I want float division. What's happening?"
- "How can I fix 'TypeError: unsupported operand type' errors?"

### ðŸš€ Challenge Prompts
- "Can you show me how to implement a simple calculator that evaluates expressions entered as strings?"
- "How would I create a function that finds all prime numbers below n using the Sieve of Eratosthenes?"
- "Can you demonstrate implementing a basic statistical analysis library (mean, median, mode, std dev)?"

---

## 5ï¸âƒ£ DECISIONS: Flow Control and Conditionals

### ðŸŽ¯ Concept Exploration Prompts
- "What's the difference between 'if-elif-else' and multiple 'if' statements?"
- "How does short-circuit evaluation work in logical expressions?"
- "When should I use a ternary operator versus a full if statement?"
- "What are good practices for nested conditionals to maintain readability?"

### ðŸ› ï¸ Implementation Prompts
- "Can you show me how to implement a state machine using if statements?"
- "What's the best way to handle multiple conditions that might all be true?"
- "How do I check if a value is in a specific range efficiently?"
- "Can you demonstrate using dictionary mappings instead of long if-elif chains?"

### ðŸ” Debugging Prompts
- "My if statement isn't being triggered even though the condition seems true. How can I debug this?"
- "I have deeply nested if statements that are hard to follow. How can I refactor this?"
- "Why does my code enter this branch when I expected it to skip it?"
- "How can I trace the execution path through complex conditional logic?"

### ðŸš€ Challenge Prompts
- "Can you show me how to implement a decision tree for a simple classification problem?"
- "How would I create a rules engine that evaluates complex business rules?"
- "Can you demonstrate building a simple expert system with conditional logic?"

---

## 6ï¸âƒ£ REPEAT: Loops and Iteration

### ðŸŽ¯ Concept Exploration Prompts
- "When should I use a for loop versus a while loop?"
- "What are list comprehensions and how do they compare to traditional loops?"
- "How do break, continue, and else clauses work in loops?"
- "What are the efficiency considerations for different iteration methods?"

### ðŸ› ï¸ Implementation Prompts
- "Can you show me how to iterate through nested data structures?"
- "What's the best way to process items in batches instead of one by one?"
- "How do I iterate through multiple lists in parallel?"
- "Can you demonstrate using generators for memory-efficient iteration?"

### ðŸ” Debugging Prompts
- "My loop seems to run forever. How can I debug infinite loops?"
- "I'm getting 'RuntimeError: dictionary changed sise during iteration'. What's happening?"
- "Why is my loop skipping certain elements?"
- "How can I optimise this loop that's running too slowly?"

### ðŸš€ Challenge Prompts
- "Can you show me how to implement a custom iterator class?"
- "How would I create a paginated data processor that works on very large datasets?"
- "Can you demonstrate using parallel processing to speed up a loop operation?"

---

## ðŸ”„ Integration Prompts: Combining Concepts

These prompts help students see how the six foundations connect:

1. **Simple Integration**:
   - "Can you show me a program that gets user input, validates it, performs calculations, and displays formatted results?"
   - "How would I create a loop that asks for input until the user enters valid data?"

2. **Intermediate Integration**:
   - "Can you demonstrate a data processing pipeline that reads data, transforms it through multiple stages, and outputs analysis?"
   - "How would I implement a command-line interface with different operations on stored data?"

3. **Advanced Integration**:
   - "Can you show me how to build a text-based game that uses all six programming foundations?"
   - "How would I implement a simple database-like system with CRUD operations?"

---

## ðŸ§  Meta-Prompts About Prompting

These help students improve their prompting skills:

1. "If I wanted to learn about [concept], what would be the most effective way to prompt you?"
2. "Which parts of my prompt were clear, and which parts could be improved?"

---
*This document was co-authored with Claude, an AI assistant by Anthropic, to demonstrate effective human-AI collaboration in instructional design.*# WeatherWise: What's This Project All About?

## The Big Picture

You'll build a weather app called "Weather Advisor" that combines real weather data with AI conversation abilities. Think of it as a smart weather assistant that can answer questions like "Should I take an umbrella tomorrow?" or "What's the temperature going to be like this weekend in Sydney?"

## What You'll Create

This project has two main parts:

1. **Weather Information Display**
   - Gets current weather and forecasts for any location
   - Shows useful charts and graphs of temperature and rain chances
   - Presents weather data in a clear, organised way

2. **Conversation Feature**
   - Lets users ask questions in everyday language
   - Understands what weather information they need
   - Responds in a natural, helpful way

## How You'll Build It

You'll:
- Write Python code to get weather data from online services
- Create visual charts to show weather patterns
- Build a user-friendly menu system
- Program the app to understand weather questions
- Use AI tools to help with coding challenges
- Document how you used AI to solve problems

## Learning Value

This project helps you learn:
- How to build a complete, working application
- Creating useful data visualisations
- Making intuitive user interfaces
- Working effectively with AI coding assistants
- Using version control (GitHub)
- Writing well-structured, maintainable code

## Assessment Approach

You'll be graded on:
- Whether your app works as expected (15%) - shown in AI conversations
- Quality of your code (10%) - refined through AI conversations
- How well you organised your work (10%) - planned in AI conversations
- How easy your app is to use (10%) - iterated in AI conversations
- How effectively you used AI tools (30%) - demonstrated by strategic prompting
- Quality of your AI interactions (15%) - showing your problem-solving journey
- Technical implementation choices (10%) - explained in AI conversations

## Why This Project Matters

This assignment gives you practical experience creating a useful application while learning to work effectively with AI tools. It's designed to be challenging but achievable, bringing together many skills you've learnt throughout the course. The focus isn't just on the final product, but on your journey of development and problem-solving.

By the end, you'll have created something practical that demonstrates your programming abilities and your skill in directing AI tools to achieve specific goals - an increasingly important skill in today's technology landscape.
---
title: "Managing Files in Your GitHub Repository via the Web Interface"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

This handout will guide you through performing common file operations directly on the GitHub website. This is useful for organising your project files, especially when working with Google Colab notebooks that are stored in your GitHub repositories. You won't need to install Git or use any command-line tools.

**Accessing Your Repository:**

1.  Go to [https://github.com](https://github.com) and log in to your account.
2.  Navigate to the repository you want to work with by clicking on its name on your dashboard or your profile page.

---

### 1. Uploading Files

You can upload various file types to your GitHub repository, such as Python scripts (`.py`), data files (`.csv`, `.txt`, `.json`), images, or other project-related documents.

**Steps:**

1.  Once you are in your repository, click on the **"Add file"** button located above the list of files.
2.  From the dropdown menu, select **"Upload files"**.
3.  You can then either:
    * **Drag and drop** your file(s) into the box provided.
    * Click on **"choose your files"** to open a file dialog and select the file(s) from your computer.
4.  After the files have been uploaded, you will see them listed.
5.  Scroll down to the **"Commit changes"** section.
    * In the first text box, provide a brief, meaningful message describing the upload (e.g., "Upload dataset for analysis", "Add utility script"). This is a commit message.
    * You can add a more detailed description in the larger text box below if needed (optional for simple uploads).
6.  Ensure that **"Commit directly to the `main` branch"** is selected (or your default branch, usually `main` or `master`). For beginner purposes, this is the standard workflow.
7.  Click the green **"Commit changes"** button. Your files are now in your repository.

---

### 2. Creating a New Folder (and adding a file to it)

GitHub doesn't allow you to create an empty folder directly. A folder is created automatically when you add a file within it.

**Steps:**

1.  In your repository, click on the **"Add file"** button.
2.  From the dropdown menu, select **"Create new file"**.
3.  In the **"Name your file..."** box at the top, type the name of your desired folder followed by a forward slash `/`. For example, to create a folder named "data", you would type `data/`.
4.  **Important:** After the `/`, you must then type a filename for a new file that will reside within this folder. GitHub requires at least one file to create a folder. Often, people create a placeholder file like `.gitkeep` (an empty file that signals the folder should be tracked) or `README.md` (if you want to describe the folder's contents). For example: `data/.gitkeep` or `data/notes.txt`.
5.  If you are creating a file like `notes.txt`, you can add some content to it in the editing area below. If you are creating a `.gitkeep` file, you can leave the content area blank.
6.  Scroll down to the **"Commit new file"** section.
    * Provide a commit message (e.g., "Create data folder", "Add initial notes for data folder").
7.  Ensure **"Commit directly to the `main` branch"** is selected.
8.  Click the green **"Commit new file"** button. You will now see your new folder in the repository.

---

### 3. Renaming a File

**Steps:**

1.  Navigate to the file you want to rename within your repository.
2.  Click on the filename to open the file view.
3.  On the right side of the file view, above the file content, you will see a set of icons. Click the **pencil icon (Edit this file)**.
4.  At the top of the page, where the filename is displayed, you can now edit the filename directly in the text box. Change it to the new desired name.
5.  Scroll down to the **"Commit changes"** section.
    * GitHub will usually pre-fill a commit message like "Rename [old filename] to [new filename]". You can customise this if needed.
6.  Ensure **"Commit directly to the `main` branch"** is selected.
7.  Click the green **"Commit changes"** button.

---

### 4. Moving a File into a Folder

Moving a file in GitHub's web interface is essentially renaming the file to include the new folder path.

**Steps:**

1.  Navigate to the file you want to move.
2.  Click on the filename to open the file view.
3.  Click the **pencil icon (Edit this file)** on the right side.
4.  In the filename box at the top, you will edit the file's path.
    * To move `myfile.txt` into an existing folder called `documents`, you would change the filename from `myfile.txt` to `documents/myfile.txt`.
    * If the folder doesn't exist yet, typing `newfolder/myfile.txt` will create `newfolder` and place `myfile.txt` inside it.
5.  Scroll down to the **"Commit changes"** section.
    * Provide a commit message (e.g., "Move script to utilities folder", "Organise data files").
6.  Ensure **"Commit directly to the `main` branch"** is selected.
7.  Click the green **"Commit changes"** button.

**Tip:** If you want to move a file "up" one level (out of a folder), you would delete the folder prefix from its name. For example, to move `data/report.txt` to the main (root) directory, you would rename it from `data/report.txt` to `report.txt`.

---

### 5. Deleting a File

**Steps:**

1.  Navigate to the file you want to delete within your repository.
2.  Click on the filename to open the file view.
3.  On the right side of the file view, above the file content, click the **trash can icon (Delete this file)**.
4.  Scroll down to the **"Commit changes"** section.
    * GitHub will pre-fill a commit message like "Delete [filename]". You can customise this.
5.  Ensure **"Commit directly to the `main` branch"** is selected.
6.  Click the green **"Commit changes"** button.

---

### 6. Deleting a Folder

Similar to creating folders, you can't directly delete a folder if it still contains files using a single "delete folder" button. You must first delete or move all files out of the folder. Once a folder becomes empty, GitHub automatically removes it from the repository view.

**Steps:**

1.  Navigate into the folder you wish to delete.
2.  Individually **delete** each file within that folder using the "Deleting a File" steps outlined above.
3.  Once all files within the folder have been deleted, the folder itself will disappear from your repository.

---

### Important Note on "Open in Colab" Buttons

If you have "Open in Colab" buttons in your README files or notebooks, remember that these buttons link to a specific file path in your GitHub repository.

* **If you rename or move a notebook file (`.ipynb`)**, the old "Open in Colab" link will no longer work. You will need to update the link to reflect the new file path. The general format for an "Open in Colab" link is:
    `https://colab.research.google.com/github/YOUR_USERNAME/YOUR_REPOSITORY_NAME/blob/main/PATH_TO_YOUR_NOTEBOOK.ipynb`
    Make sure the `PATH_TO_YOUR_NOTEBOOK.ipynb` part is correct after renaming or moving.

---

**General Tips for GitHub File Management:**

* **Commit Messages are Important:** Always write clear and concise commit messages. This helps you (and others) understand the changes made to the repository over time. Think of it as a logbook for your project.
* **Organise Early, Organise Often:** It's easier to keep your repository tidy if you create a good folder structure early on and stick to it.
* **README Files:** It's good practice to have a `README.md` file in your main repository directory and potentially in sub-folders. This file can explain what the project is about, how to use the files, or what the contents of a specific folder are. You can edit `.md` files directly on GitHub using the pencil icon.

By following these steps, you can effectively manage your project files directly on GitHub without needing to use local Git tools. This will help keep your repositories organised and your Colab notebooks easily accessible.# âœï¸ Project Reflection

## AI Tools Used
What tools did you use (e.g., ChatGPT, Copilot)? How did they help?

## Prompting Techniques
Which intentional prompting strategies did you apply?

## What Worked Well?
Describe one thing youâ€™re proud of.

## What Would You Do Differently?
Describe one thing you'd change if you had more time.

## Final Thoughts
Any parting comments on your learning experience?
---
title: "ðŸ§  AI Tips and Tricks for the Weather Advisor Project"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

> This guide provides creative approaches to working with AI assistants that go beyond basic prompting. These techniques can help you develop a more sophisticated project while demonstrating your ability to use AI tools effectively as part of your development process.

## Using Multiple AI Assistants

### AI Debate Technique
Have two different AI assistants critique each other's solutions:

1. **Get an initial solution** from Assistant A
2. **Ask Assistant B to critique it**, highlighting strengths and weaknesses
3. **Take Assistant B's critique back to Assistant A** for improvements
4. **Document this "debate"** as part of your development process

Example prompt for the critique phase:
```
I received this code suggestion from another AI assistant for parsing weather questions. Can you analyse it and identify:
1. Potential edge cases it might miss
2. Performance considerations
3. Ways to make it more robust
4. Alternative approaches that might work better

[Paste code here]
```

### Different AIs for Different Roles

Assign different AI assistants to specialised roles:

- **Architect AI**: Help with overall design and structure
- **Implementation AI**: Generate specific code solutions
- **Testing AI**: Identify potential bugs and edge cases
- **Documentation AI**: Help document your code and process

Document how different AIs approached the same problem differently, and how you integrated their various perspectives.

## Advanced Prompting Techniques

### Chain-of-Thought Programming
Guide the AI through a programming problem step by step:

1. **Start with problem definition**: "I need to parse weather questions like 'Will it rain tomorrow in Sydney?'"
2. **Ask for an analysis**: "What are the key components we need to extract?"
3. **Request an approach**: "What techniques could we use to extract these components?"
4. **Get implementation**: "Can you implement the most suitable approach?"
5. **Ask for testing**: "How would you test this with various inputs?"

This shows a methodical development process rather than just asking for a complete solution.

### Reverse Engineering
Ask AI to explain existing code to build your understanding:

1. Find relevant code examples (e.g., weather API usage)
2. Ask the AI to explain how it works line-by-line
3. Ask what could be improved or customised
4. Use this understanding to build your own implementation

Example:
```
I found this code for working with the wttr.in API. Can you explain how it works line by line, and suggest how I might adapt it for my needs?

[Code example]
```

### Progressive Disclosure
Start with minimal information and gradually provide more context:

1. Begin with a basic problem statement: "How would you parse weather-related questions?"
2. After receiving initial advice, add constraints: "The solution needs to handle questions about time periods"
3. Then add more requirements: "It should also extract locations and weather attributes"
4. Finally, provide specific examples: "Like 'Will it rain tomorrow in Sydney?'"

This helps you understand how adding context affects solutions and prevents the AI from making too many assumptions.

### Persona-Based Prompting
Ask the AI to adopt different perspectives:

- "As a UX designer, how would you organise the weather dashboard interface?"
- "As a data scientist, what visualisations would be most informative for weather data?"
- "As a security expert, what should I consider when handling location data from users?"

Document how these different perspectives influenced your design decisions.

### Prompt Engineering Experiments
Try the same basic question with different prompting techniques:

1. Direct question: "How do I parse weather questions?"
2. Contextual question: "I'm building a weather app and need to parse questions. How should I approach this?"
3. Role-based: "You are an expert in NLP. How would you parse weather questions?"
4. Comparative: "What are three different approaches to parsing weather questions?"

Document how different prompting styles yield different quality responses.

## Creative Documentation Approaches

### Code Storytelling
Have the AI help narrate the development journey:

```
I've implemented the weather data retrieval function and visualisation components. Can you help me create a narrative that explains:
1. The challenges I encountered
2. The design decisions I made
3. How the components work together
4. What I learned in the process
```

This creates more engaging documentation that shows your learning process.

### Comparative Analysis
Ask the AI to compare multiple potential solutions:

```
I'm considering these three approaches for the user interface:
1. Console-based menu with pyinputplus
2. Interactive widgets with ipywidgets
3. A hybrid approach

Can you analyse the pros and cons of each for this specific project?
```

Document how this analysis informed your implementation choice.

### Code Review Practice
Have AI review your code, then critically evaluate its suggestions:

1. Share a function you've written with the AI
2. Ask for a detailed code review: "What could be improved in this code?"
3. Evaluate each suggestion critically - accept some, question others
4. Document your reasoning for accepting or rejecting each suggestion
5. Implement the changes you agree with

This demonstrates your ability to think critically about AI advice rather than accepting it blindly.

## Interactive Development

### Iterative Refinement Sessions
Document a series of improvements to a single component:

1. Start with a basic implementation
2. Ask: "What's one thing I could improve about this code?"
3. Implement the suggestion
4. Repeat several times, documenting each iteration
5. Reflect on how the code evolved through this process

This demonstrates incremental development rather than expecting perfect code immediately.

### Error-Driven Development
Deliberately introduce hypothetical errors to explore robustness:

```
What if a user enters 'near Sydney' instead of just 'Sydney'? How would our location parser handle this?

What would happen if the weather API returns incomplete data? How should our code handle that?
```

Document how these "what if" scenarios helped you build more robust code.

### AI-Assisted Testing
Use AI to generate comprehensive test cases:

1. Ask for a variety of test inputs: "What test cases should I use to verify my weather parsing function?"
2. Request edge cases: "What unusual inputs might break this function?"
3. Generate test data: "Can you provide sample weather data that would test all branches of my display function?"
4. Create a test plan: "How would you structure a testing approach for this entire application?"

Document how these AI-suggested tests improved your code's reliability.

### Alternative Implementation Comparison
Have AI generate multiple approaches to the same problem:

```
Can you show me three different ways to implement a function that parses weather questions, using:
1. Regular expressions
2. Natural language processing techniques
3. Simple string operations

What are the tradeoffs between these approaches in terms of complexity, maintainability, and robustness?
```

Compare the solutions and document your reasoning for choosing one approach over others.

## Remember:
The quality of your AI interactions will be evaluated based on how effectively you direct and learn from the AI, not on how impressive the AI's responses are. Focus on demonstrating thoughtful engagement with the AI as a tool in your development process.

## Additional Resources

For specific prompts related to the six core programming foundations (Input, Output, Store, Calculate, Decisions, and Repeat), refer to the **Prompt Templates** document provided with this assignment. These templates offer structured ways to ask about specific programming concepts you'll need for your Weather Advisor project.

The prompt templates are organised by programming concept and include:
- Concept exploration prompts
- Implementation prompts
- Debugging prompts
- Challenge prompts

Remember to adapt these templates to your specific implementation needs rather than using them verbatim.

---

*Note: Including conversations from multiple AI assistants and documenting creative AI usage approaches can demonstrate your ability to think critically about AI tools and may result in a more comprehensive solution. However, remember that the fundamental requirement is showing intentional prompting and a clear development process, regardless of which techniques you employ.*
---
title: "Project Completion Checklist"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

Use this checklist to track your progress and ensure your Weather Advisor project meets all requirements before submission.

## Repository Setup

- [ ] Repository created from template
- [ ] README.md updated with your project information
- [ ] Instructor (michael-borck) invited to your repository

## Notebook Organisation

- [ ] Notebook has clear section headers using markdown cells
- [ ] Sections are logically organised and follow the required structure
- [ ] Code includes appropriate comments and docstrings
- [ ] No unused code or unnecessary cells
- [ ] All imports are at the top of the notebook or in the appropriate section

## Weather Data Component

- [ ] Successfully retrieves weather data from chosen source
- [ ] Handles connection errors and timeouts gracefully
- [ ] Validates user input (e.g., city names, parameters)
- [ ] Processes and structures the data for use in the application
- [ ] Provides meaningful error messages for users

## Visualisation Component

- [ ] Implements at least 2 different visualisation types
- [ ] All visualisations have proper titles, labels, and legends
- [ ] Visualisations are readable and use appropriate colors
- [ ] Handles edge cases (e.g., missing data, extreme values)
- [ ] Visualisations are relevant to the data being displayed

## Natural Language Interface

- [ ] Successfully parses user questions to extract key information
- [ ] Identifies locations in user queries
- [ ] Identifies time periods in user queries (today, tomorrow, etc.)
- [ ] Identifies weather attributes (temperature, rain, etc.)
- [ ] Generates natural-sounding responses to user questions

## User Interface

- [ ] Implements a clear menu system using pyinputplus
- [ ] Provides appropriate feedback to users
- [ ] Has a logical flow between different options
- [ ] Handles invalid inputs gracefully
- [ ] Maintains a clean and organised display

## AI Interaction Documentation

- [ ] PROMPTING.md file completed with detailed examples
- [ ] At least 5 significant AI conversations documented
- [ ] Conversations saved as text files in the repository
- [ ] Demonstrates at least 5 different intentional prompting techniques
- [ ] Six-step methodology documented for at least one component
- [ ] 3 clear before/after examples included

## Technical Requirements

- [ ] All code runs without errors in Google Colab
- [ ] No hardcoded sensitive data (API keys, personal information)
- [ ] Modular design with functions for specific tasks
- [ ] Appropriate error handling throughout the application
- [ ] Code follows consistent style (variable naming, indentation, etc.)

## Final Testing

- [ ] Tested with multiple locations
- [ ] Tested with various types of weather questions
- [ ] Tested with edge cases (invalid locations, connection issues)
- [ ] All menu options function as expected
- [ ] Visualisations render correctly

## Documentation Quality

- [ ] Code is well-commented with meaningful docstrings
- [ ] README.md provides clear overview and instructions
- [ ] PROMPTING.md shows thoughtful AI interaction
- [ ] Reflection document (300-500 words) included
- [ ] All required files are present and properly formatted

## Submission

- [ ] Final version of notebook saved to GitHub
- [ ] All AI conversation files included
- [ ] PROMPTING.md file completed
- [ ] Reflection document included
- [ ] Repository link submitted through required channel

## Extra Credit (Optional)

- [ ] Implemented additional features beyond basic requirements
- [ ] Created especially innovative visualisations
- [ ] Developed advanced natural language understanding capabilities
- [ ] Demonstrated exceptional intentional prompting techniques
- [ ] Utilised the hands-on-ai package in creative ways
---
title: "Before/After Example: Weather Data Retrieval Function"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


## Initial Prompt

```
Write a function to retrieve weather data from the wttr.in API for a given location.
```

## Initial AI-Generated Code (Before)

```python
def get_weather(location):
    import requests
    
    url = f"https://wttr.in/{location}?format=j1"
    response = requests.get(url)
    data = response.json()
    
    return data
```

## My Analysis of the Initial Code

The initial code has several issues:

1. No error handling - will crash if the API is down or returns an error
2. No input validation for the location parameter
3. Returns the raw API response which is complex and includes unnecessary data
4. No timeout parameter which could cause the application to hang
5. No docstring or comments explaining how to use the function

## My Follow-up Prompt

```
Thanks for the starting point. I'd like to improve this function with:

1. Error handling for API failures and bad responses
2. Location input validation
3. A timeout parameter to prevent hanging
4. A way to process the response to return only essential weather information
5. Proper documentation with parameters and return values explained

Also, can you make it handle the forecast_days parameter to allow getting forecast for multiple days?
```

## Improved AI-Generated Code (After)

```python
def get_weather_data(location, forecast_days=5, timeout=10):
    """
    Retrieve weather data for a specified location from wttr.in API.
    
    Args:
        location (str): City or location name
        forecast_days (int): Number of days to forecast (1-5)
        timeout (int): Timeout for API request in seconds
        
    Returns:
        dict: Weather data including current conditions and forecast,
             or None if an error occurred
    """
    import requests
    
    # Input validation
    if not location or not isinstance(location, str):
        print("Error: Location must be a non-empty string")
        return None
    
    if not 1 <= forecast_days <= 5:
        print("Error: forecast_days must be between 1 and 5")
        forecast_days = min(max(1, forecast_days), 5)  # Clamp to valid range
    
    # Clean up the location string
    location = location.strip().replace(" ", "+")
    
    try:
        # Make request to wttr.in API
        url = f"https://wttr.in/{location}?format=j1"
        response = requests.get(url, timeout=timeout)
        response.raise_for_status()  # Raise exception for HTTP errors
        
        # Parse JSON response
        data = response.json()
        
        # Process and extract relevant information
        result = {
            "location": location.replace("+", " "),
            "current": {
                "temperature": {
                    "current": int(data["current_condition"][0]["temp_C"]),
                    "feels_like": int(data["current_condition"][0]["FeelsLikeC"])
                },
                "condition": data["current_condition"][0]["weatherDesc"][0]["value"],
                "humidity": int(data["current_condition"][0]["humidity"]),
                "wind": {
                    "speed": int(data["current_condition"][0]["windspeedKmph"]),
                    "direction": data["current_condition"][0]["winddir16Point"]
                },
                "precipitation": float(data["current_condition"][0]["precipMM"])
            },
            "forecast": []
        }
        
        # Add forecast data
        for i in range(min(forecast_days, len(data["weather"]))):
            day = data["weather"][i]
            forecast_day = {
                "date": day["date"],
                "max_temp": int(day["maxtempC"]),
                "min_temp": int(day["mintempC"]),
                "condition": day["hourly"][4]["weatherDesc"][0]["value"],  # Midday condition
                "precipitation": {
                    "chance": int(day["hourly"][4]["chanceofrain"]),
                    "amount": float(day["hourly"][4]["precipMM"])
                },
                "wind": {
                    "speed": int(day["hourly"][4]["windspeedKmph"]),
                    "direction": day["hourly"][4]["winddir16Point"]
                }
            }
            result["forecast"].append(forecast_day)
        
        return result
        
    except requests.exceptions.RequestException as e:
        print(f"Error retrieving weather data: {e}")
        return None
    except (KeyError, ValueError, TypeError) as e:
        print(f"Error processing weather data: {e}")
        return None
```

## Why My Prompting Strategy Was Effective

My follow-up prompt was effective because:

1. **I identified specific problems** in the initial code rather than just asking for "better code"
2. **I requested specific improvements** with clear objectives (error handling, validation, etc.)
3. **I suggested a new feature** (forecast_days parameter) that would make the function more useful
4. **I asked for proper documentation** which resulted in comprehensive docstrings

This approach guided the AI to generate a much more robust function that:

- Is properly documented
- Validates inputs
- Has comprehensive error handling
- Returns structured, processed data instead of raw API response
- Includes the new forecast functionality I requested

The key to effective prompting was being specific about what needed improvement and why, rather than making vague requests for "better" code.
ðŸ“‚ AI Conversation Folder Instructions

This folder is where you save your AI interactions used during development.

ðŸ—‚ï¸ What to include:
- At least 5 significant AI conversations
- Each as a separate .txt file (e.g. conversation1.txt, conversation2.txt, etc.)
- Each file should include:
   - A short header at the top:
     - Tool used (e.g. ChatGPT, Claude, Copilot, etc.)
     - Date of the conversation

ðŸ’¬ Conversation Example Format:

----------------------------------
Tool: ChatGPT
Date: 2025-04-15
----------------------------------

Me: How do I parse temperature from this weather JSON?
AI: You can use `weather["current_condition"][0]["temp_C"]` to get the temperature.

Me: What if itâ€™s missing?
AI: Add error handling using `try/except`...

(continue until the conversation ends)

ðŸ“Œ No special formatting required.
Just copy the entire conversation text and paste it here.

âš ï¸ Warning:
Use the `.txt` format, **not screenshots or PDFs**. AI logs should be searchable and lightweight.

## Handout: Managing Files in Your GitHub Repository via the Web Interface

This handout will guide you through performing common file operations directly on the GitHub website. This is useful for organizing your project files, especially when working with Google Colab notebooks that are stored in your GitHub repositories. You won't need to install Git or use any command-line tools.

**Accessing Your Repository:**

1.  Go to [https://github.com](https://github.com) and log in to your account.
2.  Navigate to the repository you want to work with by clicking on its name on your dashboard or your profile page.

---

### 1. Uploading Files

You can upload various file types to your GitHub repository, such as Python scripts (`.py`), data files (`.csv`, `.txt`, `.json`), images, or other project-related documents.

**Steps:**

1.  Once you are in your repository, click on the **"Add file"** button located above the list of files.
2.  From the dropdown menu, select **"Upload files"**.
3.  You can then either:
    * **Drag and drop** your file(s) into the box provided.
    * Click on **"choose your files"** to open a file dialog and select the file(s) from your computer.
4.  After the files have been uploaded, you will see them listed.
5.  Scroll down to the **"Commit changes"** section.
    * In the first text box, provide a brief, meaningful message describing the upload (e.g., "Upload dataset for analysis", "Add utility script"). This is a commit message.
    * You can add a more detailed description in the larger text box below if needed (optional for simple uploads).
6.  Ensure that **"Commit directly to the `main` branch"** is selected (or your default branch, usually `main` or `master`). For beginner purposes, this is the standard workflow.
7.  Click the green **"Commit changes"** button. Your files are now in your repository.

---

### 2. Creating a New Folder (and adding a file to it)

GitHub doesn't allow you to create an empty folder directly. A folder is created automatically when you add a file within it.

**Steps:**

1.  In your repository, click on the **"Add file"** button.
2.  From the dropdown menu, select **"Create new file"**.
3.  In the **"Name your file..."** box at the top, type the name of your desired folder followed by a forward slash `/`. For example, to create a folder named "data", you would type `data/`.
4.  **Important:** After the `/`, you must then type a filename for a new file that will reside within this folder. GitHub requires at least one file to create a folder. Often, people create a placeholder file like `.gitkeep` (an empty file that signals the folder should be tracked) or `README.md` (if you want to describe the folder's contents). For example: `data/.gitkeep` or `data/notes.txt`.
5.  If you are creating a file like `notes.txt`, you can add some content to it in the editing area below. If you are creating a `.gitkeep` file, you can leave the content area blank.
6.  Scroll down to the **"Commit new file"** section.
    * Provide a commit message (e.g., "Create data folder", "Add initial notes for data folder").
7.  Ensure **"Commit directly to the `main` branch"** is selected.
8.  Click the green **"Commit new file"** button. You will now see your new folder in the repository.

---

### 3. Renaming a File

**Steps:**

1.  Navigate to the file you want to rename within your repository.
2.  Click on the filename to open the file view.
3.  On the right side of the file view, above the file content, you will see a set of icons. Click the **pencil icon (Edit this file)**.
4.  At the top of the page, where the filename is displayed, you can now edit the filename directly in the text box. Change it to the new desired name.
5.  Scroll down to the **"Commit changes"** section.
    * GitHub will usually pre-fill a commit message like "Rename [old filename] to [new filename]". You can customize this if needed.
6.  Ensure **"Commit directly to the `main` branch"** is selected.
7.  Click the green **"Commit changes"** button.

---

### 4. Moving a File into a Folder

Moving a file in GitHub's web interface is essentially renaming the file to include the new folder path.

**Steps:**

1.  Navigate to the file you want to move.
2.  Click on the filename to open the file view.
3.  Click the **pencil icon (Edit this file)** on the right side.
4.  In the filename box at the top, you will edit the file's path.
    * To move `myfile.txt` into an existing folder called `documents`, you would change the filename from `myfile.txt` to `documents/myfile.txt`.
    * If the folder doesn't exist yet, typing `newfolder/myfile.txt` will create `newfolder` and place `myfile.txt` inside it.
5.  Scroll down to the **"Commit changes"** section.
    * Provide a commit message (e.g., "Move script to utilities folder", "Organize data files").
6.  Ensure **"Commit directly to the `main` branch"** is selected.
7.  Click the green **"Commit changes"** button.

**Tip:** If you want to move a file "up" one level (out of a folder), you would delete the folder prefix from its name. For example, to move `data/report.txt` to the main (root) directory, you would rename it from `data/report.txt` to `report.txt`.

---

### 5. Deleting a File

**Steps:**

1.  Navigate to the file you want to delete within your repository.
2.  Click on the filename to open the file view.
3.  On the right side of the file view, above the file content, click the **trash can icon (Delete this file)**.
4.  Scroll down to the **"Commit changes"** section.
    * GitHub will pre-fill a commit message like "Delete [filename]". You can customize this.
5.  Ensure **"Commit directly to the `main` branch"** is selected.
6.  Click the green **"Commit changes"** button.

---

### 6. Deleting a Folder

Similar to creating folders, you can't directly delete a folder if it still contains files using a single "delete folder" button. You must first delete or move all files out of the folder. Once a folder becomes empty, GitHub automatically removes it from the repository view.

**Steps:**

1.  Navigate into the folder you wish to delete.
2.  Individually **delete** each file within that folder using the "Deleting a File" steps outlined above.
3.  Once all files within the folder have been deleted, the folder itself will disappear from your repository.

---

### Important Note on "Open in Colab" Buttons

If you have "Open in Colab" buttons in your README files or notebooks, remember that these buttons link to a specific file path in your GitHub repository.

* **If you rename or move a notebook file (`.ipynb`)**, the old "Open in Colab" link will no longer work. You will need to update the link to reflect the new file path. The general format for an "Open in Colab" link is:
    `https://colab.research.google.com/github/YOUR_USERNAME/YOUR_REPOSITORY_NAME/blob/main/PATH_TO_YOUR_NOTEBOOK.ipynb`
    Make sure the `PATH_TO_YOUR_NOTEBOOK.ipynb` part is correct after renaming or moving.

---

**General Tips for GitHub File Management:**

* **Commit Messages are Important:** Always write clear and concise commit messages. This helps you (and others) understand the changes made to the repository over time. Think of it as a logbook for your project.
* **Organize Early, Organize Often:** It's easier to keep your repository tidy if you create a good folder structure early on and stick to it.
* **README Files:** It's good practice to have a `README.md` file in your main repository directory and potentially in sub-folders. This file can explain what the project is about, how to use the files, or what the contents of a specific folder are. You can edit `.md` files directly on GitHub using the pencil icon.

By following these steps, you can effectively manage your project files directly on GitHub without needing to use local Git tools. This will help keep your repositories organized and your Colab notebooks easily accessible.
## Pre-Lab Modules

1. **Reviewing Basic Python Tools**  
   - **Objective:** Refresh the fundamentals: using `print()`, `input()`, and working with variables.  
   - **Content:**  
     - Quick refresher video or reading on Python syntax.  
     - Interactive notebook examples that illustrate assigning and printing variables.  
     - Mini-exercises: Write simple programs to display messages and capture user input.

2. **Introduction to Decision Making**  
   - **Objective:** Introduce if-else statements and logical operators.  
   - **Content:**  
     - Explanation of how conditionals work (e.g., â€œifâ€, â€œelseâ€).  
     - Diagrams showing the flow of decisions.  
     - Example code snippets that compare values and print different outputs.

3. **Exploring the Weather Context**  
   - **Objective:** Connect programming logic to real-world weather scenarios.  
   - **Content:**  
     - Overview of common weather conditions (cold, warm, rainy, etc.) and simple metrics (temperature thresholds).  
     - Discussion on how a program might â€œdecideâ€ a weather message based on a number (temperature) provided by the user.

4. **Designing a Simple Menu**  
   - **Objective:** Learn how to build a text-based menu interface using basic output and input.  
   - **Content:**  
     - Steps to display a menu with numbered options using `print()`.  
     - How to prompt the user for a choice and capture that choice with `input()`.  
     - Practice exercises: Create a menu that lets a user choose between two simple messages.

---

## In-Lab Activities

1. **Activity 1: Crafting the Weather Menu**  
   - **Task:** Create a menu that presents options like:  
     1. Check Temperature  
     2. Check Humidity  
     3. Check Wind Speed  
     4. Exit  
   - **Focus:** Use `print()` to display the menu and `input()` to capture the userâ€™s selection.  
   - **Discussion:** Explain how each option might trigger a different response in the code.

2. **Activity 2: Writing Weather Decision Logic**  
   - **Task:** Based on the menu selection, write code using if-else statements to provide a weather forecast.  
     - For example, if the user selects â€œCheck Temperature,â€ prompt them to enter the current temperature, then use conditionals to output messages like â€œItâ€™s cold â€“ wear a jacketâ€ or â€œItâ€™s warm â€“ enjoy the day!â€  
   - **Focus:** Practice writing nested if-else statements and understanding logical comparisons.  
   - **Guidance:** Encourage students to trace through their code with sample inputs.

3. **Activity 3: Testing and Refining the Weather Forecaster**
    - **Task:** Test the weather forecaster with different inputs to see how the program responds.  
    - **Focus:** Debugging and refining the code based on the output.  
    - **Discussion:** Discuss how to handle unexpected inputs and improve the user experience.
  - **Focus:** Debugging and refining the code based on the output.
  - **Guidance:** Encourage students to experiment with various inputs to see how the program reacts. Discuss how to handle edge cases and improve the user experience.
---

## Weekly Project: "Simple Weather Forecaster"

**Project Description:**  
Students will create a basic weather forecasting script that:
- **Displays a Menu:**  
  Presents options such as:  
  1. Check Temperature  
  2. Check Humidity  
  3. Check Wind Speed  
  4. Exit

- **Handles User Input:**  
  Based on the selected option, the script will ask for a related input. For example, if â€œCheck Temperatureâ€ is selected, the program prompts the user to input the current temperature.

- **Implements Decision Logic:**  
  Uses if-else statements to analyze the input. For instance:  
  - If temperature is below a certain threshold, print â€œItâ€™s cold â€“ expect a chilly day.â€  
  - If temperature is moderate, print â€œItâ€™s a pleasant day.â€  
  - (Similar simple logic can be applied for humidity and wind speed.)

- **Integration and Reflection:**  
  Emphasize that the focus is on understanding how conditionals make decisions.  
  Explain that next week the code will be refactored to use functions, but for now, all logic is written directly in the main block.

**Project Requirements:**
- Must use only `print()`, `input()`, variables, and basic data types.  
- Encourage creativity in designing simple weather messages.  
- Save the project in a Google Colab Notebook and push the final version to GitHub.

**Project Tips:**
- Remind students that clarity of logic is more important than complex features.
- Suggest that they use AI tools (e.g., ChatGPT) to get hints on improving readability, but they must write and understand the code themselves.
- Emphasize careful planning: drawing out the decision tree before coding can help organize the logic.

---
title: "Designing a Simple Menu"
subtitle: "Module 4: Building a Text-Based Menu Interface"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Overview  
In this module, we'll learn how to create a text-based menu interface using basic output and input.  
You'll understand the steps needed to display a menu and capture the user's choice.

::: {.notes}
The "Overview" slide provides a high-level summary of the presentation, introducing the concept of a menu interface and its role in user interaction. It sets the stage for the subsequent slides, which will delve into the specifics of implementing menu interfaces using Python programming techniques.

The slide outlines the key topics that will be covered throughout the presentation, including the definition of a menu interface, displaying menus using the `print()` function, capturing user input, and a practical example of a simple menu programme. Additionally, it highlights the inclusion of a practice exercise and a summary of the key points, along with a look ahead to the next steps in the learning journey.
:::

# What Is a Menu Interface?  
- A menu interface presents the user with numbered options.  
- It guides the user to choose between different functionalities or messages.  
- This is a common technique to improve the user experience in text-based programmes.

::: {.notes}
A menu interface is a powerful tool for guiding users through text-based programmes. It presents users with a list of numbered options, each corresponding to a specific functionality or message. By selecting an option, the user can easily navigate to their desired action without the need for complex commands or inputs.

Menu interfaces are a common technique for improving user experience in text-based programmes. They provide a clear and intuitive structure that helps users understand the available options and make informed decisions. By breaking down the programme into distinct choices, menu interfaces reduce confusion and make the programme more accessible to a wider range of users.
:::

# Displaying a Menu with `print()`  
- Use the `print()` function to list out the menu options.  
- Each option is displayed on a separate line for clarity.  
- Example:
  
  ```python
  print("1. Show greeting")
  print("2. Display farewell")
  ```

::: {.notes}
The `print()` function is a powerful tool for displaying information to users, and it's particularly useful when creating menu interfaces. By using `print()` to list out the available options, each on a separate line, you can present a clear and easily readable menu to the user. This approach helps to avoid confusion and ensures that the user can quickly identify and select their desired choice.

To illustrate this concept, the slide includes an example of how a menu might be displayed using `print()`. By examining this example, you can see how the function is used to create a well-formatted menu, with each option presented on a new line for improved readability. This example serves as a foundation for understanding how to create effective menu interfaces in your own programs.
:::

# Capturing User Input  
- Use the `input()` function to prompt the user for a choice.  
- Store the user's input in a variable for further processing.  
- Example:
  
  ```python
  choice = input("Enter your choice (1 or 2): ")
  ```
  
- This allows your programme to react based on the user's selection.

::: {.notes}
To capture user input in your programme, use the `input()` function, which prompts the user to enter a choice. The user's response is then stored in a variable for further processing within the programme. For example, you might display a menu of options and ask the user to select one by entering a corresponding number or letter.

By capturing and storing the user's input, your programme can react dynamically based on the selection made. This allows for interactive decision-making and enables your programme to follow different paths or perform specific actions depending on the user's preferences. Utilising the `input()` function is a fundamental way to create responsive and engaging command-line interfaces that adapt to user input.
:::

# Example: A Simple Menu Programme  
- Combining `print()` and `input()` to create a functional menu:
  
  ```python
  print("Menu:")
  print("1. Show greeting")
  print("2. Display farewell")
  choice = input("Enter your choice (1 or 2): ")
  
  if choice == "1":
      print("Hello! Welcome to our programme.")
  elif choice == "2":
      print("Goodbye! Have a nice day.")
  else:
      print("Invalid choice. Please try again.")
  ```
  
- This snippet demonstrates how to guide the user and respond to their input.

::: {.notes}
This slide demonstrates how to create a functional menu by combining the `print()` and `input()` functions in Python. The code snippet guides the user through a series of options and prompts them to make a selection, which the program then responds to accordingly.

By presenting a clear and concise menu interface, the user can easily navigate the available choices and interact with the program effectively. This example serves as a foundation for building more complex menu-driven applications, highlighting the importance of user-friendly design and logical flow in software development.
:::

# Practice Exercise  
- Create your own menu programme that lets a user choose between two simple messages.  
- Steps to follow:
  1. Display two menu options using `print()`.
  2. Prompt the user to enter their choice with `input()`.
  3. Use an if-else structure to print the corresponding message.
- Experiment with different messages and options.

::: {.notes}
To complete this practice exercise, create your own simple menu programme that presents the user with a choice between two messages. Experiment with different messages and options to gain a better understanding of how menu interfaces work. Follow the steps outlined in the previous slides to guide you through the process of displaying the menu using `print()` statements and capturing the user's input.

This exercise provides an opportunity to apply the concepts covered so far and reinforce your learning. Feel free to be creative with your messages and options, and don't hesitate to try different variations to see how they affect the user experience. By practising and experimenting with menu interfaces, you'll develop a stronger grasp of the fundamentals and be better prepared for more advanced programming challenges.
:::

# Summary and Next Steps  
- You learned how to build a text-based menu using basic Python functions.  
- Key points:
  - Display options with `print()`.
  - Capture choices using `input()`.
  - Process user input with conditional statements.
- With these skills, you're ready to create interactive programmes that respond to user selections.

::: {.notes}
In this slide, we summarise the key points you've learned about building a text-based menu using basic Python functions. You now know how to display menu options using the `print()` function, capture user choices with `input()`, and process user input using conditional statements. These fundamental skills form the foundation for creating interactive programmes that respond to user selections.

With the knowledge gained from this presentation, you're ready to apply these techniques to develop your own menu-driven programmes. As you continue to practise and expand your Python skills, you'll be able to create increasingly sophisticated interactive applications that engage users and provide a seamless experience. The possibilities are endless, and the concepts covered in this presentation will serve as a solid starting point for your future programming endeavours.
:::

---
title: "Introduction to Decision Making"
subtitle: "Conditionals and Logical Operators"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Overview  
In this module, we'll introduce the fundamentals of decision making in Python.  
You'll learn how to use if-else statements and logical operators to make your programmes respond to different conditions.

::: {.notes}
The overview slide introduces the topic of conditionals in programming. It sets the stage for the rest of the presentation, which will cover what conditionals are, how they work, logical operators, visualising decision flow, an example of a simple weather decision, and an activity where participants can write their own conditionals.

This slide serves as a roadmap for the presentation, giving the audience a clear idea of what to expect in the coming slides. It's important to highlight the key points that will be covered and to emphasise the practical nature of the presentation, which includes an example and a hands-on activity.
:::

# What Are Conditionals?  
- Conditionals allow your programme to make decisions based on data.  
- They let you execute different code blocks depending on whether a condition is True or False.  
- Keywords include `if`, `elif`, and `else`.

::: {.notes}
Conditionals are a fundamental concept in programming that allow your code to make decisions based on specific conditions. By evaluating whether a condition is True or False, the programme can execute different blocks of code accordingly. This enables your programme to respond dynamically to various situations and inputs.

The key components of conditionals are the `if`, `elif` (else if), and `else` keywords. The `if` statement checks the initial condition, and if it evaluates to True, the corresponding code block is executed. If the condition is False, the programme moves on to the next `elif` statement, if present, and evaluates its condition. This process continues until a True condition is found or the `else` block is reached, which is executed if none of the previous conditions were True.
:::

# How Conditionals Work  
- The `if` statement checks a condition.  
- If the condition is True, the indented block of code runs.  
- Otherwise, the programme can either move to an `elif` (else if) or `else` block.  
- Example:
  
  ```python
  temperature = 18
  if temperature < 20:
      print("It's chilly!")
  else:
      print("It's warm!")
  ```

::: {.notes}
The `if` statement in programming checks a condition, and if that condition evaluates to True, the indented block of code following the `if` statement will execute. This allows the programme to make decisions based on certain criteria being met.

If the condition is not met (evaluates to False), the programme can either move to an `elif` (else if) statement to check additional conditions, or to an `else` block which will run if none of the previous conditions were True. This branching logic enables different code paths to be taken depending on the state of the programme at runtime.
:::

# Logical Operators  
- Logical operators combine multiple conditions:  
  - **and**: Both conditions must be True.  
  - **or**: At least one condition must be True.  
  - **not**: Reverses the truth value of a condition.
- Example:
  
  ```python
  temperature = 22
  is_raining = False
  if temperature > 20 and not is_raining:
      print("Great day for a picnic!")
  ```

::: {.notes}
Logical operators are used to combine multiple conditions in programming. The "and" operator requires both conditions to be true for the overall expression to be true. The "or" operator only needs at least one condition to be true for the overall expression to be true. The "not" operator reverses the truth value of a condition, so if a condition is true, "not" will make it false, and vice versa.

For example, consider the expression "if temperature > 20 and raining == False". This will only be true when the temperature is greater than 20 and it is not raining. If either the temperature is 20 or below, or it is raining, the expression will be false. Logical operators allow for more complex decision-making in programs by combining simple conditions.
:::

# Visualising Decision Flow  
Imagine your code as a flowchart:  
- **Start**  
  â†“  
- Evaluate condition (e.g., temperature)  
  â†“  
- **Yes:** Execute if-block  
  **No:** Move to else-block  
  â†“  
- **End**  
This diagram helps you understand how your programme chooses a path.

::: {.notes}
This slide visualises the flow of a simple conditional statement. It begins with a "Start" point, then evaluates a condition such as checking the temperature. If the condition is true, the flow moves to executing the code block associated with the "Yes" branch before reaching the "End" point.

By showing the decision flow as a linear sequence of steps, this diagram helps to break down the logic of a conditional into distinct stages. The "Yes" and "No" branches clearly illustrate the different paths the code may take depending on the outcome of the condition evaluation.
:::

# Example: A Simple Weather Decision  
Consider this code snippet:
  
```python
temperature = int(input("Enter the current temperature: "))
if temperature < 15:
    print("It's quite cold today.")
elif temperature < 25:
    print("It's a pleasant day.")
else:
    print("It's hot today!")
```
- This programme makes a decision based on the temperature entered by the user.

::: {.notes}
This example demonstrates how a simple program can make decisions based on user input. Here, the user enters a temperature value, and the program checks if it is above or below a certain threshold (in this case, 20 degrees Celsius). Depending on the result of this comparison, the program will print out a different message - either "It's warm outside" or "It's cold outside".

This is a very basic example of how conditionals can be used to create programs that respond differently based on certain conditions. By using logical operators and multiple conditional statements, much more complex decision-making processes can be implemented. However, this simple weather program serves as a good starting point for understanding the fundamental concepts behind conditionals in programming.
:::

# Activity: Write Your Own Conditionals  
- Practice writing a simple programme that:  
  1. Prompts the user for a number.  
  2. Uses an if-else structure to decide if the number is high or low.
- Experiment with different conditions to see how the flow changes.

::: {.notes}
In this activity, participants will have the opportunity to apply their knowledge of conditionals by writing a simple program. They should experiment with various conditions to observe how the program's flow changes based on the conditions they define.

Encourage participants to be creative and think of real-world scenarios where conditionals can be used to make decisions. Remind them to use the logical operators they've learned and to visualise the decision flow as they write their program. Offer assistance if needed, and allocate sufficient time for participants to complete the activity.
:::

# Summary and Next Steps  
- We explored how conditionals work with `if`, `elif`, and `else`.  
- We learned to use logical operators to combine conditions.  
- Understanding these concepts is vital for building interactive and responsive programmes.  
- In the next module, we'll apply these decision-making tools to create a simple weather forecaster.

::: {.notes}
In this module, we have explored the fundamental concepts of conditionals in programming using the `if`, `elif`, and `else` statements. These statements allow our programmes to make decisions based on specified conditions, enabling them to respond differently depending on the input or state of variables. We also learned how to combine multiple conditions using logical operators such as `and`, `or`, and `not`, which gives us even more control over the flow of our code.

As we move forward, it is crucial to recognise that a solid grasp of conditionals and logical operators is essential for creating interactive and responsive programmes. These concepts form the foundation of decision-making in programming, allowing us to build software that can adapt to various situations and user inputs. In the upcoming module, we will apply the knowledge gained here to develop a simple weather forecaster, demonstrating how these decision-making tools can be used to solve real-world problems.
:::

---
title: "Exploring the Weather Context"
subtitle: "Module 3: Connecting Programming Logic to Real-World Weather Scenarios"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Welcome to the Weather Context  
In this module, we explore how to connect programming logic with real-world weather scenarios.  
You'll see how simple metrics and conditions can be used to generate meaningful weather messages.

::: {.notes}
Welcome to the Weather Context, where we'll explore how weather conditions impact our code and decision-making processes. We'll discuss common weather conditions, such as sunny, cloudy, rainy, and snowy, and how they can affect our software applications. By understanding these weather patterns, we can create more dynamic and adaptable code that responds intelligently to the environment.

Throughout this presentation, we'll delve into temperature thresholds and how they can trigger specific actions or decisions within our code. We'll examine real-world examples of how temperature data can be used to make informed choices, such as adjusting air conditioning settings or providing personalised recommendations to users. By the end of this session, you'll have a solid foundation in incorporating weather context into your programming projects, enabling you to create more engaging and contextually aware applications.
:::

# Connecting Code to Weather  
- Programming logic can model everyday situations such as weather forecasting.  
- Using conditionals, we can create a programme that decides which weather message to display based on user input.  
- This approach helps bridge abstract code with tangible, real-world examples.

::: {.notes}
Programming logic can be used to model everyday situations, such as weather forecasting. By using conditionals, we can create a programme that decides which weather message to display based on user input, such as temperature, humidity, or precipitation. This approach helps learners connect abstract coding concepts with tangible, real-world examples, making the learning process more engaging and relevant.

When teaching programming, it's crucial to provide relatable examples that learners can easily grasp. Weather forecasting serves as an excellent example, as it demonstrates how code can be used to make decisions based on specific conditions. By walking learners through the process of creating a weather-based decision-making programme, they can better understand the practical applications of programming concepts like conditionals, variables, and user input.
:::

# Common Weather Conditions  
- Consider the following typical weather conditions:  
  - **Cold:** Low temperatures, possibly with frost.  
  - **Warm:** Moderate temperatures, ideal for outdoor activities.  
  - **Hot:** High temperatures, which might require extra precautions.  
  - **Rainy:** Indicating precipitation and potentially cooler conditions.  
- These categories can be mapped to simple numeric thresholds.

::: {.notes}
This slide presents an overview of common weather conditions, focusing on temperature and precipitation. It introduces four main categories: cold, warm, hot, and rainy. Each category is associated with specific temperature ranges and characteristics, such as frost for cold weather and the need for extra precautions in hot conditions. The slide also mentions that rainy weather indicates precipitation and potentially cooler temperatures.

The slide suggests that these weather categories can be mapped to simple numeric thresholds, which will be explored further in the presentation. By categorising weather conditions based on temperature and precipitation, it becomes possible to make decisions and take appropriate actions depending on the prevailing conditions. This forms the foundation for connecting code to weather data and creating weather-aware applications or systems.
:::

# Temperature Thresholds  
- We can define temperature ranges to represent different weather conditions.  
- Example thresholds might be:  
  - **Cold:** Temperature below 15Â°C  
  - **Warm:** Temperature between 15Â°C and 25Â°C  
  - **Hot:** Temperature above 25Â°C  
- These thresholds help the programme decide which message to display.

::: {.notes}
In this slide, we introduce the concept of defining temperature ranges to represent different weather conditions. By setting specific thresholds, such as cold being below 15Â°C, warm being between 15Â°C and 25Â°C, and hot being above 25Â°C, we can categorise the weather into distinct categories. This allows us to create a clear set of criteria for our programme to use when deciding which message to display.

These temperature thresholds form the basis for the decision-making process in our weather programme. By comparing the current temperature to these predefined ranges, the programme can determine the appropriate message to show the user. For example, if the temperature is below 15Â°C, the programme will display a message indicating cold weather conditions. Similarly, temperatures between 15Â°C and 25Â°C will trigger a message for warm weather, while temperatures above 25Â°C will result in a message for hot weather.
:::

# Decision Making Based on Temperature  
- A programme can use an input number (the temperature) to choose a weather message.  
- Example code snippet:
  
  ```python
  temperature = int(input("Enter the current temperature: "))
  if temperature < 15:
      print("It's quite cold today. Stay warm!")
  elif temperature < 25:
      print("The weather is pleasant today.")
  else:
      print("It's hot today. Keep cool!")
  ```
  
- This snippet illustrates how numeric input can drive decisions in your code.

::: {.notes}
The programme uses a numeric input, the temperature, to select an appropriate weather message. The example code snippet demonstrates how the temperature value is compared against predefined thresholds using conditional statements (if-else) to determine the corresponding weather message to display.

This code snippet serves as a practical illustration of how numeric inputs can be utilized to guide decision-making processes within a programme. By evaluating the temperature value against specific thresholds, the code can intelligently choose the most suitable weather message, showcasing the power of data-driven decision-making in programming.
:::

# Visualising Weather Decisions  
Imagine a flowchart:  
- **Start** â†’ Get temperature input  
- **Is temperature < 15Â°C?**  
  - Yes: Output "Cold" message  
  - No: Proceed to next condition  
- **Is temperature < 25Â°C?**  
  - Yes: Output "Warm" message  
  - No: Output "Hot" message  
- This diagram helps understand how the programme navigates different conditions.

::: {.notes}
This slide, titled "Visualising Weather Decisions", presents a flowchart that illustrates the decision-making process of a weather programme based on temperature input. The flowchart begins with the programme receiving a temperature input, then proceeds to evaluate the temperature against two conditional statements: is the temperature less than 15Â°C, and if not, is it less than 25Â°C? Depending on the outcome of these evaluations, the programme will output either a "Cold", "Warm", or "Hot" message.

The slide's content serves as a visual aid to help the audience understand how the weather programme navigates through different temperature conditions to arrive at the appropriate output message. By presenting the decision-making process in a clear, step-by-step manner, the flowchart enables the audience to grasp the logic behind the programme's functionality easily. This slide is part of a larger presentation that covers various aspects of weather-related programming, from introducing the context to designing personalised weather decision trees.
:::

# Activity: Design Your Weather Decision Tree  
- Draw your own flowchart to decide a weather message based on temperature.  
- Consider adding extra conditions such as "rainy" or "windy" if you wish.  
- Discuss your design with peers to refine your decision-making process.

::: {.notes}
In this activity, students will create their own weather decision tree flowchart. They will decide on a weather message based on temperature and can optionally include additional conditions such as rain or wind. This hands-on exercise allows students to apply the concepts covered in the previous slides and think critically about the decision-making process involved in determining weather messages.

After completing their individual flowcharts, students will have the opportunity to discuss their designs with their peers. This collaborative element encourages them to explain their thought process, consider alternative approaches, and refine their decision trees based on feedback. Through this activity, students will gain a deeper understanding of how to structure and visualise weather-based decisions using flowcharts.
:::

# Summary and Reflection  
- We reviewed common weather conditions and set simple temperature thresholds.  
- You saw how a basic input can lead to a decision that outputs a weather message.  
- This module lays the foundation for building a weather forecaster by linking real-world data with programming logic.  
- Reflect on how this approach makes abstract concepts more tangible.

::: {.notes}
In this module, we explored common weather conditions and established simple temperature thresholds to guide our decision-making process. By connecting a basic input to a specific output in the form of a weather message, we demonstrated how programming logic can be applied to real-world scenarios.

This approach serves as a foundation for building a more comprehensive weather forecaster, bridging the gap between abstract concepts and tangible applications. Take a moment to consider how this method can be extended to create more sophisticated systems that utilise real-world data to generate meaningful outputs.
:::

---
title: "Reviewing Basic Python Tools"
subtitle: "Basic Python Tools"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Overview
In this module we will review the essential Python tools you need to get started with programming.  
We'll explore how to display messages with `print()`, capture user input with `input()`, and work with variables and basic data types.  
Letâ€™s begin our journey into Python!

::: {.notes}
Welcome to the exciting world of Python programming! In this introductory workshop, we'll explore the fundamentals of Python and equip you with the knowledge and skills to start your programming journey.

Throughout the session, we'll cover essential topics such as using the `print()` function to display output, interacting with users through the `input()` function, working with variables to store and manipulate data, and introducing the basic primitive data types in Python. By the end of the workshop, you'll have a solid foundation to build upon as you continue learning and practising Python programming.
:::

# Understanding `print()`
- The `print()` function is used to display information on the screen.
- It is a fundamental tool for debugging and communicating with the user.
- Example:
  
  ```python
  print("Hello, world!")
  ```
  
- Notice how the text is enclosed in quotes.

::: {.notes}
The `print()` function displays information on the screen and is enclosed in parentheses. Text to be printed must be enclosed in quotes, either single ('') or double (""). The `print()` function is a fundamental tool for debugging code and communicating with the user, as it allows the programmer to display messages or values at specific points in the program's execution.

In this slide, we introduce the basic syntax and usage of the `print()` function. We highlight the importance of enclosing the text to be printed in quotes, which is a common mistake made by beginners. We also discuss the role of `print()` in debugging and interacting with users, setting the stage for more advanced topics in future slides.
:::

# Exploring `input()`
- The `input()` function allows your programme to receive data from the user.
- It pauses programme execution until the user enters some text.
- Example:
  
  ```python
  name = input("What is your name? ")
  print("Hello, " + name + "!")
  ```
  
- This is the first step to making your programme interactive.

::: {.notes}
The `input()` function is a powerful tool in Python that enables your programme to accept user input, making it interactive and dynamic. When `input()` is called, the programme pauses execution and waits for the user to enter some text, which can then be stored in a variable for further processing.

To demonstrate the usage of `input()`, consider the following example code: `name = input("Please enter your name: ")`. In this case, the programme will display the prompt "Please enter your name: " and wait for the user to type in their name, which will be assigned to the variable `name`. This basic example illustrates how `input()` can be used to create engaging and responsive programmes that adapt to user input.
:::

# Working with Variables
- Variables are used to store data values.
- A variable is created the moment you assign it a value using the equals sign (`=`).
- Example:
  
  ```python
  age = 25
  print("Age:", age)
  ```
  
- Variables can hold different types of data, such as numbers or text.

::: {.notes}
Variables are fundamental building blocks in programming, allowing you to store and manipulate data values. To create a variable, you simply assign it a value using the equals sign (`=`). For example, `x = 5` creates a variable named `x` and assigns it the value of 5. Variables can hold various types of data, such as numbers (integers or floats) and text (strings).

It's crucial to choose meaningful variable names that reflect the purpose or content of the data they hold. This enhances code readability and makes it easier to understand and maintain your programs. As you progress in your programming journey, you'll encounter more complex data types and learn how to perform operations and calculations using variables. Mastering the concept of variables is a key step in becoming a proficient programmer.
:::

# Introduction to Primitive Data Types
- **Strings:** Text enclosed in quotes (e.g., `"sunny"`).
- **Integers:** Whole numbers (e.g., `10`).
- **Floats:** Numbers with decimal points (e.g., `3.14`).
- **Booleans:** `True` or `False` values.
- Example:
  
  ```python
  temperature = 20.5   # Float
  weather = "cloudy"   # String
  is_raining = False   # Boolean
  ```

::: {.notes}
In this slide, we introduce the four primitive data types in programming: strings, integers, floats, and booleans. Strings are used to represent text and are enclosed in quotes, such as "sunny". Integers are whole numbers like 10, while floats are numbers with decimal points, such as 3.14. Booleans, on the other hand, represent true or false values.

By understanding these primitive data types, you'll be able to effectively store and manipulate different kinds of data in your programs. Whether you're working with text, whole numbers, decimal numbers, or true/false values, these data types form the foundation of your programming toolkit. We'll explore an example that demonstrates how these data types can be used in practice.
:::

# Putting It All Together
- Letâ€™s combine what weâ€™ve learnt:
  1. Display a message with `print()`.
  2. Capture user input using `input()`.
  3. Store the input in a variable.
- Example programme:
  
  ```python
  print("Welcome to the weather programme!")
  temp = input("Enter the current temperature: ")
  print("You entered", temp, "degrees.")
  ```
  
- This simple code snippet demonstrates how our tools work in harmony.

::: {.notes}
Let's take a moment to consolidate our newfound knowledge by examining a concise code example that seamlessly integrates the concepts we've covered. This example will showcase the interplay between `print()`, `input()`, variables, and primitive data types, providing a clear demonstration of how these fundamental building blocks come together to create a functional program.

By dissecting this code snippet, we'll gain a deeper appreciation for the way these elements interact and contribute to the overall functionality of the program. This hands-on approach will reinforce our understanding of the core concepts and serve as a foundation for tackling more complex programming challenges in the future.
:::

# Summary and Next Steps
- In this module we reviewed:
  - The `print()` function for output.
  - The `input()` function for gathering user input.
  - How to create and use variables.
  - Basic data types in Python.
- With these fundamentals in place, youâ€™re well-prepared to tackle more complex projects.
- Up next, we will begin exploring decision making with conditionals in our weather forecasting project.

::: {.notes}
In this module, we reviewed the fundamental concepts of Python programming, including the `print()` function for displaying output, the `input()` function for gathering user input, and the creation and use of variables. We also introduced the basic data types in Python, such as integers, floats, and strings, which form the building blocks of more complex programs.

With a solid grasp of these essential concepts, you are now well-equipped to take on more challenging projects and explore the vast possibilities that Python offers. In the upcoming module, we will delve into decision making using conditionals, which will allow you to create more dynamic and interactive programs. This knowledge will be applied to our exciting weather forecasting project, where you will have the opportunity to put your newfound skills into practice.
:::

1. What is the purpose of the print() function in Python, and how do I use it?
The print() function is a fundamental tool used to display information on the screen. It's essential for debugging and communicating with the user. To use it, enclose the text or variables you want to display within the parentheses, ensuring text is enclosed in quotes. For example, print("Hello, world!") will display "Hello, world!" on the screen.

2. How does the input() function work, and why is it important?
The input() function allows your program to receive data from the user. When called, the program pauses execution and waits for the user to enter text and press Enter. This text can then be stored in a variable for later use, making your programs interactive. For example, name = input("Please enter your name: ") will prompt the user to enter their name, which is then assigned to the variable name.

3. What are variables in Python, and how do I create them?
Variables are used to store data values. You create a variable the moment you assign a value to it using the equals sign (=). For instance, age = 30 creates a variable named age and assigns it the value 30. Variables are essential for manipulating and working with data within your program.

4. What are the four basic primitive data types in Python?
The four basic primitive data types are:

- Strings: Text enclosed in quotes (e.g., "sunny").
- Integers: Whole numbers (e.g., 10).
- Floats: Numbers with decimal points (e.g., 3.14).
- Booleans: True or False values.

5. Can you give an example of how to combine print(), input(), and variables in a simple program?
name = input("Please enter your name: ")

print("Hello, " + name + "!")

This code first uses input() to ask the user for their name and stores it in the name variable. Then, it uses print() to display a greeting that includes the user's name.

6. Why is choosing meaningful names for my variables important?
Choosing meaningful variable names significantly improves code readability and maintainability. Names that reflect the purpose or content of the data they hold make it easier to understand what the code is doing, both for you and for others who may read your code in the future.

7. What role does the print() function play in debugging code?
The print() function is a valuable debugging tool because it allows you to display the values of variables or messages at specific points in your code's execution. This helps you track the flow of your program and identify any unexpected values or errors. By strategically placing print() statements, you can gain insights into what's happening behind the scenes and pinpoint the source of issues.

8. What are conditionals in programming, and why are they important?
Conditionals are a fundamental programming concept that allows your program to make decisions based on data. They enable different code blocks to be executed depending on whether a specific condition is True or False. Conditionals are crucial for creating interactive and responsive programs that can adapt to different situations and user inputs, providing flexibility in program execution by reacting dynamically to various scenarios. The key components of conditionals are the if, elif (else if), and else keywords.

9. How does an if statement work in Python?
The if statement checks a condition. If the condition evaluates to True, the indented block of code immediately following the if statement is executed. If the condition is False, the program can move to an elif (else if) statement to check another condition, or to an else block, which executes if none of the previous conditions were True. In essence, the if statement allows a program to execute certain instructions only when specific criteria are met.

10. What is the purpose of elif and else statements when used with if statements?
The elif (else if) statement provides an opportunity to check an additional condition if the initial if condition is False. You can have multiple elif statements to test for a series of conditions. The else statement provides a default block of code that executes only if none of the preceding if or elif conditions are True. Together, if, elif, and else create a decision-making structure that allows your program to handle various scenarios based on different conditions, ensuring comprehensive coverage in your logic.

11. What are logical operators, and how are they used in conditional statements?
Logical operators combine multiple conditions within a conditional statement. The primary logical operators are:

- and: Both conditions must be True for the overall expression to be True.
- or: At least one condition must be True for the overall expression to be True.
- not: Reverses the truth value of a condition (i.e., True becomes False, and False becomes True).

These operators enable more complex and nuanced decision-making processes by combining simple conditions. For example, if temperature > 20 and raining == False: checks if the temperature is above 20 and it is not raining before executing the associated code block.

12. Can you explain how to visualise the flow of a conditional statement?
Imagine your code as a flowchart. It starts, evaluates a condition (e.g., checking temperature), and then branches based on the result:
Start â†“
Evaluate condition (e.g., temperature) â†“
Yes: Execute if-block No: Move to else-block â†“
End

If the condition is True, the if-block of code is executed. If the condition is False, the flow moves to the else-block (if present). This visualisation helps in understanding the different paths the code can take based on the conditions evaluated.

13. Could you provide an example of a practical application of conditionals in a simple program?
Consider a program that determines whether it's warm or cold based on a user-entered temperature. The program would:

- Prompt the user to enter a temperature.
- Use an if statement to check if the temperature is above a certain threshold (e.g., 20 degrees Celsius).
- If the temperature is above the threshold, print "It's warm outside."
- Otherwise (using an else statement), print "It's cold outside."

This simple weather decision illustrates how conditionals allow programs to respond differently based on specific conditions, demonstrating adaptability through user inputs.

14. What is the main goal of using weather scenarios in programming education?
The primary goal is to make abstract programming concepts, such as conditionals and variables, more tangible and relatable for learners. By using real-world examples like weather forecasting, students can see how code can be used to model and respond to everyday situations. This helps them understand the practical applications of programming logic and makes the learning process more engaging.

15. How can weather conditions like 'cold', 'warm', and 'hot' be used in a program?
These weather conditions can be mapped to specific numeric temperature ranges. For instance, "cold" might be defined as temperatures below 15Â°C, "warm" as temperatures between 15Â°C and 25Â°C, and "hot" as temperatures above 25Â°C. A program can then use these temperature thresholds to determine the appropriate weather message to display to the user.

16. How can a program use temperature input to make a decision about the weather?
A program can use conditional statements (if-else) to compare the input temperature against predefined thresholds. For example, if the temperature is less than 15Â°C, the program can output a "Cold" message. If it's between 15Â°C and 25Â°C, it outputs "Warm", and if it's above 25Â°C, it outputs "Hot". This demonstrates how numeric input can drive decision-making in code.

17. What is the purpose of a flowchart in visualising weather decisions?
A flowchart provides a visual representation of the decision-making process within a weather program. It illustrates the steps the program takes to evaluate the temperature input and determine the corresponding weather message. This helps to clarify the logic and flow of the program, making it easier to understand how different temperature conditions lead to different outputs.

18. Why are temperature thresholds important in connecting code to weather?
Temperature thresholds provide a clear and defined boundary between different weather conditions. By establishing specific thresholds, such as those for 'cold', 'warm', and 'hot' weather, you provide the program with a clear set of criteria to use when deciding which message to display.

19. Beyond temperature, what other weather conditions could be included in a more complex weather program?
Besides temperature, other conditions such as precipitation (rain, snow), wind speed, and humidity could be included. These conditions can be integrated into the program using additional conditional statements to create a more nuanced and accurate weather forecast.

20. How does relating a basic input to a specific output support building more complex programming systems?
This approach lays the groundwork for creating more sophisticated systems that utilize real-world data to generate meaningful outputs. It builds a bridge between abstract coding concepts and practical applications, which can then be extended to create more comprehensive and intricate weather programs.

21. What can be learned from designing a weather decision tree?
Designing a weather decision tree helps in understanding and visualising how weather-based decisions can be structured. It encourages critical thinking about the decision-making process involved in determining weather messages and allows for exploration of alternative approaches and refinement of decision based on feedback. It showcases the practical implications and power of data-driven decision-making in programming.

22. What is a menu interface and why is it useful in text-based programs?
A menu interface is a user interface that presents the user with a list of numbered or labelled options. Each option corresponds to a specific function or message within the program. It's useful because it provides a clear and intuitive way for users to navigate and interact with text-based programs, improving the user experience by simplifying command selection and reducing confusion.

23. How can I display a menu of options in Python?
You can use the print() function to display a menu of options. Each option should be displayed on a separate line for clarity. For example:

print("1. Option A")
print("2. Option B")
print("3. Option C")

24. How do I capture user input to determine their menu selection?
Use the input() function to prompt the user to enter their choice. Store the user's input in a variable. For example:
choice = input("Enter your choice: ")

25. How can my program react differently based on the user's menu selection?
Use conditional statements (like if-elif-else) to check the value of the user's input variable and execute different code blocks accordingly. For example:
choice = input("Enter your choice: ")

if choice == "1":
    print("You selected Option A.")
elif choice == "2":
    print("You selected Option B.")
else:
    print("Invalid choice.")

26. What are the basic Python functions required to create a simple text-based menu?
The two fundamental functions are print() for displaying the menu options and input() for capturing the user's selection. These functions, combined with conditional statements, form the basis of a simple menu program.

27. Can you provide an example of a complete, simple menu program?
print("1. Greet the user")
print("2. Say goodbye")

choice = input("Enter your choice (1 or 2): ")

if choice == "1":
    print("Hello there!")
elif choice == "2":
    print("Goodbye!")
else:
    print("Invalid choice.")
---
title: "Staff Answer Guide: Mastering OOP: Design Choices Unpacked"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


**Date Prepared:** April 24, 2025

This guide provides sample solutions and evaluation points for the student worksheet focused on OOP design, justification, and ethical AI usage in Python.

## Introduction & Key Concepts
Ensure students understand the definitions provided, particularly:

* **Class:** The blueprint (`Book`, `Patron`).
* **Object:** An instance (`my_book`, `a_patron`).
* **Encapsulation:** Bundling data (attributes) and methods operating on that data within a class, controlling access to internal state (e.g., managing `is_checked_out` via methods).
* **(Inheritance/Polymorphism):** While not directly implemented in the core activities, these are background concepts. Polymorphism could be relevant if discussing how different item types (`Book`, `DVD`) might have different `check_out` logic but the same method name.

## Application Activities

### Activity 1: Designing a Simple Class (`Book`)

**Objective:** Define a `Book` class with relevant attributes and methods for basic library operations, including state management (availability).

**Expected Code Structure:**

```python
# Write your class definition here.
class Book:
    """
    Represents a book in a library system, managing its details and availability.
    """
    def __init__(self, title, author, year):
        """
        Initialises a new Book object.

        Args:
            title (str): The title of the book.
            author (str): The author of the book.
            year (int): The year of publication.
        """
        self.title = title
        self.author = author
        self.year = year
        self.is_checked_out = False # Attribute to track availability (state)

    def check_out(self):
        """
        Marks the book as checked out if it is currently available.
        Returns:
            bool: True if successfully checked out, False otherwise.
        """
        if not self.is_checked_out:
            self.is_checked_out = True
            print(f"'{self.title}' has been checked out.")
            return True
        else:
            print(f"'{self.title}' is already checked out.")
            return False

    def check_in(self):
        """
        Marks the book as available (checked in) if it is currently checked out.
        Returns:
            bool: True if successfully checked in, False otherwise.
        """
        if self.is_checked_out:
            self.is_checked_out = False
            print(f"'{self.title}' has been checked in.")
            return True
        else:
            print(f"'{self.title}' is already checked in.")
            return False

    def display_details(self):
        """ Displays the book's details and availability status. """
        status = "Checked Out" if self.is_checked_out else "Available"
        print(f"Title: {self.title}, Author: {self.author}, Year: {self.year}, Status: {status}")

# --- Example Usage (Optional - for testing the class) ---
# book1 = Book("The Lord of the Rings", "J.R.R. Tolkien", 1954)
# book1.display_details()
# book1.check_out()
# book1.display_details()
# book1.check_in()
# book1.display_details()
```

**Evaluation Notes:**

* Check for correct class and `__init__` syntax.
* Attributes `title`, `author`, `year` should be present.
* Crucially, there should be an attribute to track state (like `is_checked_out` or `is_available`), initialised appropriately.
* `check_out` and `check_in` methods should modify this state attribute *conditionally* (i.e., check the current state before changing).
* Methods should ideally provide feedback (print statements or return values) indicating success or failure. Returning a boolean is good practice for interaction (used in Extension).

### Activity 2: Justifying Your Design

**Objective:** Students should articulate the reasoning behind their `Book` class structure, linking it to OOP principles.

**Sample Justification:**

```
# Provide your justification here.
My design for the `Book` class encapsulates all relevant information (title, author, year) and behaviors (checking in, checking out) related to a single book within one structure. This follows the OOP principle of **Encapsulation**, keeping data and methods that operate on that data together.

The inclusion of the `is_checked_out` attribute is essential for managing the book's state internally. The `check_in` and `check_out` methods act as controlled interfaces to modify this state, preventing invalid operations (like checking out an already checked-out book) and hiding the direct manipulation of the `is_checked_out` variable from outside the class.

This design offers benefits like:
- **Modularity:** Each `Book` object is a self-contained unit.
- **Reusability:** The `Book` class can be used to create many book instances.
- **Maintainability:** If the logic for checking books in/out needs to change, modifications are localised to the `Book` class methods.

While Polymorphism isn't heavily demonstrated here, if we later added other item types (like `DVD` or `Magasine`) with their own `check_in`/`check_out` methods, we could potentially treat them interchangeably in parts of the system using polymorphic behavior.
```

**Evaluation Notes:**

* Look for a clear explanation of *why* specific attributes and methods were chosen.
* The justification *must* connect the design to **Encapsulation**. Does the student explain how data and methods are bundled? Do they mention controlled access to state via methods?
* Mentioning benefits like modularity, reusability, or maintainability shows a deeper understanding.
* Bonus points for correctly identifying that Polymorphism isn't the primary principle demonstrated here but explaining how it *could* apply in a broader context.

## Extension Challenge (`Patron` class)

**Objective:** Design a `Patron` class that interacts with the `Book` class, managing borrowing and returning actions.

**Expected Code Structure:**

```python
# (Assume the enhanced Book class from Activity 1 with boolean returns is available)

class Patron:
    """
    Represents a library patron who can borrow and return books.
    """
    def __init__(self, name, patron_id):
        """
        Initialises a new Patron object.

        Args:
            name (str): The name of the patron.
            patron_id (str): The unique ID of the patron.
        """
        self.name = name
        self.patron_id = patron_id
        self.borrowed_books = [] # List to hold references to borrowed Book objects

    def borrow_book(self, book):
        """
        Attempts to borrow a book. Checks availability via the book object.

        Args:
            book (Book): The Book object instance to borrow.
        """
        print(f"\nPatron '{self.name}' attempting to borrow '{book.title}'...")
        if isinstance(book, Book): # Basic type check
            if book.check_out(): # Call the book's method, which handles state change & returns status
                self.borrowed_books.append(book)
                print(f"'{book.title}' successfully borrowed by {self.name}.")
            else:
                # check_out method already printed the reason (e.g., "already checked out")
                print(f"Patron '{self.name}' could not borrow '{book.title}'.")
        else:
            print("Invalid item provided. Cannot borrow.")


    def return_book(self, book):
        """
        Attempts to return a book. Checks if the patron has borrowed it.

        Args:
            book (Book): The Book object instance to return.
        """
        print(f"\nPatron '{self.name}' attempting to return '{book.title}'...")
        if isinstance(book, Book) and book in self.borrowed_books:
            if book.check_in(): # Call the book's method, which handles state change & returns status
                self.borrowed_books.remove(book)
                print(f"'{book.title}' successfully returned by {self.name}.")
            else:
                # check_in method already printed the reason (e.g., "already checked in")
                 print(f"Patron '{self.name}' could not return '{book.title}' (state issue).")
        elif not isinstance(book, Book):
             print("Invalid item provided. Cannot return.")
        else: # Book object valid, but not found in borrowed list
            print(f"Patron '{self.name}' did not borrow '{book.title}'. Cannot return.")


    def display_borrowed_books(self):
        """ Displays the list of books currently borrowed by the patron. """
        print(f"\nBooks currently borrowed by {self.name} ({self.patron_id}):")
        if not self.borrowed_books:
            print("  None.")
        else:
            for book in self.borrowed_books:
                # Accessing attributes of the contained Book objects
                print(f"  - {book.title} by {book.author}")

# --- Example Usage (Showing Interaction) ---
# book_a = Book("Dune", "Frank Herbert", 1965)
# book_b = Book("Foundation", "Isaac Asimov", 1951)
# patron1 = Patron("Alice", "P101")

# patron1.display_borrowed_books()
# patron1.borrow_book(book_a) # Alice borrows Dune
# book_a.display_details()    # Show Dune is checked out
# patron1.borrow_book(book_a) # Alice tries to borrow Dune again (fails)
# patron1.borrow_book(book_b) # Alice borrows Foundation
# patron1.display_borrowed_books() # Show Alice has Dune and Foundation

# patron1.return_book(book_a) # Alice returns Dune
# book_a.display_details()    # Show Dune is available again
# patron1.display_borrowed_books() # Show Alice only has Foundation
# patron1.return_book(book_a) # Alice tries to return Dune again (fails)
```

**Evaluation Notes:**

* Check `Patron` class definition with `__init__` storing `name`, `patron_id`, and an empty list for `borrowed_books`.
* Verify `borrow_book` method:
    * Takes a `book` object as input.
    * Calls the `book` object's `check_out` method.
    * Adds the book to `borrowed_books` *only if* `check_out` succeeds.
    * Includes basic error handling/messaging.
* Verify `return_book` method:
    * Takes a `book` object as input.
    * Checks if the `book` is actually in the `borrowed_books` list.
    * Calls the `book` object's `check_in` method.
    * Removes the book from `borrowed_books` *only if* it was present and `check_in` succeeds.
    * Includes basic error handling/messaging.
* The interaction demonstrates how objects of different classes collaborate by calling each other's methods to manage state changes.

## Reflection

**Objective:** Assess the student's metacognition regarding their learning process and ethical use of AI in the context of OOP design.

**Evaluation Guidance:**

* **AI Helpfulness:** Ask for specifics. "Did AI help brainstorm attributes/methods?" "Did AI help structure the class interaction in the extension?" "Did AI help refine the justification paragraph?" Look for concrete examples of prompts used or suggestions received.
* **Integrity:** How did the student ensure they weren't just blindly copying AI output, especially for design choices? "Did you compare AI suggestions with OOP principles discussed in class?" "Did you consider *why* the AI suggested a certain structure?" "Did you modify or reject AI suggestions based on your own understanding or the project requirements?" "Did you test the AI-assisted code thoroughly?" Look for evidence of **Critical Evaluation** and treating the AI as a **Learning Partner**, not just an answer generator. Linking back to **Transparency** (acknowledging use) is also key.
---
title: "Staff Answer Guide: First Steps in Python: Crafting Your First Class"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

This guide provides the solutions and evaluation points for the student worksheet focused on introducing Python classes and ethical AI usage.

## Introduction & Key Concepts
Ensure students have grasped the basic definitions:

* **Class:** Blueprint (e.g., the `Book` definition).
* **Object:** Instance created from the blueprint (e.g., specific book instances like `book1`, `book2`).
* **Attribute:** Variable associated with an object (e.g., `title`, `author`).
* **Method:** Function associated with an object (e.g., `display_info`).

## Application Activities

### Activity 1: Design a Simple Class

**Objective:** Students should define a class `Book` with an initialiser (`__init__`) to set `title` and `author` attributes, and a method (`display_info`) to print these attributes.

**Expected Code Structure:**

```python
# Define the Book class here
class Book:
    """
    Represents a book with a title and author.
    """
    def __init__(self, title, author):
        """
        Initialises a new Book object.

        Args:
            title (str): The title of the book.
            author (str): The author of the book.
        """
        self.title = title  # Assign the title argument to the instance attribute 'title'
        self.author = author # Assign the author argument to the instance attribute 'author'

    def display_info(self):
        """
        Prints the book's title and author.
        """
        print(f"Title: {self.title}, Author: {self.author}")

# Note: No output is expected from just defining the class.
```

**Evaluation Notes:**

* Check for correct class definition syntax (`class Book:`).
* Verify the `__init__` method (constructor) is defined correctly with `self`, `title`, and `author` parameters.
* Ensure attributes are assigned using `self.attribute_name = parameter_name`.
* Check for the `display_info` method definition, taking `self` as the parameter.
* The method should correctly access and print the instance attributes (`self.title`, `self.author`). F-strings are common, but other printing methods are acceptable.

### Activity 2: Implement and Test Your Class

**Objective:** Students should use the `Book` class definition from Activity 1 to create two distinct book objects and call their `display_info` method.

**Expected Code:**

```python
# Implement the Book class and create instances here

# (Include the class definition from Activity 1 here or assume it's already executed)
class Book:
    """
    Represents a book with a title and author.
    """
    def __init__(self, title, author):
        """
        Initialises a new Book object.
        Args:
            title (str): The title of the book.
            author (str): The author of the book.
        """
        self.title = title
        self.author = author

    def display_info(self):
        """
        Prints the book's title and author.
        """
        print(f"Title: {self.title}, Author: {self.author}")

# Create instances (objects) of the Book class
book1 = Book("The Hitchhiker's Guide to the Galaxy", "Douglas Adams")
book2 = Book("Pride and Prejudice", "Jane Austen")

# Display information for each book
print("Book 1 Info:")
book1.display_info()

print("\nBook 2 Info:")
book2.display_info()
```

**Expected Output:**

```
Book 1 Info:
Title: The Hitchhiker's Guide to the Galaxy, Author: Douglas Adams

Book 2 Info:
Title: Pride and Prejudice, Author: Jane Austen
```

**Evaluation Notes:**

* Verify the class definition is present or correctly referenced.
* Check that at least two instances are created using `ClassName(arguments)`.
* Ensure the `display_info` method is called correctly on each instance (`instance_name.method_name()`).
* The output should reflect the data provided when creating the instances.

### Extension Challenge: Enhance Your Class

**Objective:** Students should modify the `Book` class to include `year_published`, update the display method, add an `update_author` method, and test these changes.

**Expected Code:**

```python
# Enhance and test the Book class here

class Book:
    """
    Represents a book with a title, author, and publication year.
    Includes methods to display info and update the author.
    """
    def __init__(self, title, author, year_published):
        """
        Initialises a new Book object.

        Args:
            title (str): The title of the book.
            author (str): The author of the book.
            year_published (int): The year the book was published.
        """
        self.title = title
        self.author = author
        self.year_published = year_published # Added attribute

    def display_info(self):
        """
        Prints the book's title, author, and publication year.
        """
        # Updated to include year_published
        print(f"Title: {self.title}, Author: {self.author}, Year: {self.year_published}")

    def update_author(self, new_author):
        """
        Updates the author of the book.

        Args:
            new_author (str): The new author's name.
        """
        print(f"Updating author for '{self.title}' from '{self.author}' to '{new_author}'...")
        self.author = new_author # Modify the instance attribute

# --- Testing the Enhanced Class ---

# Create an instance of the enhanced class
book3 = Book("1984", "George Orwell", 1949)

print("Original Info:")
book3.display_info()

# Update the author (Example scenario: Correcting a typo or pseudonym)
book3.update_author("Eric Arthur Blair (George Orwell)") # Using the author's real name as an example update

print("\nUpdated Info:")
book3.display_info()

```

**Expected Output:**

```
Original Info:
Title: 1984, Author: George Orwell, Year: 1949
Updating author for '1984' from 'George Orwell' to 'Eric Arthur Blair (George Orwell)'...

Updated Info:
Title: 1984, Author: Eric Arthur Blair (George Orwell), Year: 1949
```

**Evaluation Notes:**

* Check the `__init__` method signature and body include `year_published`.
* Verify `display_info` is updated to show the new attribute.
* Ensure the `update_author` method is defined correctly, taking `self` and `new_author`, and that it modifies `self.author`.
* Check that the test code creates an instance of the *enhanced* class, calls `display_info`, calls `update_author`, and calls `display_info` again to show the change.

## Reflection

**Objective:** Assess the student's understanding of the learning process, potential applications, and their approach to using AI tools ethically.

**Evaluation Guidance:**
There are no single "right" answers here. Look for thoughtful and specific responses.

* **How might you use this new knowledge in future projects?**
    * Look for connections to real-world scenarios or other programming concepts. Examples: Managing user data, creating game elements (characters, items), organising data records, building simple simulations, structuring larger applications. Vague answers like "to write code" are less insightful.
* **Reflect on how you used AI tools during this activity.**
    * Encourage honesty and specificity, referencing the AI Tips or other uses. Examples: "I asked ChatGPT for the basic syntax of a Python class as suggested," "I used GitHub Copilot to auto-complete method names," "I asked Bard to explain `self`," "I pasted my code and asked an AI to check for errors or suggest improvements." This relates to the **Transparency** guideline.
* **Describe how you ensured the integrity of your work when using AI assistance.**
    * Look for evidence of critical engagement with AI suggestions. Examples: "I compared the AI's suggestion with the lecture notes/documentation," "The AI gave me code, but I rewrote it to make sure I understood it," "I tested the AI's code to see if it actually worked as expected," "I didn't just copy-paste; I used it to understand the concept and then wrote my own version." This relates to the **Critical Evaluation** and **Learning Partner** guidelines. Assess if the student treated the AI as a tool to *aid* understanding, not just a source of answers.

---
title: "Staff Answer Guide: Exploring Code Paradigms: Procedural vs Object-Oriented in Python"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


## Introduction & Key Concepts
This guide provides solutions and evaluation points for the student worksheet comparing procedural and object-oriented programming (OOP) paradigms in Python.
Ensure students can differentiate the core ideas:

* **Procedural Programming:** Focuses on sequences of instructions grouped into functions/procedures. Data tends to be separate from the functions that operate on it.
* **Object-Oriented Programming (OOP):** Focuses on bundling data (attributes) and behavior (methods) together into objects created from class blueprints.
* **Class:** The template/blueprint (e.g., the `Triangle` definition).
* **Object:** A specific instance created from the class (e.g., `my_triangle`).

## Application Activities

### Activity 1: Identifying Paradigms in Real Code

**Scenario Code:**
```python
def calculate_area(base, height):
    return 0.5 * base * height

area = calculate_area(5, 10)
print("Area:", area)
```

**Expected Response:**

* **Paradigm:** Procedural Programming.
* **Justification:**
    * The code is organised around a function (`calculate_area`) that performs a specific task.
    * Data (`base`, `height`, `area`) is defined separately and passed into the function.
    * There are no classes or objects being defined or used. The focus is on the *procedure* (the function call) rather than on objects having state and behavior.

**Evaluation Notes:**

* The student must correctly identify the paradigm as procedural.
* The justification should mention the use of functions, the separation of data and functions, and the absence of classes/objects.

### Activity 2: Refactoring to OOP

**Task:** Convert the procedural code to an OOP structure using a `Triangle` class.

**Expected Code:**

```python
# Procedural code (for reference)
# def calculate_area(base, height):
#     return 0.5 * base * height
# area = calculate_area(5, 10)
# print("Area:", area)

# Refactor to OOP below

class Triangle:
    """
    Represents a triangle with a base and height,
    and can calculate its area.
    """
    def __init__(self, base, height):
        """
        Initialises a Triangle object with base and height.
        Args:
            base (float/int): The base length of the triangle.
            height (float/int): The height of the triangle.
        """
        self.base = base     # Store base as an instance attribute
        self.height = height # Store height as an instance attribute

    def calculate_area(self):
        """
        Calculates the area of the triangle using its base and height.
        Returns:
            float: The calculated area.
        """
        # Method uses the object's own attributes (self.base, self.height)
        return 0.5 * self.base * self.height

# --- Using the OOP approach ---
# 1. Create an instance (object) of the Triangle class
my_triangle = Triangle(5, 10)

# 2. Call the method on the object to perform the calculation
area_oop = my_triangle.calculate_area()

# 3. Print the result
print("OOP Area:", area_oop)
```

**Expected Output:**
```
OOP Area: 25.0
```

**Evaluation Notes:**

* Check for correct class definition syntax (`class Triangle:`).
* Verify the `__init__` method initialises `base` and `height` as instance attributes (`self.base`, `self.height`).
* Ensure the `calculate_area` method is defined within the class, takes `self`, and uses `self.base` and `self.height`.
* Check that an instance of `Triangle` is created (`my_triangle = Triangle(...)`).
* Verify the `calculate_area` method is called correctly on the instance (`my_triangle.calculate_area()`).

### Extension Task: Enhance the Triangle Class

**Task:** Add perimeter calculation and input validation to the `Triangle` class. *Note: Calculating the perimeter requires the lengths of the three sides. The area calculation uses base and height. For simplicity, we'll add three side attributes alongside base and height, and validate all. Acknowledge that for a general triangle, base/height aren't sufficient alone for perimeter, and side lengths aren't sufficient alone for the area formula used.*

**Expected Code:**

```python
import math # Needed for more complex area if using sides, but sticking to original area formula here.

class Triangle:
    """
    Represents a triangle with base, height, and three side lengths.
    Includes methods for area and perimeter calculation, and input validation.
    """
    def __init__(self, base, height, side1, side2, side3):
        """
        Initialises a Triangle object with dimensions and side lengths.

        Args:
            base (float/int): The base length (for area calc).
            height (float/int): The height (for area calc).
            side1 (float/int): Length of the first side (for perimeter/validation).
            side2 (float/int): Length of the second side (for perimeter/validation).
            side3 (float/int): Length of the third side (for perimeter/validation).

        Raises:
            ValueError: If any dimension/side is not positive, or if sides
                      do not form a valid triangle (triangle inequality).
        """
        # Input Validation
        if not all(isinstance(val, (int, float)) and val > 0 for val in [base, height, side1, side2, side3]):
            raise ValueError("Base, height, and all sides must be positive numbers.")

        # Triangle Inequality Check (sum of any two sides must be greater than the third)
        if not (side1 + side2 > side3 and side1 + side3 > side2 and side2 + side3 > side1):
            raise ValueError("The given side lengths do not form a valid triangle.")

        # Assign attributes if validation passes
        self.base = base
        self.height = height
        self.side1 = side1
        self.side2 = side2
        self.side3 = side3
        # Note: We store base/height and sides separately as per the task evolution.
        # In a real-world scenario, you might derive some from others if possible
        # (e.g., for a right triangle) or use formulas like Heron's for area from sides.

    def calculate_area(self):
        """
        Calculates the area using base and height.
        Returns:
            float: The calculated area.
        """
        return 0.5 * self.base * self.height

    def calculate_perimeter(self):
        """
        Calculates the perimeter using the three side lengths.
        Returns:
            float: The calculated perimeter.
        """
        return self.side1 + self.side2 + self.side3

# --- Testing the Enhanced Class ---
try:
    # Example valid triangle (e.g., a 3-4-5 right triangle, base=3, height=4)
    valid_triangle = Triangle(base=3, height=4, side1=3, side2=4, side3=5)
    print(f"Valid Triangle - Area: {valid_triangle.calculate_area()}")
    print(f"Valid Triangle - Perimeter: {valid_triangle.calculate_perimeter()}")

    # Example invalid triangle (violates triangle inequality)
    print("\nAttempting to create invalid triangle (sides 1, 2, 5):")
    invalid_triangle_sides = Triangle(base=1, height=1, side1=1, side2=2, side3=5)

except ValueError as e:
    print(f"Error creating triangle: {e}")

try:
    # Example invalid input (non-positive value)
    print("\nAttempting to create triangle with non-positive side:")
    invalid_triangle_input = Triangle(base=3, height=4, side1=3, side2=4, side3=-5)

except ValueError as e:
    print(f"Error creating triangle: {e}")
```

**Expected Output:**
```
Valid Triangle - Area: 6.0
Valid Triangle - Perimeter: 12.0

Attempting to create invalid triangle (sides 1, 2, 5):
Error creating triangle: The given side lengths do not form a valid triangle.

Attempting to create triangle with non-positive side:
Error creating triangle: Base, height, and all sides must be positive numbers.
```

**Evaluation Notes:**

* Check `__init__` includes parameters for sides (`side1`, `side2`, `side3`).
* Verify input validation logic:
    * Checks if inputs are numeric and positive.
    * Checks the triangle inequality theorem.
    * Raises `ValueError` appropriately.
* Ensure the `calculate_perimeter` method is correctly implemented using `self.side1`, `self.side2`, `self.side3`.
* Check the example usage demonstrates both successful creation/method calls and catches validation errors using `try...except`.
* Comments explaining the structure (especially the separate handling of base/height for area and sides for perimeter) are a plus.

## Reflection

**Objective:** Evaluate the student's synthesis of the concepts, self-awareness of AI tool usage, and commitment to academic integrity.

**Evaluation Guidance:**
Focus on the depth and specificity of the answers.

* **Reflect on how you might use the knowledge of different programming paradigms in your future projects.**
    * Look for understanding of trade-offs. When might procedural be suitable (simple scripts, linear workflows, performance-critical loops)? When is OOP better (modeling complex entities, code reuse via inheritance/polymorphism, large projects needing organisation, GUI development)? Specific examples strengthen the response.
* **Discuss how you used AI tools during this activity and evaluate their effectiveness.**
    * Encourage specific examples related to the tasks: "Asked AI for syntax to define a class," "Asked AI how to refactor the function into a method," "Used AI to generate ideas for input validation," "Asked AI to explain the difference between procedural and OOP with examples."
    * Evaluation: Was the AI helpful? Did it provide correct information? Was it easy to integrate its suggestions? This shows engagement with the **Learning Partner** aspect.
* **Describe how you ensured the integrity of your work when using AI suggestions.**
    * Look for actions demonstrating **Critical Evaluation** and **Transparency**. Examples: "I cross-referenced the AI's explanation with the worksheet/lecture notes," "I tested the code suggested by the AI to ensure it worked and I understood it," "I modified the AI's suggestion to fit the specific requirements of the task," "I treated the AI as a tutor to explain concepts, then wrote the code myself," "I noted where AI contributed significantly." Avoidance of simple copy-pasting should be evident.

---
title: "ðŸŒ¤ï¸ Weather Question Parser Worksheet"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

> A beginner-friendly guide to parsing weather questions using pseudocode and LLMs

## Introduction

Natural Language Processing (NLP) lets computers understand human language. In this worksheet, we'll design a system that can understand weather questions like "Will it rain tomorrow in Sydney?" by extracting:

- **Location**: Sydney
- **Time Period**: tomorrow
- **Weather Attribute**: rain

## What You'll Learn

In this worksheet, you will:
1. Understand different approaches to natural language parsing
2. Learn how to effectively use reference documentation with LLMs
3. Design a weather parser using pseudocode
4. Practice intentional prompting with LLMs to convert your design to Python
5. Learn how to use AI as a thinking partner in development

## Assessment Connection

**Important:** The skills you develop in this worksheet directly relate to your upcoming assessment. In this unit, your AI conversations with LLMs will be assessed and weighted more heavily than the resulting code. This is because the ability to effectively prompt, question, and collaborate with AI tools is becoming a critical skill for developers.

The weather parser you create here will not only help you understand NLP concepts but also provide a useful component you can apply in your assignment. Pay special attention to the intentional prompting techniques, follow-up questioning, and your approach to teaching the LLM about the hands-on-ai packageâ€”these are exactly the skills your assessment will evaluate.

## Different Approaches to NLP

There are several ways to solve this problem:

1. **Keyword Matching**: Using pattern recognition to find important words
2. **Template Matching**: Comparing questions to pre-defined templates
3. **Traditional NLP**: Using specialized linguistic analysis libraries
4. **LLM Integration**: Using AI language models

For beginners, the LLM approach can be surprisingly accessible while giving excellent results!

## Step 1: Introducing the hands-on-ai Package

The hands-on-ai package provides tools to work with language models easily. You should have access to a reference guide (`hands_on_ai_llm_guide.txt`) that explains the package's features.

### Teaching the LLM About hands-on-ai

Before asking the LLM to help you implement your parser, you need to teach it about the hands-on-ai package:

1. Upload the `hands_on_ai_llm_guide.txt` reference document to your chat with the LLM
2. Use an initial prompt like this to help the LLM understand the context:

```
I've uploaded a reference guide for the hands-on-ai package. Please review it to understand the package's capabilities, especially the chat module that we'll use for building a weather question parser. After reviewing, please confirm you understand how the package works.
```

## Step 2: Understanding the Problem

Before writing any code, let's break down what we're trying to accomplish:

1. Take a natural language question about weather
2. Extract structured information (location, time, weather attribute)
3. Return this information in a consistent format

## Step 3: Designing Our Weather Parser (Pseudocode)

Let's design our solution in pseudocode:

```
FUNCTION ParseWeatherQuestion(question)
    // Create a prompt for the language model
    prompt = "Extract location, time period, and weather attribute from: " + question
    
    // Send prompt to language model using hands-on-ai
    response = SendToLanguageModel(prompt)
    
    // Convert response to structured format
    result = ParseJsonResponse(response)
    
    // Set default values for missing information
    IF result does not have "location" OR result["location"] is empty THEN
        result["location"] = none
    END IF
    
    IF result does not have "time_period" OR result["time_period"] is empty THEN
        result["time_period"] = "today"
    END IF
    
    IF result does not have "weather_attribute" OR result["weather_attribute"] is empty THEN
        result["weather_attribute"] = "general"
    END IF
    
    RETURN result
END FUNCTION
```

## Step 4: Converting Pseudocode to Python with Intentional Prompting

Now that you've designed your parser in pseudocode and taught the LLM about the hands-on-ai package, it's time to convert this design to Python code.

### ðŸ§  What Is Intentional Prompting?

**Intentional prompting** means you:
- Ask the AI to **explain** its reasoning
- Ask questions that lead to deeper understanding of Python concepts
- Refine and adapt prompts when the first response isn't quite right
- Know when to question, correct, or reject AI-generated code
- Use the AI as a **thinking partner**, not just a code generator

### Example Intentional Prompt

Here's an example of how to intentionally prompt an LLM to help convert our pseudocode to Python:

```
Now that you understand the hands-on-ai package, I'd like your help implementing a weather question parser. I have the following pseudocode design:

FUNCTION ParseWeatherQuestion(question)
    // Create a prompt for the language model
    prompt = "Extract location, time period, and weather attribute from: " + question
    
    // Send prompt to language model using hands-on-ai
    response = SendToLanguageModel(prompt)
    
    // Convert response to structured format
    result = ParseJsonResponse(response)
    
    // Set default values for missing information
    IF result does not have "location" OR result["location"] is empty THEN
        result["location"] = none
    END IF
    
    IF result does not have "time_period" OR result["time_period"] is empty THEN
        result["time_period"] = "today"
    END IF
    
    IF result does not have "weather_attribute" OR result["weather_attribute"] is empty THEN
        result["weather_attribute"] = "general"
    END IF
    
    RETURN result
END FUNCTION

Please help me convert this to Python code using the hands-on-ai package. In your response:

1. First, explain which specific functions from the hands-on-ai.chat module would work best for parsing weather questions
2. Show me how to improve the prompt to get better structured data (JSON)
3. Write the Python implementation with comments explaining each step
4. Explain any potential errors and how to handle them
5. Suggest a simple way to test the function

After seeing your implementation, I want to understand WHY you made certain choices, not just copy the code.
```

## Step 5: Follow-up Questions for Deeper Understanding

After receiving the LLM's implementation, ask follow-up questions to deepen your understanding:

```
Thank you for the implementation. I have some follow-up questions:

1. I notice you used the get_response function from hands-on-ai.chat. Would using one of the personality bots like teacher_bot or coder_bot give better results for parsing? Why or why not?

2. Could we improve the error handling? What specific types of errors might occur when parsing JSON from an LLM response?

3. How would you modify this implementation to handle more complex weather questions like "Will I need sunscreen and a hat this weekend at the beach?" that contain multiple weather attributes?

4. If we wanted to make this part of a complete weather application, what would be the next step after parsing the question?
```

This type of follow-up demonstrates intentional prompting - you're asking "why" questions and exploring improvements rather than just accepting the first solution.

## Step 6: Experiments and Reflection

Once you have your implementation, test it with these questions:

- "Will it rain tomorrow in Sydney?"
- "What's the temperature in Tokyo today?"
- "Do I need an umbrella in London this weekend?"
- "Is it going to be windy in Chicago?"
- "How cold will it be in New York tomorrow?"

**Reflection Questions:**
1. How well did the LLM understand your pseudocode design?
2. What improvements did the LLM suggest to your original design?
3. What errors or edge cases did you encounter?
4. How could you further improve the prompt to get more accurate parsing?

## For Advanced Users: Exploring Advanced Techniques

If you're comfortable with the basic implementation, try exploring these advanced concepts:

### Using Custom Bots for Specialized Parsing

The hands-on-ai package allows creating custom bots with specific personalities and system prompts. Ask the LLM how you could create a specialized "weather parser bot" using code like this pseudocode:

```
FUNCTION CreateWeatherBot()
    // Create specialized bot for weather parsing
    SET system_prompt = "You are an expert at extracting structured data from weather questions."
    SET personality = "technical"
    
    RETURN CustomBot with system_prompt and personality
END FUNCTION
```

### Adding Schema Validation

For more reliable parsing, consider asking the LLM about adding schema validation to your implementation:

```
I'd like to ensure the parsed data always matches a specific structure. How could I use Python's data validation tools to ensure my weather query results always contain valid location, time_period, and weather_attribute fields? Please explain the concept and show me an example.
```

### Using the Agent Module for Complex Weather Questions

The hands-on-ai package includes an "agent" module with tools for multi-step reasoning. Ask the LLM how you might use this for more complex weather analysis:

```
Looking at the hands-on-ai reference guide, I see there's an "agent" module with tools for multi-step reasoning. How could I use this to handle more complex weather questions that might require calculations or conversions, like "Will it be warmer tomorrow in New York than it was yesterday in Boston?"
```

## Key Takeaways

1. LLMs make complex NLP tasks accessible to beginners
2. Pseudocode helps design solutions before jumping into implementation
3. Intentional prompting transforms AI from a code generator to a thinking partner
4. Reference documentation can be uploaded to LLMs to help them understand specific libraries
5. Follow-up questions deepen understanding and improve solutions

## Exercises

1. **Basic**: 
   - Upload the hands-on-ai reference guide and ask the LLM to explain which parts are most relevant for weather parsing
   - Create an intentional prompt to add one more field to extract from weather questions

2. **Intermediate**: 
   - Write pseudocode for a command-line interface for your parser
   - Ask the LLM to compare using the chat module versus the agent module for this task

3. **Challenge**: 
   - Design pseudocode for connecting your parser to a weather API
   - Ask the LLM to help implement a custom weather bot that can both parse questions and answer them using sample weather data

## Teaching LLMs About Domain-Specific Tools

This worksheet demonstrates a powerful approach to learning: using LLMs as collaborative learning partners by teaching them about specific tools and packages. You can apply this same approach to other domains by:

1. Finding or creating a reference document about your tool/library
2. Uploading it to the LLM
3. Using intentional prompting to ask the LLM to help you understand and use the tool
4. Following up with deeper questions to explore advanced features

## Resources

- Hands-On AI Documentation (from the reference guide you uploaded)
- [Effective Prompting Strategies for LLMs](https://example.com/prompting)
- [Python JSON and Error Handling](https://example.com/python-json)
---
title: "Unlocking Object-Oriented Programming: Simplifying Complexity"
subtitle: "A Beginner's Guide to the Foundations of OOP"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


# Introduction to Object-Oriented Programming

* What is Object-Oriented Programming (OOP)?
* Why is OOP important in modern software development?
* Overview of key OOP concepts: Classes and Objects

::: {.notes}
Welcome to the intriguing world of Object-Oriented Programming! OOP is a programming paradigm based on the concept of "objects", which can contain data in the form of fields (often known as attributes or properties), and code, in the form of procedures (often known as methods). This approach is crucial in modern software development because it helps organise software design, making it easier to manage and modify. Today, weâ€™ll explore the foundational concepts that make OOP a preferred choice among programmers for developing robust and scalable applications.
:::

# Understanding Classes and Objects

* Definition of a Class
* Definition of an Object
* How Classes and Objects interact

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

my_dog = Dog("Rex", 5)
```

::: {.notes}
In Object-Oriented Programming, a class is like a blueprint for creating objects. An object is an instance of a class. When the class is defined, no memory is allocated, but when it's instantiated, a piece of memory is allocated to accommodate the object. For instance, in Python, the 'Dog' class creates a 'Dog' object with attributes like name and age. This demonstrates how classes and objects interact: the class provides the structure, and the object provides the actual content.
:::

# Key Principles of OOP: Encapsulation

* What is Encapsulation?
* Why Encapsulation is vital
* Example of Encapsulation

```python
class Account:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.__balance = balance  # Private attribute

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print("Deposit successful")
```

::: {.notes}
Encapsulation is one of the fundamental concepts in OOP. It refers to the bundling of data with the methods that operate on that data. Encapsulation hides the internal state of an object from the outside world and only allows modification through a set of public methods. This is crucial as it prevents external entities from tampering with the internal state, thus ensuring data integrity and security. The example above shows a bank account where the balance is kept private, safely encapsulated within the class.
:::

# Key Principles of OOP: Inheritance

* What is Inheritance?
* Benefits of using Inheritance in OOP
* Example of Inheritance

```python
class Animal:
    def __init__(self, name):
        self.name = name

class Dog(Animal):
    def speak(self):
        return "Woof!"
```

::: {.notes}
Inheritance is a mechanism in OOP that allows a new class to inherit properties and methods from an existing class. The primary benefit of inheritance is reusabilityâ€”you can create a new class based on an existing class without modifying it, thus promoting code reusability and redundancy reduction. The example demonstrates a 'Dog' class inheriting from an 'Animal' class, acquiring its attributes and potentially adding or modifying others, like the 'speak' method.
:::

# Key Principles of OOP: Polymorphism

* What is Polymorphism?
* Why it enhances flexibility
* Example of Polymorphism

```python
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"
```

::: {.notes}
Polymorphism in OOP allows objects of different classes to be treated as objects of a common superclass. It enhances flexibility and integration by allowing the same interface to be used for different underlying forms (data types). This means that a single function can interact with different data types, as shown in the example where both 'Dog' and 'Cat' classes override the 'speak' method of their superclass 'Animal' to perform class-specific functionality.
:::

# Comparing Procedural vs OOP

* Definition of Procedural Programming
* Key differences between Procedural and OOP
* Advantages of OOP over Procedural

::: {.notes}
Procedural programming is a programming paradigm based upon the concept of procedure calls, where procedures (also known as routines, subroutines or functions) contain a series of computational steps to be carried out. In contrast, OOP organises software design around data, or objects, rather than functions and logic. The main advantage of OOP over procedural programming is that it is more modular and allows for classes to be reused in different programs, thereby reducing redundancy and making maintenance easier.
:::

# Applying OOP Concepts: A Python Example

* Design a simple class-based system in Python
* Demonstrate encapsulation, inheritance, and polymorphism

```python
# Simple Bank Account Class
class Account:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.__balance = balance

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print("Deposit successful")

class SavingsAccount(Account):
    def __init__(self, owner, balance=0, interest_rate=0.01):
        super().__init__(owner, balance)
        self.interest_rate = interest_rate

    def apply_interest(self):
        self.__balance += self.__balance * self.interest_rate
```

::: {.notes}
The above example illustrates a practical implementation of OOP concepts in Python. A 'SavingsAccount' class inherits from a general 'Account' class and adds a specific attribute and method related to the interest rate. This shows encapsulation (private balance), inheritance (inherits from Account), and polymorphism (method overriding for specific functionalities). Such implementations demonstrate the power and flexibility of OOP in designing real-world applications.
:::

# Conclusion: Embracing OOP for Better Software Design

* Recap of the key OOP concepts and their benefits
* How OOP can lead to more efficient and manageable code
* Encouragement to explore further with more complex projects

::: {.notes}
Today, we've explored the essential principles of Object-Oriented Programming and how they form the backbone of modern software design. By understanding and implementing classes, encapsulation, inheritance, and polymorphism, you can create more efficient, scalable, and manageable code. I encourage you to apply these principles in your projects and continue exploring more complex OOP scenarios to truly master this powerful programming paradigm.
:::---
title: "From Procedural to Object-Oriented: A Refactoring Journey"
subtitle: "Mastering Python's OOP Features for Better Software Design"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


# Introduction to Refactoring

* Understanding the need for refactoring
* Procedural vs Object-Oriented Programming
* Benefits of moving to Object-Oriented Code

::: {.notes}
Welcome to our session on refactoring procedural code to object-oriented code in Python. Refactoring involves modifying the code to improve its structure without changing its functionality. This process is crucial for maintaining code efficiency and readability as projects grow. Today, we'll explore why and how to transition from a procedural to an object-oriented approach, which promotes modularity and reusability in programming.
:::

# What is Object-Oriented Programming?

* Definition of Object-Oriented Programming (OOP)
* Core concepts: Classes, Objects
* Encapsulation, Inheritance, and Polymorphism

::: {.notes}
Object-Oriented Programming (OOP) is a programming paradigm based on the concept of "objects", which can contain data in the form of fields (often known as attributes), and code, in the form of procedures (often known as methods). OOP allows programmers to create modules that can be reused across different programs. The three pillars of OOPâ€”encapsulation, inheritance, and polymorphismâ€”help in building secure and robust programs.
:::

# Analysing a Procedural Code Example

* Typical structure of procedural code
* Example: Weather Dashboard procedural implementation
* Limitations in scalability and maintenance

::: {.notes}
Let's start with a procedural code example from a typical Weather Dashboard application. This code is linear and function-based, which can make it harder to manage as it grows. Procedural code often becomes more complex and difficult to maintain as new features are added. This complexity can lead to errors and reduce the code's overall reliability.
:::

# Introducing Classes and Objects

* Converting procedural code into classes
* Defining attributes and methods
* Example: Refactoring Weather Dashboard

::: {.notes}
To refactor our procedural code, we begin by identifying natural groupings of data and functions, which can be transformed into classes and objects. For instance, a 'Weather' class could encapsulate attributes like temperature and humidity, along with methods to compute forecast details. This encapsulation makes the code more organized and readable.
:::

# Implementing Inheritance

* What is inheritance?
* Benefits of using inheritance in refactoring
* Example: Extending the Weather class

::: {.notes}
Inheritance is a powerful feature of OOP that allows a new class to inherit attributes and methods from an existing class. In our Weather Dashboard, we might have a general 'Weather' class and specialised classes like 'RainyWeather' or 'SunnyWeather' that inherit from it. This approach reduces redundancy and enhances the clarity of the code structure.
:::

# Exploring Polymorphism

* Concept of polymorphism in OOP
* How polymorphism enhances flexibility
* Example: Different display methods for weather conditions

::: {.notes}
Polymorphism gives us the flexibility to call the same method on different objects and have each of them respond in a unique way. In the context of our Weather Dashboard, polymorphism allows different weather classes to use a common interface for displaying information, which the specific class can override to reflect different weather conditions appropriately.
:::

# Case Study: Refactoring in Action

* Step-by-step refactoring process
* Before and after code comparison
* Challenges faced and how they were resolved

::: {.notes}
Now, let's look at a practical refactoring case study. We'll take a procedural version of the Weather Dashboard and step through its transformation into an OOP design. This will include creating classes, implementing inheritance, and utilising polymorphism. We'll also discuss the challenges encountered during refactoring, such as integrating legacy code and testing changes.
:::

# Benefits of OOP Refactoring

* Improved code readability and maintenance
* Enhanced ability to extend and manage large applications
* Facilitates teamwork and code reuse

::: {.notes}
Refactoring to OOP offers numerous benefits. The code becomes easier to understand, which simplifies maintenance. It's also more scalable, making it easier to extend with new features without disrupting existing functionality. Additionally, OOP's modular nature enhances teamwork by allowing developers to work on different modules simultaneously without conflict.
:::

# Conclusion and Next Steps

* Review of key concepts and benefits
* Encouragement to practice refactoring
* Resources and further learning

::: {.notes}
To summarise, refactoring from procedural to object-oriented code in Python enhances code quality and development efficiency. We encourage you to apply these concepts to refactor your own projects. Continue your learning journey with further resources like Pythonâ€™s official documentation on classes and real-world examples from sites like Real Python.
:::---
title: "Unlocking OOP: Mastering Inheritance and Polymorphism"
subtitle: "A Beginnerâ€™s Guide to Structuring Code Efficiently"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to Inheritance and Polymorphism

* Understanding the pillars of Object-Oriented Programming (OOP)
* Defining inheritance and polymorphism
* Importance in software development

::: {.notes}
Welcome to our exploration of Object-Oriented Programming, focusing on two fundamental concepts: inheritance and polymorphism. These concepts are vital for creating modular and reusable code that is easier to manage and extend. In this session, you'll learn how these principles can help streamline your coding projects and make your software designs more efficient and adaptable.
:::

# What is Inheritance?

* A mechanism to create new classes using existing classes
* Reduces redundancy and increases reusability
* Example: Creating a 'Car' class from a 'Vehicle' class

::: {.notes}
Inheritance is a powerful feature of OOP that allows a new class to inherit attributes and methods from an existing class. For instance, if you have a 'Vehicle' class, you can create a 'Car' class that inherits properties like wheels and engine from 'Vehicle'. This inheritance mechanism prevents the need to rewrite code and enhances reusability.
:::

# What is Polymorphism?

* Concept of using a unified interface to operate on objects of different classes
* Enables flexibility in programming
* Example: Calling the .drive() method on a 'Car' or 'Bike' object

::: {.notes}
Polymorphism allows different classes to be treated through the same interface, highlighting one of the key strengths of OOP: flexibility. An example of polymorphism is having a generic .drive() method that can be applied to different types of vehicles like 'Car' and 'Bike', which might implement this method in slightly different ways but achieve the same type of functionality.
:::

# Benefits of Using Inheritance

* Simplifies and reduces the complexity of code
* Enhances the clarity of the programming structure
* Promotes code reusability and maintenance

::: {.notes}
Using inheritance in programming not only simplifies your codebase by reducing redundancy but also clarifies the structure of your programs. It promotes greater code reusability, which is a significant advantage when maintaining and updating systems. This can lead to more robust and error-free code.
:::

# Benefits of Using Polymorphism

* Increases the flexibility of code
* Simplifies code management and extension
* Facilitates adding new features without altering existing code

::: {.notes}
Polymorphism enhances the flexibility of your code by allowing the use of a single interface to interact with different data types. This simplifies management and extension of code, particularly when new features need to be added or when the system needs to evolve with minimal changes to the existing codebase.
:::

# Practical Example: Inheritance

```python
class Vehicle:
    def start(self):
        print("Engine start")

class Car(Vehicle):
    def open_trunk(self):
        print("Trunk opened")

# Use Car
my_car = Car()
my_car.start()  # Inherited method
my_car.open_trunk()  # New method
```

::: {.notes}
This Python code demonstrates how the 'Car' class inherits from the 'Vehicle' class. The 'Car' class can use the 'start' method defined in 'Vehicle', demonstrating reusability, and it also has its own method 'open_trunk'. This example illustrates how inheritance can be practically applied in programming to enhance functionality and reduce code duplication.
:::

# Practical Example: Polymorphism

```python
class Vehicle:
    def drive(self):
        print("Vehicle driving")

class Car(Vehicle):
    def drive(self):
        print("Car driving fast")

class Bike(Vehicle):
    def drive(self):
        print("Bike driving on a trail")

# Polymorphic use
vehicles = [Car(), Bike()]
for vehicle in vehicles:
    vehicle.drive()
```

::: {.notes}
In this example, both 'Car' and 'Bike' classes override the 'drive' method of the 'Vehicle' class. When calling 'drive' on each object within the loop, the appropriate class-specific method is executed, demonstrating polymorphism. This allows each class to implement an action in a way that's appropriate for its context.
:::

# Conclusion

* Recap of inheritance and polymorphism
* Their roles in clean, efficient, and reusable code
* Encouragement to apply these concepts in your projects

::: {.notes}
Today, we've uncovered the essentials of inheritance and polymorphism, two pillars of Object-Oriented Programming that make our code more efficient, clean, and reusable. As you continue developing your programming skills, try to incorporate these concepts into your projects, particularly in scenarios where code reusability and flexibility are crucial.
:::

# Further Learning and Resources

* Explore Python's official documentation on classes
* Delve into further studies with real-world projects
* Use resources like Real Python for deeper understanding

::: {.notes}
To further your understanding of inheritance and polymorphism, I recommend exploring additional resources such as Python's official documentation and tutorials from Real Python. Practical application through projects will also greatly enhance your grasp of these concepts. Keep learning and experimenting to become proficient in these essential OOP techniques.
:::---
title: "Module 3: Computational Thinking and Algorithm Design"
subtitle: "Breaking Down Problems and Designing Effective Solutions"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Module 3: Computational Thinking and Algorithm Design

Welcome to Module 3. In this module, we explore how to break down complex problems into manageable steps and design effective algorithms. These skills are key to building our User Preferences project and serve as the foundation for all programming.

::: {.notes}
This module introduces the fundamental concepts of computational thinking and algorithm design, which form the foundation for problem-solving in computer science. We will explore the process of breaking down complex problems into manageable steps, allowing us to develop efficient and effective solutions.

Throughout this module, we will learn how to utilise pseudocode as a planning tool, enabling us to outline our algorithms before diving into the actual coding process. By following a simplified development methodology, we will gain hands-on experience in applying computational thinking principles to real-world scenarios, empowering us to tackle a wide range of programming challenges.
:::

# What is Computational Thinking?

- It is the process of breaking problems into smaller, manageable parts.
- It involves recognising patterns and organising steps logically.
- This mindset helps you devise clear, step-by-step solutions.
- In our User Preferences project, computational thinking guides the way we capture and process user data.

::: {.notes}
Computational thinking is a problem-solving approach that involves breaking complex problems into smaller, more manageable parts. By recognising patterns and organising steps logically, we can develop clear, step-by-step solutions to these problems. This mindset is particularly useful in the field of computer science, where it helps us to create efficient and effective algorithms.

In our User Preferences project, computational thinking plays a crucial role in guiding the way we capture and process user data. By breaking down the process into smaller, well-defined steps, we can ensure that our solution is both accurate and efficient. This approach allows us to identify potential issues early on and develop a robust solution that meets the needs of our users.
:::

# Breaking Problems into Steps

- Divide a complex problem into simple, individual tasks.
- Tackle each task one at a time.
- For example, a User Preferences programme can be split into:
  - Collecting user input.
  - Processing the data.
  - Displaying a personalised output.

::: {.notes}
Breaking complex problems into smaller, manageable tasks is a key aspect of computational thinking. By dividing a problem into simple, individual steps, you can tackle each task one at a time, making the overall problem less overwhelming. This approach allows you to focus on solving each sub-problem independently, which can lead to a more efficient and effective solution.

To illustrate this concept, consider the example of creating a User Preferences programme. Instead of trying to solve the entire problem at once, you can split it into three main tasks: collecting user input, processing the data, and displaying a personalised output. By addressing each task separately, you can develop a clear plan of action and write code that is more organised and easier to debug. This step-by-step approach forms the foundation of algorithm design and is essential for creating well-structured, efficient programs.
:::

# Pseudocode: Your Planning Tool

- Pseudocode is an informal way to plan your solution without worrying about syntax.
- It lets you outline the logic before writing actual Python code.
- Example for our User Preferences project:
  ```
  Prompt user for name
  Prompt user for favourite colour
  Display personalised greeting using name and colour
  ```
- This step helps you visualise the programme structure clearly.

::: {.notes}
Pseudocode is a valuable tool for planning and outlining the logic of your solution before diving into writing actual Python code. It allows you to focus on the problem-solving process and structure of your programme without getting bogged down in syntax details. By using pseudocode, you can break down the problem into manageable steps and clearly visualise the flow of your programme.

Let's look at an example of how pseudocode can be applied to our User Preferences project. By writing out the high-level steps and logic in plain language, we can map out the key components and flow of the programme. This planning process helps identify any potential issues or areas that need further clarification before starting to code. Once you have a solid pseudocode outline, translating it into Python becomes a more straightforward task.
:::

# Simplified Development Methodology

Our six-step process to design a programme:

1. **Understand the problem:** Restate it in your own words.
2. **Identify the input and output:** Determine what information is needed and what the programme should produce.
3. **Work the problem by hand:** Solve a small example manually.
4. **Write the pseudocode:** Outline the logical steps to solve the problem.
5. **Convert the pseudocode to Python:** Translate your outline into working code.
6. **Test with a variety of data:** Ensure your solution works under different scenarios.

::: {.notes}
The Simplified Development Methodology breaks down the process of solving problems using computational thinking into four key stages: planning, implementation, testing, and evaluation. It provides a structured approach to guide programmers through the development lifecycle, from analysing the problem and designing a solution, to writing code, testing it thoroughly, and refining the solution based on feedback.

By following this methodology, programmers can tackle complex problems in a systematic and organised manner. The planning stage involves understanding the problem, identifying inputs and outputs, and creating a high-level solution using tools like pseudocode or flowcharts. Implementation focuses on translating the plan into working code, while testing ensures the solution performs as expected and handles edge cases. Finally, evaluation allows for reflection on the solution's effectiveness and identification of areas for improvement, fostering continuous learning and growth as a programmer.
:::

# Hands-On Activity

**Task:**  
- Write pseudocode for your User Preferences project using the six-step methodology.
- Begin by restating the problem in your own words.
- Identify the inputs (e.g. name, favourite colour) and the desired output (a personalised greeting).
- Work through an example by hand.
- Write your pseudocode outlining each step.
- Discuss your pseudocode with a peer and refine your approach before converting it to Python in a future session.

::: {.notes}
In this hands-on activity, students will apply the six-step methodology to write pseudocode for their User Preferences project. They should begin by restating the problem in their own words, ensuring they have a clear understanding of the task at hand. Next, they will identify the required inputs, such as the user's name and favourite colour, and the desired output, which is a personalised greeting.

Students will then work through an example manually, step by step, to gain a practical understanding of the process. Following this, they will write their pseudocode, outlining each step in a clear and logical manner. Finally, students will discuss their pseudocode with a peer, providing an opportunity for feedback and refinement before they convert their pseudocode into Python code in a future session.
:::

---
title: "Module 2: Using Input and Output in Python"
subtitle: "Speak and Listen: Empowering Your Programmes with Interactive Input and Output"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Module Overview

Welcome to Module 2. In this module, we explore how to interact with users through Python. We will learn how to capture user input using the `input()` function and display output with `print()`. These skills are essential for our User Preferences project.

::: {.notes}
This module introduces the fundamental concepts of input and output in Python programming. We will explore the `input()` function for capturing user input and the `print()` function for displaying output to the console. The module also covers techniques for formatting output using the `print()` function to create well-organised and visually appealing text.

Throughout the module, we will engage in hands-on activities to reinforce the concepts covered in each section. By the end of this module, you will have a solid understanding of how to interact with users through input and output operations in Python, enabling you to create more interactive and dynamic programs.
:::

# The `input()` Function: Overview

- The `input()` function allows you to receive user input as text.
- It displays a prompt message, pauses the programme, and waits for the userâ€™s response.
- All input received is in the form of a string.
- Example:  
  ```python
  name = input("What is your name? ")
  ```

::: {.notes}
The `input()` function is a powerful tool in Python that enables developers to receive user input as text. When called, it displays a prompt message to the user, pauses the program execution, and waits for the user to enter a response. This function is particularly useful for creating interactive programs that require user participation.

It's important to note that all input received through the `input()` function is treated as a string, regardless of the type of data entered by the user. This means that if you require numerical input, you'll need to explicitly convert the received string to the appropriate data type, such as an integer or float, using functions like `int()` or `float()`. The slide also mentions that an example will be provided to demonstrate the usage of the `input()` function.
:::

# Capturing and Storing User Input

- Storing input in a variable lets you re-use the information.
- You can prompt the user with clear, concise messages.
- Consider the following example:  
  ```python
  favourite_colour = input("What is your favourite colour? ")
  ```
- This information will later be used to personalise outputs in our project.

::: {.notes}
Storing user input in a variable allows for reusability and flexibility in your program. By assigning the captured input to a variable, you can access and manipulate that information at any point in your code. This enables you to personalise outputs, perform calculations, or make decisions based on the user's input. It's important to provide clear and concise prompts to guide the user and ensure they understand what information is expected from them.

Let's consider an example where we prompt the user to enter their name and store it in a variable called `name`. We can then use that variable to display a personalised greeting, such as "Hello, [name]! Welcome to our program." This demonstrates how capturing and storing user input can enhance the interactivity and customisation of your program. Throughout our project, we will leverage this technique to create a more engaging and tailored experience for the user.
:::

# The `print()` Function: Displaying Output

- The `print()` function outputs information to the screen.
- It can display strings, variables, and results of operations.
- Example:  
  ```python
  print("Hello, " + name + "!")
  ```
- This helps to create personalised messages for the user.

::: {.notes}
The `print()` function is a fundamental tool in Python for displaying output to the user. It can handle a variety of data types, including strings, variables, and the results of operations, making it a versatile and essential part of any Python program. By using `print()`, developers can provide clear and informative messages to guide users through their applications.

One of the key benefits of the `print()` function is its ability to create personalised messages for the user. By incorporating variables and other dynamic content into the output, programs can generate tailored responses based on user input or other factors. This helps to make the user experience more engaging and interactive, encouraging users to continue interacting with the application.
:::

# Formatting Output with `print()`

- You can combine text and variables using:
  - String concatenation.
  - Comma-separated items (which adds spaces automatically).
- Example using commas:  
  ```python
  print("Hello,", name)
  ```
- These methods allow you to format your output neatly and clearly.

::: {.notes}
You can combine text and variables in `print()` statements using string concatenation or comma-separated items. String concatenation involves joining strings and variables using the `+` operator, while using commas automatically adds spaces between the items. For example, `print("Hello,", name)` would display "Hello, [name]" with a space after the comma.

Formatting your output with `print()` allows you to present information clearly and neatly. By combining text and variables effectively, you can create meaningful and readable output messages. This is particularly useful when displaying user-provided input, results from calculations, or any other dynamic content in your program.
:::

# Hands-On Activity: Basic Input and Output

**Task:** Create a simple programme that:
- Asks the user for their name.
- Asks for their favourite colour.
- Displays a personalised message that incorporates both inputs.

**Instructions:**
1. Use `input()` to capture the user's name and favourite colour.
2. Store the responses in variables.
3. Use `print()` to output a message, for example:  
   > "Hi [name], it's great to know your favourite colour is [colour]!"

::: {.notes}
This hands-on activity reinforces the concepts of basic input and output in Python. The activity involves asking the user for their name and favourite colour using the `input()` function, and then storing those values in variables.

The activity then demonstrates how to use the `print()` function to display a personalised message that incorporates both the user's name and favourite colour. This serves as a practical example of how to combine user input with output formatting to create a custom, interactive experience.
:::

# Additional Considerations

- Remember that every input is received as a string.  
- Think about how you might use this information in your User Preferences project.
- In future modules, we will explore converting input into other types and further refining output formatting.

::: {.notes}
When capturing user input with the `input()` function, it's important to remember that the entered data is always received as a string, regardless of whether the user enters text, numbers, or other characters. This means that if you require the input to be used as a different data type, such as an integer or float, you will need to explicitly convert it using functions like `int()` or `float()`.

In the upcoming User Preferences project, you may find yourself needing to store and manipulate user-entered data. By keeping in mind that input is received as strings, you can plan accordingly and incorporate the necessary type conversions to ensure your program processes the data correctly. As we progress through future modules, we will explore techniques for converting input into other data types and learn how to further customize the formatting of output using the `print()` function.
:::

# Summary

- You have learned how to capture user input using `input()` and display information with `print()`.
- These functions form the basis of interactive programmes.
- Apply these skills in your User Preferences project to create engaging, personalised user experiences.

::: {.notes}
In this slide, we summarise the key takeaways from the module on capturing user input with `input()` and displaying information using `print()`. These functions are fundamental building blocks for creating interactive programmes that engage users and provide personalised experiences. By mastering these skills, you'll be well-equipped to gather valuable data from users and present meaningful output.

As you work on your User Preferences project, apply the techniques covered in this module to craft programmes that dynamically respond to user input. Experiment with different prompts and formatting options to make your output more visually appealing and informative. Remember, effective communication between your programme and the user is crucial for creating successful applications that meet user needs and expectations.
:::

---
title: "Module 1: Understanding Data, Values, and Data Types"
subtitle: "Data Demystified: Unlocking the Building Blocks of Your Digital World"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Module Overview

In this module we will:
- Define what data is.
- Explore basic data types in Python.
- Understand how variables store data.
- Connect these ideas to our User Preferences project.

::: {.notes}
This slide provides an overview of the module, outlining the key topics that will be covered. We'll start by defining what data is and exploring some real-life examples to help contextualise the concept. Then, we'll dive into the basic data types in Python, such as integers, floats, strings, and booleans, and see how they're used in practice.

Next, we'll learn about variables and how they store data in Python programs. We'll discuss naming conventions, assignment, and reassignment of values. Finally, we'll connect these ideas to our User Preferences project, demonstrating how the concepts covered in this module are applied in a practical setting. Throughout the module, there will be hands-on activities to reinforce your understanding of the material.
:::

# What is Data?

- Data is information that is stored and processed by a computer.
- It can be numerical, textual, or a combination of both.
- In programming, data is the foundation on which our programmes operate.

::: {.notes}
Data is the foundation of all computer programs. It encompasses numerical values, text, or a combination of both, providing the raw material that software manipulates and processes. Without data, programs would have nothing to operate on, making it a crucial component in the field of programming.

In the context of Python programming, data is categorised into various types, each with its own characteristics and uses. These basic data types include integers for whole numbers, floats for decimal values, strings for textual information, and booleans for true/false values. Understanding these data types and how to work with them effectively is essential for writing functional and efficient Python code.
:::

# Real-Life Examples of Data

- Consider a student's details: name, age, and favourite colour.
- Everyday examples include shopping lists or contact records.
- In our User Preferences project, data represents the choices made by users.

::: {.notes}
This slide illustrates real-life examples of data to help students grasp the concept more tangibly. A student's details, such as their name, age, and favourite colour, serve as a relatable example. Similarly, everyday instances like shopping lists or contact records demonstrate how data is used in our daily lives.

In the context of our User Preferences project, data represents the choices made by users. This practical application highlights the relevance of data in real-world scenarios and reinforces the importance of understanding data for the students' future projects and endeavours.
:::

# Basic Data Types in Python

Python supports several basic data types:
- **Integers:** Whole numbers (e.g., 5, -3)
- **Floats:** Decimal numbers (e.g., 3.14, -0.001)
- **Strings:** Text (e.g., "hello", "favourite")
- **Booleans:** True or False values

::: {.notes}
In Python, there are four fundamental data types: integers, floats, strings, and booleans. Integers are whole numbers, both positive and negative, such as 5 or -3. Floats, on the other hand, are decimal numbers like 3.14 or -0.001. Strings represent text and are enclosed in double quotes, for example, "hello" or "favourite".

Booleans are a special data type that can only have two values: True or False. They are used to represent the truth or falsity of a condition or statement in Python. It's crucial to understand these basic data types as they form the building blocks for more complex data structures and algorithms in Python programming.

Integers are use to 'count', floats are used to 'measure', strings are used to 'label' and booleans are used to 'choose'.
:::

# Data Types in Context

- A studentâ€™s age as an integer.
- A rating or score as a float.
- A userâ€™s name or favourite colour as a string.
- A confirmation (yes/no) as a Boolean.
- These examples are directly related to our User Preferences project.

::: {.notes}
In this slide, we explore how basic data types are applied in a real-world context, specifically within our User Preferences project. We see that an integer can be used to represent a student's age, while a float is suitable for storing a rating or score. When dealing with textual information, such as a user's name or favourite colour, we utilise strings. Lastly, Boolean values are employed to capture binary choices, like a yes/no confirmation.

These practical examples demonstrate the relevance and importance of selecting the appropriate data type for each piece of information we intend to work with. By understanding how to apply these data types in a meaningful way, we can ensure that our code is efficient, readable, and maintainable. As we progress through the User Preferences project, we will continue to encounter scenarios where choosing the correct data type is crucial for the success of our program.
:::

# Understanding Variables

- Variables are named containers that hold data.
- The value stored in a variable determines its data type.
- Variables allow us to refer to data by name, making our code clearer.
- They stand in for the data itself when performing operations.

::: {.notes}
Variables are named containers that store data, allowing us to refer to it by name and making our code more readable. The value held in a variable determines its data type, such as integers, floating-point numbers, or strings. By using variables, we can perform operations on the data without directly referencing the values themselves.

Variables play a crucial role in programming by providing a way to label and manipulate data effectively. They enable us to assign meaningful names to our data, making the code more self-explanatory and easier to understand. When we need to use or modify the data, we simply refer to the variable name instead of the actual value, which simplifies the coding process and reduces the likelihood of errors.
:::

# Hands-On Activity

**Task:**  
- Write a short Python programme to create and display variables.  
- For example:
  - `name = "Alice"`
  - `age = 25`
  - `favourite_colour = "blue"`
- Use `print()` to display each variable.
- Reflect on how the variable names clarify the type and purpose of the data.

::: {.notes}
In this hands-on activity, you will write a short Python programme to create and display variables. The example provided demonstrates how to assign values to variables with descriptive names such as 'name', 'age', and 'favourite_colour'. After assigning the values, you will use the print() function to display each variable.

As you work through this activity, reflect on how the variable names help clarify the type and purpose of the data they store. Well-chosen variable names make your code more readable and easier to understand, both for yourself and others who may work with your code in the future. This is an important practice to develop as you continue learning and writing Python programmes.
:::

---
title: "Module 4: Variables and Operations"
subtitle: "Storing and Manipulating Data in Python: Turning Data into Action"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Module 4: Variables and Operations

Welcome to Module 4. In this module, we learn how variables not only store data but also work with operations to manipulate that data. These skills are key to personalising our User Preferences project by performing calculations and customising outputs.

::: {.notes}
In this module, we will explore the fundamental concepts of variables and operations in programming. We will start by reviewing what variables are and how they are used to store and manipulate data. The assignment operator will be introduced, along with the concept of reassigning variables to new values. We will then dive into the basic arithmetic operations that can be performed on variables, such as addition, subtraction, multiplication, and division.

The order of precedence for these operations will be discussed, highlighting the importance of understanding how expressions are evaluated. We will look at examples using preference-related data to illustrate how variables and operations can be used in real-world scenarios. The module will include a hands-on activity to reinforce the concepts covered and provide an opportunity for practice. Finally, we will summarise the key points and reflect on the significance of variables and operations in programming.
:::

# Review of Variables

- Variables are named containers that hold data.
- They make it easier to reference and manipulate data in your code.
- A variableâ€™s type is determined by the data it holds (e.g., integer, float, string, Boolean).

::: {.notes}
Variables are named containers that store data within a program, making it easier to reference and manipulate information throughout the code. The type of data a variable holds determines its classification, such as integer, float, string, or Boolean.

Understanding variables is essential for writing efficient and organised code. By assigning meaningful names to variables, programmers can create more readable and maintainable programs, reducing the likelihood of errors and making it simpler to modify the code in the future.
:::

# The Assignment Operator

- The assignment operator (`=`) is used to store a value in a variable.
- Example:
  ```python
  name = "Alice"
  age = 30
  ```
- It assigns the value on the right to the variable on the left.

::: {.notes}
The assignment operator (`=`) is used to store a value in a variable. For example, if we write `x = 5`, the value 5 is assigned to the variable `x`. The assignment operator always assigns the value on the right side of the equals sign to the variable on the left side.

It's crucial to understand how the assignment operator works, as it forms the basis for storing and manipulating data in variables. Throughout this module, we'll explore how to assign values to variables, reassign those values, and perform basic arithmetic operations using the variables. Mastering the assignment operator is a fundamental step in learning to program effectively.
:::

# Reassigning Variables

- Variables can be updated or reassigned.
- Example:
  ```python
  age = 30
  age = age + 1  # Now, age becomes 31
  ```
- This flexibility lets us perform calculations and update data as needed.

::: {.notes}
Variables in programming can be reassigned to new values as needed, providing flexibility for performing calculations and updating data. The example code snippet on the slide demonstrates this concept by initially assigning a value to a variable, then reassigning it to a new value later in the code.

Reassigning variables allows programmers to work with changing data throughout the execution of a program. By updating variables with new values, complex calculations can be performed, user input can be incorporated, and the program can respond to changing conditions dynamically.
:::

# Basic Arithmetic Operations

- Python supports several arithmetic operators:
  - Addition (`+`)
  - Subtraction (`-`)
  - Multiplication (`*`)
  - Division (`/`)
  - Floor Division (`//`)
  - Modulus (`%`)
  - Exponentiation (`**`)
- These operations let you perform calculations using variables.

::: {.notes}
Python supports several arithmetic operators for performing calculations using variables. These include addition (`+`), subtraction (`-`), multiplication (`*`), division (`/`), floor division (`//`), modulus (`%`), and exponentiation (`**`). By utilising these operators, you can manipulate numeric values stored in variables to carry out mathematical operations within your Python code.

The slide "Basic Arithmetic Operations" is part of Module 4, which focuses on variables and operations. This module covers topics such as reviewing variables, the assignment operator, reassigning variables, order of precedence, and examples using preference-related data. The slide itself is followed by a hands-on activity to reinforce the concepts and a summary and reflection section to consolidate the learnings from the module.
:::

# Order of Precedence

- Python evaluates expressions in a specific order:
  1. Parentheses `()`
  2. Exponentiation `**`
  3. Multiplication, Division, Floor Division, Modulus (`*`, `/`, `//`, `%`)
  4. Addition and Subtraction (`+`, `-`)
- For example:
  ```python
  result = 2 + 3 * 4  # Evaluates as 2 + (3 * 4) = 14
  ```

::: {.notes}
Python evaluates expressions in a specific order, known as the order of precedence or operator precedence. This order determines which operations are performed first when an expression contains multiple operators. For example, multiplication and division have higher precedence than addition and subtraction, so they are evaluated first in an expression like "2 + 3 * 4". Understanding the order of precedence is crucial for writing correct and efficient Python code.

The order of precedence in Python follows the common mathematical conventions, with parentheses having the highest precedence, followed by exponentiation, multiplication and division, and finally addition and subtraction. When operators have the same precedence, they are evaluated from left to right. It's important to use parentheses to explicitly specify the desired order of evaluation when multiple operators are involved, as this can make the code more readable and prevent unintended results.
:::

# Examples Using Preference-Related Data

- Suppose you want to calculate the total cost of a selected item including tax:
  ```python
  base_price = 20
  tax_rate = 0.1
  total_cost = base_price + (base_price * tax_rate)
  print("Total cost is", total_cost)
  ```
- Such examples show how arithmetic operations help personalise data based on user preferences.

::: {.notes}
The slide titled "Examples Using Preference-Related Data" demonstrates how arithmetic operations can be used to personalise data based on user preferences. The example provided calculates the total cost of a selected item, including tax, which showcases how basic math can be applied to real-world scenarios in programming.

This slide is part of the larger module on "Variables and Operations", which covers essential concepts such as the assignment operator, reassigning variables, basic arithmetic operations, and order of precedence. By presenting practical examples like calculating total cost with tax, the slide helps learners understand the relevance and utility of these fundamental programming concepts in creating dynamic, user-centric applications.
:::

# Hands-On Activity

**Task:**  
- Write a simple programme that:
  1. Asks the user for their current age and their birth year.
  2. Uses arithmetic operations to calculate the expected age by subtracting the birth year from the current year.
  3. Displays a confirmation message with the calculated age.
- This exercise will reinforce using variables, the assignment operator, and basic arithmetic in a real-world context.

::: {.notes}
In this hands-on activity, students will write a simple programme that reinforces the use of variables, the assignment operator, and basic arithmetic operations. The exercise will provide a real-world context for students to apply these fundamental programming concepts.

The activity will challenge students to create a programme that demonstrates their understanding of the topics covered in the previous slides, such as declaring and reassigning variables, using the assignment operator, and performing arithmetic operations while considering the order of precedence rules. By completing this practical exercise, students will gain hands-on experience and solidify their knowledge of these essential programming concepts.
:::

# Summary and Reflection

- We reviewed how variables store data and how the assignment operator works.
- We explored basic arithmetic operators and their order of precedence.
- These concepts empower you to perform dynamic calculations in your User Preferences project.
- Reflect on how these operations can be applied to personalise data in future projects.
```

::: {.notes}
In this presentation, we reviewed the fundamental concepts of variables and operations in programming. We started by discussing how variables store data and how the assignment operator is used to assign values to variables. We also explored the concept of reassigning variables, which allows us to update the value stored in a variable throughout the program's execution.

Next, we delved into the world of basic arithmetic operations, including addition, subtraction, multiplication, and division. We examined the order of precedence, which determines the sequence in which operations are performed in an expression. To solidify these concepts, we looked at examples using preference-related data, demonstrating how these operations can be applied to personalise data in real-world scenarios. Finally, we engaged in a hands-on activity to put our newfound knowledge into practice and reflect on how these concepts can be applied to future projects.
:::

1. What is data in the context of programming, and why is it important?

Data, in programming, is information that is stored and processed by a computer. It can be numerical, textual, or a combination of both. Data forms the foundation upon which all programs operate; without data, programs would have nothing to manipulate or process. Understanding data is crucial because the effectiveness and functionality of your code depends on how well you handle and process data.

2. What are the four basic data types in Python? Can you provide examples of each?

Python has four fundamental data types:

Integers: Whole numbers, both positive and negative. (e.g., 5, -3, 0)
Floats: Decimal numbers. (e.g., 3.14, -0.001, 2.0)
Strings: Textual data, enclosed in quotation marks. (e.g., "hello", "Python", "favourite colour")
Booleans: Represent truth values, either True or False.
3. How are the basic data types applied in a real-world context, such as a User Preferences project?

Data types are used to accurately represent different types of information. For example:

A user's age would be represented as an integer.
A product rating could be a float.
A user's name or favourite hobby would be a string.
Whether a user agrees to terms and conditions would be a Boolean.
4. What are variables and what role do they play in programming?

Variables are named containers used to store data. They allow you to refer to data by a meaningful name, making your code more readable and easier to understand. The value stored in a variable determines its data type. Variables enable you to manipulate and perform operations on data without directly referencing the values themselves.

5. How does the value stored in a variable determine its data type?

Python is dynamically typed, meaning that the data type of a variable is determined by the value that is assigned to it. For instance, if you assign the value 5 to a variable, Python automatically infers that the variable is an integer. If you assign the value "hello", Python understands it as a string. The data type is associated with the value, not explicitly declared for the variable.

6. Why are meaningful variable names important in programming?

Meaningful variable names are crucial for code readability and maintainability. Descriptive names (e.g., user_age instead of a) clarify the purpose and type of data that a variable holds. This makes it easier for you and others to understand what the code is doing, reducing errors and simplifying future modifications or debugging.

7. Can you reassign the value of a variable? If so, how does this affect the variable's data type?

Yes, you can reassign the value of a variable in Python. When you reassign a variable with a value of a different data type, the variable's data type changes accordingly. For example:

my_variable = 10  # my_variable is an integer

my_variable = "Hello"  # my_variable is now a string

8. Give a practical example of writing a simple Python program to create and display variables.

# Assigning values to variables

name = "Alice"  # String

age = 25  # Integer

favourite_colour = "blue"  # String



# Displaying the variables

print(name)

print(age)

print(favourite_colour)

This program creates three variables: name, age, and favourite_colour, and assigns them string and integer values respectively. The print() function is then used to display the values of each variable. This demonstrates how variables store data and how descriptive names can clarify the purpose of the stored information.

NotebookLM can be inaccurate; please double-check its responses.FAQ: Understanding Data, Values, and Data Types in Python
1. What is data in the context of programming, and why is it important?

Data, in programming, is information that is stored and processed by a computer. It can be numerical, textual, or a combination of both. Data forms the foundation upon which all programs operate; without data, programs would have nothing to manipulate or process. Understanding data is crucial because the effectiveness and functionality of your code depends on how well you handle and process data.

2. What are the four basic data types in Python? Can you provide examples of each?

Python has four fundamental data types:

Integers: Whole numbers, both positive and negative. (e.g., 5, -3, 0)
Floats: Decimal numbers. (e.g., 3.14, -0.001, 2.0)
Strings: Textual data, enclosed in quotation marks. (e.g., "hello", "Python", "favourite colour")
Booleans: Represent truth values, either True or False.
3. How are the basic data types applied in a real-world context, such as a User Preferences project?

Data types are used to accurately represent different types of information. For example:

A user's age would be represented as an integer.
A product rating could be a float.
A user's name or favourite hobby would be a string.
Whether a user agrees to terms and conditions would be a Boolean.
4. What are variables and what role do they play in programming?

Variables are named containers used to store data. They allow you to refer to data by a meaningful name, making your code more readable and easier to understand. The value stored in a variable determines its data type. Variables enable you to manipulate and perform operations on data without directly referencing the values themselves.

5. How does the value stored in a variable determine its data type?

Python is dynamically typed, meaning that the data type of a variable is determined by the value that is assigned to it. For instance, if you assign the value 5 to a variable, Python automatically infers that the variable is an integer. If you assign the value "hello", Python understands it as a string. The data type is associated with the value, not explicitly declared for the variable.

6. Why are meaningful variable names important in programming?

Meaningful variable names are crucial for code readability and maintainability. Descriptive names (e.g., user_age instead of a) clarify the purpose and type of data that a variable holds. This makes it easier for you and others to understand what the code is doing, reducing errors and simplifying future modifications or debugging.

7. Can you reassign the value of a variable? If so, how does this affect the variable's data type?

Yes, you can reassign the value of a variable in Python. When you reassign a variable with a value of a different data type, the variable's data type changes accordingly. For example:

my_variable = 10  # my_variable is an integer

my_variable = "Hello"  # my_variable is now a string

8. Give a practical example of writing a simple Python program to create and display variables.

# Assigning values to variables

name = "Alice"  # String

age = 25  # Integer

favourite_colour = "blue"  # String



# Displaying the variables

print(name)

print(age)

print(favourite_colour)

This program creates three variables: name, age, and favourite_colour, and assigns them string and integer values respectively. The print() function is then used to display the values of each variable. This demonstrates how variables store data and how descriptive names can clarify the purpose of the stored information.

9. What is the purpose of the input() function in Python, and what data type does it return?

The input() function allows Python programs to receive text-based input from the user. It pauses the program's execution, displays a prompt message on the screen, and waits for the user to enter a response. Importantly, the input() function always returns the user's input as a string, regardless of whether the user enters numbers, text, or other characters. You might need to convert the string to another data type (like an integer or a float) if you want to perform mathematical operations or comparisons.

10. Why is it useful to store the result of the input() function in a variable?

Storing user input in a variable is useful because it allows you to reuse and manipulate the information provided by the user later in your program. For example, you can use the stored value to personalise messages, perform calculations, or make decisions based on the user's input. Without storing the input in a variable, you would have to ask the user for the same information again each time you needed it.

11. How does the print() function work, and what can it display?

The print() function is Python's way of displaying output to the user on the screen (usually the console). It can display various data types, including strings, numbers, variables, and the results of operations. You can also combine text and variables to create personalised messages or provide informative feedback to the user.

12. What are the different ways to combine text and variables when using the print() function, and what are the advantages of each?

There are two main methods to combine text and variables when using print(): string concatenation and comma-separated items.
String concatenation uses the + operator to join strings and variables together. It's flexible but can be less readable, especially with many elements. You also need to manually convert non-string variables to strings using str() before concatenating them.
Comma-separated items involve listing the items you want to print, separated by commas. print() automatically inserts a space between each item. This approach is often more readable and doesn't require explicit type conversions.

13. What is an example of a simple programme using input() and print()?

A simple programme using input() and print() could ask the user for their name and favourite colour and then display a personalised message:

name = input("What is your name? ")
colour = input("What is your favourite colour? ")
print("Hello,", name + "! Your favourite colour is", colour + ".")

14. What should you keep in mind when dealing with user input in Python, especially concerning data types?

It is crucial to remember that the input() function always returns the user's input as a string. Therefore, if you need to use the input as a number for calculations or comparisons, you must explicitly convert it to the appropriate data type (e.g., int() for integers or float() for floating-point numbers). Failing to do so can lead to errors or unexpected results. Always validate user input to ensure it meets your program's requirements before processing it.

15. How can the knowledge of input() and print() be applied in a User Preferences project?

In a User Preferences project, input() can be used to gather information about the user's preferences (e.g., favourite movie genre, preferred notification settings). This information can then be stored in variables and used to customise the application's behaviour or display personalised content. The print() function can be used to provide feedback to the user, display their preferences, or present tailored recommendations.

16. What will be covered in future modules that builds on the concepts of input() and print()?

Future modules will delve into more advanced techniques for manipulating and formatting output, including string formatting methods that provide greater control over the appearance of the printed text. We'll also explore how to convert input into different data types, handle potential errors during the conversion process, and validate user input to ensure data integrity. This will allow you to create more robust and user-friendly interactive programmes.


17. What is computational thinking, and why is it important in programming?

Computational thinking is a problem-solving approach that involves breaking down complex problems into smaller, more manageable parts. It includes recognising patterns, organising steps logically, and devising clear, step-by-step solutions. In programming, it's crucial because it helps to create efficient and effective algorithms, ensuring code is well-structured, easier to debug, and more maintainable. It's especially important in projects like the User Preferences project, guiding how you capture and process data.

18. How can I break down a complex problem into smaller, manageable tasks?

To break down a complex problem, start by identifying the major components or goals. Then, divide each component into smaller, more specific tasks. Tackle each task individually, focusing on solving one sub-problem at a time. For example, in a User Preferences programme, you might break it down into collecting user input, processing the data, and displaying a personalised output.

19. What is pseudocode, and how is it used in algorithm design?

Pseudocode is an informal way to plan your solution to a programming problem before writing actual code. It allows you to outline the logic and steps involved without being concerned about the specific syntax of a programming language. Using pseudocode helps you visualise the programme structure, identify potential issues, and refine your approach before you start coding in Python or another language.

20. What are the key steps in the Simplified Development Methodology, and how do they contribute to effective problem-solving?

The six-step Simplified Development Methodology is:

- Understand the problem: Restate it in your own words to ensure clarity.
- Identify the input and output: Determine what information the programme needs and what it should produce.
- Work the problem by hand: Solve a small example manually to understand the logic.
- Write the pseudocode: Outline the logical steps to solve the problem.
- Convert the pseudocode to Python: Translate the outline into working code.
- Test with a variety of data: Ensure the solution works in different scenarios.

These steps provide a structured approach to problem-solving, ensuring you fully understand the problem, plan your solution effectively, and thoroughly test your code.

21. How does the Simplified Development Methodology help with debugging?

By working through each step in the Simplified Development Methodology, especially creating pseudocode and testing thoroughly, potential errors are easier to identify and rectify. Pseudocode allows you to catch logical flaws early on before even writing code. Testing with diverse data helps reveal edge cases and input-related issues that might otherwise go unnoticed, thus simplifying the debugging process.

22. In the User Preferences project, what are some examples of inputs and outputs that I might consider?

In a User Preferences project, inputs could include the user's name, age, location, favourite colour, preferred type of content (e.g., movies, music, books), and communication preferences. The desired outputs could then be a personalised greeting, recommended content based on their preferences, a customized colour scheme for the application interface, or targeted notifications.

23. Why is it important to test a program with a variety of data?

Testing with a variety of data is essential to ensure that your program works correctly under different conditions and handles edge cases effectively. Different data types (e.g., numbers, text, special characters), ranges (e.g., very large or very small numbers), and combinations of inputs can expose potential bugs or vulnerabilities that might not be apparent with limited testing. Thorough testing helps to improve the reliability and robustness of your solution.

24. How does working through an example by hand help in algorithm design?

Working through a small example by hand allows you to fully understand the logic and steps required to solve the problem. By manually performing the calculations or operations, you can gain a deeper insight into the problem's dynamics and identify any hidden complexities or edge cases. This understanding then informs the creation of accurate and efficient pseudocode, which can be readily translated into a working program.


25. What is a variable in Python, and why are they important?

Variables are named storage locations in a computer's memory that hold data. They are crucial because they allow us to store, reference, and manipulate data within a program. Using variables makes code more readable, maintainable, and reusable, as it provides a way to refer to data using meaningful names instead of directly using the data itself. The data in these variables determine their type, such as integers, floats, strings or Boolean values.

26. How does the assignment operator work in Python?

The assignment operator, represented by the equals sign (=), is used to assign a value to a variable. The expression on the right-hand side of the operator is evaluated, and the resulting value is then stored in the variable on the left-hand side. For example, x = 5 assigns the integer value 5 to the variable x. The assignment operator is fundamental for storing and manipulating data within variables.

27. Can a variable's value be changed after it is initially assigned? If so, how?

Yes, variables in Python can be reassigned to new values after their initial assignment. This is done by using the assignment operator (=) again with the same variable name and a new value. For instance, if we initially have age = 25, we can later reassign the variable with age = 30. This flexibility allows for dynamic calculations and updates as needed throughout the program's execution.

28. What are the basic arithmetic operators available in Python, and what do they do?

Python provides a range of arithmetic operators for performing mathematical calculations:
    + (Addition): Adds two values together.
    - (Subtraction): Subtracts the second value from the first.
    * (Multiplication): Multiplies two values.
    / (Division): Divides the first value by the second, resulting in a floating-point number.
    // (Floor Division): Divides the first value by the second, resulting in the largest possible integer.
    % (Modulus): Returns the remainder of the division of the first value by the second.
    ** (Exponentiation): Raises the first value to the power of the second.

These operators allow you to manipulate numerical data stored in variables and perform various calculations.

29. What is meant by "order of precedence" in arithmetic operations, and why is it important?

The "order of precedence" refers to the rules that determine the order in which operations are performed in an expression containing multiple operators. Python follows a specific order:

- Parentheses ()
- Exponentiation **
- Multiplication, Division, Floor Division, Modulus (*, /, //, %)
- Addition and Subtraction (+, -)

Understanding the order of precedence is vital because it ensures that expressions are evaluated correctly and produce the expected results. Using parentheses can override the default order and explicitly define the desired calculation sequence.

30. How can variables and arithmetic operations be used in the context of personalising user preferences?

Variables and arithmetic operations are fundamental to personalising user preferences in software applications. For instance, you can store a user's age, preferred discount rate, or selected item price in variables. Then, using arithmetic operations, you can calculate discounts, total costs, or personalised recommendations based on these preferences. For example, calculate the total cost of an item including tax: total_cost = item_price * (1 + tax_rate).

31. Describe an example scenario that combines variables, arithmetic operations, and user input.

Consider a programme that calculates a user's expected age. The programme first prompts the user to enter their current age and birth year, storing these values in variables called current_age and birth_year, respectively. Then, it calculates the expected age by subtracting the birth_year from the current year: expected_age = current_year - birth_year. Finally, it displays a message confirming the calculated age. This demonstrates the combined use of variables, arithmetic operations, and user input to provide a personalised output.

32. How does reassigning variables empower more complex programmes?

Reassigning variables allows programmers to work with changing data throughout the execution of a program. By updating variables with new values, complex calculations can be performed, user input can be incorporated, and the program can respond to changing conditions dynamically.
NotebookLM can be inaccurate; please double-check its responses.---
title: "STAFF ANSWER GUIDE: Activity 1: Personalised Greeting & User Preferences"
subtitle: "From Input to Impact: Crafting Personalised Greetings in Python"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Staff Answer Guide for Activity 1

## Overview

This guide provides a sample solution and explanations for Activity 1: Personalized Greeting & User Preferences. The goal of this activity is to reinforce:
- How to collect user input with `input()`.
- Storing responses in variables.
- Producing personalised output using `print()`.

This resource is intended to assist tutors in guiding students through the exercise and addressing common pitfalls.

## Sample Solution

Below is a sample solution that demonstrates two acceptable approaches to constructing the output message.

```python
# Step 1: Collect user input and store responses in variables
name = input("What is your name? ")
favourite_colour = input("What is your favourite colour? ")
favourite_food = input("What is your favourite food? ")

# Step 2: Construct a personalised greeting using string concatenation
greeting = "Hello, " + name + "! Your favourite colour is " + favourite_colour + " and you love " + favourite_food + "."
print(greeting)

# Alternatively, using comma-separated arguments in print() for automatic spacing:
print("Hello,", name + "!", "Your favourite colour is", favourite_colour + ",", "and you love", favourite_food + ".")
```

## Explanation of the Code

- **Collecting Input:**  
  - The `input()` function prompts the user and returns their response as a string.
  - Each response is stored in a variable (`name`, `favourite_colour`, and `favourite_food`), which can be reused later in the programme.

- **Constructing the Output Message:**  
  There are two common methods shown:
  
  1. **String Concatenation using the `+` Operator:**  
     - Combines literal strings with variables.
     - Example: `"Hello, " + name + "!"`  
     - Tutors should remind students to manage spaces and punctuation carefully.
  
  2. **Using Comma-Separated Arguments in `print()`:**  
     - Multiple items passed to `print()` are automatically separated by a space.
     - Example: `print("Hello,", name + "!")`  
     - This method simplifies formatting by reducing the need to explicitly include spaces.

- **Output:**  
  - Both methods produce a personalised message that incorporates the user's inputs.
  - Encourage students to test with various inputs to ensure their programme works as intended.

## Tutor Tips

- **Common Pitfalls:**  
  - Students might forget that `input()` always returns a string, even if the user enters numbers.
  - Managing spaces correctly when using the `+` operator can be challenging. Encourage them to compare the two methods.
  
- **Discussion Points:**  
  - Ask students why it is useful to store user input in variables.
  - Discuss the readability benefits of each method and when one might be preferred over the other.
  
- **Further Exploration:**  
  - Once students are comfortable, mention that f-strings provide an even cleaner way to format output and will be introduced later.
  - Invite students to extend the programme by adding another preference (e.g., favourite hobby) to further personalise their greeting.
---
title: "STAFF ANSWER GUIDE: Activity 3: User Preferences with Simplified Methodology"
subtitle: "From Blueprint to Code: Building Your User Preferences Programme Step by Step"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Staff Answer Guide: Activity 3 â€“ User Preferences with Simplified Methodology

## Overview

This guide provides a sample solution and detailed explanations for Activity 3. In this activity, students are guided through a structured problem-solving methodology to design and implement a User Preferences programme. Key steps include:

1. **State the Problem**
2. **Describe Input and Output**
3. **Work the Problem by Hand**
4. **Develop an Algorithm (Pseudocode)**
5. **Write the Code**
6. **Tackle Mini-Challenges**

In addition, students are encouraged to use AI tools to clarify their thought process and verify their workâ€”while ensuring that all AI suggestions stay within the course scope (i.e., using only input(), print(), basic data types, and variables).



## Detailed Breakdown

### Step 1 â€“ State the Problem

- **Student Task:**  
  Define the goal: build a programme that collects user preferences and displays them in a personalised summary.

- **Staff Explanation:**  
  Students should identify what information to gather (e.g., name, favourite colour, favourite food, and hobby) and decide how to present it. 

- **AI Usage Tip:**  
  Encourage students to ask an AI tool to rephrase their description. For example:  
  > "Can you restate my description of a user preferences programme to ensure I have captured the intent correctly?"  
  Remind them to verify that the AIâ€™s response aligns with the topics covered so far.



### Step 2 â€“ Describe Input and Output

- **Student Task:**  
  List the inputs (name, favourite colour, favourite food, favourite hobby) and define the expected output (e.g., a summary message).

- **Staff Explanation:**  
  Mapping the inputs to a clear output helps structure the programme. The expected output might be:  
  > "Hello, [name]! Your favourite colour is [colour], you love [food], and you enjoy [hobby]."

- **AI Usage Tip:**  
  Students can ask, "What are some creative ways to format a user preferences summary?" but must ensure the suggestions only use basic concepts.



### Step 3 â€“ Work the Problem by Hand

- **Student Task:**  
  Use sample inputs (e.g., name = "Alice", favourite colour = "Blue", favourite food = "Pasta", favourite hobby = "Reading") to manually determine the expected output.

- **Staff Explanation:**  
  This step validates the studentâ€™s understanding. The manually written output should match what the code will generate.

- **AI Usage Tip:**  
  If unsure, students may ask, "Does this output message clearly reflect the provided inputs?" ensuring the feedback adheres to current learning.



### Step 4 â€“ Develop an Algorithm (Pseudocode)

- **Student Task:**  
  Write pseudocode outlining the logical steps. An example might be:

  ```plain
  1. Start the programme.
  2. Prompt the user for their name and store the input.
  3. Prompt for favourite colour and store the input.
  4. Prompt for favourite food and store the input.
  5. Prompt for favourite hobby and store the input.
  6. Construct a summary message using the inputs.
  7. Print the summary message.
  8. End the programme.
  ```

- **Staff Explanation:**  
  Pseudocode helps bridge the planning phase with the coding phase. It doesnâ€™t need to follow Python syntax.

- **AI Usage Tip:**  
  Students can ask an AI tool, "Can you review my pseudocode and suggest improvements?" Remind them to keep suggestions within the basics they have learned.



### Step 5 â€“ Write the Code

- **Student Task:**  
  Translate the pseudocode into a Python script. A sample solution might be:

  ```python
  # Collect user input for various preferences
  name = input("What is your name? ")
  favourite_colour = input("What's your favourite colour? ")
  favourite_food = input("What's your favourite food? ")
  favourite_hobby = input("What's your favourite hobby? ")

  # Construct and display a personalised summary message
  print("\nHello, " + name + "!")
  print("Your favourite colour is " + favourite_colour + 
        ", you love " + favourite_food + 
        ", and you enjoy " + favourite_hobby + ".")
  ```

- **Staff Explanation:**  
  This code uses string concatenation and demonstrates the basic usage of input() and print() functions. Emphasize that this solution should not include advanced topics like functions, f-strings, or exception handling yet.

- **AI Usage Tip:**  
  In case of errors or confusion, students should ask follow-up questions like, "How can I improve this code using only input(), print(), and variables?" This ensures that AI feedback remains aligned with current topics.



### Mini-Challenges

The worksheet includes optional mini-challenges to encourage creative problem-solving:

1. **Starred Preferences:**  
   Print each preference on a separate line with a star at the beginning.

   ```python
   print("* Name:", name)
   print("* Favourite Colour:", favourite_colour)
   print("* Favourite Food:", favourite_food)
   print("* Favourite Hobby:", favourite_hobby)
   ```

2. **Age Calculator Challenge:**  
   Ask for the birth year, calculate the age, and print it.  
   *Note:* This may introduce the concept of basic arithmetic and importing modules, so students should verify with an AI tool if uncertain.
   
   ```python
   import datetime
   birth_year = int(input("What year were you born? "))
   current_year = datetime.datetime.now().year
   age = current_year - birth_year
   print("You are", age, "years old!")
   ```

3. **(Optional Advanced) F-String Formatting:**  
   Refactor the summary message using f-strings for cleaner syntax.  
   *Note:* This challenge is optional and should only be attempted if the student is comfortable with the material.
   
   ```python
   print(f"Hello, {name}! Your favourite colour is {favourite_colour}, you love {favourite_food}, and you enjoy {favourite_hobby}.")
   ```

- **Staff Explanation:**  
  These challenges reinforce the core concepts and gently introduce new ideas. Tutors should stress that students must use only what they've learned so far unless they explicitly choose to explore the advanced option.  

- **AI Usage Tip:**  
  Remind students to ask, "Can you explain how to complete this mini-challenge using only the topics we've covered?" if they receive suggestions that include more advanced content.



## Testing and Reflection

- **Testing:**  
  Students should test their programmes with various input scenarios. For example, when inputting "Alice" for the name, "blue" for the favourite colour, and so on, the output should match the expected result.

- **Reflection Questions:**  
  - How did planning (pseudocode) assist in coding the solution?
  - Which mini-challenge did you find most useful or interesting?
  - How did using AI tools enhance your understanding?  
    (Encourage them to verify and ask follow-up questions if any AI response uses concepts beyond input(), print(), and basic variables.)

- **Staff Explanation:**  
  Discuss the importance of systematic planning and how AI tools can be used to clarify and refine ideasâ€”provided the student critically evaluates the output against what theyâ€™ve learned.



## Tutor Tips

- **Planning Emphasis:**  
  Encourage students to invest time in planning and pseudocoding before coding.

- **Comparative Discussion:**  
  Ask students to share both their pseudocode and final solutions. Compare the structured approach to earlier, less formal methods (like Activity 2).

- **Critical Evaluation of AI Outputs:**  
  Remind students that if any AI suggestion includes advanced topics (e.g., user-defined functions, exceptions, f-strings), they should ask follow-up questions to have the explanation tailored to the current level of learning.

- **Encourage Experimentation:**  
  Support creative extensions and mini-challenges as long as the core solution remains aligned with the course content.



## Conclusion

This staff guide is designed to help tutors support students through Activity 3. The guide includes a sample pseudocode, a basic Python solution, and mini-challengesâ€”all supplemented with AI usage tips. These tips aim to encourage students to ask follow-up questions and critically evaluate AI outputs, ensuring that their solutions use only the concepts taught so far.

Happy tutoring!
---
title: "STAFF ANSWER GUIDE: User Preferences Survey Project"
subtitle: "Applying Industry Best Practices in a Real-World Environment"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Staff Answer Guide: User Preferences Survey Project

## Overview

This project collates several exercises from the weekâ€™s activities and requires students to build a simple User Preferences Survey using Python. The purpose is to practice fundamental concepts (variables, data types, input(), print(), and basic operations) while adhering to industry best practices. These best practices include using descriptive names, proper documentation, version control, and careful use of AI for guidance.

This guide provides sample answers and discussion points for tutors.



## Step 1 â€“ State the Problem

**Expected Student Response:**  
Students should clearly articulate that the goal of the programme is to collect a user's preferences (such as name, favourite colour, favourite food, and favourite hobby) and then display a personalized summary message.

*Example Answer:*  
> "The programme is designed to ask the user for their name, favourite colour, favourite food, and favourite hobby. It will then use this data to generate a personalized greeting, such as 'Hello, Alice! Your favourite colour is blue, you love pizza, and you enjoy reading.'"

**Discussion Points:**  
- Verify that students have captured both the input data and the expected output.
- Emphasise that the problem statement must be clear and concise.

**AI Tip for Students:**  
Students are encouraged to ask an AI tool to rephrase their description. Tutors can suggest:  
> "Can you restate my description of a User Preferences Survey program using only input(), print(), and variables?"  
Ensure the AIâ€™s response is in line with the basic concepts taught so far.



## Step 2 â€“ Describe Input and Output

**Expected Student Response:**  
Students should list the inputs and clearly describe the expected output.

*Inputs:*  
- `user_name` (string)
- `fav_colour` (string)
- `fav_food` (string)
- `fav_hobby` (string)

*Expected Output:*  
A summary message formatted as:  
> "Hello, [user_name]! Your favourite colour is [fav_colour], you love [fav_food], and you enjoy [fav_hobby]."

**Discussion Points:**  
- Ensure that students understand the mapping between the inputs and the output.
- Discuss why a clear specification of inputs and outputs is important for planning.

**AI Tip for Students:**  
Ask an AI tool for creative formatting ideas, ensuring that suggestions remain within the basic techniques of input(), print(), and string concatenation.



## Step 3 â€“ Work the Problem by Hand

**Expected Student Response:**  
Students should simulate the programme by writing sample inputs and manually determining the expected output.

*Sample Simulation:*  
- **Inputs:**  
  - `user_name`: "Alice"  
  - `fav_colour`: "blue"  
  - `fav_food`: "pizza"  
  - `fav_hobby`: "reading"
- **Expected Output:**  
  > "Hello, Alice! Your favourite colour is blue, you love pizza, and you enjoy reading."

**Discussion Points:**  
- Highlight that working the problem by hand helps to verify understanding before coding.
- Encourage students to try multiple scenarios.

**AI Tip for Students:**  
If uncertain, ask:  
> "Does this output message clearly reflect the provided inputs?"  
Review the AI feedback to ensure consistency.



## Step 4 â€“ Develop an Algorithm (Pseudocode)

**Expected Student Response:**  
Students should produce pseudocode that outlines the logical steps of the programme. The pseudocode does not need to be written in Python syntax.

*Sample Pseudocode:*
```plain
1. Start the program.
2. Prompt the user for their name and store it in user_name.
3. Prompt the user for their favourite colour and store it in fav_colour.
4. Prompt the user for their favourite food and store it in fav_food.
5. Prompt the user for their favourite hobby and store it in fav_hobby.
6. Create a summary message using the stored inputs.
7. Print the summary message.
8. End the program.
```

**Discussion Points:**  
- Emphasize that pseudocode helps bridge planning and coding.
- Ask students to compare their pseudocode with a sample solution.

**AI Tip for Students:**  
Students can ask an AI tool:  
> "Can you review my pseudocode for a User Preferences Survey program and suggest improvements?"  
Ensure that the suggestions stay within the basic concepts taught.



## Step 5 â€“ Write the Code

**Expected Student Response:**  
Students will translate their pseudocode into Python code using basic operations, input(), and print().

*Sample Python Code:*
```python
# Collect user input for preferences
user_name = input("What is your name? ")
fav_colour = input("What's your favourite colour? ")
fav_food = input("What's your favourite food? ")
fav_hobby = input("What's your favourite hobby? ")

# Construct the personalized summary message
summary = "Hello, " + user_name + "! Your favourite colour is " + fav_colour + \
          ", you love " + fav_food + ", and you enjoy " + fav_hobby + "."

# Display the summary message
print(summary)
```

**Discussion Points:**  
- Point out the importance of descriptive variable names.
- Discuss how comments and clear structure improve code readability.
- Verify that the solution uses only the concepts covered so far (no advanced topics).

**AI Tip for Students:**  
If any confusion arises, students can ask:  
> "Can you review my Python code for a User Preferences Survey and suggest improvements using only input(), print(), and basic variables?"  
This ensures that the solution remains aligned with course content.



## Reflection on Industry Best Practices

**Expected Reflection Points:**
- **Descriptive Names & Comments:**  
  How did using meaningful variable names and inline comments improve the clarity of the code?
- **Version Control:**  
  Emphasize the importance of frequent saves and using descriptive commit messages on GitHub.
- **Documentation:**  
  Reflect on how documenting the thought process in text cells helped understand and refine the solution.
- **Collation of Exercises:**  
  Note that this project collates several weekly activities. This approach is intentional and allows for reflection on whether students are improving in following industry best practices.

**Discussion Points:**  
- Discuss with students how this structured approach compares with more ad-hoc methods.
- Encourage them to critically evaluate any AI output they received and verify that it uses only the core topics covered so far.

**AI Tip for Students:**  
Ask an AI tool, "Can you suggest improvements to my project documentation and commit message examples based on industry best practices?" Ensure that any advice given adheres to the basic concepts learned.



## Final Reflection and Next Steps

**Expected Student Reflections:**
- How did following a structured methodology help in organizing the solution?
- Which aspects of industry best practices were most challenging to implement, and how can they be improved?
- How did the process of collating exercises help in understanding the overall project?

**Next Steps:**
- Experiment with adding new inputs or modifying the output format.
- Save your work frequently and use descriptive commit messages when uploading to GitHub.
- Share your completed project with peers and discuss possible improvements.

**Discussion Points for Tutors:**
- Encourage students to continue refining their code and documentation.
- Remind them that the best practices followed here are examples from the industryâ€”useful habits to emulate as they grow in their careers.



## Tutor Tips

- **Encourage Reflection:**  
  Ask students to share what they learned about the importance of planning and documentation.
- **Emphasize Best Practices:**  
  Highlight the benefits of using descriptive names, version control, and proper commenting.
- **Foster Critical Use of AI:**  
  Remind students that AI is a tool to aid learning, but they should always verify that its suggestions are appropriate for their current level.



This staff answer guide is intended to provide a robust framework to support and evaluate student work on the User Preferences Survey Project. It emphasizes both the technical aspects and the industry best practices that are crucial for a successful software development career.

Happy tutoring!
---
title: "STAFF ANSWER GUIDE: Activity 2: Ad-Hoc User Preferences Survey"
subtitle: "Explore and Experiment: Crafting Your Own User Preferences Survey"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Staff Answer Guide: Activity 2 â€“ Ad-Hoc User Preferences Survey

## Overview

This guide provides a sample solution and explanations for Activity 2. The goal is to create a Python script that gathers user preferences in an ad-hoc manner and then displays them. The exercise encourages experimentation with basic input/output functions in Python. In addition, mini-challenges are included to foster creative problem-solving and to hint at upcoming concepts such as basic calculations and alternative output formatting.

## Sample Solution

Below is one example of how a student might implement the activity. Note that there is no single correct solutionâ€”students are encouraged to be creative.

### Main Survey Implementation

```python
# Collect user input for various preferences
name = input("What is your name? ")
favourite_colour = input("What's your favourite colour? ")
favourite_food = input("What's your favourite food? ")
favourite_hobby = input("What's your favourite hobby? ")

# Option 1: Using string concatenation
print("Hello, " + name + "! Your favourite colour is " + favourite_colour +
      ", you love " + favourite_food + ", and you enjoy " + favourite_hobby + ".")

# Option 2: Using comma-separated arguments for automatic spacing
print("Hello,", name + "!", "Your favourite colour is", favourite_colour + ",",
      "you love", favourite_food + ", and you enjoy", favourite_hobby + ".")
```

## Mini-Challenges

These mini-challenges are designed to stimulate further creativity and introduce additional concepts:

### Challenge 1: Starred Preferences
Print each preference on a separate line with a star (`*`) at the beginning of each line.

```python
print("* Name:", name)
print("* Favourite Colour:", favourite_colour)
print("* Favourite Food:", favourite_food)
print("* Favourite Hobby:", favourite_hobby)
```

### Challenge 2: Age Calculator
Ask the user for their birth year and calculate how old they will be this year.  
*Hint: You may use the `datetime` module to get the current year.*

```python
import datetime

birth_year = int(input("What year were you born? "))
current_year = datetime.datetime.now().year
age = current_year - birth_year
print("You are", age, "years old!")
```

### Challenge 3 (Optional Advanced): F-String Formatting
Refactor the summary message to use Python's f-string formatting instead of string concatenation. (This is an optional advanced challenge intended for students who wish to explore newer formatting methods.)

```python
print(f"Hello, {name}! Your favourite colour is {favourite_colour}, you love {favourite_food}, and you enjoy {favourite_hobby}.")
```

## Explanation of the Code

- **Collecting Input:**  
  - The `input()` function is used to prompt the user for information.
  - Each response is stored in its own variable (e.g., `name`, `favourite_colour`) for later use.

- **Constructing the Output Message:**  
  - **Option 1 (String Concatenation):**  
    Combines strings using the `+` operator. Note that extra spaces and punctuation must be managed manually.
  - **Option 2 (Comma-Separated Arguments):**  
    When multiple arguments are passed to `print()`, Python automatically inserts spaces between them.

- **Mini-Challenges:**  
  - **Starred Preferences:**  
    This challenge reinforces printing multiple lines and adds a simple formatting twist.
  - **Age Calculator:**  
    Introduces the concept of using external modules (like `datetime`) and basic arithmetic operations to perform a calculation.
  - **F-String Formatting:**  
    Provides a glimpse into a modern way of formatting strings. This challenge is optional and can be attempted by more advanced students.

## Tutor Tips

- **Encourage Flexibility:**  
  Remind students that there are several ways to construct their output. The goal is to practice and understand basic input/output operations.
  
- **Address Common Issues:**  
  - Ensure students understand that the `input()` function always returns a string.
  - Clarify the differences between string concatenation and using commas in the `print()` function.
  
- **Mini-Challenges as Extensions:**  
  - Explain that the mini-challenges are optional but provide great opportunities to stretch their understanding.
  - For the f-string challenge, emphasize that itâ€™s an introduction to a topic that will be covered in more detail later.

- **Discussion Points:**  
  - Ask students what other preferences they might add.
  - Discuss the benefits of clear output formatting.
  - Encourage students to share creative modifications they made to the program.

## Extension Ideas

- **Additional Preferences:**  
  Invite students to add more questions (e.g., favourite movie, book, travel destination) to further personalize the output.
  
- **Refactoring:**  
  Once students are comfortable, challenge them to refactor their code for improved readability or to implement functions to reuse code.
---
title: "Unravelling Python Dictionaries: A Beginner's Guide"
subtitle: "Mastering the Art of Key-Value Storage"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# What is a Python Dictionary?

- A dictionary is a collection of key-value pairs
- Keys are unique identifiers used to access values
- Values can be any data type, including other collections
- Dictionaries are unordered, unlike lists or tuples

::: {.notes}
In Python, a dictionary is a powerful data structure that allows you to store and retrieve data using unique keys. Unlike lists or tuples, which are ordered collections, dictionaries are unordered. Each piece of information in a dictionary is stored as a key-value pair, where the key acts as a unique identifier to access the corresponding value.

The keys in a dictionary can be any immutable data type, such as strings, numbers, or tuples, while the values can be any valid Python object, including other collections like lists or even other dictionaries. This flexibility makes dictionaries incredibly versatile and useful for a wide range of applications, from storing configuration settings to building complex data models.
:::

# Creating a Dictionary

```python
# Create an empty dictionary
my_dict = {}

# Create a dictionary with initial key-value pairs
person = {
    "name": "Alex",
    "age": 30,
    "city": "Sydney"
}
```

::: {.notes}
To create a dictionary in Python, you can use curly braces `{}` to enclose the key-value pairs. Each pair is separated by a colon `:`, with the key on the left and the value on the right.

You can create an empty dictionary by simply using the curly braces, like `my_dict = {}`. This gives you a blank canvas to start building your dictionary.

Alternatively, you can create a dictionary with some initial key-value pairs, as shown in the `person` example. Here, we have three key-value pairs: "name" is associated with the string "Alex", "age" is associated with the integer 30, and "city" is associated with the string "Sydney".

The keys in a dictionary can be any immutable data type, such as strings, numbers, or tuples, while the values can be any valid Python object, including other collections like lists or even other dictionaries.
:::

# Accessing Dictionary Values

```python
person = {
    "name": "Alex",
    "age": 30,
    "city": "Sydney"
}

# Access values using keys
print(person["name"])  # Output: "Alex"
print(person["age"])   # Output: 30

# Use the get() method to handle missing keys
print(person.get("occupation", "Not found"))  # Output: "Not found"
```

::: {.notes}
To access the values stored in a dictionary, you can use the keys as indices, just like you would with a list or tuple. Simply place the key inside square brackets `[]` after the dictionary name.

In the example, we access the values associated with the keys "name" and "age" by using `person["name"]` and `person["age"]`, respectively. This will output the corresponding values: "Alex" and 30.

If you try to access a key that doesn't exist in the dictionary, you'll get a `KeyError`. To handle this, you can use the `get()` method, which allows you to provide a default value to return if the key is not found. In the example, we use `person.get("occupation", "Not found")` to retrieve the value for the "occupation" key, but since it doesn't exist, the method returns the default value "Not found".

Using the `get()` method is a safe way to access dictionary values, as it prevents your code from crashing if a key is missing.
:::

# Adding and Updating Entries

```python
person = {
    "name": "Alex",
    "age": 30,
    "city": "Sydney"
}

# Add a new key-value pair
person["occupation"] = "Software Engineer"

# Update an existing value
person["age"] = 31

print(person)
# Output: {'name': 'Alex', 'age': 31, 'city': 'Sydney', 'occupation': 'Software Engineer'}
```

::: {.notes}
Dictionaries are mutable, which means you can add new key-value pairs or update the values of existing keys.

To add a new key-value pair, simply assign a value to a new key. In the example, we add the key "occupation" and assign it the value "Software Engineer".

To update an existing value, you can assign a new value to the corresponding key. Here, we change the value of the "age" key from 30 to 31.

After making these changes, the `person` dictionary now contains four key-value pairs: "name" is associated with "Alex", "age" is associated with 31, "city" is associated with "Sydney", and "occupation" is associated with "Software Engineer".

Modifying dictionaries in this way is a common operation and allows you to keep your data up-to-date and relevant.
:::

# Removing Entries

```python
person = {
    "name": "Alex",
    "age": 30,
    "city": "Sydney"
}

# Remove a key-value pair
del person["age"]

# Use the pop() method to remove a key-value pair and get the value
occupation = person.pop("occupation", "Not found")
print(occupation)  # Output: "Not found"

print(person)
# Output: {'name': 'Alex', 'city': 'Sydney'}
```

::: {.notes}
Dictionaries also allow you to remove key-value pairs. There are a few ways to do this:

1. Using the `del` keyword: You can remove a specific key-value pair by using the `del` keyword followed by the dictionary name and the key you want to remove. In the example, we use `del person["age"]` to remove the "age" key-value pair.

2. Using the `pop()` method: The `pop()` method allows you to remove a key-value pair and get the value associated with that key. If the key doesn't exist, you can provide a default value to be returned. In the example, we use `person.pop("occupation", "Not found")` to remove the "occupation" key-value pair (if it exists) and store the value in the `occupation` variable. Since the key doesn't exist, the method returns the default value "Not found".

After removing the key-value pairs, the `person` dictionary now only contains the "name" and "city" keys.

Removing entries from a dictionary is useful when you need to clean up or update your data, especially if certain information is no longer relevant or needed.
:::

# Looping through a Dictionary

```python
person = {
    "name": "Alex",
    "age": 30,
    "city": "Sydney"
}

# Loop through keys
for key in person:
    print(key)
# Output:
# name
# age
# city

# Loop through key-value pairs
for key, value in person.items():
    print(f"{key}: {value}")
# Output:
# name: Alex
# age: 30
# city: Sydney
```

::: {.notes}
Dictionaries are very versatile, and you can loop through them in various ways to access their contents.

The most basic way is to loop through the keys using a `for` loop. In the example, we simply iterate over the `person` dictionary, and for each iteration, the `key` variable will be assigned the current key.

A more common and useful way to loop through a dictionary is to use the `items()` method, which returns a view object containing the key-value pairs. This allows you to access both the keys and the values in each iteration. In the example, we use `for key, value in person.items()` to unpack each key-value pair into the `key` and `value` variables, respectively.

Looping through a dictionary is a great way to perform operations on all the key-value pairs, such as printing them out, modifying the values, or performing some other logic based on the data.
:::

# Dictionary Methods

- `len(dict)`: Returns the number of key-value pairs in the dictionary
- `dict.keys()`: Returns a view object containing the keys
- `dict.values()`: Returns a view object containing the values
- `dict.items()`: Returns a view object containing the key-value pairs
- `dict.get(key, default)`: Returns the value for the given key, or the default value if the key is not found
- `dict.pop(key, default)`: Removes the key-value pair and returns the value, or the default value if the key is not found
- `dict.update(other_dict)`: Merges the key-value pairs from another dictionary into the current one

::: {.notes}
Dictionaries in Python come with a variety of built-in methods that allow you to perform common operations on them. Here are some of the most useful methods:

- `len(dict)`: Returns the number of key-value pairs in the dictionary.
- `dict.keys()`: Returns a view object containing all the keys in the dictionary.
- `dict.values()`: Returns a view object containing all the values in the dictionary.
- `dict.items()`: Returns a view object containing the key-value pairs as tuples.
- `dict.get(key, default)`: Returns the value associated with the given key, or the default value if the key is not found.
- `dict.pop(key, default)`: Removes the key-value pair with the given key and returns the value. If the key is not found, it returns the default value.
- `dict.update(other_dict)`: Merges the key-value pairs from another dictionary into the current one, overwriting any existing keys.

These methods provide a wide range of functionality for working with dictionaries, from getting information about the dictionary's contents to modifying and manipulating the data.
:::

# Nested Dictionaries

```python
person = {
    "name": "Alex",
    "age": 30,
    "address": {
        "street": "123 Main St",
        "city": "Sydney",
        "state": "NSW"
    }
}

# Access nested values
print(person["address"]["city"])  # Output: "Sydney"

# Update a nested value
person["address"]["state"] = "Victoria"

print(person)
# Output: {'name': 'Alex', 'age': 30, 'address': {'street': '123 Main St', 'city': 'Sydney', 'state': 'Victoria'}}
```

::: {.notes}
Dictionaries can also contain other dictionaries, creating a nested data structure. This is particularly useful when you need to model more complex data, such as information about a person that includes their address details.

In the example, the `person` dictionary has a key called "address" that is associated with another dictionary containing the street, city, and state information.

To access the nested values, you can chain the keys together, separating them with square brackets `[]`. In the example, we use `person["address"]["city"]` to get the value "Sydney" for the "city" key in the nested "address" dictionary.

Similarly, you can update the values of the nested dictionary by assigning new values to the corresponding keys. Here, we change the "state" value in the "address" dictionary from "NSW" to "Victoria".

Nested dictionaries allow you to build sophisticated data models that reflect the real-world relationships and hierarchies in your data.
:::

# Conclusion

- Dictionaries are unordered collections of key-value pairs
- Keys must be unique and can be any immutable data type
- Values can be any valid Python object, including other collections
- Dictionaries are versatile and can be used for a wide range of applications
- Key operations include creating, accessing, modifying, and removing entries
- Dictionaries can be nested to model complex data structures

::: {.notes}
In this presentation, we've covered the basics of Python dictionaries, a powerful data structure that allows you to store and retrieve data using unique keys.

We've learned that dictionaries are unordered collections of key-value pairs, where the keys must be unique and can be any immutable data type, while the values can be any valid Python object, including other collections like lists or even other dictionaries.

We've explored how to create dictionaries, access and modify their contents, remove entries, an---
title: "Mastering Dictionary Methods and Operations"
subtitle: "Unlocking the Power of Python's Versatile Data Structure"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to Dictionaries

- What are dictionaries in Python?
- Key-value pairs for storing and retrieving data
- Advantages over other data structures
- Common use cases for dictionaries

::: {.notes}
Dictionaries are a fundamental data structure in Python, allowing you to store and retrieve data using unique keys. Unlike lists, which store data in an ordered sequence, dictionaries are unordered collections of key-value pairs. This makes them incredibly versatile and efficient for a wide range of tasks, from data processing to program configuration.

Some of the key advantages of dictionaries include fast lookup times, the ability to associate data with meaningful labels, and the flexibility to store different data types within the same structure. Dictionaries are commonly used for tasks like tracking inventory, managing user preferences, and building recommendation systems.
:::

# Creating and Populating Dictionaries

- Initialising an empty dictionary
- Adding key-value pairs
- Using different data types as keys and values
- Example: Building a contact list

::: {.notes}
To create a new dictionary in Python, you can simply use curly braces `{}`. You can then add key-value pairs using the assignment operator `=`. The keys in a dictionary can be strings, numbers, or even other immutable data types like tuples. The values can be any valid Python object, including other dictionaries, lists, or even functions.

Let's look at an example of building a simple contact list using a dictionary. We'll create keys for people's names and store their phone numbers and email addresses as the corresponding values. This demonstrates how dictionaries allow you to associate multiple pieces of information with a single identifier.
:::

# Accessing and Retrieving Data

- Accessing values using keys
- Handling missing keys (KeyError)
- Using the `get()` method for safer access
- Retrieving all keys or values

::: {.notes}
Once you've created a dictionary, you can access the values stored within it by using the corresponding keys. Simply use square brackets `[]` and the key name to retrieve the associated value.

However, it's important to handle the case where a key doesn't exist in the dictionary, as this will raise a `KeyError`. To avoid this, you can use the `get()` method, which allows you to provide a default value to return if the key is not found.

Dictionaries also provide methods to retrieve all the keys or all the values as separate lists, which can be useful for various operations and data processing tasks.
:::

# Common Dictionary Operations

- Checking if a key exists
- Adding, modifying, and removing key-value pairs
- Iterating over keys, values, or key-value pairs
- Merging dictionaries using the `update()` method

::: {.notes}
In addition to accessing and retrieving data, dictionaries support a variety of common operations that make them a powerful tool in your Python programming arsenal.

You can use the `in` keyword to check if a particular key exists in a dictionary. To add, modify, or remove key-value pairs, you simply assign a new value to an existing key or use the `del` keyword to remove a key-value pair.

Dictionaries are also iterable, allowing you to loop over their keys, values, or key-value pairs. This makes them useful for tasks like processing data or generating reports.

Finally, you can use the `update()` method to merge two dictionaries, which can be handy when working with data from multiple sources.
:::

# Nested Dictionaries

- Storing dictionaries within dictionaries
- Accessing and manipulating nested data
- Use case: Representing hierarchical data

::: {.notes}
Dictionaries can also contain other dictionaries as values, creating a nested data structure. This allows you to represent more complex, hierarchical data, such as a database of employees with information about their departments, salaries, and contact details.

To access and manipulate data within a nested dictionary, you can use a combination of keys to drill down to the desired value. This can take some practice, but it's a powerful technique for working with structured data.

Nested dictionaries are particularly useful when you need to model real-world scenarios that have a hierarchical nature, such as organisational structures, product catalogues, or geographic data. By nesting dictionaries, you can maintain a logical and efficient representation of the data.
:::

# Dictionary Comprehensions

- Concise way to create new dictionaries
- Filtering, transforming, and combining data
- Example: Creating a dictionary of squares

::: {.notes}
Dictionary comprehensions provide a compact and expressive way to create new dictionaries from existing data. Similar to list comprehensions, dictionary comprehensions use a single line of code to generate key-value pairs based on some transformation or filtering logic.

This can be a powerful tool for tasks like data manipulation, feature engineering, or creating lookup tables. Let's look at an example of using a dictionary comprehension to create a dictionary of squares, where the keys are the numbers 1 through 10, and the values are the squares of those numbers.

Dictionary comprehensions help you write more concise and readable code, especially when working with larger or more complex data structures.
:::

# Best Practices and Tips

- Choosing appropriate data types for keys and values
- Handling missing keys and default values
- Iterating over dictionaries efficiently
- Optimising performance for large dictionaries

::: {.notes}
As you become more comfortable working with dictionaries, it's important to keep a few best practices and tips in mind:

First, be thoughtful about the data types you use for your keys and values. Strings, numbers, and tuples make good key choices, while you can store any valid Python object as a value.

When accessing dictionary values, always be prepared to handle missing keys to avoid `KeyError` exceptions. The `get()` method is a great way to provide default values in these cases.

Efficient iteration is also important, especially when working with large dictionaries. Looping over the `.keys()`, `.values()`, or `.items()` methods can help you traverse the dictionary in the most appropriate way for your use case.

Finally, for extremely large dictionaries, you may need to consider performance optimisations, such as using a specialized data structure like a `defaultdict` or `OrderedDict` from the `collections` module.

Following these best practices will help you write more robust, efficient, and maintainable code when working with dictionaries in Python.
:::

# Conclusion

- Key takeaways from the presentation
- Importance of dictionaries in Python programming
- Resources for further learning

::: {.notes}
In this presentation, we've explored the powerful capabilities of dictionaries in Python. We've learned that dictionaries are flexible, efficient data structures that allow you to store and retrieve data using unique keys.

Dictionaries offer many advantages over other data structures, such as fast lookup times, the ability to associate data with meaningful labels, and the flexibility to store different data types within the same structure. We've seen how dictionaries can be used in a wide range of applications, from building contact lists to representing hierarchical data.

By mastering dictionary methods and operations, you'll be well on your way to becoming a more proficient Python programmer. To continue your learning journey, I recommend exploring the official Python documentation, as well as searching for online tutorials and coding challenges that focus on dictionary usage.

Remember, the more you practice working with dictionaries, the more comfortable and confident you'll become in leveraging this versatile data structure in your Python projects.
:::
```---
title: "Mastering Python Data Structures"
subtitle: "Building the Foundation for Powerful Data Applications"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Welcome to Python Data Structures

- What are data structures and why are they important?
- The core data structures in Python
- How to choose the right data structure for your needs

::: {.notes}
In this presentation, we'll dive into the world of Python data structures. Data structures are the fundamental building blocks of any programming language, allowing us to organize and manage data in efficient and meaningful ways. Understanding how to work with different data structures is crucial for developing powerful and effective applications.

We'll start by exploring what data structures are and why they're so important, then we'll take a closer look at the core data structures available in Python. By the end, you'll have a solid grasp of how to select the right data structure for your specific needs, setting you up for success in your Python programming journey.
:::

# The Core Python Data Structures

- Lists
- Tuples
- Dictionaries
- Sets

::: {.notes}
The four core data structures in Python are:

1. Lists: Ordered collections of items that can be of different data types. Lists are versatile and allow for easy manipulation, such as adding, removing, and sorting elements.

2. Tuples: Ordered collections of items that are immutable, meaning their contents cannot be changed after creation. Tuples are useful for storing data that should remain constant.

3. Dictionaries: Unordered collections of key-value pairs, allowing for efficient data lookup and retrieval. Dictionaries are great for representing complex relationships and modeling real-world scenarios.

4. Sets: Unordered collections of unique elements. Sets are useful for tasks like finding common elements, removing duplicates, and performing set operations like union and intersection.

Understanding the strengths and use cases of each of these data structures will empower you to choose the right tool for the job and write more efficient, effective Python code.
:::

# Lists

- Ordered collection of items
- Can contain items of different data types
- Supports a variety of operations, such as:
  - Indexing
  - Slicing
  - Appending
  - Inserting
  - Removing

::: {.notes}
Lists are one of the most fundamental and versatile data structures in Python. They are ordered collections of items, which means the elements maintain a specific sequence. This allows you to access individual elements using their index.

Lists can contain items of different data types, such as numbers, strings, and even other data structures like dictionaries or even other lists. This flexibility makes lists a powerful tool for organizing and manipulating data.

Some common operations you can perform on lists include indexing to access specific elements, slicing to extract a subset of elements, appending new items, inserting elements at specific positions, and removing items. These operations make lists highly adaptable and useful for a wide range of programming tasks.
:::

# Tuples

- Ordered collection of items
- Immutable, meaning the contents cannot be changed
- Useful for storing data that should remain constant
- Faster than lists for certain operations

::: {.notes}
Tuples are similar to lists in that they are ordered collections of items. However, the key difference is that tuples are immutable, meaning you cannot modify their contents after creation.

This immutability makes tuples useful for storing data that should remain constant, such as configuration settings, geographic coordinates, or database records. Since the contents of a tuple cannot be changed, they are generally faster than lists for certain operations.

Tuples are often used to return multiple values from a function, as the return values are guaranteed to remain unchanged. They can also be used as dictionary keys, as dictionaries require immutable objects as keys.

While tuples may seem less flexible than lists, their immutability can be a strength in certain situations where you need to ensure the integrity of your data.
:::

# Dictionaries

- Unordered collection of key-value pairs
- Keys must be unique and immutable (like strings or numbers)
- Values can be of any data type
- Efficient data lookup and retrieval

::: {.notes}
Dictionaries are a powerful data structure in Python that store data in key-value pairs. Unlike lists and tuples, dictionaries are unordered, meaning the elements are not stored in a specific sequence.

Each element in a dictionary has a unique key, which is used to access the associated value. The keys must be immutable data types, such as strings or numbers, while the values can be of any data type, including other data structures like lists or even other dictionaries.

Dictionaries are highly efficient for data lookup and retrieval, as they use hash tables under the hood. This makes them an excellent choice for tasks like maintaining a database of customer information, tracking inventory, or representing complex relationships in your data.

By leveraging the power of key-value pairs, dictionaries allow you to build sophisticated data models and access specific pieces of information quickly and easily.
:::

# Sets

- Unordered collection of unique elements
- Elements must be immutable (like strings or numbers)
- Useful for tasks like:
  - Finding common elements
  - Removing duplicates
  - Performing set operations (union, intersection, difference)

::: {.notes}
Sets are another useful data structure in Python, representing an unordered collection of unique elements. Unlike lists and dictionaries, sets do not allow duplicate values. Each element in a set must be an immutable data type, such as a string or a number.

Sets are particularly helpful for tasks that involve finding common elements, removing duplicates, or performing set operations like union, intersection, and difference. For example, you could use a set to quickly identify the unique words in a text document or the common interests between two groups of people.

The unique and unordered nature of sets makes them efficient for tasks that require quickly checking the presence or absence of an element. This can be especially useful in data cleaning, analysis, and processing workflows.
:::

# When to Use Each Data Structure

- Lists: Ordered collections, good for sequential data
- Tuples: Immutable ordered collections, good for constant data
- Dictionaries: Unordered key-value pairs, good for modeling relationships
- Sets: Unordered unique elements, good for membership tests and set operations

::: {.notes}
Now that we've covered the core Python data structures, let's discuss when you might choose to use each one:

Lists are a great choice when you need to work with ordered, sequential data, such as a list of items in a shopping cart or a chronological series of events.

Tuples are useful when you have data that should remain constant, like configuration settings or geographic coordinates. Their immutability can help ensure the integrity of your data.

Dictionaries are ideal for modeling real-world relationships and representing complex data structures. They allow for efficient lookup and retrieval of information, making them useful for tasks like maintaining customer records or inventory management.

Sets are particularly helpful when you need to perform operations on unique elements, such as finding common interests, removing duplicates, or checking membership. They can be a great choice for data cleaning and processing tasks.

Choosing the right data structure for your specific needs will help you write more efficient, effective, and maintainable Python code.
:::

# Recap

- Python has four core data structures: lists, tuples, dictionaries, and sets
- Each data structure has its own strengths and use cases
- Lists are ordered, mutable collections
- Tuples are ordered, immutable collections
- Dictionaries are unordered key-value pairs
- Sets are unordered collections of unique elements
- Selecting the appropriate data structure is crucial for effective Python programming

::: {.notes}
In this presentation, we've explored the four core data structures in Python: lists, tuples, dictionaries, and sets. Each of these data structures has its own unique characteristics and use cases, and understanding when to use each one is crucial for effective Python programming.

Lists are ordered, mutable collections that are great for working with sequential data. Tuples are also ordered, but they are immutable, making them useful for storing constant data. Dictionaries are unordered key-value pairs, allowing for efficient data lookup and retrieval, and are well-suited for modeling real-world relationships. Finally, sets are unordered collections of unique elements, making them useful for tasks like finding common elements, removing duplicates, and performing set operations.

By mastering these fundamental data structures, you'll be well on your way to building powerful and efficient Python applications. Remember to choose the right data structure for the job at hand, as this will help you write cleaner, more maintainable code.
:::

# Thank You!

- Questions?
- Resources for further learning

::: {.notes}
Thank you for joining me on this introduction to Python data structures. I hope you now have a better understanding of the core data structures available in Python and how to choose the right one for your needs.

If you have any questions or would like to explore this topic further, please don't hesitate to ask. There are also many great resources available online, such as the official Python documentation, tutorials, and coding challenges, that can help you deepen your knowledge and skills.

Remember, mastering data structures is a crucial step in becoming a proficient Python programmer. Keep practicing, experimenting, and building projects, and you'll be well on your way to creating powerful, efficient, and maintainable applications.

Thank you for your attention, and I wish you all the best in your Python learning journey!
:::---
title: "STAFF ANSWER: Designing a Smart Inventory System: Justifying Decisions"
subtitle: "Applying Analytical Thinking to Inventory Management"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

Activity 1: Conceptual Application & Analysis

1. Key considerations for choosing a dictionary-based approach:
   - Efficient storage and retrieval of inventory data using the key-value structure
   - Ability to easily associate product information (e.g., name, SKU, quantity) with a unique identifier (the key)
   - Suitability for handling a large and dynamic inventory with frequent updates

2. Potential challenges and limitations of using a dictionary:
   - Handling complex inventory data that may require more structure than a simple key-value pair
   - Potential performance issues for large inventories or frequent updates (dictionary lookups have O(1) time complexity, but the underlying hash table implementation can degrade with many collisions)
   - Difficulty in maintaining order or sorting of inventory items (dictionaries are unordered)
   - Limitations in reporting and aggregating inventory data compared to more structured data models

3. Structuring the dictionary:
   - Use product SKU or unique ID as the dictionary key
   - Store relevant inventory information as the value, such as:
     - Product name
     - Quantity in stock
     - Reorder threshold
     - Supplier information
   - Consider using nested dictionaries or other data structures within the values to handle more complex inventory data

Activity 2: Evaluation, Comparison, and Justification

1. Key principles and assumptions of JIT and EOQ:
   - Just-in-Time (JIT):
     - Principle: Produce or deliver goods only as they are needed, minimizing inventory
     - Assumptions: Reliable and frequent supplier deliveries, stable demand, low setup costs
   - Economic Order Quantity (EOQ):
     - Principle: Determine the optimal order quantity to minimize total inventory costs
     - Assumptions: Constant and known demand, fixed ordering and holding costs

2. Advantages and disadvantages of JIT and EOQ for the given business scenario:
   - JIT advantages: Reduced inventory costs, less waste, improved cash flow
   - JIT disadvantages: Reliance on reliable suppliers, potential stock-outs, sensitivity to demand changes
   - EOQ advantages: Systematic approach to determining optimal order quantities, lower ordering costs
   - EOQ disadvantages: Requires accurate demand forecasting, potential for excessive inventory

3. Recommendation and justification:
   Given the small size of the business and the potential for demand fluctuations, the EOQ strategy may be more suitable. The EOQ approach provides a structured way to balance ordering and holding costs, which aligns better with the business owner's needs. While JIT can offer cost savings, the risk of stock-outs may be too high for a small retail business. The EOQ strategy provides a more stable and predictable inventory management system, which is likely more suitable for the given scenario.

Extension: Integrating Concepts

1. Modifying the dictionary structure:
   - Add a "reorder_level" key to track the minimum inventory level that triggers a reorder
   - Include a "forecast" key to store predicted future demand for each product
   - Consider using a nested dictionary to group related inventory data (e.g., product details, sales history, reorder information)

2. Algorithms and techniques for automated reordering and forecasting:
   - Automated reordering:
     - Monitor inventory levels and trigger a reorder when the "reorder_level" is reached
     - Use the EOQ formula to determine the optimal reorder quantity
   - Forecasting:
     - Implement a simple moving average or exponential smoothing algorithm to predict future demand
     - Use the forecasted demand to update the "forecast" key in the dictionary

3. Potential challenges and mitigation strategies:
   - Handling exceptions and edge cases (e.g., sudden demand spikes, supplier issues)
   - Ensuring data integrity and consistency as the inventory system grows more complex
   - Integrating the dictionary-based system with other business systems (e.g., sales, accounting)
   - Scaling the system to handle a larger, more diverse inventory

Reflection:

1. The analytical and evaluative skills practiced in this activity can be applied to other complex, real-world problems that require critical thinking, problem-solving, and justification of design choices. These skills are valuable in software engineering, project management, and various other fields.

2. AI tools were used to explain the underlying principles of JIT and EOQ in a different way, which helped deepen the understanding for the justification needed in Activity 2. The AI's suggestions were critically evaluated to assess their relevance and significance for the expanded inventory management system in the Extension activity.

3. Critically evaluating information and justifying choices was challenging, as it required a deep understanding of the concepts and the ability to apply them to a specific business scenario. The process was insightful, as it forced me to consider multiple perspectives, anticipate potential issues, and provide well-reasoned arguments to support the recommended solutions.---
title: "STAFF ANSWER: Optimising Dictionary Performance: Evaluating Options for Large Datasets"
subtitle: "Analysing Trade-offs and Justifying Choices for Efficient Data Structures"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## Activity 1: Conceptual Application & Analysis

Key factors to consider when selecting a dictionary implementation:
- **Time complexity:** The efficiency of key operations (lookup, insertion, deletion) is crucial, especially for large datasets. Aim for O(1) time complexity for these operations.
- **Space complexity:** The memory usage of the data structure should be reasonable and scale well with the dataset size.
- **Concurrency handling:** If the data needs to be accessed and modified by multiple users/processes, the data structure should support thread-safe or lock-free operations.
- **Ease of use:** The implementation should be straightforward and integrate well with the rest of the system.

The large dataset size (millions of products) would likely make a standard dictionary implementation inefficient due to the potential for hash collisions and linear search times. Alternative data structures like hash tables, ordered dictionaries, or tries may be more suitable.

Potential challenges and trade-offs:
- Hash tables offer constant-time lookups, but may have higher memory usage and potential issues with hash collisions as the dataset grows.
- Ordered dictionaries provide efficient sorting and range queries, but may have slightly higher overhead compared to standard dictionaries.
- Tries offer efficient prefix-based lookups, but can have higher memory usage for sparse datasets.

The choice would depend on the specific requirements of the system, such as the frequency and nature of the lookups, the need for sorting or range queries, and the available memory resources.

## Activity 2: Evaluation, Comparison, and Justification

Two suitable dictionary-based data structures for the caching system:
1. **Concurrent Hash Table**: A thread-safe hash table implementation, such as the `ConcurrentHashMap` in Java or the `concurrent.ConcurrentHashMap` in Python, which provides efficient concurrent access and modification.
2. **Ordered Dictionary**: An ordered dictionary data structure, such as the `OrderedDict` in Python or a `TreeMap` in Java, which maintains the keys in sorted order and supports efficient range queries.

Comparison:
- **Time complexity:**
  - Concurrent Hash Table: O(1) for lookup, insertion, and deletion on average.
  - Ordered Dictionary: O(log n) for lookup, insertion, and deletion.
- **Space complexity:**
  - Concurrent Hash Table: Higher memory usage due to the need for additional metadata for concurrency handling.
  - Ordered Dictionary: Slightly higher memory usage compared to a standard dictionary due to the overhead of maintaining the sorted order.
- **Concurrency handling:**
  - Concurrent Hash Table: Provides built-in thread-safety and atomic operations.
  - Ordered Dictionary: May require additional synchronization mechanisms to ensure thread-safety.
- **Ease of implementation and maintenance:**
  - Concurrent Hash Table: Relatively straightforward to implement, with well-established libraries available.
  - Ordered Dictionary: Slightly more complex to implement, but many libraries provide ready-to-use implementations.

Justification:
For the concurrent caching system, the **Concurrent Hash Table** would be the most appropriate choice. The constant-time lookups and updates are crucial for the caching requirements, and the built-in thread-safety simplifies the implementation and ensures the cache can be accessed and modified concurrently without issues. While the Ordered Dictionary offers useful features like range queries, the slightly higher time complexity and the need for additional concurrency handling make it less suitable for this specific use case.

## Extension: Optimising Dictionary Performance in a Real-World Scenario

To design an efficient data processing pipeline for the log file analysis, the following dictionary-based data structures could be used:

1. **Trie (Prefix Tree)**: Tries can be used to efficiently store and retrieve log entries based on the timestamp or user ID. Tries provide O(k) time complexity for lookup, insertion, and deletion, where k is the length of the key (e.g., timestamp or user ID). This makes them well-suited for quickly filtering and grouping the log data by these metadata fields.

2. **Hash Table**: A standard hash table implementation can be used to store aggregated or summarised data from the log entries, such as counts, averages, or other metrics per user or time period. The constant-time lookups and updates make hash tables efficient for these types of operations.

Justification:
- Handling large datasets with millions of entries:
  - Tries can efficiently store and retrieve data based on the log entry metadata, even for very large datasets, without suffering from hash collisions.
  - Hash tables can scale well to store the aggregated data, as their performance is not significantly impacted by the dataset size.
- Efficiently grouping and aggregating data:
  - Tries enable fast prefix-based lookups and grouping of log entries by timestamp or user ID.
  - Hash tables provide constant-time access to the aggregated metrics, allowing efficient data summarisation.
- Optimising lookup and update operations:
  - Tries offer O(k) time complexity for lookups, insertions, and deletions, where k is the length of the key (e.g., timestamp or user ID).
  - Hash tables provide O(1) average-case time complexity for lookups, insertions, and deletions.
- Trade-offs between time complexity, space usage, and ease of implementation:
  - Tries have a slightly higher space complexity compared to hash tables, but their performance characteristics make them well-suited for this scenario.
  - Hash tables are generally simpler to implement and maintain, with readily available library implementations.

By using a combination of tries and hash tables, the data processing pipeline can efficiently handle the large log dataset, quickly group and aggregate the data, and provide fast lookups and updates to support the analysis tasks.

## Reflection

1. The analytical and evaluative skills practiced in this worksheet, such as comparing the performance characteristics of different data structures, considering trade-offs, and justifying choices, are highly applicable to many other areas of computer science and software engineering. These skills can be used to optimize the performance and design of various systems, not just dictionary-based data structures.

2. In this worksheet, I used AI tools (e.g., asking an AI to summarize key factors or suggest potential issues) to supplement my own understanding and analysis. I found the AI's suggestions to be a helpful starting point, but I critically evaluated them and incorporated only the relevant insights into my justifications. Using AI in this way allowed me to explore the problem from different angles and deepen my comprehension, rather than simply relying on the AI-generated answers.

3. Critically evaluating information and justifying choices was a valuable exercise that required me to deeply understand the concepts and trade-offs involved. It was challenging to consider all the relevant factors and articulate a well-reasoned argument, but this process helped solidify my understanding of dictionary performance optimization and develop my critical thinking skills. The need to justify my choices forced me to think more deeply about the problem and consider alternative approaches, which was insightful and will be helpful in future problem-solving tasks.---
title: "STAFF ANSWER: Mastering Dictionaries: Unlocking Insights from Business Data"
subtitle: "Analyse, Evaluate, and Justify Your Decisions with Dictionaries"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## Activity 1: Conceptual Application & Analysis

1. To calculate the total revenue generated from the sales data:

   - Iterate through the `sales_data` dictionary using a `for` loop or the `items()` method.
   - For each product, multiply the `price` and `qty_sold` values to get the revenue for that product.
   - Sum up the individual product revenues to get the total revenue.

   Example code:
   ```python
   total_revenue = 0
   for product_id, product_data in sales_data.items():
       revenue = product_data['price'] * product_data['qty_sold']
       total_revenue += revenue
   print(f"Total revenue: ${total_revenue:.2f}")
   ```

   Potential challenges:
   - Handling missing or invalid data in the dictionary (e.g., missing price or quantity sold).
   - Accounting for discounts, taxes, or other factors that may impact the final revenue calculation.

2. To determine the best-selling product:

   - Iterate through the `sales_data` dictionary and keep track of the product with the highest `qty_sold` value.
   - Use the `max()` function with a `key` parameter to find the product with the maximum quantity sold.

   Example code:
   ```python
   best_selling_product = max(sales_data.items(), key=lambda x: x[1]['qty_sold'])
   print(f"The best-selling product is {best_selling_product[1]['name']} with {best_selling_product[1]['qty_sold']} units sold.")
   ```

   Explanation:
   - The `max()` function is used to find the key-value pair with the maximum `qty_sold` value.
   - The `key` parameter in `max()` specifies that we want to compare the values of the `qty_sold` field for each product.
   - The resulting `best_selling_product` variable contains the product ID and its corresponding data dictionary, from which we can extract the product name and quantity sold.

## Activity 2: Evaluation, Comparison, and Justification

To evaluate the two new product options and recommend the better one:

1. Calculate the potential monthly revenue for each new product:
   - Product A: $19.99 x 50 units = $999.50
   - Product B: $14.75 x 80 units = $1,180.00

2. Compare the potential monthly revenue:
   - Product B has a higher potential monthly revenue of $1,180.00 compared to $999.50 for Product A.

3. Justify the recommendation:
   - Based on the potential monthly revenue, Product B would be the better addition to the business. The higher estimated sales volume and slightly lower price point for Product B result in a higher overall revenue potential compared to Product A.

   Additional factors to consider (per the AI tip):
   - Production costs and profit margins for each product
   - Potential cannibalization of existing product sales
   - Customer demand and market trends for the new product types

   By considering these additional factors, you can provide a more comprehensive justification for the recommendation.

## Extension: Combining Concepts

1. Calculate the total revenue generated from all products:
   ```python
   total_revenue = 0
   for product_data in sales_data.values():
       total_revenue += product_data['price'] * product_data['qty_sold']
   print(f"Total revenue: ${total_revenue:.2f}")
   ```

2. Determine the product with the highest total revenue:
   ```python
   highest_revenue_product = max(sales_data.items(), key=lambda x: x[1]['price'] * x[1]['qty_sold'])
   print(f"The product with the highest total revenue is {highest_revenue_product[1]['name']}")
   ```

3. Calculate the average price of all products:
   ```python
   total_price = sum(product_data['price'] for product_data in sales_data.values())
   average_price = total_price / len(sales_data)
   print(f"The average price of all products is ${average_price:.2f}")
   ```

Explanation:
- For the total revenue, we iterate through the values in the `sales_data` dictionary and multiply the price and quantity sold for each product, then sum the results.
- To find the product with the highest total revenue, we use the `max()` function with a `key` parameter that calculates the total revenue for each product (price * quantity sold) and returns the product with the maximum value.
- To calculate the average price, we sum the prices of all products and divide by the number of products in the `sales_data` dictionary.

## Reflection

1. The analytical and evaluative skills practiced with dictionaries can be applied to many other data structures and problem domains, such as:
   - Analyzing and manipulating complex data structures (e.g., nested dictionaries, lists of dictionaries) to extract insights.
   - Choosing appropriate data representations (e.g., lists, sets, dataframes) to model and solve problems effectively.
   - Evaluating the trade-offs and suitability of different data structures for specific use cases.
   - Justifying design decisions and data analysis approaches based on the characteristics and capabilities of the chosen data structures.

2. In this worksheet, I used AI tools to suggest alternative approaches and identify additional factors to consider when evaluating the new product options. The AI's suggestions helped me broaden my perspective and incorporate more comprehensive considerations into my justification. However, I carefully examined the AI's outputs, verified their relevance and accuracy, and adapted them to fit the specific requirements of the task.

3. Critically evaluating information and justifying choices was challenging, as it required me to think critically about the assumptions, limitations, and potential biases in the data and analysis. It was insightful to consider alternative viewpoints and factors that could impact the decision-making process. This exercise helped me develop a more holistic and nuanced approach to problem-solving and decision-making.Thatâ€™s a fantastic teaching strategy â€” bringing everything together with a practical, student-created `safe_utils` module hits the sweet spot between review, extension, and motivation.

Hereâ€™s a sketch of how you could structure the **Week 12 â€œMake Your Own Moduleâ€ Wrap-up**:

---

## ðŸ§° Week 12: Build Your Own Python Module â€” `safe_utils`

### ðŸŒŸ Goal:
Create a small utility module called `safe_utils.py` containing reusable â€œsafe_â€ functions you've used during the semester.

---

### ðŸ”¹ Step 1: Create `safe_utils.py`

```python
# safe_utils.py

import json

def safe_json_loads(text):
    try:
        return json.loads(text)
    except json.JSONDecodeError:
        return {}

def safe_int(text):
    try:
        return int(text)
    except ValueError:
        return 0

def safe_float(text):
    try:
        return float(text)
    except ValueError:
        return 0.0

def safe_read_file(filename):
    try:
        with open(filename, "r", encoding="utf-8") as f:
            return f.read()
    except Exception:
        return ""

def safe_write_file(filename, content):
    try:
        with open(filename, "w", encoding="utf-8") as f:
            f.write(content)
            return True
    except Exception:
        return False
```

---

### ðŸ”¹ Step 2: Save to GitHub

- Guide students to upload this file to a GitHub repo
- Keep the repo simple: just the `.py` file and maybe a `README.md`

---

### ðŸ”¹ Step 3: Use from Colab

In Colab, they can run:

```python
!wget https://raw.githubusercontent.com/username/repo/main/safe_utils.py
import safe_utils

data = safe_utils.safe_read_file("something.txt")
```

ðŸ§  Or install via:

```python
!pip install git+https://github.com/username/repo.git
```

(only works if you structure it with `setup.py`, optional for advanced students)

---

### ðŸ”¹ Step 4: Optional Challenge

Ask students to add one new `safe_` function of their own:
- `safe_list_access(mylist, index)`
- `safe_divide(a, b)`
- `safe_input_int(prompt)` â€” continues asking until a valid int is given

---

### ðŸŽ“ Wrap-Up Discussion

- Why wrap unsafe functions?
- How could you test and document this module?
- What would you need to publish this to PyPI?
- Where might `safe_utils` fit into a real project?

---

Would you like a Quarto/Colab version of this, or a worksheet version students can fill out as they go?## ðŸ§ ðŸ¤– AI Conversation Worksheet â€“ Debugging AI Outputs  
> **Title**: *Be the Boss: Guide the AI to Build a Gradebook*

---

### ðŸ§© The Challenge:
> Build a **Gradebook Program** that:
> - Stores **student names and their test scores**
> - Uses a **function** to calculate average score
> - Handles **invalid input** and **empty scores**
> - Outputs each studentâ€™s **name and average**

---

### ðŸ—£ Prompt 1: â€œCan you help me write a program that stores student names and scores, and prints their average?â€

**ðŸ¤– AI Response (has subtle mistakes):**
```python
students = {
    "Alice": "85, 90, 78",
    "Bob": "70, 88, 92"
}

for name in students:
    avg = sum(students[name]) / len(students[name])
    print(f"{name}: {avg}")
```

---

### âŒ Whatâ€™s wrong with this code?

âœ… Use this space to **list the problems**:

- _________________________________________________________  
- _________________________________________________________  

ðŸ§  Hint: Think about **data types**, **string vs. list**, and `sum()`.

âœï¸ Suggested Prompt:  
`"Your code stores scores as strings. Can you fix it so each student has a list of numbers instead?"`

---

### ðŸ—£ Prompt 2: â€œCan you fix the scores so theyâ€™re stored as numbers in a list?â€

**ðŸ¤– AI Response (better, but still not ideal):**
```python
students = {
    "Alice": [85, 90, 78],
    "Bob": [70, 88, 92]
}

for name in students:
    total = 0
    for score in students[name]:
        total += score
    avg = total / 3
    print(f"{name} average is {avg}")
```

---

### âŒ Critique This:

1. What assumption is made about score count?
2. Could we use a function here?

âœï¸ Prompt Idea:  
`"Can you make a function to calculate the average of any list of scores, instead of assuming 3?"`

---

### ðŸ—£ Prompt 3: â€œPlease use a function to calculate the average instead of hardcoding â€˜3â€™.â€

**ðŸ¤– AI Response (Oops! Watch this one):**
```python
def average(scores):
    return sum(scores) / len(scores)

for name in students:
    print(f"{name} average: {average(name)}")
```

---

### âŒ Spot the Mistake:

- What is being passed to `average()` here?
- Why does it crash?

âœï¸ Prompt Idea:  
`"You're passing the name to average instead of the list of scores. Can you fix the for-loop?"`

---

### ðŸ—£ Prompt 4: Fixing the Loop

**ðŸ¤– AI Response (Corrected):**
```python
def average(scores):
    return sum(scores) / len(scores)

for name, scores in students.items():
    print(f"{name} average: {average(scores)}")
```

ðŸŽ‰ This version works â€” but now letâ€™s push it further...

---

### ðŸ—£ Prompt 5: â€œCan you modify the code to ask the user to enter student names and scores?â€

**ðŸ¤– AI Response (Flawed Input Handling):**
```python
students = {}

while True:
    name = input("Enter name (or 'done'): ")
    if name == "done":
        break
    scores = input("Enter scores separated by spaces: ")
    students[name] = scores.split()
```

---

### âŒ Critique the Input Code:

- Are the scores strings or integers?
- What happens if the user enters bad input?

âœï¸ Prompt Idea:  
`"Can you convert the scores to integers and ignore blank entries?"`

---

### ðŸ—£ Prompt 6: Fix Input Parsing

**ðŸ¤– AI Response (Improving):**
```python
scores = [int(s) for s in scores.split() if s.strip() != ""]
```

âœï¸ Extension Prompt:  
`"Can you skip entries that arenâ€™t valid numbers?"`

---

### ðŸ—£ Final Prompt: â€œCan you combine this with the average function and print student averages?â€

**ðŸ¤– AI Final Version (Almost There... but whatâ€™s missing?):**
```python
def average(scores):
    return sum(scores) / len(scores)

for name in students:
    print(f"{name} average: {average(students[name])}")
```

---

### âŒ Final Check:

- Does this handle **empty scores**?
- What if someone enters no valid numbers?

âœï¸ Prompt Idea:  
`"Can you make sure the average function handles an empty list without crashing?"`

---

### âœ… Your Turn: Rewrite the Final Version with Fixes

```python
# Your improved version here:
```

---

### ðŸ” Wrap-Up: What You Learned About Directing the AI

- What kinds of mistakes did the AI make?
- How did your understanding of Python help you fix them?
- How would you change your prompts next time?

âœï¸ Notes:  
_________________________________________________________  
_________________________________________________________  

---
## ðŸ Python Problem Solving Handout

### ðŸ’¡ Core Concepts

| Concept     | Description / Python Examples                            |
|-------------|-----------------------------------------------------------|
| **Input**   | `input()`, `pyinputplus`, function arguments/parameters   |
| **Output**  | `print()`, `return`                                       |
| **Store**   | Variables, assignment `=`, lists `[]`, dictionaries `{}`  |
| **Calculate** | `+`, `-`, `*`, `/`, `//`, `%`, `**`<br>`<`, `<=`, `>`, `>=`, `==`<br>`in`, `not`, `and`, `or` |
| **Decisions** | `if`, `if-else`, `if-elif`                              |
| **Repeat**  | `for`, `while`, list comprehensions                       |

---

### ðŸ§  Simple Methodology: From Problem to Program

#### âœï¸ Design (Think First)
1. **Restate the problem in your own words**  
2. **Identify input and output**  
3. **Work the problem by hand**  
4. **Write pseudocode** (plain-English steps)

âž¡ï¸ Use comments (`#`) to turn pseudocode into your starting point in Python.

#### ðŸ§‘â€ðŸ’» Coding (Do)
5. **Convert to Python** â€“ Start writing real code  
6. **Test with a variety of data** â€“ Try different inputs and edge cases

> ðŸ’¬ Tip: If something isnâ€™t working, go back to Step 3 or 4. Try smaller test cases or break down the logic.
## ðŸ§ ðŸ¤– AI Conversation Worksheet â€“ Advanced Programming via Prompting  
> **Title**: *Guiding the AI: Building a Python Gradebook*

### ðŸ§© Task:  
> **Create a gradebook program that:**
> - Uses a dictionary to store student names and their list of scores  
> - Has a function to calculate average score  
> - Prints each studentâ€™s name and average  
> - Handles edge cases (e.g., empty lists, invalid inputs)

---

### ðŸ‘£ Step-by-Step Prompt Walkthrough

---

### ðŸ”¹ Prompt 1: Start Simple

**You ask AI:**  
ðŸŸ¢ `"Can you help me write a Python program to store student names and their test scores, and print their average?"`

**AI replies:**  
```python
students = {
    "Alice": [85, 90, 78],
    "Bob": [70, 88, 92],
    "Charlie": [100, 100, 90]
}

for name, scores in students.items():
    avg = sum(scores) / len(scores)
    print(f"{name} has an average of {avg}")
```

---

### ðŸ” Reflection:
> âœ… **Whatâ€™s good about this solution?**  
> âš ï¸ **Whatâ€™s missing?** (Think: user-defined functions, flexibility, edge cases)

âœï¸ **Your notes:**  
___________________________________________________________  
___________________________________________________________  

---

### ðŸ”¹ Prompt 2: Add a Function

**You ask AI:**  
ðŸŸ¢ `"Can you turn the average calculation into a function?"`

**AI replies:**  
```python
def average(scores):
    return sum(scores) / len(scores)

for name, scores in students.items():
    print(f"{name} has an average of {average(scores)}")
```

---

### ðŸ§  Pause & Think:

> What if `scores` is an empty list?  
> Try this prompt:  
ðŸŸ¢ `"What happens if a student has no scores? Can you fix that?"`

---

### ðŸ”¹ Prompt 3: Improve Robustness

**AI replies:**  
```python
def average(scores):
    if not scores:
        return 0
    return sum(scores) / len(scores)
```

> ðŸ’¬ Not bad â€” but is returning 0 always the best choice?

âœï¸ **Optional Critique:**  
___________________________________________________________  
___________________________________________________________  

---

### ðŸ”‚ Optional Fork:
> You realize you want to enter student data manually.

ðŸŸ¢ Prompt: `"Can I ask the user to enter student names and scores?"`

---

### ðŸ”¹ Prompt 4: Collect User Input

**AI tries (but gives this shaky code):**  
```python
students = {}
while True:
    name = input("Enter student name (or 'done'): ")
    if name == "done":
        break
    scores = input("Enter scores separated by commas: ").split(",")
    students[name] = scores
```

---

### ðŸ” Letâ€™s Critique That:

- ðŸš« Scores are strings, not numbers  
- ðŸš« No validation  
- âœ… Good start using loop & dictionary

âœï¸ **Prompt suggestion to fix it:**  
ðŸŸ¢ `"Can you convert scores to numbers and skip blanks?"`

---

### ðŸ”¹ Prompt 5: Improve Input Handling

**AI replies:**  
```python
students = {}
while True:
    name = input("Enter student name (or 'done'): ")
    if name == "done":
        break
    raw_scores = input("Enter scores separated by commas: ")
    scores = [int(s) for s in raw_scores.split(",") if s.strip().isdigit()]
    students[name] = scores
```

---

### âœ… Final Prompt: Combine with Function

ðŸŸ¢ `"Can you combine this with the average function and print each student's name and average?"`

---

### âœ¨ Final Result (AI replies):  
```python
def average(scores):
    if not scores:
        return "No scores"
    return sum(scores) / len(scores)

students = {}
while True:
    name = input("Enter student name (or 'done'): ")
    if name == "done":
        break
    raw_scores = input("Enter scores separated by commas: ")
    scores = [int(s) for s in raw_scores.split(",") if s.strip().isdigit()]
    students[name] = scores

for name, scores in students.items():
    print(f"{name}: Average = {average(scores)}")
```

---

### ðŸ§  Reflection: Directing the AI Like a Programmer

> - What *concepts* helped you understand what to ask?
> - When did you have to **correct or clarify** the AI?
> - Could someone without a good grasp of `dict`, `functions`, `input()` etc. make this work?

âœï¸ **Your Thoughts:**  
___________________________________________________________  
___________________________________________________________  

---
## ðŸ§ ðŸ¤– AI-Powered Python Worksheet  
> *Using AI to Think, Design, and Code with Python*

### ðŸ§© Problem Statement:
> **Write a program that calculates the average test score from a list of scores input by the user.**

---

### PART 1 â€” Understanding the Problem (with AI support)

| Step | What You Do | Your Prompt to the AI | AI Response Notes |
|------|-------------|------------------------|--------------------|
| 1. Restate the problem | Rephrase it in your own words | `"Can you help me restate this problem clearly: I need a program that calculates average test scores?"` | |
| 2. Identify Input & Output | Figure out what goes in/out | `"What inputs does this program need? What should it output?"` | |
| 3. Work it by hand | Try an example yourself | N/A â€“ write down how youâ€™d manually do it | |
| 4. Write pseudo code | Ask AI to help with steps | `"Can you help me write pseudocode for this problem?"` | |

---

### PART 2 â€” Coding with AI

| Step | Your Goal | Your Prompt to the AI | AI Code / Response |
|------|-----------|------------------------|--------------------|
| 5. Convert to Python | Ask AI to write code from the pseudocode | `"Can you convert the pseudocode above into working Python code?"` | |
| 6. Test with data | Try different examples | `"Can you show how this program would work with scores: 90, 85, 78?"` | |
| ðŸ›  Debug or Refine | Identify & fix issues | `"The code gives an error if I enter nothing. Can you help me fix that?"` | |

---

### ðŸ§  Reflection

- âœ… What did the AI do well?
- âš ï¸ What did you still have to guide or fix?
- ðŸ’¬ What would you ask differently next time?

---

## ðŸ›  Bonus: Explore Programming Concepts with the AI

Ask AI to explain or show examples for:

| Concept     | Prompt Example |
|-------------|----------------|
| Input       | `"How do I get user input in Python?"` |
| Output      | `"Whatâ€™s the difference between print() and return?"` |
| Store       | `"How do I store numbers in a list?"` |
| Calculate   | `"Whatâ€™s the difference between / and // in Python?"` |
| Decisions   | `"How do I use if-else to check for a passing score?"` |
| Repeat      | `"How do I loop through a list of scores?"` |


1. **Build a progression of complexity**: Your current materials already show a nice progression from basic to more complex interactions. Consider organizing exercises that explicitly build from simpler concepts to more complex integrations.

2. **Incorporate reflection points**: Add more structured reflection prompts throughout your materials to help students internalize what they're learning about both programming concepts and effective prompting.

3. **Add visual guides**: Consider creating flowcharts of effective prompting patterns that students can reference. This could show the decision tree of when to use different types of prompts.

4. **Create starter templates**: Provide students with "prompt templates" for different programming scenarios that they can customize.

5. **Peer review component**: Add an exercise where students review each other's AI conversations and identify ways to improve their prompting.

6. **Challenge scenarios**: Include specific programming challenges where the AI is intentionally programmed to provide initially flawed solutions, requiring careful prompting to resolve.

## Key Improvements in the New Materials

1. The **Complete AI Programming Conversation Exercise** provides a fully worked example that follows your six-step methodology while showing non-linear paths students might explore.

2. The **Guide to Intentional Prompting** explains the concept, categorizes different types of prompts, and provides concrete patterns students can follow.

3. The **Prompt Templates** document organizes effective prompts by the six core programming concepts from your handout, giving students a reference library.

4. The **Assessment Guide** helps you evaluate student progress in AI prompting as a skill, with rubrics and sample activities.

5. The **Loops Worksheet** demonstrates how one specific core concept can be deeply explored through the intentional prompting approach.

These materials complement your existing worksheets by providing more structured guidance, conceptual frameworks, and practical exercises that turn AI interactions into meaningful learning experiences.

Absolutely! Here's a **mini-lab worksheet** that introduces `safe_` wrappers through guided examples. It walks students through:

1. What can go wrong with built-in functions
2. How to handle it manually
3. How to wrap it into reusable `safe_` functions
4. A few small challenges to practice building their own

---

## ðŸ§ª Mini-Lab: Building Safe Wrappers in Python

**Topic:** Handling errors with `safe_` functions  
**Level:** Week 7 â€“ Intro to error handling (pre-exceptions deep dive)  
**Goal:** Help students recognize where things might break, and how to prevent it using wrapper functions.

---

### ðŸ§­ Part 1: The Problem with Unreliable Input

Try running this in a Python cell:

```python
import json

bad_json = "Not valid JSON at all!"
parsed = json.loads(bad_json)
```

â“What happens?

âœï¸ **Write the error message below:**

```text
# Your answer here
```

---

### ðŸ›¡ï¸ Part 2: Adding Basic Protection

Update the code to handle this more safely:

```python
try:
    parsed = json.loads(bad_json)
except json.JSONDecodeError:
    parsed = {}
```

ðŸ§  Why do we use a `try` block here?

```text
# Your answer here
```

---

### ðŸ§° Part 3: Turning It Into a Safe Wrapper

Letâ€™s wrap that logic into a **reusable function**:

```python
def safe_json_loads(text):
    try:
        return json.loads(text)
    except json.JSONDecodeError:
        return {}
```

âœ… Test it:

```python
print(safe_json_loads('{"name": "Alice"}'))         # Should return a dictionary
print(safe_json_loads("This is not JSON!"))         # Should return {}
```

---

### ðŸ§ª Part 4: Build Your Own Safe Wrapper

Letâ€™s build a safe version of a function that might fail: `int()`  
What happens when we try to convert text to a number?

```python
print(int("123"))       # âœ…
print(int("hello"))     # âŒ
```

ðŸ”§ Fill in the blanks:

```python
def safe_int(text):
    try:
        return int(text)
    except ValueError:
        return 0  # Or None
```

âœ… Test your function:

```python
print(safe_int("42"))       # âžœ 42
print(safe_int("banana"))   # âžœ 0
```

---

### ðŸ§  Reflection Questions

1. Why might we want to return a default value (like `{}` or `0`)?
2. What would happen if we didnâ€™t catch the error?
3. When is it okay to crash, and when should we try to recover?

âœï¸ Write your thoughts here:

```text
# Your thoughts...
```

---

### ðŸŽ¯ Extension Challenge (Optional)

Try writing your own `safe_float()` function.

```python
def safe_float(text):
    # Your code here
    ...
```

---

### ðŸ“Ž Instructor Notes (for you)

- This lab bridges the gap between practical problem-solving and formal exception handling.
- Ideal to follow up next week by "unpacking" the try/except syntax they've already used inside `safe_` wrappers.
- You can extend this to `safe_divide(a, b)`, `safe_list_access(lst, i)`, or even `safe_open(filename)`.

---

Would you like this exported as a PDF/Markdown/Colab/Quarto version for your class?



Great instinct â€” **yes**, making a `safe_` wrapper for file operations is a **very practical idea**, especially for beginner programmers.

### ðŸ§¨ Why?

File operations often fail in ways that **crash programs**:
- File doesn't exist â†’ `FileNotFoundError`
- No permission â†’ `PermissionError`
- File is in use or locked â†’ `OSError`
- Encoding errors â†’ `UnicodeDecodeError` (when reading text)

At Week 7, students may not yet be ready to handle all of this â€” but a `safe_open()` or `safe_read_file()` can let them move forward **without fear** of runtime crashes.

---

## âœ… Example: `safe_read_file()` (Beginner Version)

```python
def safe_read_file(filename):
    """
    Tries to read a file. Returns the file contents as a string,
    or an empty string if something goes wrong.
    """
    try:
        with open(filename, "r", encoding="utf-8") as f:
            return f.read()
    except Exception as e:
        print(f"Could not read file: {e}")
        return ""
```

### ðŸ”§ Usage:

```python
data = safe_read_file("myfile.txt")
print(data)
```

---

## ðŸ§ª Mini-Lab Exercise: Reading Files Safely

### âš ï¸ Step 1: What happens if the file is missing?

```python
with open("not_a_real_file.txt", "r") as f:
    data = f.read()
```

âœï¸ What error do you see?

```text
# Your answer
```

---

### âœ… Step 2: Use `safe_read_file()` instead

```python
def safe_read_file(filename):
    try:
        with open(filename, "r", encoding="utf-8") as f:
            return f.read()
    except Exception:
        return ""
```

Test with:
```python
print(safe_read_file("not_a_real_file.txt"))
```

---

### ðŸ” Bonus: A Safe File Writer

```python
def safe_write_file(filename, content):
    try:
        with open(filename, "w", encoding="utf-8") as f:
            f.write(content)
            print("Write successful.")
    except Exception as e:
        print(f"Failed to write file: {e}")
```

---

### ðŸ§  Why This Matters

Having students **build and use safe_ wrappers**:
- Encourages reuse
- Builds awareness of failure points in code
- Eases anxiety around crashing
- Lays a foundation for exception handling next week

---

Would you like me to bundle `safe_json_loads()`, `safe_int()`, and `safe_read_file()` into a mini â€œsafe_utils.pyâ€ module for student use? Or make a short coding task sheet around just `safe_read_file()`?---
title: "Unlocking the Power of Iteration: Beyond the Basics"
subtitle: "Mastering Nested Loops and List Comprehensions in Python"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Welcome to Advanced Iteration

* Introduction to advanced iteration techniques
* Why nested loops and list comprehensions matter
* How these techniques improve code efficiency and readability
* What we'll cover in today's presentation

::: {.notes}
Welcome to our exploration of advanced iteration techniques in Python! Today we'll be building on your foundational knowledge of loops to discover more sophisticated ways to work with data. Nested loops and list comprehensions are powerful tools that allow you to write more efficient, readable code while solving complex problems.

Throughout this presentation, we'll examine how these techniques work, when to use them, and how they can simplify your code. Whether you're processing multi-dimensional data or transforming collections of items, these iteration techniques will become valuable additions to your programming toolkit. By the end of this session, you'll have a solid understanding of how to implement and leverage these patterns in your own code.
:::

# Review: Basic Iteration

* Refresher on simple for loops
* Common loop patterns with single collections
* Limitations of basic loops
* Setting the stage for advanced techniques

```python
# Basic for loop
for item in collection:
    print(item)
    
# Looping with index
for i in range(len(collection)):
    print(f"Item {i}: {collection[i]}")
```

::: {.notes}
Before diving into advanced topics, let's quickly refresh our understanding of basic loops. In Python, a simple for loop allows us to iterate through a collection like a list or string, performing the same operation on each item. We can also use the range() function to generate indices when we need to track positions.

While these basic patterns are incredibly useful, they have limitations when dealing with more complex data structures or when we need to perform multiple levels of iteration. As your programming challenges become more sophisticated, you'll encounter situations where basic loops become unwieldy or inefficient. This is where our advanced techniques come in, allowing us to express more complex operations in cleaner, more efficient ways.
:::

# Nested Loops: The Concept

* What are nested loops?
* The outer loop and inner loop relationship
* How execution flows in nested structures
* Common use cases for nested iteration

```python
# Basic nested loop structure
for outer_item in outer_collection:
    for inner_item in inner_collection:
        print(f"{outer_item}, {inner_item}")
```

::: {.notes}
Nested loops are simply loops within loops. When we nest loops, the inner loop runs completely for each iteration of the outer loop. Think of it like the hands of a clock: the minute hand (inner loop) makes a complete rotation for each hour (outer loop) that passes. This structure is particularly useful when working with multi-dimensional data or when you need to compare each item in a collection with every other item.

Understanding the execution flow is crucial: for each single iteration of the outer loop, the inner loop runs completely from start to finish. This creates a multiplicative effect on the number of operations - if the outer loop runs 5 times and the inner loop runs 10 times, the inner code block will execute 50 times total. This powerful pattern enables us to process matrices, grids, and perform combinatorial operations that would be difficult to express with simple loops.
:::

# Nested Loops: Practical Examples

* Working with multi-dimensional data
* Generating combinations and permutations
* Processing matrices and tables
* Comparing all items in a collection

```python
# Printing a multiplication table
for i in range(1, 6):
    for j in range(1, 6):
        print(f"{i} Ã— {j} = {i*j}")
    print("-----")  # Separator between rows
```

::: {.notes}
Nested loops shine when working with structured data that has multiple dimensions. The example shown creates a simple multiplication table, where each combination of numbers is processed to display their product. This pattern extends naturally to processing data in grids, such as pixels in an image or cells in a spreadsheet.

Another common application is generating all possible combinations or pairs from collections. For instance, if you need to compare each item in a list with every other item (like finding all possible matchups in a tournament), nested loops make this straightforward. While these operations can require significant computational resources as the collections grow larger, they are often the clearest way to express these kinds of operations, especially for beginners working with moderately sized datasets.
:::

# Nested Loop Challenges

* Understanding iteration complexity
* Avoiding common pitfalls
* Performance considerations
* Readability and maintainability concerns

```python
# Potential performance issue with large datasets
for i in range(1000):
    for j in range(1000):
        # This inner code runs 1,000,000 times!
        result = i * j
```

::: {.notes}
While nested loops are powerful, they come with challenges worth noting. The most significant is performance - nested loops multiply the number of operations performed, which can lead to slow code when working with large datasets. The example shown would perform one million operations, which might be acceptable for some applications but prohibitively slow for others.

Another common pitfall is the complexity of maintaining and debugging deeply nested code. When loops are nested three or more levels deep, the code becomes difficult to read and reason about. It's often better to refactor such code, either by splitting complex operations into separate functions or by using more advanced techniques like list comprehensions. As you work with nested loops, be mindful of these trade-offs and consider whether there might be more efficient or readable approaches to your specific problem.
:::

# Introduction to List Comprehensions

* What are list comprehensions?
* Basic syntax and structure
* Advantages over traditional loops
* When to use list comprehensions

```python
# Traditional approach with for loop
squares = []
for x in range(10):
    squares.append(x**2)

# Equivalent list comprehension
squares = [x**2 for x in range(10)]
```

::: {.notes}
List comprehensions offer a concise, elegant way to create lists based on existing collections. They package the operation of looping through items, transforming them, and collecting the results in a single expressive line of code. As shown in our example, what takes multiple lines with traditional loops can often be accomplished in a single line with a list comprehension.

Beyond just saving space, list comprehensions can sometimes be more efficient than equivalent loop code, as they're optimized at the implementation level. They're particularly valuable when you need to transform data from one form to another or filter items based on certain conditions. The syntax may look intimidating at first, but it follows a natural language-like pattern: "Give me x squared for each x in the range of numbers from 0 to 9." Once you become comfortable with this pattern, you'll find list comprehensions make your code more readable and expressive.
:::

# Advanced List Comprehensions

* Adding conditional logic (filtering)
* Nested list comprehensions
* Working with multiple collections
* Converting between data structures

```python
# Filtering with conditional logic
even_squares = [x**2 for x in range(10) if x % 2 == 0]

# Nested list comprehension (flattening a matrix)
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [num for row in matrix for num in row]
```

::: {.notes}
List comprehensions become even more powerful when combined with conditional logic and nesting. Adding a condition allows you to filter items based on certain criteria - in our example, we're only including squares of even numbers. This ability to filter while transforming makes list comprehensions incredibly versatile for data processing tasks.

Nested list comprehensions mimic the behaviour of nested for loops but in a more compact form. While the syntax can be tricky to parse at first, it follows a specific pattern where each "for" clause corresponds to a level of nesting, reading from left to right. The example shown flattens a matrix (a list of lists) into a single list, demonstrating how nested comprehensions can simplify working with multi-dimensional data. As with nested loops, be mindful of readability - sometimes breaking complex operations into multiple steps can make your code easier to understand and maintain.
:::

# Comparing Nested Loops and List Comprehensions

* Clarity vs. conciseness trade-offs
* Performance considerations
* When to use each approach
* Best practices for readable code

```python
# Nested loops approach
result = []
for i in range(3):
    for j in range(3):
        result.append((i, j))

# Equivalent list comprehension
result = [(i, j) for i in range(3) for j in range(3)]
```

::: {.notes}
Choosing between nested loops and list comprehensions involves balancing several factors. Nested loops often provide more clarity for complex operations, especially when multiple steps or complex logic are involved. They're easier to debug and can be clearer for beginners to understand. List comprehensions, on the other hand, offer conciseness and can sometimes provide better performance, but may become difficult to read when they include multiple levels of nesting or complex conditions.

As a rule of thumb, consider using list comprehensions for straightforward transformations and filters, and nested loops when the logic becomes complex or when you need to perform multiple operations within each iteration. Remember that code readability is paramount - if a list comprehension becomes so complex that it's difficult to understand at a glance, breaking it down into explicit loops or multiple steps might be the better approach. The goal is to write code that clearly expresses your intent, not just to use the most concise syntax possible.
:::

# Real-World Applications

* Data processing and transformation
* Image processing (pixel manipulation)
* Generating test cases and simulations
* Working with JSON and nested data structures

```python
# Processing structured data
data = [
    {"name": "Alice", "scores": [85, 90, 78]},
    {"name": "Bob", "scores": [92, 88, 95]}
]
# Calculate average score for each person
averages = {person["name"]: sum(person["scores"])/len(person["scores"])
            for person in data}
```

::: {.notes}
Advanced iteration techniques are not just academic exercises - they solve real problems in everyday programming. Data processing often involves transforming, filtering, and aggregating collections, tasks that are well-suited to list comprehensions and nested loops. The example shown uses a dictionary comprehension (a close relative of list comprehensions) to calculate average scores from a nested data structure, demonstrating how these techniques help navigate complex data.

These patterns appear in many applications: image processing uses nested loops to manipulate pixels in a grid; simulations often generate combinations of parameters; and data processing frequently involves extracting and transforming values from nested structures like JSON. As you encounter these scenarios in your own projects, you'll develop an intuition for which technique fits each situation. Remember that the best approach is often the one that most clearly expresses your intent while maintaining appropriate performance for your specific use case.
:::

# Wrap-Up and Best Practices

* Choose the right tool for the task
* Prioritise readability over cleverness
* Break complex operations into manageable steps
* Practice and experiment with these techniques

::: {.notes}
As we conclude our exploration of advanced iteration techniques, remember that mastery comes through thoughtful practice. When approaching a problem that requires iteration, consider both nested loops and list comprehensions, evaluating which approach best suits your specific needs. While list comprehensions offer elegant conciseness, sometimes explicit nested loops provide better clarity.

Keep readability as your north star - code is read far more often than it's written, and clear code saves time and prevents bugs. Don't hesitate to break complex operations into multiple steps with meaningful variable names to document your intent. As you practice these patterns, you'll develop an intuition for when each approach shines. Remember that these advanced techniques aren't about showing off coding prowess but about expressing your solution in the most appropriate, maintainable way possible.
:::---
title: "Mastering Python Lists: Beyond the Basics"
subtitle: "Powerful Techniques for Efficient Data Manipulation"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to Lists

* What are lists in Python?
* Why lists are fundamental data structures
* Common applications of lists in programming
* How lists compare to other data structures

::: {.notes}
Welcome to our exploration of Python lists! Lists are one of Python's most versatile and commonly used data structures. At their core, lists are ordered collections that can store multiple items of different types. What makes lists particularly powerful is their flexibilityâ€”they can contain numbers, strings, and even other lists, all within a single structure.

Lists serve as the foundation for many programming tasks, from storing user inputs to managing complex datasets. Throughout this presentation, we'll examine various techniques for manipulating lists effectively, focusing on built-in methods that make working with lists both intuitive and efficient for beginners and experienced programmers alike.
:::

# List Basics

* Creating lists: `my_list = [1, 2, 3, 'hello']`
* Accessing elements: `my_list[0]` â†’ `1`
* List indexing (zero-based)
* Negative indexing: `my_list[-1]` â†’ `'hello'`
* Slicing lists: `my_list[1:3]` â†’ `[2, 3]`

::: {.notes}
Let's start with the fundamentals of working with lists. Creating a list in Python is as simple as placing comma-separated values within square brackets. What's particularly useful about Python lists is how they handle indexingâ€”with the first element at position 0, not 1 as you might expect. This zero-based indexing is consistent across many programming languages.

Python also offers handy features like negative indexing, where -1 refers to the last element, making it easy to access elements from the end of a list. Slicing is another powerful technique that allows you to extract a portion of a list using the format `list[start:end]`, where the end index is exclusive. These basic operations form the building blocks for more complex list manipulations we'll explore in the following slides.
:::

# Common List Methods: Adding Elements

* `append()`: Add an item to the end
  * `my_list.append(4)` â†’ `[1, 2, 3, 'hello', 4]`
* `insert()`: Add an item at a specific position
  * `my_list.insert(1, 'new')` â†’ `[1, 'new', 2, 3, 'hello']`
* `extend()`: Add multiple items from another iterable
  * `my_list.extend([5, 6])` â†’ `[1, 2, 3, 'hello', 5, 6]`

::: {.notes}
Python provides several intuitive methods for adding elements to lists. The `append()` method is perhaps the most frequently usedâ€”it simply adds an item to the end of a list. This is perfect for when you're collecting items one at a time, such as during user input or data processing.

When you need more control over where an element is placed, `insert()` allows you to specify the exact position. The `extend()` method is particularly useful when combining lists, as it adds each element of the second list individually rather than nesting it. Understanding the differences between these methods is crucial, as using the wrong one (like using `append()` instead of `extend()` when adding multiple items) can lead to unexpected results in your data structure.
:::

# Common List Methods: Removing Elements

* `remove()`: Delete a specific value
  * `my_list.remove('hello')` â†’ `[1, 2, 3]`
* `pop()`: Remove an item at a specific position and return it
  * `my_list.pop(1)` â†’ returns `2`, list becomes `[1, 3]`
* `del` statement: Remove an item or slice
  * `del my_list[0]` â†’ list becomes `[3]`
* `clear()`: Remove all items
  * `my_list.clear()` â†’ `[]`

::: {.notes}
Removing elements from lists is just as important as adding them, and Python offers multiple approaches for different scenarios. The `remove()` method searches for a specific value and removes the first occurrence, which is useful when you know what to remove but not where it is. If it doesn't find the value, Python will raise an error, so it's often paired with an if statement in practice.

The `pop()` method is particularly versatile as it not only removes an item (by default, the last one) but also returns it, allowing you to use the removed value. The `del` statement offers more flexibility, allowing you to remove individual items or slices. Finally, the `clear()` method provides a quick way to empty a list completely without reassigning it. Each of these methods has its own use case, and selecting the right one depends on your specific requirements.
:::

# List Ordering and Sorting

* `sort()`: Sort the list in place
  * `numbers.sort()` â†’ `[1, 2, 3, 4, 5]`
* Sorting with custom key function
  * `names.sort(key=len)` â†’ sorts by string length
* `reverse()`: Reverse the order of elements
  * `my_list.reverse()`
* Built-in `sorted()` function: Create a new sorted list
  * `sorted_list = sorted(my_list)`

::: {.notes}
Ordering and sorting operations are essential when working with lists containing related items. The `sort()` method rearranges elements in ascending order by default, directly modifying the original list. This in-place sorting is efficient when you don't need to preserve the original order. For more complex sorting scenarios, you can provide a custom key functionâ€”for example, sorting strings by length rather than alphabetically.

The `reverse()` method simply flips the order of elements, which is useful for changing sort direction or implementing simple algorithms. When you need to keep the original list intact, the built-in `sorted()` function creates a new sorted list without modifying the source. Understanding these ordering operations helps you organise data efficiently, whether you're displaying information to users or preparing data for further processing.
:::

# List Comprehensions

* Concise way to create new lists
* Basic syntax: `[expression for item in iterable]`
* Example: `[x**2 for x in range(5)]` â†’ `[0, 1, 4, 9, 16]`
* Adding conditions: `[x for x in range(10) if x % 2 == 0]` â†’ `[0, 2, 4, 6, 8]`
* Advantages over traditional for loops

::: {.notes}
List comprehensions represent one of Python's most elegant features, allowing you to create new lists with a single line of code. This approach is not only more concise than traditional for loops but often more readable once you become familiar with the syntax. The basic pattern follows a natural language structure: "give me this expression for each item in this iterable."

The real power of list comprehensions becomes apparent when you add conditions to filter elements. For example, creating a list of only even numbers becomes remarkably simple. While traditional for loops might be easier for beginners to understand initially, list comprehensions typically execute faster and encourage a more functional programming style. They're particularly valuable when transforming data or extracting specific elements from existing collectionsâ€”tasks that are common in data analysis and processing.
:::

# Finding Information in Lists

* `index()`: Find the position of an item
  * `my_list.index('hello')` â†’ returns the index
* `count()`: Count occurrences of an item
  * `my_list.count(2)`
* `in` operator: Check if an item exists
  * `if 'hello' in my_list:`
* `len()`: Get the length of a list
  * `len(my_list)`

::: {.notes}
Extracting information from lists is a crucial skill for effective programming. The `index()` method helps you locate where a specific value appears in a list, which is particularly useful when you need to find and then modify or remove elements. Be aware that this method raises an error if the value isn't found, so it's often used with the `in` operator as a safety check.

The `count()` method provides a quick way to count how many times a specific value appears, which is valuable for data analysis tasks. The `in` operator offers a readable way to check for existence, making your code more intuitive. Finally, the built-in `len()` function gives you the total number of elements in a list, which is essential for loop control and validation. These tools for finding information enable you to make informed decisions about how to process your list data.
:::

# Advanced List Operations

* Copying lists properly: `new_list = old_list.copy()`
* Nested lists for multi-dimensional data
* Unpacking lists: `a, b, c = [1, 2, 3]`
* List as arguments: `function(*my_list)`
* Using `map()` and `filter()` with lists

::: {.notes}
As you become more comfortable with basic list operations, several advanced techniques can enhance your programming toolkit. Proper list copying is essential to avoid unintended side effectsâ€”using `copy()` creates a new list rather than just another reference to the same list. This distinction is crucial when modifying data, as changes to a copied list won't affect the original.

Nested lists provide a way to represent multi-dimensional data, such as grids or matrices. List unpacking offers an elegant syntax for assigning multiple variables at once, while the star operator (`*`) lets you use list elements as individual arguments to functions. Functions like `map()` and `filter()` provide functional programming approaches to list transformation. These advanced operations might seem complex initially, but they make your code more expressive and efficient once mastered.
:::

# Practical List Applications

* Data collection and storage
* Building user interfaces and menus
* Implementing algorithms (queues, stacks)
* Data analysis and transformation
* Working with external data sources
* List processing in real-world projects

::: {.notes}
Let's connect our technical knowledge to practical applications. Lists appear everywhere in real-world programmingâ€”they're the backbone of data collection systems, where information is gathered and stored for further processing. In user interfaces, lists often represent menu options or collections of UI elements that need to be managed dynamically.

From an algorithmic perspective, lists can implement fundamental data structures like queues and stacks, enabling complex operations like tracking history or managing order-dependent processes. In data analysis, lists frequently serve as intermediate structures during transformation pipelines. Whether you're developing a simple script to process CSV files or building complex applications that interact with databases, understanding list manipulation techniques will significantly improve your ability to write efficient, maintainable code.
:::

# Summary and Best Practices

* Choose the right list method for each task
* Consider performance implications for large lists
* Use list comprehensions for cleaner code
* Remember that lists are mutable (modifiable)
* Balance readability and efficiency
* Practice with real-world examples

::: {.notes}
As we conclude our exploration of Python lists, remember that the choice of list method significantly impacts both code readability and performance. For large datasets, operations like `insert()` at the beginning of a list can be costly, while `append()` at the end is typically very efficient. Understanding these performance characteristics helps you write more optimised code.

List comprehensions offer a powerful balance between conciseness and readability, but don't sacrifice clarity for brevity. Always keep in mind that lists are mutable, meaning they can be modified after creationâ€”this is both a strength and a potential source of bugs if not managed carefully. The best way to master list manipulation is through practice with real data and real problems. As you apply these techniques in your projects, you'll develop an intuitive sense for which approaches work best in different scenarios.
:::---
title: "The Power of Lists: Building Your Data Collection Toolkit"
subtitle: "Mastering the Fundamentals of Creating and Accessing Data Collections"
author: "Michael Borck"
format:
   pptx:
     reference-doc: ../../../_assets/template.pptx
   pdf:
     toc: false
     colorlinks: true
   docx:
     toc: false
     highlight-style: github
   html:
     toc: true
     toc-expand: 2
     embed-resources: true
---

# The Power of Lists

* Lists are ordered collections of items
* One of the most versatile data structures in programming
* Foundation for many applications
* Essential skill for any programmer

::: {.notes}
Welcome to our presentation on list fundamentals! Lists are one of the most powerful tools in programming, allowing us to store and organise multiple items in a single variable. Whether you're building a simple to-do application or analysing complex datasets, understanding lists is essential.

Today, we'll explore how to create and access data within lists. We won't be covering loops yetâ€”that's coming in the next moduleâ€”but you'll learn everything you need to start working with collections of data effectively. These skills form the foundation for more advanced programming concepts we'll explore later.
:::

# Creating Lists

* Lists can contain multiple values in a single variable
* Created using square brackets `[]`
* Can contain any data type (numbers, strings, etc.)
* Elements are separated by commas

```python
# Empty list
my_list = []

# List of numbers
numbers = [1, 2, 3, 4, 5]

# List of strings
colours = ["red", "green", "blue"]

# Mixed data types
mixed = [42, "hello", True, 3.14]
```

::: {.notes}
Creating lists in Python is straightforward. You simply use square brackets and separate individual items with commas. What makes lists particularly flexible is their ability to hold different types of dataâ€”you can store numbers, strings, booleans, or even other lists within a list.

Think of a list like a shopping list, where each item is stored in sequence. This ordering is important, as we'll see when we discuss accessing list elements. When you're just starting out, experiment with creating different types of lists to get comfortable with the syntax. Try making lists of your favourite foods, films, or any collection of items that interests you.
:::

# List Indexing

* Accessing individual elements using indices
* Indices start at 0 (first element is at position 0)
* Use square brackets with the index number
* Negative indices count from the end (-1 for last element)

```python
fruits = ["apple", "banana", "cherry", "date"]

# Accessing elements
first_fruit = fruits[0]  # "apple"
second_fruit = fruits[1]  # "banana"
last_fruit = fruits[-1]  # "date"
```

::: {.notes}
Understanding list indexing is crucial when working with lists. In Python (and most programming languages), we count positions starting from 0, not 1. This means the first element is at index 0, the second at index 1, and so on. This zero-based indexing can be confusing at first, but it quickly becomes second nature.

A helpful feature in Python is the ability to use negative indices to access elements from the end of the list. For example, -1 refers to the last element, -2 to the second-last, and so forth. This is particularly useful when you don't know the exact length of a list but need to access its final elements. When teaching beginners about indexing, I often recommend visualising the list with position numbers written above each element to reinforce this concept.
:::

# List Slicing

* Extract multiple elements from a list
* Syntax: `list_name[start:end]`
* Returns elements from `start` up to (but not including) `end`
* Omitting `start` begins from index 0
* Omitting `end` goes until the end of the list

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

first_three = numbers[0:3]  # [0, 1, 2]
middle = numbers[3:7]      # [3, 4, 5, 6]
last_four = numbers[-4:]    # [6, 7, 8, 9]
every_second = numbers[::2] # [0, 2, 4, 6, 8]
```

::: {.notes}
List slicing extends the concept of indexing to allow us to access a range of elements at once. The syntax `list_name[start:end]` creates a new list containing elements from the start index up to, but not including, the end index. This "up to but not including" pattern is common in programming and takes some getting used to.

Slicing offers incredible flexibility. You can omit the start index to slice from the beginning, omit the end index to slice until the end, or even use a third parameter (as in `numbers[::2]`) to specify a step value, which lets you take every nth element. Think of slicing as cutting pieces from a loaf of breadâ€”you specify where to start cutting and where to stop, and you get everything in between.
:::

# List Methods

* Functions built into lists
* Common methods for adding items:
  * `append()` - adds an item to the end
  * `insert()` - adds an item at a specific position
* Common methods for removing items:
  * `remove()` - removes a specific value
  * `pop()` - removes and returns an item at a specific index

```python
shopping = ["bread", "milk"]

# Adding items
shopping.append("eggs")        # ["bread", "milk", "eggs"]
shopping.insert(0, "butter")   # ["butter", "bread", "milk", "eggs"]

# Removing items
shopping.remove("milk")        # ["butter", "bread", "eggs"]
last_item = shopping.pop()     # ["butter", "bread"], last_item = "eggs"
```

::: {.notes}
List methods provide powerful tools for manipulating lists. These built-in functions let you modify lists in various ways without having to write complex code. Understanding these methods is essential for effective list manipulation.

The append and insert methods allow you to add items to a list. Append is simpler, always adding to the end, while insert gives you more control by specifying the exact position. For removing items, remove lets you specify the value to remove, while pop removes an item at a specific position and returns it, which can be useful when you need to use the removed value. Think of these methods as different ways to modify your shopping listâ€”adding forgotten items or crossing off items you've already purchased.
:::

# List Properties

* Lists are mutable (can be changed after creation)
* Lists maintain order of elements
* Lists can contain duplicate values
* Finding the length with `len()`
* Checking for values with `in`

```python
numbers = [3, 1, 4, 1, 5, 9]

# Modifying elements
numbers[0] = 10          # [10, 1, 4, 1, 5, 9]

# Length of list
length = len(numbers)    # 6

# Checking membership
has_five = 5 in numbers  # True
has_seven = 7 in numbers # False
```

::: {.notes}
Understanding list properties helps you work with them effectively. Unlike some data structures, lists are mutable, meaning you can change their contents after creating them. This makes them incredibly flexible for storing data that might need to change.

Lists also maintain the order of elements, which is crucial for many applications. The `len()` function tells you how many elements are in a list, while the `in` operator lets you check if a specific value exists in the list. These features are particularly useful when validating data or implementing search functionality. Whenever you're working with collections of data that need to maintain order and might require modifications, lists are often the go-to data structure.
:::

# Lists vs Other Data Types

* String: ordered collection of characters (immutable)
* Tuple: ordered collection like lists (immutable)
* Dictionary: key-value pairs (unordered in older Python versions)
* Set: unordered collection of unique elements

```python
# Comparison
my_list = [1, 2, 3]           # Mutable, ordered
my_tuple = (1, 2, 3)          # Immutable, ordered
my_dict = {"a": 1, "b": 2}    # Key-value pairs
my_set = {1, 2, 3}            # Unique elements only
```

::: {.notes}
While lists are incredibly versatile, they're just one of several collection types in Python. Understanding the differences between these types helps you choose the right tool for specific tasks. Strings, like lists, are ordered collections, but they're specifically for text and are immutable (cannot be changed after creation). Tuples are similar to lists but immutable, making them useful when you want to ensure data doesn't change.

Dictionaries use key-value pairs instead of indices, allowing you to access elements by name rather than position. Sets are collections of unique elements with no duplicates allowed. Each type has its strengthsâ€”lists excel when you need an ordered collection that can change, tuples when order matters but immutability is required, dictionaries when you need named access, and sets when you only care about unique membership. In real-world programming, you'll often use multiple types together to solve complex problems.
:::

# Common List Operations

* Joining two lists with `+`
* Repeating lists with `*`
* Finding an item's index with `index()`
* Counting occurrences with `count()`
* Sorting lists with `sort()` or `sorted()`

```python
list1 = [1, 2, 3]
list2 = [4, 5, 6]

# Combine lists
combined = list1 + list2      # [1, 2, 3, 4, 5, 6]

# Repeat lists
repeated = list1 * 3          # [1, 2, 3, 1, 2, 3, 1, 2, 3]

numbers = [3, 1, 4, 1, 5]
position = numbers.index(4)   # 2
occurrences = numbers.count(1) # 2
numbers.sort()                # [1, 1, 3, 4, 5]
```

::: {.notes}
Beyond basic creation and access, Python provides many powerful operations for working with lists. The `+` operator joins lists together, while `*` lets you repeat a list multiple times. The `index()` method finds the position of an item (returning the first occurrence if duplicates exist), and `count()` tells you how many times an item appears in a list.

Sorting is another common operation, with two main approaches: `sort()` modifies the original list in place, while `sorted()` returns a new sorted list without changing the original. These operations give you tremendous flexibility when manipulating collections of data. For instance, when building a playlist app, you might use `+` to combine genre-specific lists, `index()` to find a specific song, and `sort()` to arrange songs alphabetically.
:::

# Practical Applications of Lists

* Storing collections of related items
* Building data-driven applications
* Managing user inputs
* Implementing data structures (stacks, queues)
* Foundation for data analysis

```python
# Example: Simple to-do list application
todo_list = []

# Add tasks
todo_list.append("Complete assignment")
todo_list.append("Read chapter 5")
todo_list.append("Prepare for quiz")

# Mark a task as complete (remove it)
todo_list.remove("Read chapter 5")

# Current tasks: ["Complete assignment", "Prepare for quiz"]
```

::: {.notes}
Lists have countless practical applications in real-world programming. In fact, they're so fundamental that it's hard to imagine building modern applications without them. From simple to-do lists to complex data analysis, lists provide the structure needed to organise and manipulate collections of data.

As a beginner, implementing a basic to-do list application is an excellent way to practise list operations. You can add tasks with `append()`, remove completed tasks with `remove()`, and display the current list to the user. This simple example demonstrates how lists facilitate data management in applications. As you advance, you'll use lists as building blocks for more complex data structures like stacks (last-in, first-out) and queues (first-in, first-out), which have applications in everything from browser history management to printer job scheduling.
:::

# Next Steps

* In the next module: loops for iterating through lists
* Future topics:
  * List comprehensions
  * Nested lists (lists within lists)
  * Advanced list operations
  * Working with libraries that use lists (NumPy, Pandas)
* Practice is key to mastery!

::: {.notes}
Today we've covered the fundamentals of creating and accessing lists, but this is just the beginning of your journey. In the next module, we'll explore loops, which will allow you to process every element in a list automaticallyâ€”a crucial skill for working with larger collections of data.

As you continue learning, you'll encounter more advanced list concepts like list comprehensions (a concise way to create lists), nested lists (lists containing other lists), and powerful libraries built around list-like structures. The skills you've learned today form the foundation for all of this future learning. I encourage you to practice regularly by creating small programs that use listsâ€”perhaps a contact list, a music playlist, or a collection of your favourite quotes. Remember, programming is like learning an instrument: regular practice leads to mastery.
:::---
title: "The Power of Repetition: Mastering Loop Structures"
subtitle: "Understanding For and While Loops in Programming"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to Loop Structures

* Programming often requires repeating actions
* Loops are control structures that automate repetition
* Two primary loop types: For loops and While loops
* Essential for efficient, scalable code
* Foundational concept for all programming languages

::: {.notes}
Welcome to our presentation on loop structures! When writing programs, we frequently encounter situations where we need to perform the same action multiple times. Rather than writing the same code over and over, programming languages provide loop structures to handle repetition efficiently. 

In this presentation, we'll focus on the two most common loop types: For loops and While loops. Understanding these structures is fundamental to programming as they appear in virtually every programming language and are used in countless applications, from simple counters to complex data processing algorithms. Mastering loops will significantly enhance your ability to write clean, efficient code.
:::

# The Problem: Why We Need Loops

* Manual repetition is tedious and error-prone
* Consider checking 1,000 numbers for even/odd status
* Without loops:
  * Write the same code 1,000 times
  * Hard to maintain and update
* With loops:
  * Write the logic once
  * Let the computer handle repetition

::: {.notes}
Imagine you need to check whether each number in a list of 1,000 numbers is even or odd. Without loops, you would need to write the same checking code 1,000 timesâ€”a tedious and error-prone approach. If you later discovered a bug in your logic, you'd need to fix it in all 1,000 places!

Loops solve this problem elegantly by allowing you to write the logic once and then instruct the computer to repeat it as many times as needed. This not only makes your code more concise and readable but also much easier to maintain. When your requirements change, you only need to update the logic in one place, and the loop will apply that updated logic to all iterations.
:::

# For Loops: Concept and Structure

* Used when the number of iterations is known beforehand
* Components of a For loop:
  * Initialisation (starting value)
  * Condition (when to stop)
  * Update statement (how to change the counter)
* Executes a specific number of times
* Common uses: iterating over collections, counting

::: {.notes}
For loops are the perfect choice when you know exactly how many times you need to repeat an action. They follow a clear structure with three key components: initialisation (where we set our starting point), a condition (that determines when to stop), and an update statement (that changes our counter with each iteration).

Think of a For loop like a recipe that says "stir the mixture 20 times." You know exactly how many stirs to perform before you start. For loops are commonly used to process elements in a collection (like items in a list), perform actions a set number of times, or count up or down between specific values. Their predictable nature makes them easy to understand and reason about.
:::

# For Loop: Python Example

* Basic syntax in Python:

```python
for variable in sequence:
    # Code to repeat
```

* Example: Printing numbers 1 through 5

```python
for i in range(1, 6):
    print(i)
# Output: 1 2 3 4 5
```

* Example: Iterating through a list

```python
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print("I like " + fruit)
```

::: {.notes}
The Python For loop has a straightforward syntax that makes it particularly readable. The loop variable (often named 'i' for 'index', or something more descriptive like 'fruit') takes on each value in the specified sequence, one at a time, and the indented code block executes once for each value.

The `range()` function is frequently used with For loops to generate a sequence of numbers. In our first example, `range(1, 6)` creates a sequence from 1 up to (but not including) 6, so the loop prints numbers 1 through 5. In the second example, we iterate directly through a list of fruits, demonstrating how loops can work with different data types. This flexibility makes For loops incredibly versatile for all kinds of repetitive tasks.
:::

# While Loops: Concept and Structure

* Used when the number of iterations is unknown beforehand
* Continues as long as a specified condition is true
* Components:
  * Initialisation (before the loop)
  * Condition (when to continue)
  * Update statement (inside the loop)
* May execute zero or many times
* Requires careful condition design to avoid infinite loops

::: {.notes}
While loops are fundamentally different from For loops because they're designed for scenarios where you don't know in advance how many iterations you'll need. Instead of counting, a While loop continues executing as long as its specified condition remains true. This makes While loops particularly useful for situations that depend on user input, external data, or complex conditions.

The structure of a While loop requires careful attention. You typically initialise variables before the loop begins, check a condition at the start of each iteration, and include statements inside the loop that eventually change the condition to false. If you forget to update the condition, you might create an "infinite loop" that never endsâ€”a common beginner mistake. While loops give you more flexibility but also require more responsibility to ensure they terminate properly.
:::

# While Loop: Python Example

* Basic syntax in Python:

```python
while condition:
    # Code to repeat
    # Update condition
```

* Example: Counting to 5

```python
count = 1
while count <= 5:
    print(count)
    count += 1
# Output: 1 2 3 4 5
```

* Example: User input validation

```python
password = ""
while password != "secret":
    password = input("Enter password: ")
print("Access granted")
```

::: {.notes}
In Python, While loops begin with the keyword "while" followed by a condition that evaluates to either True or False. As long as the condition is True, the indented code block continues to execute. Notice that in our counting example, we need to manually initialise the counter before the loop and increment it inside the loopâ€”steps that For loops handle automatically.

The second example demonstrates a practical application of While loops: validating user input. The loop continues asking for a password until the user enters the correct one. This kind of interaction couldn't easily be handled with a For loop because we don't know how many attempts the user will need. While loops excel at these open-ended scenarios where the number of iterations depends on dynamic conditions.
:::

# Choosing the Right Loop

* For loops: Best when you know the number of iterations
  * Iterating through collections
  * Counting a specific number of times
  * Processing sequences

* While loops: Best for conditional repetition
  * User input validation
  * Waiting for a condition to be met
  * Unknown number of iterations

* Both can often solve the same problem in different ways

::: {.notes}
Choosing between For and While loops is an important skill that improves with practice. Generally, if you can answer the question "How many times will this loop run?" before the loop starts, a For loop is probably the better choice. For loops are typically more concise and less prone to errors since they handle the initialisation and incrementation automatically.

While loops shine in situations where the termination depends on a condition that can't be predicted in advance. They're perfect for scenarios like processing input until the user enters a specific value, or running a simulation until a certain state is reached. Remember that most problems can be solved with either type of loop, but choosing the appropriate one will make your code clearer and more maintainable.
:::

# Common Loop Patterns

* Loop control statements:
  * `break`: Exit the loop immediately
  * `continue`: Skip to the next iteration
  
* Nested loops: Loops within loops
  * Useful for working with multi-dimensional data
  
* Accumulators: Building results during iteration
  * Summing values, collecting results

* Loop and a half: Checking conditions mid-loop

::: {.notes}
Beyond the basic loop structures, several common patterns appear frequently in programming. The `break` statement allows you to exit a loop immediately when a certain condition is met, while `continue` lets you skip the rest of the current iteration and move to the next one. These control statements are powerful tools for making your loops more efficient.

Nested loopsâ€”placing one loop inside anotherâ€”are essential for working with multi-dimensional data structures like matrices or tables. Accumulators are variables that collect or combine results during iteration, such as summing numbers or building a list of results. The "loop and a half" pattern addresses situations where you need to check conditions in the middle of processing each item. These patterns build on the basic loop structures to solve more complex problems elegantly.
:::

# Loop Pitfalls and Best Practices

* Common mistakes to avoid:
  * Infinite loops (forgetting to update condition)
  * Off-by-one errors (including or excluding endpoints)
  * Inefficient loop designs

* Best practices:
  * Keep loops simple and focused
  * Use meaningful variable names
  * Consider performance for large datasets
  * Test boundary conditions (first/last iterations)

::: {.notes}
Loops can be tricky, especially for beginners. Infinite loops occur when the termination condition is never met, causing your program to hang indefinitely. Off-by-one errors happen when you mistakenly include or exclude an element at the boundaries of your iteration rangeâ€”for example, iterating from 0 to 9 when you meant 1 to 10. These bugs can be subtle and frustrating to track down.

Following best practices can help you avoid these pitfalls. Keep your loops focused on a single task, use variable names that clearly indicate their purpose (e.g., `student_index` rather than just `i`), and consider the performance implications when working with large datasets. Always test your loops with attention to the boundary conditionsâ€”what happens on the first and last iterations? Taking these precautions will help you write more reliable loop structures.
:::

# Summary and Further Practice

* Loops are essential programming constructs
* For loops: Use when the iteration count is known
* While loops: Use for condition-based repetition
* Practice is key to mastery
* Next steps:
  * Experiment with different loop types
  * Solve problems using loops
  * Learn about loop variants in different languages

::: {.notes}
We've covered the fundamental concepts of For and While loops, examining their structures, use cases, and some common patterns and pitfalls. Remember that For loops are best when you know the number of iterations in advance, while While loops excel when the repetition depends on a condition that may change dynamically.

To truly master loops, there's no substitute for practice. Try rewriting While loops as For loops and vice versa to understand their differences and similarities. Tackle programming challenges that involve repetition, such as processing lists, validating input, or implementing algorithms. As you progress, you'll also encounter variations of these basic loop structures in different programming languages, but the core concepts you've learned today will remain relevant regardless of the language you use.
:::---
title: "Staff Answer Guide: ColabTurtlePlus Worksheet"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---



## Setup Checklist

- Ensure ColabTurtlePlus is installed on all student machines with `pip install ColabTurtlePlus`
- If using Google Colab, have students run `!pip install ColabTurtlePlus` in a code cell at the beginning
- Verify internet connectivity for SVG rendering
- Have the second worksheet (Chatbot) ready for the second hour

## Expected Learning Outcomes

By the end of this worksheet, students should be able to:
1. Use basic ColabTurtlePlus commands to create drawings
2. Apply loops to repeat drawing operations
3. Create and manipulate lists of data (colors, coordinates, etc.)
4. Combine loops and lists to create more complex patterns
5. Understand the concept of iteration and how to use it efficiently

## Activity 1: Getting Started with ColabTurtlePlus

### Expected Output
Students should see a window with a turtle that draws a simple square.


### Common Issues
- **Error: No module named 'ColabTurtlePlus'** - Student needs to run the pip install command
- **No output visible** - Check if `done()` was called at the end
- **Square doesn't appear centered** - Check if the setup dimensions are correct and if clearscreen() was called

### Teaching Notes
- The parameters for `setup()` define the width and height of the drawing area
- The `speed()` function accepts values 1-13, with 13 being the fastest
- Point out the difference between creating object-oriented `t = Turtle()` versus procedural style

## Activity 2: Using Lists with ColabTurtlePlus

### Expected Output
Students should see a series of colored lines followed by colored squares.


### Discussion Questions
- What is the advantage of storing the colors in a list rather than setting each color individually?
- How does the index `i` help us access different elements in the colors list?
- What would happen if we had more colors than squares or more squares than colors?

### Teaching Notes
- The list indexing using `colors[i]` is a key concept to emphasize
- Point out how the nested loops work (outer loop for colors, inner loop for drawing squares)
- Discuss the difference between `for color in colors` and `for i in range(len(colors))`

## Activity 3: Nested Loops and Patterns

### Expected Output
Students should see a colorful spiral followed by a pattern of filled circles.


### Code Explanation
- The modulo operator `i % len(spiral_colors)` creates a repeating pattern through the colors list
- The size variable increases by 2 each iteration, creating the expanding spiral
- The positions list contains tuples of (x,y) coordinates for each circle

### Teaching Notes
- The modulo operator is worth explaining in detail as many students find it confusing
- Explain how lists can store different types of data (strings for colors, tuples for positions)
- Discuss how `begin_fill()` and `end_fill()` work together to create filled shapes

## Activity 4: Create Your Own Pattern

### Sample Solution
Here's a sample solution students might create:

```python
clearscreen()
setup(400, 400)
showborder()
t = Turtle()
t.shape("turtle")
t.speed(6)

# Create lists for colors and sizes
my_colors = ["blue", "purple", "teal"]
my_sizes = [20, 40, 60, 80, 100]

# Draw a series of concentric squares with different colors
for i, size in enumerate(my_sizes):
    # Get the color (cycle through if more sizes than colors)
    current_color = my_colors[i % len(my_colors)]
    t.color(current_color)
    
    # Move to starting position for this square
    t.penup()
    t.goto(-size/2, -size/2)  # Bottom left corner of square
    t.pendown()
    
    # Draw the square
    for _ in range(4):
        t.forward(size)
        t.left(90)

# Display the final pattern
done()
```

### Alternative Solution
A different approach students might take:

```python
clearscreen()
setup(400, 400)
showborder()
t = Turtle()
t.shape("turtle")
t.speed(10)

# Create a list of angles for a star
angles = [144, 144, 144, 144, 144]
colors = ["red", "orange", "yellow", "green", "blue"]

# Draw a colorful star
t.penup()
t.goto(0, 50)
t.pendown()

for i in range(5):
    t.color(colors[i])
    t.forward(150)
    t.right(angles[i])

done()
```

### Discussion Points
- How did students choose to organize their lists?
- Did they use nested loops effectively?
- What creative approaches did they take to create interesting patterns?

## Extension: Multiple Turtles and Shapes

### Expected Output
Students should see a gold star and a green triangle drawn by two different turtles.



### Teaching Notes
- Creating multiple turtles with different characteristics is a key feature of ColabTurtlePlus
- The `draw_shape` function is an example of how to reuse code for different shapes
- Lists of coordinates are a powerful way to define complex shapes

### Common Questions
- **Can I have more than two turtles?** Yes, you can create as many as you need
- **How do coordinates work in ColabTurtlePlus?** By default, (0,0) is the center of the screen in "standard" mode
- **How do I save my drawing?** Use `saveSVG()` to save the drawing as an SVG file

## Challenge: Create Something Artistic

### Expected Output
Students should see a colorful flower with multiple petals.


### Key Concepts Demonstrated
- Using loops to create repeating patterns (petals)
- Using modulo to cycle through a color list
- Creating complex shapes with simple geometric operations
- Using fill to create colored regions

## Transition to Chatbot Activity

### Discussion Points
- How are the concepts of loops and lists transferable to other applications?
- What similarities might exist between graphic patterns and conversation patterns?
- How might lists be useful for storing conversation history?

## Assessment Criteria

To evaluate student understanding, look for:

1. **Basic Skills (C grade)**
   - Successfully completes Activities 1 & 2
   - Can create a simple pattern using loops
   - Understands basic list access

2. **Intermediate Skills (B grade)**
   - Successfully completes all required activities
   - Creates an original pattern in Activity 4
   - Uses nested loops effectively
   - Demonstrates understanding of list indexing

3. **Advanced Skills (A grade)**
   - Completes extension activities
   - Creates complex, creative patterns
   - Efficiently combines loops and lists
   - Adds additional features or customizations
   - Can explain code concepts to others

## Common Student Mistakes

1. **Loop Confusion**
   - Forgetting to indent code inside loops
   - Mixing up range() parameters
   - Not understanding when to use nested loops

2. **List Errors**
   - Using an index that's out of range (e.g., accessing element 5 in a 5-item list)
   - Forgetting that indexing starts at 0
   - Not understanding list slicing

3. **Coordinate Confusion**
   - Forgetting that (0,0) is at center of screen
   - Mixing up x and y coordinates
   - Not accounting for the drawing extending beyond screen boundaries

## Time Management

- Activity 1: ~10 minutes
- Activity 2: ~15 minutes
- Activity 3: ~15 minutes
- Activity 4: ~15 minutes
- Extension/Challenge: ~10 minutes

If students are progressing rapidly, encourage them to try the Challenge activity. If they are struggling, focus on ensuring they understand the core concepts in Activities 1-3 before moving on.

## Additional ColabTurtlePlus Features to Highlight

If time permits, you can introduce these additional features:

- Different turtle shapes: `t.shape("arrow")`, `t.shape("circle")`, etc.
- Stamping: `t.stamp()` to leave an impression without drawing a line
- Pen size: `t.pensize(3)` to change line thickness
- Fill rule options: `t.fillrule("evenodd")` vs `t.fillrule("nonzero")`
- SVG saving: `saveSVG()` to export drawings

## Preparation for Hour 2 (Chatbot)

Before transitioning to the chatbot activity, ensure:
- All students have completed at least through Activity 3
- Students understand the basic concepts of loops and lists
- You've discussed how these concepts will apply to the next activity
- Everyone has access to the `simple_bot` package for the next portion---
title: "Staff Answer Guide: Build-A-Bot Worksheet"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


## Setup Checklist

- Ensure the `simple_bot` package is properly installed and accessible to all students
- Verify that the local Ollama server is running and accessible
- Test the connection to ensure `get_response()` works correctly
- Have sample responses prepared in case the AI service is unavailable

## Expected Learning Outcomes

By the end of this worksheet, students should be able to:
1. Use loops to create continuous interactions with a chatbot
2. Create and manipulate lists to store conversation history
3. Implement basic command structures using conditionals and lists
4. Apply the concepts of loops and lists to a conversational interface
5. Understand how to provide context to an AI using previous messages

## Activity 1: One-Shot Bot Response

### Expected Output
Students should successfully import the `simple_bot` package and get a single response from the AI.

```
Ask the bot something: What is Python?
Bot: Python is a high-level, interpreted programming language known for its readability and simplicity. It supports multiple programming paradigms including procedural, object-oriented, and functional programming. Python is widely used for web development, data analysis, artificial intelligence, scientific computing, and automation.
```

### Common Issues
- **ImportError**: Student needs to check that `simple_bot` is correctly installed
- **No response from bot**: Check connection to Ollama server
- **Delayed response**: Reassure students that the first response might take longer as the model loads

### Teaching Notes
- Explain that `get_response()` sends the text to an AI model running locally on the Ollama server
- Point out that this is a simple sequential execution - one question, one answer
- Ask students to identify limitations of this approach (doesn't remember context, can't have a conversation)

## Activity 2: Creating a Looping Bot

### Expected Output
Students should see a continuous conversation loop that exits when they type 'bye', 'quit', or 'exit'.

```
Welcome to LoopBot! Ask me anything! Type 'bye' to quit.
You: Hello
Bot: Hello! How can I assist you today?
You: What can you do?
Bot: I'm a simple AI assistant trained to have conversations and answer questions. I can provide information, help with tasks, offer suggestions, and engage in casual discussion. Feel free to ask me anything!
You: bye
Bot: Goodbye! ðŸ‘‹
```

### Code Explanation
- The `while True:` creates an infinite loop that continues until explicitly broken
- The `if user_input.lower() in ["bye", "quit", "exit"]:` checks for exit commands
- The `break` statement exits the loop when an exit command is detected
- Each iteration of the loop gets new input and displays a response

### Teaching Notes
- Emphasize how the loop creates continuous interaction
- Discuss the importance of providing an exit condition to break out of infinite loops
- Ask students how this improves upon the one-shot approach from Activity 1

## Activity 3: Adding Memory with Lists

### Expected Output
Students should see a bot that remembers previous inputs and can report on its memory when asked.

```
Welcome to MemoryBot! I'll try to remember what you say.
You: Hello
Bot: Hello! How can I assist you today?
You: My name is Alex
Bot: Nice to meet you, Alex! How can I help you today?
You: what do you remember
Bot memory contains:
  1. Hello
  2. My name is Alex
  3. what do you remember
You: bye
Bot: Chat ended. I remembered 3 messages. Bye! ðŸ‘‹
```

### Code Explanation
- `memory = []` creates an empty list to store the conversation history
- `memory.append(user_input)` adds each new input to the memory list
- `len(memory)` returns the number of items stored in the list
- `for i, message in enumerate(memory):` loops through each item in the memory list with its position

### Common Questions
- **Why does the bot repeat my last message?** Because we're appending the message to memory before getting a response
- **What would happen if we store thousands of messages?** Memory usage would increase and could potentially slow down the program
- **Does the AI see all the remembered messages?** In this implementation, the AI only sees the current message, not the memory

## Activity 4: Enhanced Memory Bot Challenge

### Sample Solution
Here's a complete implementation that students might create:

```python
# Your enhanced memory bot implementation
print("\nYour Advanced MemoryBot! Type 'help' for commands.")

# Import the needed package
from simple_bot import get_response

# Create your lists and initialize variables here
memory = []
commands = ["help", "memory", "clear", "bye"]

# Write your loop here
while True:
    user_input = input("You: ")
    
    # Implement the command handling
    if user_input.lower() == "bye":
        print("Bot: Goodbye!")
        break
    elif user_input.lower() == "help":
        print("Available commands:", ", ".join(commands))
    elif user_input.lower() == "memory":
        if memory:
            print("I remember these messages:")
            for i, msg in enumerate(memory):
                print(f"  {i+1}. {msg}")
        else:
            print("My memory is empty!")
    elif user_input.lower() == "clear":
        memory = []
        print("Memory cleared!")
    else:
        # Add message to memory
        memory.append(user_input)
        
        # Keep only the last 3 items using list slicing
        if len(memory) > 3:
            memory = memory[-3:]
            
        # Join the memory items with newlines to create context
        context = "\n".join(memory)
        
        # Send the context to get a more informed response
        response = get_response(context)
        print("Bot:", response)
        print(f"(Memory size: {len(memory)} messages)")
```

### Alternative Approach
A different approach might use a dictionary to track both user inputs and bot responses:

```python
from simple_bot import get_response

print("\nDual Memory Bot! Type 'help' for commands.")

# Track both sides of the conversation
conversation = {
    "user": [],
    "bot": []
}
commands = ["help", "history", "clear", "bye"]

while True:
    user_input = input("You: ")
    
    if user_input.lower() == "bye":
        print("Bot: Chat ended. Goodbye!")
        break
    elif user_input.lower() == "help":
        print("Available commands:", ", ".join(commands))
    elif user_input.lower() == "history":
        if conversation["user"]:
            print("Conversation history:")
            for i in range(len(conversation["user"])):
                print(f"  You: {conversation['user'][i]}")
                print(f"  Bot: {conversation['bot'][i]}")
        else:
            print("No conversation history yet!")
    elif user_input.lower() == "clear":
        conversation = {"user": [], "bot": []}
        print("History cleared!")
    else:
        # Add to user history
        conversation["user"].append(user_input)
        
        # Create context from the last 3 exchanges
        if len(conversation["user"]) > 3:
            conversation["user"] = conversation["user"][-3:]
            conversation["bot"] = conversation["bot"][-3:]
            
        # Create context string with both user and bot messages
        context = ""
        for i in range(len(conversation["user"])-1):
            context += f"User: {conversation['user'][i]}\n"
            context += f"Bot: {conversation['bot'][i]}\n"
        context += f"User: {conversation['user'][-1]}"
        
        # Get response
        response = get_response(context)
        print("Bot:", response)
        
        # Add to bot history
        conversation["bot"].append(response)
```

### Key Concepts to Look For
- Proper handling of commands using conditionals
- Use of list methods (append, slicing with [-3:])
- Properly joining messages into context
- Checking for empty lists before trying to display them
- Displaying relevant information to the user

## Extension: Personality Bot Challenge

### Expected Output
Students should be able to switch between different bot personalities.

```
Multi-Personality Bot! Type 'personalities' to see options.
You: personalities
Available personalities: regular, pirate, emoji, formal
To change, type 'switch to [personality]'
You: switch to pirate
Bot: Switched to pirate personality!
You: What is Python?
PirateBot: Arrr, matey! Python be a programmin' language that's easy to learn and powerful to use! Many a scallywag starts their codin' journey with it! Treasure be waitin'!
```

### Solution Explanation
- `personalities = ["regular", "pirate", "emoji", "formal"]` stores available options
- `current_personality = "regular"` tracks which personality is active
- `startswith()` checks if the input begins with "switch to"
- A conditional structure selects the right function based on the current personality

### Common Issues
- Forgetting to import the personality functions (`pirate_bot`, `emoji_bot`)
- Not checking if the requested personality exists in the list
- Confusion about string methods like `startswith()` and `replace()`

## Creating Custom Bot Personalities

### Sample Implementation
Here's how students might implement a custom bot personality:

```python
from simple_bot import get_response

# Define a custom personality
def wise_dragon_bot(message):
    return get_response(message, system="You are a wise old dragon who answers questions in riddles and ancient wisdom.")

print("\nWise Dragon Bot Test:")
print(wise_dragon_bot("How do I debug my code?"))
```

### Expected Output
```
Wise Dragon Bot Test:
To untangle the webs of code that confound thee, young seeker, first thou must observe with patience. Look for the tracks of thy preyâ€”the elusive bugâ€”in the sands of thy console output. Set traps with print statements to reveal its hiding place. Break thy journey into smaller quests, testing each portion of thy code in isolation. Remember, even the mightiest dragon must sometimes step back to see the entire mountain. In the ancient scrolls, it is written: "To understand the bug, one must become the bug." Walk through thy code as the machine would, one instruction at a time, and the truth shall reveal itself.
```

### Teaching Notes
- Explain that the `system` parameter gives instructions to the AI about how to respond
- Discuss the concept of "persona" in AI interactions
- Encourage creativity while keeping responses appropriate

## Assessment Criteria

To evaluate student understanding, look for:

1. **Basic Skills (C grade)**
   - Successfully implements the looping bot
   - Can add items to a list for memory
   - Uses basic conditionals for commands

2. **Intermediate Skills (B grade)**
   - Successfully implements the enhanced memory bot
   - Correctly uses list slicing to limit memory
   - Properly provides context to the AI
   - Implements multiple commands correctly

3. **Advanced Skills (A grade)**
   - Implements the personality switching functionality
   - Creates custom personalities with the system parameter
   - Adds creative extensions to the basic requirements
   - Code is well-organized and commented

## Common Student Mistakes

1. **Loop Control Flow Issues**
   - Forgetting to include a break statement for exit commands
   - Adding too many nested conditions making code difficult to follow
   - Not handling edge cases (empty input, unexpected commands)

2. **List Management Errors**
   - Attempting to access indexes that don't exist
   - Not checking if the list is empty before trying to display it
   - Incorrect use of slicing syntax to limit the memory size

3. **Context Building Problems**
   - Not properly joining the list items with newlines
   - Sending too much context to the AI (causing confusion)
   - Not providing enough context to maintain conversation flow

## Time Management

- Activity 1: ~5 minutes
- Activity 2: ~10 minutes
- Activity 3: ~15 minutes
- Activity 4: ~20 minutes
- Extension: ~10 minutes

If students are progressing rapidly, encourage them to implement additional features like:
- Error handling for API connection issues
- Saving conversation history to a file
- Loading different system prompts from a configuration file

## Connecting Back to Turtle Graphics

Help students see the parallels between the two worksheets:
- Both use loops to repeat actions (drawing shapes vs. continuing conversation)
- Both use lists to store collections (colors/coordinates vs. message history)
- Both combine loops and lists to create more complex behavior

## Stretch Goals for Advanced Students

If some students finish early, suggest these extensions:
- Implement a chat log feature that saves conversations to a file
- Create a menu of different personalities the bot can switch between
- Add a feature to summarize the conversation so far
- Create a "reset context" command that keeps the memory but starts a fresh conversation

## Troubleshooting the `simple_bot` Package

If students encounter issues with the `simple_bot` package:

1. **ImportError**
   - Verify the package is installed correctly
   - Check for typos in the import statement

2. **Connection Issues**
   - Ensure the Ollama server is running
   - Check for network connectivity issues

3. **Slow Responses**
   - Remind students the first response may be slow as the model loads
   - Suggest using shorter prompts for testing

4. **API-Related Errors**
   - Have a backup activity ready if the API service is down
   - Consider implementing a simple mock version of `get_response()` that returns fixed responses

## Final Project Ideas

To extend learning beyond the workshop, suggest these project ideas:
1. Create a specialized bot for a specific domain (sports, cooking, etc.)
2. Build a chatbot that can play a text-based game
3. Combine the turtle graphics with the chatbot to create a drawing assistant
4. Create a study helper bot that quizzes students on course material

## Reflection Questions for Wrap-up

End the session with these discussion questions:
1. How did using loops make your program more interactive?
2. How did lists help you create a more intelligent conversation?
3. What similarities did you notice between the two activities?
4. How might you use these concepts in other programming projects?
5. What was the most challenging part of building your chatbot?---
title: STAFF ANSWER Weather Presenter Bot Mini-Project (Student Version)e
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Weather Forecast Analyzer: Staff Answer Guide

## Project Overview
This guide provides complete solutions and teaching notes for the Weather Forecast Analyzer mini-project. This project helps students practice working with lists, loops, conditionals, and basic calculations without requiring dictionaries, classes, or file I/O.

## Complete Solutions

### Task 1: Print Weather Report
```python
def print_weather_report(data):
    print("\n===== WEEKLY WEATHER REPORT =====\n")
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        humidity = day_data[2]
        wind = day_data[3]
        condition_code = day_data[4]
        condition = condition_names[condition_code]
        
        print(f"{day}: {temp}Â°C, {humidity}% humidity, {wind} km/h wind, {condition}")
```

**Key concepts**: Loops, list indexing, f-strings

### Task 2: Find Temperature Extremes
```python
def find_temperature_extremes(data):
    warmest_day = data[0][0]
    warmest_temp = data[0][1]
    coldest_day = data[0][0]
    coldest_temp = data[0][1]
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        
        if temp > warmest_temp:
            warmest_day = day
            warmest_temp = temp
        
        if temp < coldest_temp:
            coldest_day = day
            coldest_temp = temp
    
    return ([warmest_day, warmest_temp], [coldest_day, coldest_temp])
```

**Key concepts**: Variables to track extremes, conditionals, nested lists, return values

### Task 3: Calculate Averages
```python
def calculate_averages(data):
    total_temp = 0
    total_humidity = 0
    total_wind = 0
    days = len(data)
    
    for day_data in data:
        total_temp += day_data[1]
        total_humidity += day_data[2]
        total_wind += day_data[3]
    
    avg_temp = round(total_temp / days, 1)
    avg_humidity = round(total_humidity / days, 1)
    avg_wind = round(total_wind / days, 1)
    
    return [avg_temp, avg_humidity, avg_wind]
```

**Key concepts**: Summation, division, rounding, lists as return values

### Task 4: Count Conditions
```python
def count_conditions(data):
    # Create a list of zeros with the same length as condition_names
    counts = [0] * len(condition_names)
    
    # Loop through the data and increment the count for each condition found
    for day_data in data:
        condition_code = day_data[4]
        counts[condition_code] += 1
    
    return counts
```

**Key concepts**: List creation with multiplication, using list indices as counters

### Task 5: Create Temperature Chart
```python
def create_temperature_chart(data):
    print("\n===== TEMPERATURE CHART =====\n")
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        
        # Create a bar using â–ˆ characters (one per degree)
        temp_bar = "â–ˆ" * temp
        
        print(f"{day}: {temp_bar} ({temp}Â°C)")
```

**Key concepts**: String repetition, text-based visualization

### Task 6: Check Severe Weather
```python
def check_severe_weather(data):
    alerts = []
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        humidity = day_data[2]
        wind = day_data[3]
        condition_code = day_data[4]
        
        # Check for severe conditions
        if condition_code == 4:  # Thunderstorm
            alerts.append(f"Thunderstorm expected on {day}")
        
        if wind > 20:
            alerts.append(f"High winds ({wind} km/h) expected on {day}")
        
        if humidity > 90:
            alerts.append(f"Very high humidity ({humidity}%) expected on {day}")
        
        if temp < 0:
            alerts.append(f"Freezing temperature ({temp}Â°C) expected on {day}")
        elif temp > 35:
            alerts.append(f"Extreme heat ({temp}Â°C) expected on {day}")
    
    return alerts
```

**Key concepts**: Multiple conditions, building lists dynamically, string formatting

### Task 7: Suggest Activities
```python
def suggest_activities(data):
    activities = []
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        condition_code = day_data[4]
        
        # Choose an activity based on weather
        if condition_code == 0:  # Sunny
            if temp > 25:
                activity = "Go to the beach or pool"
            else:
                activity = "Go for a hike or picnic"
        elif condition_code == 1:  # Partly Cloudy
            activity = "Perfect for outdoor sports"
        elif condition_code == 2:  # Cloudy
            activity = "Visit a park or go for a walk"
        elif condition_code == 3:  # Rainy
            activity = "Visit a museum or watch a movie"
        elif condition_code == 4:  # Thunderstorm
            activity = "Stay indoors with a good book"
        elif condition_code == 5:  # Snowy
            activity = "Build a snowman or go sledding"
        else:
            activity = "Check weather again"
        
        activities.append((day, activity))
    
    return activities
```

**Key concepts**: Nested conditionals, tuples, complex decision-making

## Common Student Questions and Answers

### 1. "I'm confused about how to access the weather data. What does `day_data[1]` mean?"
**Answer**: The `weather_data` is a list of lists. Each inner list represents one day's data. When we loop through `weather_data`, each `day_data` is one of those inner lists. So `day_data[0]` is the day name, `day_data[1]` is the temperature, and so on. Think of it like a table where each row is a day, and each column is a different weather attribute.

### 2. "Why do we need to return a tuple with two lists in the `find_temperature_extremes` function?"
**Answer**: The function needs to return two pieces of information: the warmest day and the coldest day. Each of these needs both a day name and a temperature. We put each pair (day name, temperature) in its own list, and then return both lists inside a tuple. This way, when the main function calls it, it can easily unpack both pieces of information with: `warmest, coldest = find_temperature_extremes(weather_data)`.

### 3. "I don't understand the line `counts = [0] * len(condition_names)` in the count_conditions function."
**Answer**: This creates a new list filled with zeros. The `len(condition_names)` tells us how many different weather conditions we have, and the `* len(condition_names)` part repeats the `[0]` that many times. So if we have 6 possible conditions, this creates `[0, 0, 0, 0, 0, 0]`. Then we can use each position to count a specific condition.

### 4. "What does the `â–ˆ` character do in the temperature chart function?"
**Answer**: That's a special character called a "block" that creates a solid bar when printed. By repeating it (using `"â–ˆ" * temp`), we create a visual bar where each block represents one degree Celsius. This gives us a simple visual chart using just text.

### 5. "When I run my code, I get an error that says 'TypeError: can only concatenate str (not "int") to str'. What's wrong?"
**Answer**: This error happens when you try to combine a string and a number directly, like `"Temperature: " + temp`. You need to convert the number to a string first, like `"Temperature: " + str(temp)`. Alternatively, you can use an f-string like `f"Temperature: {temp}"`, which automatically handles the conversion.

### 6. "In the severe weather check, why do we have separate if statements instead of using elif?"
**Answer**: We use separate `if` statements because we want to check for multiple severe conditions that could happen on the same day. With `elif`, only one condition would be checked. For example, a day could be both very hot AND have high winds, and we want to report both of those alerts.

### 7. "Why do we use tuples in the activities list but not in other functions?"
**Answer**: In the `suggest_activities` function, we need to keep two pieces of information together for each day: the day name and the suggested activity. A tuple like `(day, activity)` is a good way to keep these paired. The main function then unpacks these pairs with `for day, activity in activities:`. In other functions, we use lists when we need to modify the data, and tuples when we just need to group related items.

### 8. "I'm having trouble with the for loops. How do I know when to use them?"
**Answer**: Generally, use a for loop when you need to:
- Process each item in a collection (like each day in `weather_data`)
- Perform the same operation multiple times
- Build a new collection based on an existing one
In this project, we often need to process each day's weather data, so we use `for day_data in data:` to go through each day one by one.

### 9. "What's the difference between `return` and `print`?"
**Answer**: `print` displays information to the console but doesn't save it for later use in your program. `return` sends data back from a function so it can be stored in a variable and used later. For example, the `calculate_averages` function returns a list of values that the main function can then use to print specific messages.

### 10. "My temperature chart looks weird. The bars are too long for some temperatures."
**Answer**: If you're testing with very high temperatures, the bars might be too long to display nicely. You could modify the function to scale the bars, for example by dividing the temperature by 2 or using a different character. For example: `temp_bar = "â–ˆ" * (temp // 2)` would make each block represent 2 degrees.

## Teaching Tips

### Understanding List Structure
Draw a table representation of the weather data on the board:

| Index | Day       | Temp | Humidity | Wind | Condition |
|-------|-----------|------|----------|------|-----------|
| 0     | Monday    | 23   | 65       | 8    | 0 (Sunny) |
| 1     | Tuesday   | 21   | 70       | 10   | 1 (Partly)|
| ...   | ...       | ...  | ...      | ...  | ...       |

Explain that `weather_data[0]` gets the first row: `["Monday", 23, 65, 8, 0]`
And `weather_data[0][1]` gets the temperature (23) from that row.

### Demonstrating Loop Patterns
Show the common pattern for processing each day:
```python
for day_data in weather_data:
    # day_data is now each individual day's list
    day_name = day_data[0]
    temperature = day_data[1]
    # ... work with this data
```

### Introducing Testing Techniques
Encourage students to test each function individually:
```python
# Test the print_weather_report function
print_weather_report(weather_data)

# Test the calculate_averages function
averages = calculate_averages(weather_data)
print(f"Average temperature: {averages[0]}Â°C")
```

## Extension Implementation Ideas

### Random Weather Generation
```python
def generate_random_weather():
    days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
    new_data = []
    
    for day in days:
        temp = random.randint(0, 35)
        humidity = random.randint(30, 95)
        wind = random.randint(0, 30)
        condition = random.randint(0, 5)
        
        day_data = [day, temp, humidity, wind, condition]
        new_data.append(day_data)
    
    return new_data
```

### Temperature Trend Analysis
```python
def analyze_temperature_trend(data):
    temperatures = [day[1] for day in data]
    
    # Compare first half with second half
    first_half = sum(temperatures[:len(temperatures)//2]) / (len(temperatures)//2)
    second_half = sum(temperatures[len(temperatures)//2:]) / (len(temperatures) - len(temperatures)//2)
    
    if second_half > first_half:
        return "Getting warmer through the week"
    elif second_half < first_half:
        return "Getting cooler through the week"
    else:
        return "Temperatures are stable through the week"
```

## Assessment Rubric

| Criteria | Excellent (A) | Satisfactory (B/C) | Needs Improvement (D/F) |
|----------|---------------|--------------------|-----------------------|
| **Task Completion** | All 7 functions implemented correctly | 5-6 functions working correctly | Fewer than 5 functions working |
| **Code Logic** | Logic is sound with optimal solutions | Logic works but may not be optimal | Logic has significant flaws |
| **Lists Usage** | Effectively uses lists for all data | Generally uses lists appropriately | Struggles with list operations |
| **Loops** | Correctly implements all required loops | Most loops implemented correctly | Problems with loop implementation |
| **Conditionals** | Uses conditionals effectively and efficiently | Basic conditionals implemented correctly | Incorrect or missing conditions |
| **Creativity** | Highly creative activity suggestions or extensions | Standard activity suggestions | Minimal effort in suggestions |
| **Code Style** | Well-formatted, clear variable names | Generally readable code | Poor formatting, unclear naming |---
title: Weather Presenter Bot Mini-Project (Student Version)e
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Weather Forecast Analyser Mini-Project

## Project Overview
In this mini-project, students will create a program that analyses a week's worth of weather forecast data using only lists and basic Python concepts. The program will perform various calculations and provide insights about the weather patterns.

## Learning Objectives
- Work with lists and nested lists
- Apply selection logic (if/elif/else)
- Use loops to process data
- Perform calculations (min, max, average)
- Generate text-based visualisations
- Practice importing modules

## Starter Code

```python
# Weather Forecast Analyser
# Analyse a week's worth of weather data and provide insights

import random  # For random weather generation
import time    # For program timing and pauses

# Sample weather data for a week
# Format: [day_name, temperature, humidity, wind_speed, condition_code]
# Condition codes: 0=Sunny, 1=Partly Cloudy, 2=Cloudy, 3=Rainy, 4=Thunderstorm, 5=Snowy

weather_data = [
    ["Monday", 23, 65, 8, 0],
    ["Tuesday", 21, 70, 10, 1],
    ["Wednesday", 18, 80, 12, 2],
    ["Thursday", 17, 85, 15, 3],
    ["Friday", 16, 75, 14, 3],
    ["Saturday", 19, 60, 8, 1],
    ["Sunday", 22, 55, 6, 0]
]

# Weather condition names (for translating codes to text)
condition_names = ["Sunny", "Partly Cloudy", "Cloudy", "Rainy", "Thunderstorm", "Snowy"]

# TASK 1: Complete this function to print a formatted weather report
def print_weather_report(data):
    """
    Prints a nicely formatted report of the week's weather
    """
    print("\n===== WEEKLY WEATHER REPORT =====\n")
    
    # Your code here:
    # Loop through the weather data and print each day's information
    # Format example: "Monday: 23Â°C, 65% humidity, 8 km/h wind, Sunny"
    pass

# TASK 2: Complete this function to find the warmest and coldest days
def find_temperature_extremes(data):
    """
    Find the warmest and coldest days of the week
    Returns a tuple with two lists: (warmest_day_info, coldest_day_info)
    """
    # Your code here:
    # Loop through the data to find the day with highest and lowest temperature
    # Return them as a tuple with two elements: ([warmest_day_name, temp], [coldest_day_name, temp])
    pass

# TASK 3: Complete this function to calculate average weather values
def calculate_averages(data):
    """
    Calculate average temperature, humidity, and wind speed for the week
    Returns a list with the three averages: [avg_temp, avg_humidity, avg_wind]
    """
    # Your code here:
    # Loop through the data to sum up the values, then calculate averages
    # Round the averages to one decimal place
    pass

# TASK 4: Complete this function to count the occurrences of each weather condition
def count_conditions(data):
    """
    Count how many days have each weather condition
    Returns a list of counts in the same order as condition_names
    """
    # Your code here:
    # Create a list of seros with the same length as condition_names
    # Loop through the data and increment the count for each condition found
    pass

# TASK 5: Complete this function to create a simple text-based temperature chart
def create_temperature_chart(data):
    """
    Create a simple text-based chart showing temperature for each day
    Each bar should be made of â–ˆ characters, one for each degree Celsius
    """
    print("\n===== TEMPERATURE CHART =====\n")
    
    # Your code here:
    # Loop through the data
    # For each day, print the name and a bar made of â–ˆ characters (one per degree)
    # Example: "Monday: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ (23Â°C)"
    pass

# TASK 6: Complete this function to check if any severe weather is expected
def check_severe_weather(data):
    """
    Check if any severe weather conditions are expected
    Severe weather is defined as:
    - Thunderstorm (condition code 4)
    - High winds (> 20 km/h)
    - Very high humidity (> 90%)
    - Very low or very high temperatures (< 0Â°C or > 35Â°C)
    """
    # Your code here:
    # Loop through the data and check for severe conditions
    # If found, return a list of alerts (strings describing the issues)
    # If none found, return an empty list
    pass

# TASK 7: Complete this function to suggest activities based on the weather
def suggest_activities(data):
    """
    Suggest activities based on the weather for each day
    Returns a list of tuples: [(day_name, activity), ...]
    """
    activities = []
    
    # Your code here:
    # Loop through the data
    # Based on the conditions, temperature, etc., suggest an appropriate activity
    # Append (day_name, activity) tuples to the activities list
    
    return activities

# Main function - already completed for you
def main():
    print("Welcome to the Weather Forecast Analyser!")
    time.sleep(1)
    
    # Print the basic weather report
    print_weather_report(weather_data)
    time.sleep(1)
    
    # Find and display temperature extremes
    warmest, coldest = find_temperature_extremes(weather_data)
    print(f"\nWarmest day: {warmest[0]} ({warmest[1]}Â°C)")
    print(f"Coldest day: {coldest[0]} ({coldest[1]}Â°C)")
    time.sleep(1)
    
    # Calculate and display averages
    avg_temp, avg_humidity, avg_wind = calculate_averages(weather_data)
    print(f"\nWeekly Averages:")
    print(f"Temperature: {avg_temp}Â°C")
    print(f"Humidity: {avg_humidity}%")
    print(f"Wind Speed: {avg_wind} km/h")
    time.sleep(1)
    
    # Count and display weather conditions
    condition_counts = count_conditions(weather_data)
    print("\nWeather Conditions This Week:")
    for i in range(len(condition_names)):
        if condition_counts[i] > 0:
            print(f"{condition_names[i]}: {condition_counts[i]} day(s)")
    time.sleep(1)
    
    # Display temperature chart
    create_temperature_chart(weather_data)
    time.sleep(1)
    
    # Check for severe weather
    severe_alerts = check_severe_weather(weather_data)
    if severe_alerts:
        print("\nâš ï¸ WEATHER ALERTS âš ï¸")
        for alert in severe_alerts:
            print(f"- {alert}")
    else:
        print("\nNo severe weather expected this week.")
    time.sleep(1)
    
    # Suggest activities
    activities = suggest_activities(weather_data)
    print("\nRecommended Activities:")
    for day, activity in activities:
        print(f"{day}: {activity}")

# Run the program
if __name__ == "__main__":
    main()
```

## Project Tasks

Students need to complete the following tasks:

1. **Create a Weather Report**: Format and display the weather data in a readable way.
2. **Find Temperature Extremes**: Determine the warmest and coldest days of the week.
3. **Calculate Weather Averages**: Find average temperature, humidity, and wind speed.
4. **Count Weather Conditions**: Count occurrences of each weather condition type.
5. **Create a Temperature Chart**: Generate a simple text-based bar chart for temperatures.
6. **Check for Severe Weather**: Identify any potentially severe weather conditions.
7. **Suggest Activities**: Recommend activities based on the forecast for each day.

## Extension Challenges

For students who finish early:

1. **Add Weather Data Generation**: Write a function that randomly generates a new week of weather data.
2. **Create a Rain Prediction Model**: Based on humidity and temperature, predict if it might rain.
3. **Implement a Temperature Trend Analysis**: Identify if the week is getting warmer or cooler.
4. **Create a Simple Text-Based Weather Animation**: Use ASCII art to animate weather (e.g., falling rain).

## Sample Solution Guidance

### Task 1: Print Weather Report
```python
def print_weather_report(data):
    print("\n===== WEEKLY WEATHER REPORT =====\n")
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        humidity = day_data[2]
        wind = day_data[3]
        condition_code = day_data[4]
        condition = condition_names[condition_code]
        
        print(f"{day}: {temp}Â°C, {humidity}% humidity, {wind} km/h wind, {condition}")
```

### Task 2: Find Temperature Extremes
```python
def find_temperature_extremes(data):
    warmest_day = data[0][0]
    warmest_temp = data[0][1]
    coldest_day = data[0][0]
    coldest_temp = data[0][1]
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        
        if temp > warmest_temp:
            warmest_day = day
            warmest_temp = temp
        
        if temp < coldest_temp:
            coldest_day = day
            coldest_temp = temp
    
    return ([warmest_day, warmest_temp], [coldest_day, coldest_temp])
```

### Task 5: Create Temperature Chart
```python
def create_temperature_chart(data):
    print("\n===== TEMPERATURE CHART =====\n")
    
    for day_data in data:
        day = day_data[0]
        temp = day_data[1]
        
        # Create a bar using â–ˆ characters (one per degree)
        temp_bar = "â–ˆ" * temp
        
        print(f"{day}: {temp_bar} ({temp}Â°C)")
```

## Assessment Criteria

Students will be evaluated based on:

1. **Correct Implementation**: Functions work as expected and produce correct results.
2. **Code Organisation**: Code is well-structured and easy to follow.
3. **Use of Lists**: Effective use of lists for data storage and manipulation.
4. **Selection Logic**: Appropriate use of if/elif/else statements.
5. **Loop Implementation**: Proper use of loops to process data.
6. **Creativity**: Especially for the activity suggestions and extended challenges.

## Teaching Tips

1. **Start with Data Exploration**: Have students print and examine the weather data structure before implementing functions.
2. **Encourage Step-by-Step Development**: Suggest students complete one function at a time and test it before moving on.
3. **Review List Indexing**: Remind students about accessing elements in nested lists.
4. **Introduce Tuple Unpacking**: Show how to unpack tuples in assignments (e.g., `warmest, coldest = find_temperature_extremes()`).
5. **Emphasise Reusability**: Point out how functions can be reused (e.g., using `find_temperature_extremes()` for other analyses).

## Connection to Final Project

This mini-project prepares students for their weather API dashboard by:

1. Familiarising them with weather data structure and terminology
2. Teaching them how to extract insights from weather data
3. Practicing the calculation of weather statistics
4. Creating visualisations of weather information
5. Building a foundation for more complex data handling---
title: "Mastering Data Processing Techniques in Business"
subtitle: "Evaluating and Applying Effective Strategies"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Evaluating Data Processing Techniques

* Understanding the role of data processing in business
* Key concepts: Efficiency, reliability, and scalability
* Importance of choosing the right technique

::: {.notes}
Data processing is a critical aspect of modern businesses that involves collecting, cleaning, and analysing data to make informed decisions. The right data processing techniques can enhance efficiency, ensure data reliability, and scale as business needs grow. This presentation will explore various techniques and how to evaluate them in the context of business applications, particularly focusing on the use of the pandas library and Python programming.
:::

# Introduction to pandas

* What is pandas? 
* Core features of pandas for data processing
* How pandas supports business data analysis

::: {.notes}
The pandas library is a powerful tool for data manipulation and analysis in Python. It provides data structures and operations for manipulating numerical tables and time series. This is especially useful in business contexts where decision-making is data-driven, requiring quick and accurate data processing. We will explore how pandas can transform raw data into actionable insights.
:::

# Advanced Data Structures

* Overview of Python data structures
* Importance of choosing the right structure for the task
* Examples: Lists, Dictionaries, DataFrames

::: {.notes}
Python offers a variety of data structures that are fundamental to efficient data processing. Choosing the right structure, such as lists for ordered data, dictionaries for key-value pairs, or DataFrames for tabular data, can significantly affect the performance and simplicity of data processing tasks. Understanding these structures will help you design more effective data processing solutions.
:::

# Evaluating Effectiveness

* Criteria for evaluating data processing techniques
* Case study: Weather report generation
* Assessing pandas functions in real-world applications

::: {.notes}
To evaluate data processing techniques, we consider criteria such as speed, ease of use, and the ability to handle large datasets. For instance, in generating accurate weather reports, how effectively can pandas manage and manipulate large volumes of data? This real-world application demonstrates the practical utility of pandas in business contexts, highlighting its robustness and flexibility.
:::

# Algorithm Design and Efficiency

* What makes an algorithm efficient?
* Critiquing a sample data processing algorithm
* Balancing complexity and performance

::: {.notes}
An efficient algorithm is key to processing data quickly and reliably. We will examine a sample algorithm to understand factors that contribute to its efficiency, such as minimal processing time and optimal resource usage. It's crucial to balance complexity and performance to avoid over-engineering solutions while ensuring they meet business requirements.
:::

# Synthesising Knowledge for Projects

* Integrating Python and pandas for the weather project
* Decision-making in data presentation
* Analytical techniques to summarise weather trends

::: {.notes}
In our ongoing project to generate weekly weather reports, integrating Python's data structures with pandas' functionality allows for sophisticated data manipulation and analysis. This synthesis requires critical decisions about data presentationâ€”how to summarise trends and which analytical techniques to use, ensuring the reports are both informative and accessible.
:::

# Workshop Activities and Peer Learning

* Exploring basics of pandas
* Designing efficient data structures


::: {.notes}
Our workshop activities will provide hands-on experience with pandas and help you understand how to design efficient data structures.
:::

# Resources and Continuing Your Learning

* Utilising online resources like pandas Documentation
* Engaging with community forums and tutorials
* Importance of continuous learning in data processing

::: {.notes}
To further your learning in data processing, engaging with available resources such as the pandas documentation, community forums, and online tutorials is crucial. Data processing techniques and tools evolve rapidly, and staying updated through continuous learning will be key to maintaining and enhancing your skills in a business context.
:::

# Conclusion and Next Steps

* Evaluating and applying data processing techniques
* Encouragement to apply these techniques in your projects
* Next week: Deepening skills in pandas and Python

::: {.notes}
We've explored various data processing techniques and how to evaluate their effectiveness in business contexts. I encourage you to apply what you've learned today in your projects, especially in generating the weekly weather reports. Looking ahead, we will continue to deepen our skills in pandas and Python, building on the strong foundation laid today.
:::---
title: "Mastering pandas: Essential Skills for Data Processing"
subtitle: "Unlock the Power of Python for Effective Data Analysis"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to pandas

* Overview of pandas in Python
* Importance of pandas in data processing
* Objectives of today's session

::: {.notes}
Welcome to our introductory session on pandas, a pivotal library in Python for data analysis and manipulation. pandas stands out for its powerful data structures that allow for efficient data manipulation and analysis, essential in business and data science applications. Today, we aim to familiarise you with the basics of pandas, understand its significance in handling large datasets, and prepare you to utilise its functionalities for practical data processing tasks.
:::

# What is pandas?

* pandas: Python library for data manipulation
* Key features: DataFrame and Series objects
* Used extensively for data cleaning, transformation, and analysis

::: {.notes}
pandas is a fundamental library in the Python programming landscape, designed for detailed data manipulation and analysis. At the heart of pandas are two primary data structures: DataFrames, which are essentially tabular data structures, and Series, which are single-dimensional arrays. These structures are not only powerful but also intuitive, making pandas an indispensable tool in data science and business analytics for tasks like data cleaning, transforming datasets, and complex data analysis.
:::

# Installing and Importing pandas

* Installing pandas: `pip install pandas`
* Importing in Python: `import pandas as pd`
* Checking version: `print(pd.__version__)`

::: {.notes}
Before diving into data manipulation, you'll need to install pandas on your system. This is easily done using the pip package manager. Once installed, you can import pandas, typically as 'pd', which is a standard shorthand used in the Python community. It is also good practice to check the installed version to ensure compatibility with your data processing scripts.
:::

# pandas Data Structures

* Understanding Series: 1D array, homogeneous data
* Exploring DataFrame: 2D table, heterogeneous data
* Creating these structures from scratch

```python
import pandas as pd
# Creating a Series
series = pd.Series([1, 2, 3])
# Creating a DataFrame
dataframe = pd.DataFrame({'Name': ['Alice', 'Bob'], 'Age': [25, 30]})
```

::: {.notes}
The two primary data structures in pandas, Series and DataFrames, cater to different needs in data processing. A Series is ideal for single-dimensional data and operates similar to a Python list but with additional functionalities. A DataFrame, on the other hand, is more complex and can be thought of as a table where data is organised in rows and columns, allowing for more extensive data manipulation. Understanding how to create and manipulate these structures is foundational in leveraging pandas effectively.
:::

# Basic Operations in pandas

* Viewing data: `head()`, `tail()`
* Descriptive statistics: `describe()`
* Data selection and filtering

```python
# Viewing the first few rows of a DataFrame
dataframe.head()
# Generating descriptive statistics
dataframe.describe()
```

::: {.notes}
Basic operations in pandas are straightforward yet powerful. Functions like `head()` and `tail()` allow you to quickly inspect the beginning and end of datasets, which is particularly useful in large datasets to get a quick overview. The `describe()` function provides a summary of the statistics related to the DataFrame columns, offering insights into data distribution, count, mean, and other important metrics. These operations are essential for initial data exploration and analysis.
:::

# Data Cleaning with pandas

* Handling missing values: `dropna()`, `fillna()`
* Data type conversions: `astype()`
* Renaming columns and indexes

```python
# Handling missing values by filling them
dataframe.fillna(value="Unknown")
# Changing data type of a column
dataframe['Age'] = dataframe['Age'].astype(float)
```

::: {.notes}
Data cleaning is a crucial step in data processing, ensuring the accuracy and completeness of the data set. pandas provides robust tools for handling missing values and erroneous data types, which are common issues in real-world data. Methods like `dropna()` and `fillna()` help in managing missing data, while `astype()` is used for converting data types to ensure consistency in operations and analyses.
:::

# Advanced Data Manipulation

* Grouping data: `groupby()`
* Merging and joining data frames: `merge()`, `join()`
* Pivot tables and cross-tabulations: `pivot_table()`

```python
# Grouping data by a column and calculating mean
dataframe.groupby('Name')['Age'].mean()
# Merging two DataFrames
pd.merge(df1, df2, on='employee_id')
```

::: {.notes}
As you become more comfortable with pandas, you'll start to explore more complex data manipulation techniques. Grouping data allows for segmenting the dataset and applying functions like mean or sum, which is essential in data analysis. Merging and joining tables are critical when working with relational data, enabling you to combine data from different sources effectively. These advanced techniques are vital for thorough data analysis and decision-making processes.
:::

# Conclusion: Why pandas?

* Facilitates extensive data analysis and manipulation
* Integrates seamlessly with other Python libraries
* Essential tool for data scientists and business analysts

::: {.notes}
To sum up, mastering pandas is indispensable for anyone aspiring to work in data science or business analytics. Its comprehensive functionalities for handling, cleaning, and analysing data make it a preferred choice among professionals. Additionally, its integration with other Python libraries enhances its utility, making it a robust tool for real-world data processing tasks. As we conclude, I encourage you to delve deeper into pandas through practice and exploration to fully leverage its capabilities in your projects.
:::---
title: "Exploring Advanced Data Structures in Python"
subtitle: "Enhancing Data Management for Effective Business Solutions"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


# Introduction to Advanced Data Structures

* Overview of basic vs advanced data structures
* Importance of selecting the right data structure
* Focus of today's presentation: Advanced structures in Python

::: {.notes}
Welcome to our session on advanced data structures in Python. Today, we'll differentiate between basic and advanced data structures and understand why choosing the right one is crucial for optimising data management, especially in business applications. This presentation will specifically focus on advanced structures that can enhance our ability to handle complex data efficiently.
:::

# Arrays and Lists in Python

* Recap of basic structures: Arrays and Lists
* Characteristics and use cases
* Limitations that lead to advanced structures

::: {.notes}
Before diving into advanced structures, let's recap arrays and lists, which are the foundational data structures in Python. Arrays store elements of the same type, while lists can contain elements of different types. They are essential for simple data collection but have limitations in size modification and data access speed, prompting the need for more complex structures.
:::

# Dictionaries and Sets

* Introduction to Dictionaries and Sets
* Key-value pairs in Dictionaries
* Uniqueness in Sets - ideal for distinct element storage

::: {.notes}
Moving to more complex types, dictionaries store data in key-value pairs, making data retrieval fast and efficient. Sets, on the other hand, are collections of unique elements. Both are used widely when data integrity and speed are crucial, such as managing user information or ensuring no duplicate entries in data sets.
:::

# Trees and Graphs

* What are Trees and Graphs?
* Types of Trees (Binary, AVL, Red-Black Tree)
* Real-world application: Hierarchical data management

::: {.notes}
Trees and graphs represent more advanced data structures. Trees organise data hierarchically and are invaluable in applications like file systems or decision processes. Graphs help in representing complex networks like social connections or web links. Understanding these structures is crucial for managing structured data effectively.
:::

# Hash Tables

* Explaining Hash Tables
* Handling collisions in hash tables
* Usage: Fast data retrieval

::: {.notes}
Hash tables are a type of data structure that provides very fast data retrieval. They work by mapping keys to indices in an array using a hash function. However, handling collisionsâ€”where different keys map to the same indexâ€”is crucial for their efficiency. Hash tables are widely used in database indexing and caching.
:::

# Implementing Advanced Data Structures

* Example: Using a Binary Tree in Python
* Code demonstration

```python
class TreeNode:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

def insert(root, key):
    if root is None:
        return TreeNode(key)
    else:
        if root.val < key:
            root.right = insert(root.right, key)
        else:
            root.left = insert(root.left, key)
    return root
```

::: {.notes}
Let's look at a practical example of implementing a binary tree in Python. This simple class and function allow us to insert new nodes in a sorted manner. Understanding and implementing such structures can significantly improve the efficiency of data operations, especially in processing large volumes of data.
:::

# Choosing the Right Data Structure

* Factors to consider: Speed, Memory, Complexity
* Examples of matching business needs to structures

::: {.notes}
Choosing the right data structure is crucial and depends on factors like operation speed, memory usage, and complexity of implementation. For instance, hash tables might be perfect for quick lookups in customer databases, while trees could be better for organising product categories.
:::

# Conclusion and Recap

* Recap of key advanced data structures
* Importance in business applications
* Encouragement to explore further in Python

::: {.notes}
Today, we explored several advanced data structures that play vital roles in managing complex data efficiently. These structures are particularly important in business contexts where large volumes of data need fast and efficient processing. I encourage you to delve deeper into these structures with Python to enhance your programming and data management skills.
:::

# Questions and Further Learning

* Open for questions
* Suggest further reading and practice resources

::: {.notes}
Thank you for your attention! I am now open to any questions you might have. For further learning, I recommend exploring the pandas documentation and additional Python tutorials available online. Practising these concepts will solidify your understanding and improve your data handling capabilities in real-world scenarios.
:::# ðŸ§° Week 11 Mini-Project: Building Your Safe Utils Module

**Topic:** Creating Error-Resistant Utility Functions  
**Goal:** Build a Python module of reusable "safe_" wrapper functions that handle errors gracefully

## ðŸ“ Introduction

When programs encounter unexpected situations, they often crash with error messages. While these errors are helpful for debugging, they can create a poor user experience. In this mini-project, you'll:

1. Learn why programs crash and how to prevent it
2. Create wrapper functions that make unsafe operations safe
3. Build your own Python module that you can reuse in future projects

### ðŸ”„ Connecting to Previous Knowledge

Earlier in the semester, we used packages like **PyInputPlus** to handle user input validation without worrying about exception handling:

```python
import pyinputplus as pyip

# Gets an integer input with automatic validation
age = pyip.inputInt("Enter your age: ")
```

Similarly, we used **pandas** to process file contents without dealing with low-level file operations:

```python
import pandas as pd

# Reads a CSV file without manual file handling
df = pd.read_csv("data.csv")
```

Now it's time to understand what's happening "under the hood" of these helpful packages and build our own error-resistant utilities!

## ðŸ§­ Part 1: Understanding Errors with Unreliable Input

### Example 1: JSON Parsing

Try running this in a Python cell:

```python
import json

bad_json = "Not valid JSON at all!"
parsed = json.loads(bad_json)
```

â“What happens?

âœï¸ **Write the error message here:**

```text
# Your answer here
```

### Example 2: Converting Text to Numbers

Try running this:

```python
user_input = "hello"
number = int(user_input)
```

âœï¸ **Write the error message here:**

```text
# Your answer here
```

### Example 3: Reading Files

Try running this:

```python
with open("file_that_doesnt_exist.txt", "r") as f:
    content = f.read()
```

âœï¸ **Write the error message here:**

```text
# Your answer here
```

## ðŸ›¡ï¸ Part 2: Adding Basic Protection with try/except

### How to Handle JSON Errors

```python
import json

bad_json = "Not valid JSON at all!"

try:
    parsed = json.loads(bad_json)
    print("JSON parsed successfully:", parsed)
except json.JSONDecodeError:
    parsed = {}
    print("JSON parsing failed, using empty dictionary instead.")
```

### How to Handle Conversion Errors

```python
user_input = "hello"

try:
    number = int(user_input)
    print("Converted to number:", number)
except ValueError:
    number = 0
    print("Conversion failed, using 0 instead.")
```

### How to Handle File Errors

```python
try:
    with open("file_that_doesnt_exist.txt", "r") as f:
        content = f.read()
        print("File content:", content)
except FileNotFoundError:
    content = ""
    print("File not found, using empty string instead.")
```

ðŸ§  **Question:** Why do we use `try` blocks in these examples?

```text
# Your answer here
```

## ðŸ§° Part 3: Creating Reusable Safe Wrapper Functions

Let's wrap the error-handling logic into reusable functions:

### Safe JSON Parser

```python
def safe_json_loads(text):
    """
    Safely parse JSON, returning an empty dict if parsing fails.
    
    Args:
        text (str): The JSON string to parse
        
    Returns:
        dict: The parsed JSON data or an empty dict if parsing failed
    """
    try:
        return json.loads(text)
    except json.JSONDecodeError:
        return {}
```

### Safe Integer Converter

```python
def safe_int(text):
    """
    Safely convert text to integer, returning 0 if conversion fails.
    
    Args:
        text (str): The text to convert to an integer
        
    Returns:
        int: The converted integer or 0 if conversion failed
    """
    try:
        return int(text)
    except ValueError:
        return 0
```

### Safe File Reader

```python
def safe_read_file(filename):
    """
    Safely read a file, returning an empty string if reading fails.
    
    Args:
        filename (str): The path to the file to read
        
    Returns:
        str: The file content or an empty string if reading failed
    """
    try:
        with open(filename, "r", encoding="utf-8") as f:
            return f.read()
    except Exception as e:
        print(f"Could not read file: {e}")
        return ""
```

**Note:** While pandas is excellent for processing structured data files (like CSV or Excel), understanding basic file operations is still essential. This function demonstrates proper file handling with the `with` statement, which ensures files are properly closed even if errors occur.

## ðŸ§ª Part 4: Testing Your Safe Functions

Test your safe functions with both valid and invalid inputs:

```python
# Test safe_json_loads
print(safe_json_loads('{"name": "Alice"}'))         # Should return a dictionary
print(safe_json_loads("This is not JSON!"))         # Should return {}

# Test safe_int
print(safe_int("123"))       # Should return 123
print(safe_int("hello"))     # Should return 0

# Test safe_read_file
print(safe_read_file("existing_file.txt"))          # Should return file content
print(safe_read_file("non_existent_file.txt"))      # Should return ""
```

## ðŸ”§ Part 5: Build Your Own Safe Function

Now it's your turn! Create a `safe_float` function that converts text to a floating-point number:

```python
def safe_float(text):
    """
    Safely convert text to float, returning 0.0 if conversion fails.
    
    Args:
        text (str): The text to convert to a float
        
    Returns:
        float: The converted float or 0.0 if conversion failed
    """
    # Your code here
    ...
```

Test your function with:

```python
print(safe_float("3.14"))       # Should return 3.14
print(safe_float("pi"))         # Should return 0.0
```

**Challenge question:** Would a different default value than 0.0 ever be more appropriate? What situations might call for a different default?

## ðŸ“Š Part 6: Creating More Advanced Safe Functions

Let's build a few more useful safe functions:

### Safe Division

```python
def safe_divide(a, b):
    """
    Safely divide two numbers, returning 0 if division by zero would occur.
    
    Args:
        a (number): The dividend
        b (number): The divisor
        
    Returns:
        float: The result of a/b or 0 if b is 0
    """
    try:
        return a / b
    except ZeroDivisionError:
        return 0
```

### Safe List Access

```python
def safe_list_access(lst, index):
    """
    Safely access a list element, returning None if the index is out of range.
    
    Args:
        lst (list): The list to access
        index (int): The index to access
        
    Returns:
        Any: The element at lst[index] or None if index is out of range
    """
    try:
        return lst[index]
    except IndexError:
        return None
```

### Safe File Writer

```python
def safe_write_file(filename, content):
    """
    Safely write content to a file, returning True if successful, False otherwise.
    
    Args:
        filename (str): The path to the file to write
        content (str): The content to write to the file
        
    Returns:
        bool: True if writing was successful, False otherwise
    """
    try:
        with open(filename, "w", encoding="utf-8") as f:
            f.write(content)
        return True
    except Exception as e:
        print(f"Failed to write file: {e}")
        return False
```

## ðŸŽ¯ Part 7: Create Your Safe Utils Module

Now let's organize all these functions into a reusable Python module. This is an important step as we transition from notebook-based learning to working with Python scripts and modules in the coming weeks.

### Creating Your First Python Module

1. Create a new file called `safe_utils.py`
2. Add all the safe functions we've created
3. Add proper docstrings and comments

Here's how your file should look:

```python
# safe_utils.py

import json

def safe_json_loads(text):
    """
    Safely parse JSON, returning an empty dict if parsing fails.
    
    Args:
        text (str): The JSON string to parse
        
    Returns:
        dict: The parsed JSON data or an empty dict if parsing failed
    """
    try:
        return json.loads(text)
    except json.JSONDecodeError:
        return {}

def safe_int(text):
    """
    Safely convert text to integer, returning 0 if conversion fails.
    
    Args:
        text (str): The text to convert to an integer
        
    Returns:
        int: The converted integer or 0 if conversion failed
    """
    try:
        return int(text)
    except ValueError:
        return 0

def safe_float(text):
    """
    Safely convert text to float, returning 0.0 if conversion fails.
    
    Args:
        text (str): The text to convert to a float
        
    Returns:
        float: The converted float or 0.0 if conversion failed
    """
    try:
        return float(text)
    except ValueError:
        return 0.0

def safe_read_file(filename):
    """
    Safely read a file, returning an empty string if reading fails.
    
    Args:
        filename (str): The path to the file to read
        
    Returns:
        str: The file content or an empty string if reading failed
    """
    try:
        with open(filename, "r", encoding="utf-8") as f:
            return f.read()
    except Exception as e:
        print(f"Could not read file: {e}")
        return ""

def safe_write_file(filename, content):
    """
    Safely write content to a file, returning True if successful, False otherwise.
    
    Args:
        filename (str): The path to the file to write
        content (str): The content to write to the file
        
    Returns:
        bool: True if writing was successful, False otherwise
    """
    try:
        with open(filename, "w", encoding="utf-8") as f:
            f.write(content)
        return True
    except Exception as e:
        print(f"Failed to write file: {e}")
        return False

def safe_divide(a, b):
    """
    Safely divide two numbers, returning 0 if division by zero would occur.
    
    Args:
        a (number): The dividend
        b (number): The divisor
        
    Returns:
        float: The result of a/b or 0 if b is 0
    """
    try:
        return a / b
    except ZeroDivisionError:
        return 0

def safe_list_access(lst, index):
    """
    Safely access a list element, returning None if the index is out of range.
    
    Args:
        lst (list): The list to access
        index (int): The index to access
        
    Returns:
        Any: The element at lst[index] or None if index is out of range
    """
    try:
        return lst[index]
    except IndexError:
        return None
```

### Creating Your Module in Colab

Since we've been using Google Colab all semester, here are options for creating and using your module:

1. **Generate the module file in Colab:**
   ```python
   %%writefile safe_utils.py
   # Copy the module code here
   ```

2. **Test importing your module:**
   ```python
   import safe_utils
   
   # Test a function
   print(safe_utils.safe_int("123"))  # Should display 123
   ```

3. **Download your module** for use in upcoming weeks when we begin working with local Python development.

## ðŸš€ Part 8: Using Your Module

### Testing in Colab

If you're working in Colab, you can test your module in the same notebook:

```python
# After creating safe_utils.py with %%writefile
import safe_utils

# Test all functions
print("Testing safe_json_loads:")
print(safe_utils.safe_json_loads('{"name": "Alice"}'))
print(safe_utils.safe_json_loads("Not JSON"))

print("\nTesting safe_int:")
print(safe_utils.safe_int("42"))
print(safe_utils.safe_int("banana"))

# Additional tests for other functions...
```

### Testing as a Script

For the upcoming weeks when we'll be working with Python scripts locally, you can create a test file called `test_safe_utils.py`:

```python
# test_safe_utils.py

import safe_utils

# Test all functions
print("Testing safe_json_loads:")
print(safe_utils.safe_json_loads('{"name": "Alice"}'))
print(safe_utils.safe_json_loads("Not JSON"))

print("\nTesting safe_int:")
print(safe_utils.safe_int("42"))
print(safe_utils.safe_int("banana"))

print("\nTesting safe_float:")
print(safe_utils.safe_float("3.14"))
print(safe_utils.safe_float("pi"))

print("\nTesting safe_divide:")
print(safe_utils.safe_divide(10, 2))
print(safe_utils.safe_divide(10, 0))

print("\nTesting safe_list_access:")
print(safe_utils.safe_list_access([1, 2, 3], 1))
print(safe_utils.safe_list_access([1, 2, 3], 10))

print("\nTesting safe_write_file:")
print(safe_utils.safe_write_file("test.txt", "Hello, world!"))

print("\nTesting safe_read_file:")
print(safe_utils.safe_read_file("test.txt"))
print(safe_utils.safe_read_file("nonexistent.txt"))
```

### Multiple Ways to Use Your Module

1. **In Colab (current environment):** 
   - Create the module using `%%writefile`
   - Import it directly in the same session

2. **Between Colab notebooks:**
   - Upload the .py file to Colab
   - Import it in any notebook

3. **In local Python (coming weeks):**
   - Download your module
   - Place it in the same directory as your script
   - Import it using `import safe_utils`

This project serves as a bridge between our notebook-based work and the upcoming weeks focused on local Python development and debugging.

## ðŸ§  Part 9: Extension Challenges

Choose one or more of these challenges to extend your module:

1. **Create a `safe_input_int` function** that keeps asking for input until valid integer is given:

```python
def safe_input_int(prompt):
    """
    Repeatedly ask for input until a valid integer is given.
    
    Args:
        prompt (str): The prompt to display to the user
        
    Returns:
        int: The valid integer input
    """
    while True:
        try:
            return int(input(prompt))
        except ValueError:
            print("Invalid input. Please enter a number.")
```

**Discussion Point:** How does this function compare to PyInputPlus's `inputInt()` function we learned about earlier? What advantages or disadvantages does each approach have?

2. **Create a `safe_dict_access` function** that safely gets a value from a dictionary:

```python
def safe_dict_access(d, key, default=None):
    """
    Safely access a dictionary value, returning a default if the key doesn't exist.
    
    Args:
        d (dict): The dictionary to access
        key: The key to look up
        default: The value to return if the key doesn't exist (default: None)
        
    Returns:
        Any: The value at d[key] or default if key doesn't exist
    """
    try:
        return d[key]
    except (KeyError, TypeError):
        return default
```

3. **Create a `safe_json_file` function** that combines reading a file and parsing JSON:

```python
def safe_json_file(filename):
    """
    Safely read a JSON file, returning an empty dict if reading or parsing fails.
    
    Args:
        filename (str): The path to the JSON file
        
    Returns:
        dict: The parsed JSON data or an empty dict if reading or parsing failed
    """
    content = safe_read_file(filename)
    return safe_json_loads(content)
```

**Discussion point:** This function demonstrates function composition - using simpler functions to build more complex ones. How does this compare to pandas' approach of having a `pd.read_json()` function? What are the advantages of each approach?

## ðŸŒŸ Part 10: Publish Your Module to GitHub

1. Create a GitHub repository
2. Upload your `safe_utils.py` file
3. Create a `README.md` file explaining your module
4. Add a `LICENSE` file (optional)
5. Share your module with classmates

## ðŸ§  Reflection Questions

1. Why is it important to handle errors in code?
2. When is it appropriate to use a `try`/`except` block?
3. What default values did you choose for your safe functions? Why?
4. When might it be better to let an error crash your program rather than handling it silently?
5. How could you improve your module to make it even more robust?
6. Compare creating your own safe functions versus using existing libraries like PyInputPlus or pandas. When would you choose each approach?

âœï¸ Write your reflections here:

```text
# Your thoughts...
```

## ðŸ† Submission Requirements

1. Your completed `safe_utils.py` module
2. Your `test_safe_utils.py` test file
3. Answers to the reflection questions
4. Link to your GitHub repository (if created)
5. At least one additional safe function that you created on your own

## ðŸ“š Resources

- [Python Exception Handling Tutorial](https://docs.python.org/3/tutorial/errors.html)
- [Python Module Documentation](https://docs.python.org/3/tutorial/modules.html)
- [GitHub Quickstart Guide](https://docs.github.com/en/get-started/quickstart)
- [PyInputPlus Documentation](https://pypi.org/project/PyInputPlus/)
- [pandas Documentation](https://pandas.pydata.org/docs/)

## ðŸ¤– Learning with AI Guidance

As you work through this mini-project, you might consider using an AI assistant like Claude to help deepen your understanding. Here are some effective prompting strategies to maximize your learning:

### âœ… Effective Learning Prompts 

1. **Get conceptual explanations:** 
   "Explain the difference between catching specific exceptions vs. catching all exceptions in Python."

2. **Request step-by-step reasoning:**
   "Walk me through how I should decide what default value to return from a safe function."

3. **Ask for analogies:**
   "Can you provide an analogy that explains why exception handling is important in programming?"

4. **Get debugging help:**
   "My safe_json_loads function is returning None instead of an empty dictionary. What might be wrong?"

5. **Request implementation variations:**
   "How would you implement safe_read_file differently if you wanted to return the error message instead of an empty string?"

### âŒ Avoid These Approaches

1. **Don't copy-paste complete solutions:**
   Instead of "Write me a safe_dict_access function," try "What considerations should I keep in mind when designing a safe_dict_access function?"

2. **Don't request fully-written code without understanding it:**
   Instead of "Give me a complete safe_utils module," ask "How should I structure my safe_utils module and what functions should I include?"

3. **Don't skip reflection:**
   Take time to understand *why* certain approaches work better than others. Ask about tradeoffs and alternatives to deepen your understanding.

Remember: AI tools are most valuable when they help you understand concepts more deeply, not when they just provide answers!
---
title: "Mastering File Operations in Python"
subtitle: "Understanding the Basics and Advanced Techniques for Effective Data Management"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to File Operations

* Importance of file operations in programming
* Overview of file operations: Opening, reading, writing, and closing files
* Python's built-in functions for file handling

::: {.notes}
Welcome to our session on file operations in Python! File handling is a fundamental aspect of programming that involves reading from and writing to files. This is essential for data management in any software application. In Python, this can be achieved using several built-in functions that make it straightforward to handle various file operations. Today, we will explore these operations and understand how they can be used to manage data effectively.
:::

# The File Operation Workflow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Open  â”‚ â”€â”€â–¶  â”‚ Read / Write  â”‚ â”€â”€â–¶  â”‚ Close  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

* A typical file operation follows this three-step process
* Each step has specific functions and best practices
* Errors can occur at any stage and should be handled properly

::: {.notes}
File operations typically follow a three-step workflow: opening the file, performing read or write operations, and then closing the file. Each step is critical and has specific functions in Python. It's important to understand that errors can occur at any of these stages, so proper error handling should be implemented throughout the process. This workflow forms the foundation of all file operations in Python.
:::

# Opening Files in Python

* Using `open()` function
* Modes of opening a file: 'r', 'w', 'a', 'r+', 'b'
* Importance of specifying the correct mode

```python
# Open a file for reading
file = open('example.txt', 'r')

# Open a file for writing (creates a new file or overwrites existing)
file = open('output.txt', 'w')

# Open a file for appending
file = open('log.txt', 'a')
```

::: {.notes}
To begin working with files in Python, you must first open them using the `open()` function. This function requires the name of the file and the mode as arguments. Modes include 'r' for reading, 'w' for writing (which creates a new file or overwrites existing content), 'a' for appending to existing content, 'r+' for both reading and writing, and 'b' for binary mode. It's crucial to choose the correct mode to prevent errors such as data loss or file corruption.
:::

# Reading Files

* Reading entire content using `read()`
* Reading line by line using `readline()` and `readlines()`
* Practical example: Reading a text file

```python
# Read entire file content
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)

# Read file line by line
with open('example.txt', 'r') as file:
    for line in file:
        print(line.strip())
```

::: {.notes}
Once a file is opened in read mode ('r'), you can extract its contents using `read()`, which reads the entire file, or `readline()` that reads the file line by line. The `readlines()` function returns a list of all lines in the file. Alternatively, you can iterate through the file object directly as shown in the example. This approach is memory-efficient for large files as it reads one line at a time.
:::

# Writing to Files

* Using `write()` and `writelines()`
* Differences between 'w' and 'a' modes
* Example: Writing to a log file

```python
# Write a single string to a file
with open('output.txt', 'w') as file:
    file.write('Hello, World!')

# Write multiple lines to a file
lines = ['Line 1\n', 'Line 2\n', 'Line 3\n']
with open('output.txt', 'w') as file:
    file.writelines(lines)
```

::: {.notes}
Writing to files in Python is handled by `write()` for individual strings or `writelines()` for a list of strings. It's important to understand the difference between 'w' (write) mode, which overwrites the existing file, and 'a' (append) mode, which adds to the end of the file. Notice that with `writelines()`, you need to explicitly include newline characters if you want each item to appear on a separate line in the file.
:::

# Context Managers: The `with` Statement

* Using `with` to automatically manage resources
* Ensures files are properly closed even if errors occur
* Best practice for file operations

```python
# Without context manager - requires explicit close
file = open('example.txt', 'r')
content = file.read()
file.close()  # Must remember to close!

# With context manager - automatically closes file
with open('example.txt', 'r') as file:
    content = file.read()
# File is automatically closed when we exit the block
```

::: {.notes}
The `with` statement in Python implements context management, which automatically handles resource cleanup. When working with files, this means the file is automatically closed when the block is exited, even if an exception occurs. This is considered a best practice as it prevents resource leaks and ensures files are properly closed in all scenarios. Always prefer the `with` statement when working with files in Python.
:::

# Working with File Paths

* Challenges with file paths across operating systems
* Using `os.path` or `pathlib` for platform-independent code
* Examples of path handling

```python
# Using os.path (older approach)
import os
file_path = os.path.join('data', 'files', 'example.txt')

# Using pathlib (modern approach, Python 3.4+)
from pathlib import Path
file_path = Path('data') / 'files' / 'example.txt'
with open(file_path, 'r') as file:
    content = file.read()
```

::: {.notes}
File paths can be a source of errors, especially when your code runs on different operating systems that use different path separators (backslash on Windows, forward slash on Unix-based systems). Python provides two main ways to handle this: the older `os.path` module and the newer `pathlib` module introduced in Python 3.4. `pathlib` offers an object-oriented approach to file paths and is generally recommended for modern Python code.
:::

# Error Handling in File Operations

* Common file errors: FileNotFoundError, PermissionError, IOError
* Using `try` and `except` blocks
* Example: Handling errors while reading a file

```python
try:
    with open('nonexistent.txt', 'r') as file:
        content = file.read()
except FileNotFoundError:
    print("Error: The file does not exist.")
except PermissionError:
    print("Error: You don't have permission to read this file.")
except IOError as e:
    print(f"An I/O error occurred: {e}")
```

::: {.notes}
File operations can sometimes lead to errors, such as `FileNotFoundError` when the file doesn't exist, `PermissionError` when you don't have the necessary permissions, or general `IOError` for other input/output issues. It is important to handle these errors gracefully using `try` and `except` blocks. This prevents the program from crashing and allows for more robust error management, providing a better user experience.
:::

# Understanding File Types

* Common file types: TXT, CSV, JSON, XML
* Binary vs. Text files
* Choosing the right file type for your data

::: {.notes}
Files can be broadly classified into text and binary types. Text files (like TXT, CSV, JSON, XML) are readable by humans and are often used for data storage that involves textual data. Binary files, however, are more suitable for images, audio, or other multimedia data. Choosing the correct file type is crucial for optimal data management and processing efficiency in your applications.
:::

# Handling CSV Data

* CSV (Comma-Separated Values) for tabular data
* Reading and writing CSV with the `csv` module
* Example: Processing a CSV file

```python
import csv

# Reading a CSV file
with open('data.csv', 'r', newline='') as file:
    reader = csv.reader(file)
    for row in reader:
        print(row)  # Each row is a list

# Writing to a CSV file
with open('output.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(['Name', 'Age', 'City'])  # Header
    writer.writerow(['Alice', '30', 'New York'])  # Data
```

::: {.notes}
CSV (Comma-Separated Values) files are commonly used for storing tabular data. Python's built-in `csv` module provides functionality to read from and write to CSV files easily. The `reader` object returns each row as a list, while the `writer` object allows you to write rows to the file. Note the use of `newline=''` parameter, which is recommended when working with CSV files to ensure consistent line endings across different platforms.
:::

# Handling JSON Data

* Why JSON is important in web applications
* Reading and writing JSON data with Python
* Practical example of JSON operations

```python
import json

# Writing JSON data
data = {'name': 'John', 'age': 30, 'city': 'New York'}
with open('data.json', 'w') as file:
    json.dump(data, file, indent=4)  # indent for pretty formatting

# Reading JSON data
with open('data.json', 'r') as file:
    loaded_data = json.load(file)
    print(loaded_data['name'])  # Access as a Python dictionary
```

::: {.notes}
JSON (JavaScript Object Notation) is a lightweight data interchange format that's easy to read and write for humans, and easy to parse and generate for machines. It is extensively used in web applications for data exchange. In Python, the `json` module provides methods like `dump()` to write Python objects as JSON to a file and `load()` to read JSON from a file into Python objects. The `indent` parameter in `json.dump()` creates a more readable, formatted JSON file.
:::

# Advanced Techniques: File Compression

* Benefits of file compression
* Using `gzip` and `zipfile` modules
* Example of compressing a file

```python
import gzip

# Compressing data
text = "This is a long string that will be compressed."
with gzip.open('file.txt.gz', 'wt') as f:
    f.write(text)

# Reading compressed data
with gzip.open('file.txt.gz', 'rt') as f:
    decompressed_text = f.read()
    print(decompressed_text)
```

::: {.notes}
File compression is a useful technique to reduce file size, making storage and transmission more efficient. Python provides built-in libraries such as `gzip` and `zipfile` for compressing and decompressing files. In this example, we use `gzip` to compress and later decompress text data. Note the use of 'wt' and 'rt' modes, which stand for "write text" and "read text" respectively, ensuring proper text encoding and decoding during the compression process.
:::

# Practical Exercise: Word Counter

Create a program that:
1. Reads a text file
2. Counts the frequency of each word
3. Writes the results to a new file
4. Handles potential errors appropriately

```python
# Starter code
def count_words(filename):
    try:
        # Your code here
        pass
    except FileNotFoundError:
        # Error handling
        pass
    
    return word_counts  # Dictionary of word frequencies
```

::: {.notes}
This exercise challenges you to apply the file operation concepts we've learned. You'll need to open and read a file, process its contents to count word frequencies, and then write the results to a new file. Make sure to implement proper error handling for scenarios like the file not existing. This practical exercise reinforces the file operation workflow and error handling techniques.
:::

# Looking Ahead: Building Safe Utilities

* In our upcoming mini-project, we'll combine file operations and exception handling
* You'll create reusable "safe" functions that handle errors gracefully
* Example: A function that safely reads a file and returns a default value if the operation fails

```python
def safe_read_file(filename, default=""):
    """Safely read a file, returning a default value if it fails."""
    try:
        with open(filename, 'r') as file:
            return file.read()
    except Exception as e:
        print(f"Error reading file: {e}")
        return default
```

::: {.notes}
Our upcoming mini-project will focus on creating "safe" utility functions that combine file operations with robust error handling. These functions will encapsulate common file operations while gracefully handling any errors that might occur. The example shown here is a simple safe file reading function that returns a default value if the file cannot be read for any reason. This approach makes your code more resilient and user-friendly by preventing crashes due to file operation errors.
:::

# Practical Applications of File Operations

* Data logging
* Configuration files management
* Reading and writing CSV files for data analysis
* Storing and retrieving application state

::: {.notes}
File operations are widely used in real-world applications such as data logging, managing configuration files, and handling CSV files for data analysis. They're also commonly used for storing and retrieving application state, allowing programs to remember settings or data between runs. Understanding these operations enhances your ability to manage data effectively in various programming scenarios, which is crucial for any software development project, especially in business and technology contexts.
:::

# Conclusion

* Recap of key points: Opening, reading, writing, and closing files
* Importance of using context managers with the `with` statement
* Value of proper error handling in file operations
* Best practices for working with different file types

::: {.notes}
Today, we covered the basic yet crucial aspects of file operations in Python, including how to open, read, write, and close files, along with the importance of handling errors efficiently. We emphasized the use of context managers with the `with` statement as a best practice for file handling. We also explored working with different file types like CSV and JSON, and advanced techniques like file compression. Remember, good file management practices are critical for efficient data handling and can significantly impact the performance and reliability of your applications.
:::

# Further Resources and Next Steps

* Official Python documentation on file operations:
  [Python File Handling](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files)
* Explore `pathlib` for modern file path handling:
  [pathlib â€” Object-oriented filesystem paths](https://docs.python.org/3/library/pathlib.html)
* Practice by developing your own file handling projects

::: {.notes}
For further learning, I recommend visiting the official Python documentation on file handling. The `pathlib` module documentation is especially useful for understanding modern approaches to file path handling. There are also numerous online resources and tutorials available that can provide additional examples and projects to practice these concepts. The best way to learn is by doing, so try to implement what you've learned today in your own projects!
:::

# Quick Check

Which of these is the recommended way to open and read a file in Python?

A. 
```python
file = open('data.txt', 'r')
content = file.read()
# No close statement
```

B. 
```python
file = open('data.txt', 'r')
content = file.read()
file.close()
```

C. 
```python
with open('data.txt', 'r') as file:
    content = file.read()
```

D. 
```python
content = read_file('data.txt')
```

::: {.notes}
The correct answer is C. Using the `with` statement is the recommended approach as it automatically handles closing the file, even if exceptions occur. Option A is problematic because it never closes the file, which can lead to resource leaks. Option B is better but doesn't handle exceptions well. Option D is not valid Python syntax for built-in functions.
:::
---
title: "Mastering Exception Management in Python"
subtitle: "Best Practices for Robust and Resilient Code"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to Exception Handling

* Understanding exceptions in Python
* Importance of error handling for program reliability
* Overview of today's key concepts

::: {.notes}
Welcome to our exploration of exception handling in Python! Today, we will delve into how Python handles errors and exceptions, which are critical for writing robust and user-friendly applications. Understanding this concept will not only help you debug programs but also allow you to anticipate and manage potential issues effectively. Let's start by defining what exceptions are and why they are fundamental in Python programming.
:::

# What are Exceptions?

* Exceptions: Events that disrupt normal program flow
* Difference between syntax errors and exceptions
* Why handling exceptions is important for program stability

::: {.notes}
In programming, an exception is an event that disrupts the normal flow of a program. It occurs whenever the program encounters an error during execution. While syntax errors are mistakes in the use of the programming language, which are caught before the execution of the program, exceptions can occur during execution. Without proper handling, exceptions will cause the program to crash. Understanding these differences is crucial for effective error handling and creating more resilient applications.
:::

# Python's Exception Hierarchy

```
BaseException
â”œâ”€â”€ SystemExit
â”œâ”€â”€ KeyboardInterrupt
â”œâ”€â”€ Exception
â”‚   â”œâ”€â”€ ArithmeticError
â”‚   â”‚   â”œâ”€â”€ ZeroDivisionError
â”‚   â”‚   â””â”€â”€ OverflowError
â”‚   â”œâ”€â”€ LookupError
â”‚   â”‚   â”œâ”€â”€ IndexError
â”‚   â”‚   â””â”€â”€ KeyError
â”‚   â”œâ”€â”€ TypeError
â”‚   â””â”€â”€ ValueError
â””â”€â”€ ... (other exceptions)
```

* Python organizes exceptions in a hierarchical structure
* Most exceptions you'll handle derive from `Exception`
* Understanding the hierarchy helps with effective exception catching

::: {.notes}
Python organizes exceptions in a hierarchical structure. At the top of this hierarchy is the BaseException class, from which all other exceptions inherit. Directly under BaseException is the Exception class, which serves as the base for most exceptions you will typically handle. Examples of specific exceptions inheriting from Exception include ValueError, which is raised when a function receives an argument of the correct type but inappropriate value, TypeError, and IOError. By understanding this hierarchy, you can make informed decisions about which exceptions to catch and how to structure your error handling code.
:::

# Basic Exception Handling Syntax

* Using `try` and `except` blocks
* Basic syntax pattern
* Example of simple exception handling

```python
try:
    # Code that might raise an exception
    x = int(input("Enter a number: "))
    result = 10 / x
    print(f"10 divided by {x} is {result}")
except ValueError:
    # Handles invalid input
    print("That was not a valid number.")
except ZeroDivisionError:
    # Handles division by zero
    print("Cannot divide by zero.")
```

::: {.notes}
Exception handling in Python is primarily conducted using `try` and `except` blocks. You wrap the code that might cause an exception in a `try` block, and the code to execute if an exception occurs goes in an `except` block. You can have multiple `except` blocks to handle different types of exceptions differently. In this example, we're handling two specific exceptions: ValueError for invalid input conversion and ZeroDivisionError for division by zero. This targeted approach allows for more precise error responses.
:::

# Complete Exception Handling Structure

* The full `try`/`except`/`else`/`finally` structure
* When to use each clause
* Complete example

```python
try:
    # Code that might raise an exception
    x = int(input("Enter a number: "))
    result = 100 / x
except ValueError:
    # Handles invalid input
    print("That's not a valid number!")
except ZeroDivisionError:
    # Handles division by zero
    print("Cannot divide by zero!")
else:
    # Executes if no exceptions were raised
    print(f"100 divided by {x} is {result}")
finally:
    # Always executes, regardless of what happened
    print("Execution completed")
```

::: {.notes}
The complete exception handling structure in Python includes four components: `try`, `except`, `else`, and `finally`. The `try` block contains code that might raise exceptions. The `except` blocks handle specific exceptions. The `else` clause runs only if no exceptions were raised in the `try` block, making it a good place for code that should run only if the operation was successful. The `finally` clause contains code that will execute no matter what, whether an exception occurred or not, making it perfect for cleanup operations.
:::

# Catching Multiple Exceptions

* Different ways to handle multiple exception types
* Using tuple of exceptions
* Using Exception hierarchy for broader catching

```python
# Method 1: Multiple except blocks
try:
    # Risky code
    pass
except ValueError:
    # Handle ValueError
    pass
except TypeError:
    # Handle TypeError
    pass

# Method 2: Catching multiple exceptions in one block
try:
    # Risky code
    pass
except (ValueError, TypeError):
    # Handle either ValueError or TypeError
    pass

# Method 3: Catching parent exception
try:
    # Risky code
    pass
except Exception:
    # Handle any exception that inherits from Exception
    # Be careful with this approach!
    pass
```

::: {.notes}
Python offers several ways to handle multiple types of exceptions. You can use separate `except` blocks for each exception type, which allows for different handling logic for each. You can also catch multiple exception types in a single `except` block by specifying them as a tuple, which is useful when you want to handle different exceptions in the same way. Finally, you can catch a parent exception class to handle all its child exceptions, but this approach should be used carefully as it might catch unexpected exceptions and mask bugs.
:::

# Example: Handling File Errors

```python
try:
    with open('data.txt', 'r') as file:
        content = file.read()
        data = int(content)
except FileNotFoundError:
    print("Error: File does not exist.")
    data = 0
except ValueError:
    print("Error: File does not contain a valid number.")
    data = 0
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    data = 0
finally:
    print(f"Processing complete. Data value: {data}")
```

* Practical example of file error handling
* Handling specific file-related exceptions
* Using general exception as a fallback

::: {.notes}
Let's consider a practical example where we handle various exceptions that might occur when working with files. Here, we're trying to open a file, read its content, and convert it to an integer. Several things might go wrong: the file might not exist (FileNotFoundError), the content might not be a valid number (ValueError), or some other unexpected error might occur. We handle each specific case differently and use a generic Exception handler as a fallback. The finally block ensures we always print a completion message.
:::

# Raising Exceptions

* When to raise exceptions in your code
* Using `raise` to signal errors
* Re-raising exceptions after handling

```python
def validate_age(age):
    if not isinstance(age, int):
        raise TypeError("Age must be an integer")
    if age < 0:
        raise ValueError("Age cannot be negative")
    if age > 120:
        raise ValueError("Age is unrealistically high")
    return age

# Example of re-raising an exception
try:
    age = validate_age("twenty")
except TypeError as e:
    print(f"Error: {e}")
    print("Please enter a number instead.")
    # Re-raise if you want calling code to also handle it
    # raise
```

::: {.notes}
Sometimes you need to raise exceptions in your own code to signal error conditions. The `raise` statement allows you to trigger a specific exception when a condition occurs that should interrupt normal program flow. In this example, we've created a function that validates an age value, raising appropriate exceptions for different invalid inputs. Additionally, you can re-raise an exception after handling it partially, which allows the exception to propagate up the call stack while still performing some local error handling.
:::

# Exception Chaining

* Using `raise ... from ...` to indicate causality
* Preserving the exception stack
* Helps with debugging complex applications

```python
try:
    x = int("not a number")
except ValueError as e:
    # This creates a new exception while preserving the original cause
    raise RuntimeError("Processing failed") from e

# Example of implicit chaining
try:
    try:
        x = int("not a number")
    except ValueError:
        # This implicitly chains the exceptions
        # (Python remembers the original cause)
        raise RuntimeError("Processing failed")
except RuntimeError as e:
    print(f"Error: {e}")
    # Access the original cause
    print(f"Original cause: {e.__cause__}")
```

::: {.notes}
Exception chaining is a feature in Python 3 that allows you to indicate that one exception was caused by another. Using the syntax `raise new_exception from original_exception`, you explicitly link the two exceptions, which helps with debugging by preserving the full exception history. Python also supports implicit chaining when you raise a new exception inside an except block. This feature is especially valuable in complex applications where errors might propagate through multiple layers of code.
:::

# Creating Custom Exceptions

* Benefits of custom exception classes
* How to create your own exception types
* Example of using custom exceptions

```python
# Define custom exceptions
class NetworkError(Exception):
    """Exception raised for network-related errors."""
    pass

class DatabaseError(Exception):
    """Exception raised for database-related errors."""
    pass

# Using custom exceptions
def fetch_data(database_url):
    try:
        # Attempt to connect...
        if "database" not in database_url:
            raise DatabaseError(f"Invalid database URL: {database_url}")
        # More code...
    except ConnectionError:
        # Convert standard exception to our custom one
        raise NetworkError("Could not connect to the database") from ConnectionError
```

::: {.notes}
Creating custom exception classes allows you to define application-specific error types that provide more context about what went wrong. Custom exceptions typically inherit from the Exception class or one of its subclasses. They can be as simple as empty classes that just define a new type, or they can include additional attributes and methods to provide more information about the error. Using custom exceptions makes your code more readable and allows calling code to catch specific application-level exceptions.
:::

# Using Assertions

* Purpose of assertions in code
* When to use assertions vs. exceptions
* Example of effective assertion usage

```python
def calculate_average(numbers):
    # Assert that the input is a non-empty list
    assert isinstance(numbers, list), "Input must be a list"
    assert len(numbers) > 0, "List cannot be empty"
    
    total = sum(numbers)
    return total / len(numbers)

# Assertions can be disabled in production with -O flag
# Use exceptions for errors that should always be checked
```

::: {.notes}
Assertions are a debugging aid that tests a condition and triggers an error if the condition is false. Unlike regular exception handling, assertions are typically used to catch programming errors rather than runtime errors. They're often used to verify assumptions about your code's state or input values. It's important to note that assertions can be disabled in production code by running Python with the -O (optimize) flag, so you shouldn't rely on them for security or data validation that must always occur. For such checks, use regular exception handling instead.
:::

# Common Pitfalls in Exception Handling

* Overusing `try` blocks
* Catching too general exceptions
* Ignoring caught exceptions
* Silent failures

```python
# Bad: Too general, masks errors
try:
    # A lot of code...
    process_data()
    save_results()
except Exception:  # Catches everything!
    pass  # Silent failure!

# Better: Specific, informative
try:
    # Minimal code that might fail
    data = process_data()
except ValueError as e:
    print(f"Data processing error: {e}")
    log_error(e)  # Log for debugging
```

::: {.notes}
Several common pitfalls can reduce the effectiveness of exception handling. First, wrapping too much code in a single try block makes it harder to determine which part caused the error. Second, catching overly general exceptions like `Exception` might mask bugs by catching exceptions you didn't anticipate. Third, ignoring exceptions by using empty except blocks or just passing creates silent failures that are difficult to debug. Always include minimal code in try blocks, catch specific exceptions, and provide meaningful error messages or logging to help diagnose issues.
:::

# Common Exception Handling Patterns

* Retry pattern for transient failures
* Logging and re-raising for debugging
* Converting between exception types
* Default values for graceful degradation

```python
# Retry pattern
def retry_operation(max_attempts=3):
    attempts = 0
    while attempts < max_attempts:
        try:
            return perform_operation()  # Might fail
        except TransientError:
            attempts += 1
            if attempts == max_attempts:
                raise  # Re-raise after max attempts
            time.sleep(1)  # Wait before retrying

# Default value pattern
def get_config_value(key, default=None):
    try:
        return config[key]
    except KeyError:
        return default
```

::: {.notes}
Several exception handling patterns are commonly used in Python. The retry pattern attempts an operation multiple times before giving up, which is useful for transient errors like network timeouts. Logging and re-raising helps with debugging by recording the error but still allowing it to propagate. Converting between exception types helps abstract lower-level errors into application-specific ones. The default value pattern provides graceful degradation by substituting a sensible default when an operation fails, allowing the program to continue running with reduced functionality rather than crashing.
:::

# Real-World Application: Data Processing Pipeline

```python
def process_data_pipeline(input_file, output_file):
    try:
        # Step 1: Read input file
        with open(input_file, 'r') as f:
            data = f.read()
        
        # Step 2: Parse data
        try:
            parsed_data = json.loads(data)
        except json.JSONDecodeError:
            # Attempt CSV parsing as a fallback
            parsed_data = parse_csv(data)
        
        # Step 3: Transform data
        transformed_data = transform(parsed_data)
        
        # Step 4: Write output
        with open(output_file, 'w') as f:
            json.dump(transformed_data, f)
            
        return True
    except Exception as e:
        log_error(f"Pipeline failed: {e}")
        return False
```

* Exception handling in a multi-step process
* Using nested try-except blocks for specific steps
* Implementing fallback strategies

::: {.notes}
This real-world example shows exception handling in a data processing pipeline. We have an outer try-except block that catches any unhandled exceptions in the overall process, while inner try-except blocks handle specific steps that might fail. We also implement a fallback strategy: if JSON parsing fails, we try CSV parsing instead. This approach combines different exception handling patterns to create a robust pipeline that can deal with various error conditions while still attempting to complete the task. The function returns a boolean indicating success or failure, allowing calling code to take appropriate action.
:::

# Looking Ahead: Safe Utility Functions

* Combining exception handling with reusable functions
* Creating "safe" versions of operations that might fail
* Preview of our upcoming mini-project

```python
def safe_json_loads(text, default=None):
    """
    Safely parse JSON text, returning a default value if parsing fails.
    
    Args:
        text (str): The JSON string to parse
        default: Value to return if parsing fails (default: None)
        
    Returns:
        The parsed JSON data or the default value
    """
    if default is None:
        default = {}
        ---
title: "Staff Answer Guide: Introduction to Safe Utility Functions"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

## Overview
This guide provides instructors with implementation answers, discussion points, and teaching tips for the "Introduction to Safe Utility Functions" worksheet. The activity introduces students to the concept of error-resistant wrapper functions that handle exceptions internally and return sensible default values.

## Implementation Solutions

### Task: Create a Safe Integer Conversion Function

```python
def safe_int(text, default=0):
    """
    Safely convert text to an integer.
    
    Args:
        text (str): The text to convert
        default (int): Value to return if conversion fails
        
    Returns:
        int: The converted integer or the default value
    """
    try:
        return int(text)
    except ValueError:
        return default
```

Expected outputs:
- `safe_int("123")` â†’ 123
- `safe_int("abc")` â†’ 0
- `safe_int("abc", -1)` â†’ -1

### Extension Function Solutions

#### Option 1: safe_float()
```python
def safe_float(text, default=0.0):
    """
    Safely convert text to a floating-point number.
    
    Args:
        text (str or number): The value to convert
        default (float): Value to return if conversion fails
        
    Returns:
        float: The converted float or the default value
    """
    try:
        return float(text)
    except (ValueError, TypeError):
        return default
```

#### Option 2: safe_divide()
```python
def safe_divide(numerator, denominator, default=0.0):
    """
    Safely divide two numbers, handling division by zero.
    
    Args:
        numerator (number): The dividend
        denominator (number): The divisor
        default (number): Value to return if division fails
        
    Returns:
        number: The result of division or the default value
    """
    try:
        return numerator / denominator
    except ZeroDivisionError:
        return default
```

#### Option 3: safe_read_file()
```python
def safe_read_file(filename, default=""):
    """
    Safely read a file, returning a default value if the file doesn't exist.
    
    Args:
        filename (str): Path to the file
        default (str): Value to return if file reading fails
        
    Returns:
        str: The contents of the file or the default value
    """
    try:
        with open(filename, 'r') as file:
            return file.read()
    except (FileNotFoundError, PermissionError, IOError):
        return default
```

## Teaching Notes

### Key Concepts to Emphasize
1. **Error Prevention vs. Error Handling**: Safe functions represent a proactive approach to dealing with potential errors.
2. **Abstraction of Error Handling**: Users of safe functions don't need to worry about try-except blocks in their code.
3. **Graceful Degradation**: Programs can continue functioning even when operations fail.

### Common Student Misconceptions
1. **All Errors Should Be Hidden**: Clarify that some errors should propagate (e.g., programming errors).
2. **Default Values Are Always Good**: Discuss how default values can sometimes mask real problems.
3. **Safe Functions Replace Exception Handling**: Explain that both approaches have their place.

### Discussion Question Guidance

#### Q1: How does your safe_int function compare to the built-in int() function?
**Key points to guide discussion:**
- The standard `int()` raises exceptions for invalid inputs
- `safe_int()` returns a default value instead of raising exceptions
- `safe_int()` has the same conversion behavior for valid inputs
- `safe_int()` may hide errors that could be important to know about

#### Q2: What are the advantages of returning a default value instead of raising an exception?
**Key points to guide discussion:**
- Simpler calling code without try-except blocks
- Programs continue running despite errors
- Reasonable fallback behavior for non-critical operations
- Better user experience for applications with casual users

#### Q3: Are there any disadvantages to hiding errors this way?
**Key points to guide discussion:**
- Errors might go unnoticed
- Debugging can become harder when errors are silently handled
- The program might continue with invalid data
- Default values might not be appropriate for all use cases

#### Q4: When might it be better to let exceptions propagate?
**Key points to guide discussion:**
- Critical operations where errors should not be ignored
- When detailed error information is needed
- During development and debugging
- When the calling code needs to handle the error specifically

### Reflection Question Guidance

#### How does creating "safe" versions of functions improve reliability?
**Key points to guide discussion:**
- Prevents crashes from unexpected inputs
- Allows for graceful degradation
- Simplifies error handling throughout the codebase
- Creates more predictable behavior

#### What considerations for choosing appropriate default values?
**Key points to guide discussion:**
- The default should be sensible within the domain context
- Ideally identifiable as a "default" and not a valid result
- Should not cause further errors down the line
- May need to be customizable for different contexts

#### How might students apply this concept to other operations?
**Key points to guide discussion:**
- Network operations that might time out
- Database queries that might fail
- User input validation
- JSON/data parsing functions

## Classroom Management Tips

1. **Live Coding**: Demonstrate the building of a safe function from scratch.
2. **Real-world Examples**: Show examples of safe functions in popular libraries.
3. **Pair Programming**: Have students work in pairs to implement different safe functions and then swap implementations.
4. **Error Challenge**: Create a challenge where students must identify scenarios where errors might occur in existing code.

## Assessment Guidelines

### What to Look For in Student Solutions

#### Correct Implementation (40%)
- Proper try-except structure
- Correct exception types being caught
- Appropriate use of the default parameter

#### Function Design (30%)
- Clear, descriptive function name
- Comprehensive docstring
- Sensible parameter names and default values

#### Error Handling Strategy (30%)
- Thoughtful consideration of which exceptions to catch
- Not catching overly broad exceptions without justification
- Appropriate error isolation

#### Bonus Points
- Additional error logging or reporting features
- Parameter validation
- Consideration of multiple error types

## Mini-Project Connection
Remind students that this activity is preparation for the Week 11 mini-project. You might want to have students start brainstorming what types of safe utility functions would be useful in their own programming projects.

## Conclusion
The concept of safe functions provides a powerful tool for creating more robust code. By learning to anticipate and handle errors gracefully, students are developing a key software engineering skill that will serve them throughout their programming careers.---
title: "Staff Answer Guide: Advanced Exception Handling Techniques"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


## Overview
This guide provides instructors with answers, explanations, and teaching notes for the "Advanced Exception Handling Techniques" worksheet. It includes solutions to all tasks, anticipated student questions, and suggestions for classroom delivery.

## Learning Objectives
- Implement multi-level exception handling for different error types
- Use the complete try-except-else-finally structure
- Analyze and improve code with robust exception handling

## Worksheet Structure
The worksheet progresses through:
1. Review of basic exception handling
2. Introduction to advanced techniques (multiple exception types, else, finally)
3. Code analysis and improvement activity
4. Extension activity with timeout handling
5. Reflection questions

## Task 1: Identify Issues in Code - Answer Key

Students should identify the following potential errors in the `process_data_file` function:

1. **FileNotFoundError**: If the file doesn't exist
2. **PermissionError**: If the file exists but can't be accessed
3. **IOError/OSError**: For other file I/O issues
4. **ValueError**: If any line can't be converted to an integer
5. **ZeroDivisionError**: If the file is empty, `len(numbers)` will be 0
6. **Resource Leak**: If an exception occurs, the file won't be closed properly
7. **UnicodeDecodeError**: If the file contains characters that can't be decoded

## Task 2: Improved Code - Answer Key

```python
def improved_process_data_file(filename):
    """
    Processes a file containing numbers and returns their average.
    Handles various potential errors gracefully.
    
    Args:
        filename (str): Name of the file to process
        
    Returns:
        float: Average of numbers in the file, or None if processing failed
    """
    file = None
    try:
        file = open(filename, 'r')
        lines = file.readlines()
        
        if not lines:
            print(f"Warning: File '{filename}' is empty.")
            return None
        
        numbers = []
        for i, line in enumerate(lines):
            try:
                numbers.append(int(line.strip()))
            except ValueError:
                print(f"Warning: Line {i+1} does not contain a valid number. Skipping.")
        
        if not numbers:
            print(f"Error: No valid numbers found in '{filename}'.")
            return None
            
        average = sum(numbers) / len(numbers)
        
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found.")
        return None
    except PermissionError:
        print(f"Error: No permission to read '{filename}'.")
        return None
    except Exception as e:
        print(f"Unexpected error processing '{filename}': {str(e)}")
        return None
    else:
        # This executes if no exceptions were raised in the try block
        print(f"Successfully processed {len(numbers)} numbers from '{filename}'.")
    finally:
        # This always executes, regardless of exceptions
        if file is not None and not file.closed:
            file.close()
            
    return average
```

Key improvements in this solution:
1. Uses `try-except-else-finally` structure
2. Handles multiple specific exception types
3. Provides informative error messages
4. Ensures the file is always closed with `finally`
5. Handles the case of empty files and non-numeric data
6. Returns `None` when processing fails
7. Uses specific exception handling for line parsing (nested try-except)

## Task 3: Testing - Expected Output

When testing with various files, students should see behavior similar to:

```
# For nonexistent.txt
Error: File 'nonexistent.txt' not found.
None

# For bad_data.txt
Warning: Line 3 does not contain a valid number. Skipping.
Successfully processed 3 numbers from 'bad_data.txt'.
2.3333333333333335

# For empty.txt
Warning: File 'empty.txt' is empty.
None

# For good_data.txt
Successfully processed 4 numbers from 'good_data.txt'.
25.0
```

## Extension: Timeout Handler - Sample Solution

```python
import signal
import time

class TimeoutError(Exception):
    pass

def timeout_handler(signum, frame):
    raise TimeoutError("Operation timed out")

def read_file_with_timeout(filename, timeout_seconds=5):
    """
    Attempts to read a file but gives up if it takes too long.
    
    Args:
        filename (str): The file to read
        timeout_seconds (int): Maximum seconds to wait
        
    Returns:
        str: File contents or error message
    """
    # Set the timeout signal handler
    signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(timeout_seconds)
    
    file = None
    try:
        file = open(filename, 'r')
        contents = file.read()
        signal.alarm(0)  # Cancel the alarm
        return contents
    except FileNotFoundError:
        return f"Error: File '{filename}' not found."
    except PermissionError:
        return f"Error: No permission to read '{filename}'."
    except TimeoutError:
        return f"Error: Reading '{filename}' timed out after {timeout_seconds} seconds."
    except Exception as e:
        return f"Unexpected error reading '{filename}': {str(e)}"
    finally:
        if file is not None and not file.closed:
            file.close()
        signal.alarm(0)  # Ensure alarm is canceled even if an exception occurred
```

**Note for instructors**: The timeout functionality may not work in all environments, particularly in Windows. Be prepared to discuss alternative timeout methods like threading if needed.

## Reflection Questions - Teaching Notes

1. **How does handling specific exceptions improve your code?**
   - Key points: Allows for specific responses to different error types
   - Avoids masking bugs with generic handlers
   - Provides more informative feedback to users
   - Creates more targeted recovery strategies

2. **When would you use the `else` clause?**
   - For code that should only run if no exceptions occurred
   - Separates "success path" code from error handling
   - Makes code logic clearer and prevents nesting
   - Example: processing results that only exist if earlier steps succeeded

3. **How could exception handling make programs more user-friendly?**
   - Prevents crashes and provides helpful error messages
   - Offers recovery options instead of simply failing
   - Preserves user data when errors occur
   - Logs useful diagnostic information for support

4. **How do these practices relate to the "Safe Utils Module" project?**
   - They form the foundation for creating robust utility functions
   - Encapsulate complex error handling behind a clean interface
   - Allow consistent error management across an application
   - Convert technical exceptions into meaningful user feedback

## Classroom Delivery Suggestions

1. **Start with a live demo** showing how basic code fails with various inputs
2. **Pair programming** for Task 2 works well - one student focusing on structure, the other on specific exceptions
3. **Create additional test cases** to challenge student solutions (files with mixed valid/invalid data, very large files, etc.)
4. **Relate to real applications** students might create (data analysis, web scraping, configuration handling)
5. **Discuss performance implications** of exception handling vs. checking conditions beforehand

## Common Student Questions

**Q: When should I catch a specific exception vs. using a general `except` clause?**
A: Catch specific exceptions when you can take a specific recovery action. Use a general clause only as a last resort to prevent crashes, preferably logging the unexpected error.

**Q: Why use `else` when I could just put that code after the try-except?**
A: The `else` clause only executes if no exceptions occurred AND no `return`/`break`/`continue` statements were hit in the try block, making program flow clearer.

**Q: Is there a way to catch multiple exception types with the same handler?**
A: Yes, use a tuple: `except (FileNotFoundError, PermissionError):` to handle both with the same code.

**Q: Why not just use context managers (with statements) instead of try-finally?**
A: Context managers are excellent for resource management (`with open() as f`), but try-except-else-finally gives you more control over the entire error handling process.

## Assessment Criteria

When evaluating student solutions for Task 2, look for:
1. **Correctness**: Handles all identified error cases
2. **Robustness**: Deals gracefully with unexpected situations
3. **Usability**: Provides clear, actionable error messages
4. **Efficiency**: Doesn't over-complicate the solution
5. **Resource management**: Properly closes files in all cases

## Extended Discussion Topics

* Exception handling performance implications
* Custom exception classes (when and how to create them)
* Python's error handling compared to other languages
* Balancing robust error handling with readable code
* Error logging best practices---
title:"Staff Answer Guide: Introduction to File Operations and Basic Error Handling"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


## Overview
This worksheet introduces students to essential file operations in Python and basic error handling techniques. The activities focus on opening, reading, writing, and closing files, as well as implementing try-except blocks to handle potential errors gracefully.

## Learning Objectives
- Apply basic file operations in Python
- Identify common errors in file operations
- Implement exception handling with try-except blocks
- Use context managers with the `with` statement

## Key Concepts Review

### File Operations
Students will learn:
- Opening files with different modes (`'r'`, `'w'`, `'a'`)
- Reading and writing file content
- Importance of properly closing files

### Exception Handling
Students will practice:
- Identifying errors that occur during file operations
- Using try-except blocks to catch specific exceptions
- Creating more robust programs that don't crash on common errors

## Expected Error Messages

When students run the code that attempts to open a nonexistent file, they should see an error like:
```
FileNotFoundError: [Errno 2] No such file or directory: 'nonexistent_file.txt'
```

## Solution to Task 1: Write the Basic Log Function

```python
from datetime import datetime

def add_log_entry(note):
    """
    Adds a timestamped entry to a log file.
    
    Args:
        note (str): The message to log
    """
    try:
        # Method 1: Without context manager
        # file = open('daily_log.txt', 'a')
        # current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        # file.write(f"[{current_time}] {note}\n")
        # file.close()
        
        # Method 2: With context manager (preferred)
        with open('daily_log.txt', 'a') as file:
            current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # Optional: Check if note is empty
            if not note.strip():
                note = "(Empty entry)"
                
            file.write(f"[{current_time}] {note}\n")
            
    except Exception as e:
        print(f"Error writing to log file: {e}")
```

## Solution to Task 2: Test Your Function

Key points to discuss with students:
- The function should handle empty strings
- Additional test cases might include:
  - Very long entries
  - Entries with special characters
  - Multiple entries in succession

```python
# Testing with valid input
add_log_entry("Started working on Python file operations assignment")

# Testing with empty input
add_log_entry("")

# Additional test cases
add_log_entry("Entry with special characters: !@#$%^&*()")
add_log_entry("A" * 1000)  # Very long entry
```

## Solution to Extension: Reading and Processing the Log

```python
def display_recent_logs(num_entries=5):
    """
    Displays the most recent log entries.
    
    Args:
        num_entries (int): Number of recent entries to display
    """
    try:
        with open('daily_log.txt', 'r') as file:
            # Read all lines and convert to a list
            lines = file.readlines()
            
            # Calculate how many entries to show
            entries_to_show = min(num_entries, len(lines))
            
            if entries_to_show == 0:
                print("No log entries found.")
                return
                
            print(f"Displaying the {entries_to_show} most recent log entries:")
            
            # Display the most recent entries (from the end of the file)
            for i in range(1, entries_to_show + 1):
                print(lines[-i].strip())
                
    except FileNotFoundError:
        print("Log file doesn't exist yet. Try adding some entries first.")
    except Exception as e:
        print(f"Error reading log file: {e}")
```

## Discussion Points for Reflection Questions

### 1. Benefits of try-except blocks
- Programs continue running instead of crashing
- Errors can be handled gracefully with user-friendly messages
- Allows for recovery strategies when operations fail
- Makes code more robust in unpredictable environments

### 2. Importance of closing files
- Prevents resource leaks (open file handles)
- Ensures all data is properly written (flushes buffers)
- Makes files available to other processes
- The `with` statement ensures files are closed even if exceptions occur

### 3. Other potential file errors to handle
- `PermissionError`: Insufficient permissions to read/write the file
- `IOError`: General input/output errors
- `IsADirectoryError`: Trying to open a directory as a file
- `DiskFullError`: No space left on the device
- `JSONDecodeError`: When working with JSON files
- `UnicodeDecodeError`: Issues with character encoding

## Teaching Tips

1. **Demonstrate Real-World Relevance**: Explain how proper file handling is crucial in professional applications (databases, log systems, data processing).

2. **Visualization**: Draw diagrams showing the flow of try-except blocks and how they change program execution.

3. **Common Pitfalls to Highlight**:
   - Forgetting to close files
   - Using bare `except:` without specifying exceptions
   - Not handling empty or malformed input

4. **Scaffolding**: 
   - For struggling students, provide a partially completed solution
   - For advanced students, challenge them to add features like:
     - Searching the log by keyword
     - Deleting old entries
     - Sorting or filtering entries

5. **Check for Understanding**:
   - Ask students to explain why the `with` statement is preferred
   - Have them predict what happens with different error scenarios

## Extension Activities

For students who finish early or want additional challenges:

1. **Log Parser**: Create a function that analyzes the log file to show statistics (e.g., entries per day)

2. **Categories**: Modify the log system to support different categories of entries (e.g., INFO, WARNING, ERROR)

3. **Multiple Log Files**: Extend the program to maintain separate log files for different users or purposes

4. **CSV Integration**: Convert the log to CSV format for easier data analysis

## Assessment Criteria

When reviewing student work, look for:

- Proper use of context managers (`with` statement)
- Appropriate exception handling
- Input validation
- Clear, well-formatted output
- Thoughtful reflection responses---
title: "STAFF-ANSWER-GUIDE Activity 1: Setting Up Your Local Python Environment"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

## Overview for Tutors

This guide will help you support students as they install Anaconda and set up their local Python environment. The transition from cloud-based environments (like Google Colab) to local development is a significant step that often presents challenges for beginners. This guide highlights common issues, provides troubleshooting strategies, and offers additional context to help you guide students effectively.

## Learning Objectives Assessment

Students should demonstrate the following by the end of this activity:

1. Successfully installed Anaconda on their system
2. Created and run a Jupyter Notebook locally
3. Verified that essential libraries (pandas, matplotlib, numpy) work properly
4. Installed an additional package (pygame) for future activities
5. Basic understanding of Anaconda's components and environment management

## Expected Submission from Students

âœ… Screenshot showing Jupyter Notebook with working matplotlib plot  
âœ… Written answers to the checkpoint questions  

## Answer Key for Checkpoint Questions

### 1. What are two advantages of using Anaconda instead of installing Python directly?

**Strong answers include any two of:**
- Includes many pre-installed scientific and data analysis packages
- Provides an integrated package manager (conda) for easy installation of additional libraries
- Includes tools like Jupyter Notebook, Spyder IDE, and Anaconda Navigator
- Simplifies environment management and package dependencies
- Works consistently across different operating systems
- Avoids conflicts with system Python installations

**Weak answers:**
- "It's easier" (without specifics)
- "It's better for beginners" (without explaining why)
- Answers that confuse Anaconda with Python itself

### 2. What is the difference between Jupyter Notebook and Python IDLE?

**Strong answers include:**
- Jupyter Notebook provides an interactive, cell-based interface where code, text, and visualisations can coexist; IDLE is a basic code editor and shell
- Jupyter supports markdown, HTML, and rich media outputs; IDLE is primarily text-based
- Jupyter Notebooks can be shared as documents with outputs included; IDLE is focused on writing and running scripts
- Jupyter runs in a web browser; IDLE is a standalone application

**Weak answers:**
- Answers that don't recognise the fundamentally different purposes and interfaces
- Answers that claim one is "better" without explaining the differences

### 3. Why might you want to create different environments for different projects?

**Strong answers include:**
- To manage different package versions or dependencies between projects
- To avoid conflicts between packages that may be incompatible
- To ensure reproducibility by isolating project requirements
- To experiment with different Python versions
- To share exact environment specifications with collaborators

**Weak answers:**
- Vague responses about "organisation" without mentioning package management
- Answers that suggest environments are just for file organisation

### 4. How would you install a new package that isn't currently in your Anaconda installation?

**Strong answers include either:**
- Using conda: `conda install package_name`
- Using pip within Anaconda: `pip install package_name`
- Using Anaconda Navigator's graphical interface to search and install packages

**Bonus points** for mentioning:
- Specifying the channel: `conda install -c conda-forge package_name`
- Creating/activating environments before installing: `conda activate myenv`
- Using environment files: `conda env create -f environment.yml`

**Weak answers:**
- Incorrect syntax for installation commands
- Methods that don't use conda or pip (within the Anaconda ecosystem)

### 5. What does the following code do in a Jupyter Notebook?
```python
import sys
print(sys.executable)
```

**Strong answer:**
- It displays the path to the Python executable that's currently running the notebook
- This helps verify which Python installation/environment is being used

**Weak answers:**
- Answers that don't recognise this shows the Python interpreter location
- Answers that confuse this with displaying Python version information

## Common Technical Issues and Solutions

### Installation Problems

| Issue | Common Causes | Solution |
|-------|--------------|----------|
| "Anaconda is not recognised" in command prompt/terminal | PATH not set correctly during installation | 1. Reinstall with "Add to PATH" option checked<br>2. Manually add Anaconda to PATH<br>3. Use Anaconda Prompt instead |
| Installation appears to hang | Large download, slow extraction on older hardware | Be patient - the installer may take 10-30 minutes on slower systems |
| "Permission denied" errors on macOS/Linux | Not running as administrator/sudo | Rerun installer with appropriate permissions |
| "Failed to create Anaconda menu" on Windows | Multiple users on system | Run installer as administrator |
| Disk space errors | Insufficient free space (Anaconda needs ~3GB) | Help student clear space or identify another drive with sufficient space |

### Jupyter Notebook Issues

| Issue | Common Causes | Solution |
|-------|--------------|----------|
| Jupyter doesn't launch from Navigator | Browser issues, port conflicts | 1. Try launching from command line: `jupyter notebook`<br>2. Check if another notebook server is running |
| "Kernel not found" error | Python kernel not registered properly | Run: `python -m ipykernel install --user` |
| Plots don't display | Missing matplotlib backend config | Add `%matplotlib inline` at top of notebook |
| Notebook runs slowly | Low system resources, too many notebooks open | Close other applications, restart kernel between tests |
| Cannot connect to kernel | Background process issues | Restart computer; if persists, reinstall Jupyter: `conda install -c conda-forge notebook` |

### Package Installation Issues

| Issue | Common Causes | Solution |
|-------|--------------|----------|
| Package install fails | Internet connectivity, conflicts | 1. Check internet connection<br>2. Try `conda install -c conda-forge package_name`<br>3. Create a fresh environment for problematic packages |
| "PackagesNotFoundError" | Package not in default channels | Try pip instead: `pip install package_name` |
| "EnvironmentNotWritableError" | Trying to install in base env without permissions | Use `conda create -n myenv` to create a new environment first |
| Installing pygame specifically | Missing dependencies | On Linux: install SDL dev libraries<br>On Windows: update Visual C++ Redistributable |
| Different versions between pip and conda | Using both package managers | Stick to one manager per environment when possible |

### Platform-Specific Issues

#### Windows
- Command Prompt vs. Anaconda Prompt confusion
- PATH environment variable limitations
- Windows Defender/antivirus blocking executables

#### macOS
- M1/M2 chip compatibility issues with some packages
- XCode command-line tools requirements
- Homebrew conflicts

#### Linux
- Different package dependencies across distributions
- X11 requirements for graphical applications
- Permissions and multi-user setup complexities

## Teaching Tips

### Beginning of Session
- **Verify system requirements** before students begin installation
- **Ask students to download** Anaconda installer before the session starts
- **Prepare a backup plan** for students with unsuitable hardware (e.g., temporary cloud alternatives)
- **Group students by OS** to address platform-specific issues efficiently

### During Installation
- **Set expectations** about download and installation time (10-30 minutes)
- **Encourage screenshots** of any error messages
- **Create a help queue** for students stuck on installation issues
- **Prepare a demo environment** to show expected outcomes while students wait

### For Struggling Students
- **Prioritise getting Jupyter working** - even if not all packages install correctly
- **Offer "pair programming"** to let struggling students work with those who are successful
- **Provide screenshots** of expected outputs and interfaces
- **Consider alternative paths** (e.g., online Jupyter environments) if local installation is impossible

### For Advanced Students
- **Challenge them to explore** conda environments more deeply
- **Have them assist** peers who are having trouble
- **Introduce more advanced topics** like environment.yml files or JupyterLab
- **Discuss IDEs** like VS Code or PyCharm as alternatives to Jupyter

## Activity Extensions

For students who finish early or need additional challenges:

1. **Create a new environment** with a different Python version and observe differences
2. **Install and test JupyterLab** as an alternative to Jupyter Notebook
3. **Export their environment** to an environment.yml file and recreate it
4. **Install a specialised package** like scikit-learn, OpenCV, or TensorFlow and test it
5. **Compare performance** between local Jupyter and Google Colab for identical notebooks

## Assessment Guidance

### Exemplary Work Should Show:
- Complete, successful installation with all test code running
- Clear understanding of Anaconda's purpose and components
- Thoughtful answers to checkpoint questions that demonstrate understanding
- Evidence of exploration beyond minimum requirements
- Clean, well-organised notebook with appropriate markdown cells

### Satisfactory Work Should Show:
- Successful installation with basic functionality working
- Basic understanding of Anaconda's purpose
- Reasonable answers to checkpoint questions
- Completed basic tasks as outlined in worksheet

### Needs Improvement If:
- Installation incomplete or non-functional
- Unable to run basic Python code locally
- Minimal or incorrect answers to checkpoint questions
- No evidence of independent problem-solving

## Preventing Common Conceptual Misunderstandings

### Anaconda vs. Python
Many students confuse Anaconda with Python itself. Clarify that Anaconda is a distribution that includes Python plus additional tools and packages.

### Jupyter vs. Python
Some students think Jupyter is a different language. Emphasise that Jupyter is just an interface for running Python (and other languages).

### Conda vs. Pip
Students often don't understand the difference between these package managers. Explain that conda can handle non-Python dependencies and environment management, while pip is Python-specific.

### Environments vs. Folders
Students may conflate environments with simple file organisation. Explain that environments are isolated installations with their own packages and dependencies.

## Post-Activity Follow-Up

After all students have completed the activity:

1. **Conduct a brief survey** to identify common challenges
2. **Prepare a follow-up document** addressing frequently asked questions
3. **Create a troubleshooting guide** specific to your class's common issues
4. **Check installation status** before the next activity that requires local Python

## Final Notes for Tutors

- **Be patient** - this is often students' first experience with development environment setup
- **Validate frustration** - acknowledge that environment setup is challenging even for professionals
- **Emphasise the value** of learning to set up local environments despite the initial hurdles
- **Document unique issues** you encounter for future sessions

Remember that successfully navigating installation challenges is itself a valuable learning experience for students, preparing them for real-world development environments.
---
title: "STAFF-ANSWER-GUIDE Activity 2: Exploring Python Mini-Projects"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


## Overview for Tutors

This guide will help you support students as they explore and modify the example mini-projects from the "Beyond the Basics" lecture. In this activity, students will run pre-written code examples, understand their functionality, and make modifications to learn about different Python application domains. This is a bridge activity between following structured tutorials and creating original code, so students will need guidance in understanding existing code and making meaningful changes.

## Learning Objectives Assessment

Students should demonstrate the following by the end of this activity:

1. Successfully run at least one example project from the provided code pack
2. Demonstrate understanding of the code's structure and functionality
3. Make meaningful modifications to existing code
4. Document their changes and reflect on what they've learned
5. Identify areas of interest for future learning

## Expected Submission from Students

âœ… Modified code files  
âœ… Screenshots showing their modifications in action  
âœ… Written answers to the reflection questions  
âœ… Documentation of challenges or errors encountered  

## Example Project Guidelines and Common Issues

### Data Science Example (Weather Analysis)

#### Expected Understanding

Students should grasp:
- How to load data from CSV files using pandas
- Basic data cleaning operations
- Creating simple visualisations with matplotlib
- Performing data aggregation and calculations

#### Likely Modification Attempts

1. **Changing chart types**: Line to bar, scatter, etc.
2. **Altering colors or visual elements**
3. **Adding new calculations**: Averages, min/max, etc.
4. **Filtering data** based on different criteria

#### Common Issues and Solutions

| Issue | Likely Cause | Solution |
|-------|-------------|----------|
| "FileNotFoundError" | Incorrect path to CSV file | Check relative path; ensure file is in expected location |
| Empty or unexpected plots | Data filtering removed all points | Check filter conditions; print data before plotting |
| Type errors in calculations | Mixed data types in columns | Add explicit conversion: `df['column'] = df['column'].astype(float)` |
| Plots not showing | Missing `plt.show()` or incorrect environment | Ensure `plt.show()` is called; use `%matplotlib inline` in notebooks |
| SettingWithCopyWarning | Modifying a slice of a DataFrame | Use `df.loc[]` for assignment or create explicit copy with `df.copy()` |

#### Extension Guidance

For students who grasp the basics quickly, suggest:
- Combining multiple visualisations into subplots
- Implementing interactive widgets (if using notebooks)
- Conducting more complex statistical analysis
- Creating annotated plots with important data points highlighted

### Web Development Example (Flask App)

#### Expected Understanding

Students should grasp:
- Basic Flask application structure
- Routes and view functions
- Templates and passing data to HTML
- Handling basic form input (if implemented)

#### Likely Modification Attempts

1. **Adding new routes/pages**
2. **Modifying HTML templates**
3. **Adding form inputs**
4. **Changing display logic**

#### Common Issues and Solutions

| Issue | Likely Cause | Solution |
|-------|-------------|----------|
| "ModuleNotFoundError" for Flask | Flask not installed | Run `pip install flask` |
| App runs but shows "Not Found" | Incorrect route definition | Check route decorator matches URL being accessed |
| Template not found | Incorrect template folder structure | Ensure templates are in a folder named "templates" |
| Changes not appearing | Browser caching | Hard refresh (Ctrl+F5 or Cmd+Shift+R) |
| Permission denied on port | Port already in use | Change port number in `app.run(port=8080)` |
| Variables not appearing in template | Incorrect variable names | Match template variables to those passed in `render_template()` |

#### Extension Guidance

For students who grasp the basics quickly, suggest:
- Adding persistent data storage (simple file-based or SQLite)
- Implementing more complex form handling with validation
- Adding basic user authentication
- Styling the site with CSS (if they have web experience)

### GUI Application Example (Weather App)

#### Expected Understanding

Students should grasp:
- Tkinter window and widget creation
- Event handling with callbacks
- Layout management (grid, pack, or place)
- Updating UI elements dynamically

#### Likely Modification Attempts

1. **Changing colors or fonts**
2. **Adding new buttons or inputs**
3. **Modifying the layout**
4. **Extending functionality** with new features

#### Common Issues and Solutions

| Issue | Likely Cause | Solution |
|-------|-------------|----------|
| Window appears briefly then closes | Main loop not called or error in code | Ensure `root.mainloop()` is at the end; check for runtime errors |
| Widgets not appearing | Layout manager not called | Check for `.pack()`, `.grid()`, or `.place()` on all widgets |
| Buttons don't do anything | Callback function not connected properly | Verify command parameter: `command=function_name` (no parentheses) |
| Layout looks different than expected | Mixed layout managers | Stick to one layout manager per container |
| Text not updating | StringVar not used correctly | Ensure `textvariable=var` and update with `var.set()` |
| "TclError" | Invalid widget operations | Check widget state before operations; handle errors with try/except |

#### Extension Guidance

For students who grasp the basics quickly, suggest:
- Implementing multiple frames or screens
- Adding data validation for inputs
- Creating custom styled widgets
- Connecting the UI to external data sources

### Automation Example (File Organisation)

#### Expected Understanding

Students should grasp:
- File system operations with `os` and `shutil`
- Working with file paths and extensions
- Conditional logic for file categorisation
- Basic automation workflow

#### Likely Modification Attempts

1. **Adding new file categories**
2. **Implementing file renaming**
3. **Adding logging functionality**
4. **Modifying organisation criteria**

#### Common Issues and Solutions

| Issue | Likely Cause | Solution |
|-------|-------------|----------|
| "PermissionError" | Files in use or insufficient permissions | Close open files; run with appropriate permissions |
| No files moved | Incorrect path or no matching files | Verify directory path; print files found before processing |
| Files moved to wrong location | Logic error in categorisation | Review conditional statements; print category before moving |
| Script runs but nothing happens | Silent failures | Add more print statements; implement error handling |
| Files unexpectedly overwritten | Destination file already exists | Add checks with `os.path.exists()` and handle duplicates |

#### Extension Guidance

For students who grasp the basics quickly, suggest:
- Implementing a scheduled task (basic cron-like functionality)
- Adding a simple configuration file to customise behavior
- Creating a basic undo functionality
- Building a log analyser to summarise operations

### Game Development Example (Pygame)

#### Expected Understanding

Students should grasp:
- Pygame initialisation and basic setup
- Game loop structure
- Drawing graphics to the screen
- Handling user input
- Basic collision detection

#### Likely Modification Attempts

1. **Changing colors or object sises**
2. **Adjusting game speed**
3. **Adding new game elements**
4. **Modifying game mechanics**

#### Common Issues and Solutions

| Issue | Likely Cause | Solution |
|-------|-------------|----------|
| "ModuleNotFoundError" for pygame | Pygame not installed | Run `pip install pygame` |
| Black window with no elements | Drawing code issue or timing problem | Check draw calls; verify screen update is called |
| Game runs too fast/slow | Frame rate not controlled | Use `clock.tick(FPS)` to regulate speed |
| Input not recognised | Event handling incomplete | Ensure all events processed with `for event in pygame.event.get()` |
| Objects don't move | Position not updated | Verify position variables change; check for logic errors |
| Collision not detected | Collision logic error | Print object positions; check collision detection math |

#### Extension Guidance

For students who grasp the basics quickly, suggest:
- Adding scoring and display elements
- Implementing game states (start, play, game over)
- Adding sound effects
- Creating multiple levels or difficulty settings

## Answering Reflection Questions: Guidance for Strong Responses

### 1. Which example(s) did you explore? Why did you choose these?

**Strong responses include:**
- Specific reasons related to interests or career goals
- Connections to prior programming experience
- Thoughtful consideration of which domains they wanted to learn more about
- Reflection on what seemed challenging or novel to them

**Encourage students to:** Explain not just what they chose, but their decision-making process and what they hoped to learn.

### 2. What modifications did you make to the code? Describe the before and after.

**Strong responses include:**
- Specific code changes with examples
- Clear explanation of how the original functionality worked
- Detailed description of the modified behavior
- Discussion of any challenges in implementing changes
- Screenshots or examples showing the changes in action

**Encourage students to:** Use technical language precisely and demonstrate understanding of why their changes had the effect they did.

### 3. What was the most challenging part of understanding the example code?

**Strong responses include:**
- Identification of specific complex concepts
- Reflection on their own knowledge gaps
- Description of their process for overcoming challenges
- Insights gained from working through difficulties

**Encourage students to:** Be specific about what confused them and how they resolved their confusion, not just stating that something was "hard."

### 4. What new Python features, libraries, or concepts did you learn from these examples?

**Strong responses include:**
- Specific language features, methods, or functions
- New libraries or modules they hadn't encountered before
- Concepts or patterns used in the code
- Comparisons to what they already knew

**Encourage students to:** Go beyond just naming libraries to discussing specific functions, methods, or patterns they learned.

### 5. Which area of Python programming most interests you for future learning? Why?

**Strong responses include:**
- Thoughtful reflection on their interests and strengths
- Connections to potential projects or applications
- Specific aspects of the area that appeal to them
- Consideration of learning resources or next steps

**Encourage students to:** Think about both what interests them and what would be valuable for their goals, not just what seemed easiest.

### 6. How could you apply what you learned to create a project of your own?

**Strong responses include:**
- Specific project ideas that build on the examples
- Realistic assessment of what they could implement now
- Identification of skills they would need to develop further
- Connections between multiple concepts or examples

**Encourage students to:** Be creative but realistic in their ideas, focusing on projects that would consolidate their learning.

## Common Conceptual Challenges and Teaching Strategies

### Challenge: Understanding Code Structure in Larger Programs

Many students are used to writing small programs and struggle to understand the organisation of larger codebases.

**Teaching strategies:**
- Encourage students to trace the execution flow on paper
- Suggest adding print statements to track program flow
- Help them identify the "entry point" and follow execution from there
- Demonstrate how to break down large functions into logical components

### Challenge: Making Meaningful vs. Superficial Changes

Students often default to changing colors or text rather than functional aspects.

**Teaching strategies:**
- Provide specific suggestions for more substantial changes
- Ask questions about how specific features work to guide deeper understanding
- Challenge students to extend functionality in specific ways
- Validate simple changes as a starting point, but push for more

### Challenge: Understanding Library Documentation

Many students struggle to find information in documentation for new libraries.

**Teaching strategies:**
- Demonstrate how to search for specific functions in documentation
- Show examples of reading function signatures to understand parameters
- Point out patterns common to many libraries (e.g., initialisation, cleanup)
- Encourage experimentation in the REPL or notebook to test assumptions

### Challenge: Connecting Theory to Implementation

Students sometimes understand concepts in theory but struggle to identify them in code.

**Teaching strategies:**
- Explicitly point out where theoretical concepts appear in the code
- Ask students to identify specific patterns or concepts in the examples
- Draw diagrams to connect abstract concepts to concrete implementation
- Use analogies that relate programming concepts to familiar ideas

## Differentiated Support Strategies

### For Struggling Students

1. **Simplify the task**: Suggest more straightforward modifications
2. **Provide scaffolding**: Give partially completed code for changes
3. **Break it down**: Divide modifications into smaller steps
4. **Pair programming**: Partner with another student or tutor
5. **Visual aids**: Draw diagrams of code structure and flow

### For Advanced Students

1. **Challenge extensions**: Suggest more complex modifications
2. **Integration projects**: Combine elements from multiple examples
3. **Research assignments**: Encourage deeper exploration of libraries
4. **Optimisation tasks**: Improve efficiency or organisation of code
5. **Mentoring opportunities**: Have them help explain concepts to peers

## Assessment Guidance

### Exemplary Work Should Show:

- Multiple successful modifications that change program functionality
- Evidence of deep code comprehension in explanations
- Creative extensions beyond suggested modifications
- Thoughtful reflection showing connections to programming concepts
- Clean, well-documented code with appropriate comments

### Satisfactory Work Should Show:

- At least one working modification per example
- Basic understanding of code structure and function
- Reasonable attempts at all reflection questions
- Evidence of problem-solving when faced with challenges
- Functional code that runs without significant errors

### Needs Improvement If:

- Unable to make working modifications
- Superficial understanding of code demonstrated in reflections
- Minimal effort in answering reflection questions
- No evidence of troubleshooting or problem-solving
- Submitted code has significant errors or doesn't run

## Tips for Specific Teaching Scenarios

### Remote/Online Sessions

- Have students share screens when troubleshooting
- Create breakout rooms for different project types
- Use collaborative coding tools if available
- Prepare screen recordings of common modifications as references
- Establish a chat/forum for asynchronous help

### Large Group Sessions

- Prepare handouts with common modifications for each project
- Group students by project choice for peer support
- Create a "help queue" system for efficient assistance
- Have example solutions ready to show intermediate steps
- Use "pair programming" approach to share knowledge

### Mixed-Ability Groups

- Create tiered modification suggestions (basic, intermediate, advanced)
- Establish "expert tables" where advanced students can support others
- Provide extended time for students who need it
- Prepare additional examples for students who finish early
- Design reflection questions that allow for different levels of insight

## Additional Resources for Tutors

### Data Science
- Common pandas operations cheat sheet
- Matplotlib gallery examples
- Data cleaning best practices

### Web Development
- Flask quick reference
- HTML/CSS basics refresher
- Common web application patterns

### GUI Applications
- Tkinter widget reference
- Layout manager comparison
- Event handling patterns

### Automation
- File system operations reference
- Error handling best practices
- Logging implementation examples

### Game Development
- Pygame function reference
- Game loop explanation
- Sprite and collision handling examples

## Final Notes for Tutors

- **Process over product**: This activity is about exploration and understanding, not creating perfect code
- **Encourage experimentation**: Validate attempts even if they don't work perfectly
- **Focus on transferable concepts**: Help students see how techniques apply across domains
- **Build confidence**: This is often students' first time modifying substantial existing code
- **Connect to next activity**: Highlight how these skills will help with building the Snake game

Remember that the goal is to bridge the gap between following tutorials and creating original code. Celebrate small wins and create a supportive environment for experimentation.
---
title: "STAFF-ANSWER-GUIDE Mini-Project: Building Your Own Snake Game"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

## Overview for Tutors

This guide will help you support students as they build a Snake game using Pygame. This activity represents a significant shift from modifying existing code (Activity 2) to building a more complex project from starter code. Students will implement core game functionality and add their own enhancements and customisations. This guide covers implementation details, common issues, assessment criteria, and strategies for supporting different student needs.

## Learning Objectives Assessment

Students should demonstrate the following by the end of this activity:

1. Implement a functional Snake game with core mechanics
2. Apply programming concepts like loops, conditionals, and functions in a game context
3. Debug and troubleshoot issues in their own code
4. Extend base functionality with creative enhancements
5. Understand basic game development concepts (game loop, rendering, input handling)

## Expected Submission from Students

âœ… Complete Snake game code file  
âœ… Screenshots or short video of their game in action  
âœ… Description of enhancements and customisations added  
âœ… Reflection on challenges and solutions  

## Implementation Guide and Common Issues

### Core Game Functionality - Step by Step

#### Setting Up Snake and Food

```python
# Initial snake position (middle of screen)
x = SCREEN_WIDTH // 2
y = SCREEN_HEIGHT // 2

# Initial movement direction
x_change = 0
y_change = 0

# Snake body (list of segments)
snake_segments = []
snake_length = 1

# Generate initial food position
food_x = round(random.randrange(0, SCREEN_WIDTH - BLOCK_SIsE) / BLOCK_SIsE) * BLOCK_SIsE
food_y = round(random.randrange(0, SCREEN_HEIGHT - BLOCK_SIsE) / BLOCK_SIsE) * BLOCK_SIsE
```

**Common Issues:**

| Issue | Likely Cause | Solution |
|-------|-------------|----------|
| Food appears outside game area | Incorrect boundary calculation | Ensure food positions are properly rounded and within screen bounds |
| Snake not appearing | Missing drawing code or position issues | Verify snake segments are correctly added and drawn |
| Food spawns on snake | No collision check when generating food | Add verification that new food position doesn't overlap with snake |

**Conceptual Challenges:**
- Understanding how the snake is represented as a list of segments
- Grasping the grid-based movement system with BLOCK_SIsE
- Properly initialising positions to align with the grid

#### Handling User Input

```python
# Handle key presses
if event.type == pygame.KEYDOWN:
    if event.key == pygame.K_LEFT:
        x_change = -BLOCK_SIsE
        y_change = 0
    elif event.key == pygame.K_RIGHT:
        x_change = BLOCK_SIsE
        y_change = 0
    elif event.key == pygame.K_UP:
        y_change = -BLOCK_SIsE
        x_change = 0
    elif event.key == pygame.K_DOWN:
        y_change = BLOCK_SIsE
        x_change = 0
```

**Common Issues:**

| Issue | Likely Cause | Solution |
|-------|-------------|----------|
| Snake can reverse direction | No check for opposite direction | Add logic to prevent 180Â° turns (e.g., LEFT when moving RIGHT) |
| Multiple key presses cause erratic movement | Processing all events in one frame | Only change direction once per frame or add a small delay |
| Input feels unresponsive | Frame rate issues or event processing | Ensure consistent frame rate with clock.tick(); check event queue is emptied |

**Conceptual Challenges:**
- Understanding Pygame's event queue system
- Grasping how direction changes are represented as coordinate deltas
- Implementing constraints on movement (preventing reversing into self)

#### Updating Snake Position

```python
# Update snake position
x += x_change
y += y_change

# Check for boundary collisions
if x >= SCREEN_WIDTH or x < 0 or y >= SCREEN_HEIGHT or y < 0:
    game_over = True

# Snake head
snake_head = []
snake_head.append(x)
snake_head.append(y)
snake_segments.append(snake_head)

# Remove extra segments if snake is too long
if len(snake_segments) > snake_length:
    del snake_segments[0]
```

**Common Issues:**

| Issue | Likely Cause | Solution |
|-------|-------------|----------|
| Snake disappears after moving | Not properly maintaining segment list | Verify segments are added/removed correctly |
| Snake doesn't grow after eating | Not increasing snake_length | Confirm snake_length increments when food is eaten |
| Snake leaves "trail" behind | Not removing old segments | Check that old segments are deleted when needed |

**Conceptual Challenges:**
- Understanding how the snake moves by adding a new head and removing the tail
- Grasping how list operations manage the snake body
- Implementing collision detection with boundaries

#### Collision Detection and Food

```python
# Check if snake hits itself
for segment in snake_segments[:-1]:  # All segments except the head
    if segment == snake_head:
        game_over = True

# Check if snake eats food
if x == food_x and y == food_y:
    # Generate new food
    food_x = round(random.randrange(0, SCREEN_WIDTH - BLOCK_SIsE) / BLOCK_SIsE) * BLOCK_SIsE
    food_y = round(random.randrange(0, SCREEN_HEIGHT - BLOCK_SIsE) / BLOCK_SIsE) * BLOCK_SIsE
    # Increase snake length
    snake_length += 1
```

**Common Issues:**

| Issue | Likely Cause | Solution |
|-------|-------------|----------|
| Self-collision not detected | Incorrect comparison or list slicing | Verify comparison logic and list operations |
| Food collision not detected | Precision issues with positions | Ensure positions align to the same grid |
| Snake grows at wrong time | Logic error in collision detection | Add debug prints to track positions and collisions |

**Conceptual Challenges:**
- Understanding list slicing to separate head from body
- Implementing precise collision detection
- Managing state changes after collisions

#### Drawing Game Elements

```python
# Clear the screen
screen.fill(BLACK)

# Draw food
pygame.draw.rect(screen, RED, [food_x, food_y, BLOCK_SIsE, BLOCK_SIsE])

# Draw snake
for segment in snake_segments:
    pygame.draw.rect(screen, GREEN, [segment[0], segment[1], BLOCK_SIsE, BLOCK_SIsE])

# Update display
pygame.display.update()
```

**Common Issues:**

| Issue | Likely Cause | Solution |
|-------|-------------|----------|
| Elements flicker or disappear | Missing or out-of-order display updates | Ensure pygame.display.update() is called after all drawing |
| Game visually stutters | Inconsistent frame rate | Use clock.tick(FPS) consistently |
| Elements drawn incorrectly | Coordinate or sise issues | Check rectangle parameters and coordinate calculations |

**Conceptual Challenges:**
- Understanding Pygame's drawing system and coordinate space
- Implementing efficient rendering of multiple objects
- Managing the drawing order and screen updates

### Enhancement Implementation Tips

#### Enhancement 1: Score Display

```python
def display_score(score):
    font = pygame.font.SysFont(None, 25)
    score_text = font.render(f"Score: {score}", True, WHITE)
    screen.blit(score_text, [10, 10])
```

**Implementation Tips:**
- Pygame's font rendering is straightforward but requires initialisation
- Text position is based on the top-left corner of the text rectangle
- Consider using a separate function to keep the main loop clean
- Use a consistent location and style for the score

**Common Issues:**
- Fonts not loading (missing initialisation)
- Text appearing in wrong location
- Score not updating correctly

#### Enhancement 2: Game Over Screen

```python
def display_game_over():
    font = pygame.font.SysFont(None, 50)
    game_over_text = font.render("Game Over!", True, RED)
    restart_text = font.render("Press R to Restart or Q to Quit", True, WHITE)
    
    game_over_rect = game_over_text.get_rect(center=(SCREEN_WIDTH/2, SCREEN_HEIGHT/2 - 50))
    restart_rect = restart_text.get_rect(center=(SCREEN_WIDTH/2, SCREEN_HEIGHT/2 + 50))
    
    screen.blit(game_over_text, game_over_rect)
    screen.blit(restart_text, restart_rect)
    pygame.display.update()
```

**Implementation Tips:**
- Use a separate game state variable to track when to show this screen
- Center text using rect.center for more precise positioning
- Consider adding a slight delay before accepting restart input
- Remember to handle the restart logic in the event loop

**Common Issues:**
- Game immediately restarting without showing the screen
- Text not properly centered
- Restart functionality not working correctly

#### Enhancement 3: Speed Progression

```python
# When snake eats food
if x == food_x and y == food_y:
    # Generate new food, increase length, etc.
    
    # Increase game speed every 5 points
    if score % 5 == 0 and GAME_SPEED < MAX_SPEED:
        GAME_SPEED += 2
```

**Implementation Tips:**
- Define a maximum speed to prevent the game from becoming impossible
- Consider tying speed increases to score milestones
- Update the frame rate in the main loop with `clock.tick(GAME_SPEED)`
- Add visual or audio feedback when speed increases

**Common Issues:**
- Game becoming too fast too quickly
- Speed not actually changing despite code
- GAME_SPEED variable conflicts if defined as a constant

#### Enhancement 4: Different Types of Food

```python
# Define food types with different properties
food_types = [
    {"color": RED, "points": 1, "probability": 0.7},
    {"color": BLUE, "points": 3, "probability": 0.2},
    {"color": GOLD, "points": 5, "probability": 0.1}
]

# Choose food type based on probabilities
def generate_food():
    fx = round(random.randrange(0, SCREEN_WIDTH - BLOCK_SIsE) / BLOCK_SIsE) * BLOCK_SIsE
    fy = round(random.randrange(0, SCREEN_HEIGHT - BLOCK_SIsE) / BLOCK_SIsE) * BLOCK_SIsE
    food_type = random.choices(food_types, 
                              weights=[f["probability"] for f in food_types])[0]
    return fx, fy, food_type
```

**Implementation Tips:**
- Use dictionaries to store food properties
- Consider time-limited special food for extra challenge
- Provide visual distinction between food types
- Use random.choices() with weights for probability-based selection

**Common Issues:**
- Incorrect probability implementation
- Not properly handling the different food properties
- Visual distinction not clear enough

#### Enhancement 5: Wall Obstacles

```python
# Create obstacle positions
obstacles = []
for _ in range(5):  # Create 5 random obstacles
    obs_x = round(random.randrange(0, SCREEN_WIDTH - BLOCK_SIsE) / BLOCK_SIsE) * BLOCK_SIsE
    obs_y = round(random.randrange(0, SCREEN_HEIGHT - BLOCK_SIsE) / BLOCK_SIsE) * BLOCK_SIsE
    # Make sure obstacles don't overlap with snake's starting position
    if abs(obs_x - x) > BLOCK_SIsE * 3 and abs(obs_y - y) > BLOCK_SIsE * 3:
        obstacles.append([obs_x, obs_y])

# Draw obstacles
for obs in obstacles:
    pygame.draw.rect(screen, BLUE, [obs[0], obs[1], BLOCK_SIsE, BLOCK_SIsE])

# Check for obstacle collisions
for obs in obstacles:
    if x == obs[0] and y == obs[1]:
        game_over = True
```

**Implementation Tips:**
- Ensure obstacles don't spawn too close to the snake's starting position
- Consider creating patterns of obstacles rather than just random positions
- Check that food doesn't spawn on obstacles
- Allow sufficient play space between obstacles

**Common Issues:**
- Obstacles making the game impossible
- Obstacles or food spawning in unreachable areas
- Collision detection issues with obstacles

## Creative Customisation Guidance

When students are adding their own personal touches, suggest these guidelines:

### Appearance Customisations
- **Background designs:** Solid colors, gradients, or simple patterns
- **Snake appearance:** Different colors for head and body, simple shapes, or thematic designs
- **Animation effects:** Simple animations for food, snake movement, or game events

**Implementation Tips:**
- For backgrounds, use screen.fill() or blit a simple surface
- For snake appearance, vary the draw method or use different colors for head/body
- Keep animations simple - subtle effects like pulsing or simple rotation

### Sound Effects
- **Basic sound integration:** Food collection, collisions, game over
- **Background music:** Simple looping track

**Implementation Tips:**
- Use pygame.mixer for sound loading and playback
- Keep sound files small and in common formats (WAV, MP3)
- Control volume levels to prevent sounds from being jarring
- Add option to mute sounds

### Gameplay Features
- **Power-ups:** Temporary effects like speed changes, invincibility, or point multipliers
- **Portals:** Teleportation between sides of the screen
- **Time limits:** Countdown timer or timed bonus objectives

**Implementation Tips:**
- Implement power-ups similar to food but with temporary effects
- For portals, modify the boundary collision logic
- Use pygame.time to track elapsed time for timers

### Difficulty Levels
- **Selectable speeds:** Easy, medium, hard options at the start
- **Obstacle layouts:** Predetermined patterns for different difficulties
- **Game area sise:** Adjustable playing field sise

**Implementation Tips:**
- Use a menu or keyboard selection for difficulty choice
- Store difficulty-specific settings in a dictionary or separate variables
- Ensure game is still playable at all difficulty levels

## Common Technical Issues and Solutions

| Issue | Likely Cause | Solution |
|-------|-------------|----------|
| Game crashes on startup | Missing initialisation or import error | Check import statements and pygame.init() call |
| Snake doesn't move | Direction variables not set or updated | Verify x_change and y_change are being set and used |
| Game runs at inconsistent speed | Clock timing issues | Ensure clock.tick(FPS) is called consistently in the main loop |
| Collision detection fails | Position calculation errors | Print positions for debugging; ensure grid alignment |
| Snake grows continuously | Logic error in growth code | Verify snake_length only increases when food is eaten |
| Game never ends | Missing collision checks | Check boundary and self-collision logic |
| Screen updates look strange | Drawing or update sequence issues | Follow clear-draw-update sequence consistently |
| Input lag or unresponsiveness | Event handling problems | Ensure event queue is processed completely each frame |

## Debugging and Problem-Solving Strategies

Help students develop systematic debugging approaches:

1. **Add print statements** to track:
   - Snake and food positions
   - Direction changes
   - Collision detections
   - Game state changes

2. **Simplify to isolate problems:**
   - Comment out enhancements to test core functionality
   - Hardcode values temporarily to verify specific behaviors
   - Test components separately when possible

3. **Visual debugging:**
   - Add temporary visual indicators for collision areas
   - Use different colors to highlight game states
   - Draw grid lines to verify alignment

4. **Common logical errors to look for:**
   - Off-by-one errors in list operations
   - Confusion between pixel positions and grid positions
   - Missing state updates after events
   - Boundary condition failures

## Assessment Criteria

### Exemplary Work Should Show:

- **Fully functional core game** with smooth movement and correct collision detection
- **Multiple enhancements** implemented successfully
- **Creative personal touches** that demonstrate understanding beyond the requirements
- **Clean, well-organised code** with appropriate comments and function organisation
- **Thoughtful reflection** on the development process and challenges
- **Evidence of debugging** and problem-solving applied to overcome challenges

### Satisfactory Work Should Show:

- **Working core gameplay** with basic movement and collision detection
- **At least two enhancements** implemented with reasonable functionality
- **Some personal customisation**, even if simple
- **Functional code organisation** that follows basic programming practices
- **Basic reflection** on the development process
- **Attempts to resolve** common issues, even if not all are successful

### Needs Improvement If:

- **Core game mechanics** are incomplete or significantly buggy
- **No working enhancements** beyond the base requirements
- **Little or no personal customisation** attempted
- **Poorly organised code** that's difficult to follow
- **Minimal reflection** on the development process
- **Unresolved basic issues** that impair gameplay

## Differentiated Support Strategies

### For Struggling Students

1. **Provide scaffold code** for specific functions
2. **Break down tasks** into smaller, more manageable steps
3. **Offer pseudocode outlines** before asking for implementation
4. **Provide visual diagrams** of game structure and data flow
5. **Create checkpoints** with known working states to fall back to
6. **Pair programming** with more confident peers

**Implementation approach:**
- Focus on getting core functionality working first
- Start with simpler enhancements like score display
- Suggest simplifications where needed
- Provide more direct guidance on debugging

### For Advanced Students

1. **Challenge with advanced enhancements:**
   - Multiple levels with increasing difficulty
   - AI-controlled opponent snake
   - More complex scoring mechanics
   - Physics-based movement variations

2. **Suggest code optimisation:**
   - Refactoring into more organised classes
   - Implementing design patterns
   - Performance optimisation strategies
   - More sophisticated collision detection

3. **Extend to new concepts:**
   - Saving high scores to files
   - Creating a complete menu system
   - Adding networked multiplayer functionality
   - Implementing custom graphics or animations

**Implementation approach:**
- Ask guiding questions rather than providing solutions
- Suggest resources for advanced concepts
- Challenge them to analyse and improve their own code
- Encourage peer teaching or demonstrations

## Conceptual Understanding Focus Areas

### Game Loop Concept

Many students struggle to understand the game loop paradigm. Focus on explaining:
- How the loop maintains consistent updates
- The separation of input, update, and render phases
- How state changes propagate through iterations
- Why timing control is essential

**Teaching approach:** Draw a flowchart of the game loop, highlight the three main phases, and explain the purpose of each.

### State Management

Help students understand how game state is represented and modified:
- How variables represent the game state
- When and how state should be updated
- The relationship between state and visualisation
- How to handle state transitions (start â†’ playing â†’ game over)

**Teaching approach:** Use analogies like "taking a snapshot" of the game at each frame.

### Coordinate Systems and Grid-Based Movement

Many students struggle with:
- The relationship between pixels and game grid
- How to ensure aligned movement and collision
- Converting between different coordinate representations

**Teaching approach:** Draw a grid on the board/screen and demonstrate how positions map to the display.

### List Operations for Snake Body

The snake body implementation using lists is conceptually challenging:
- How adding/removing segments creates movement
- Why the head is handled separately from the body
- How list slicing works for collision detection

**Teaching approach:** Use a physical demonstration with objects representing segments, or draw step-by-step diagrams.

## Activity Adaptations for Different Scenarios

### For Remote/Online Teaching:

- Create short video demonstrations of key implementation steps
- Set up virtual "office hours" for debugging help
- Use screen sharing for troubleshooting
- Create a shared document for common issues and solutions
- Prepare checkpoints students can download if they get stuck

### For Limited Time Sessions:

- Provide more complete starter code with clear "TODO" sections
- Focus on core functionality first, then enhancements if time permits
- Have pre-made enhancement code snippets students can integrate
- Create a "checkpoint" system where students can catch up if behind
- Prepare a complete implementation to demonstrate if students don't finish

### For Hardware Limitations:

- Provide simplified versions with fewer graphical elements
- Suggest alternative rendering approaches if Pygame is problematic
- Have fallback options like terminal-based versions
- Prepare cloud-based alternatives if local installation is challenging
- Reduce game complexity for slower machines

## Final Notes for Tutors

- **Emphasise the process**: The learning happens in the problem-solving, not just in the final product
- **Celebrate incremental progress**: Each working piece is an achievement
- **Use peer demonstrations**: Have students who solve problems share their approaches
- **Create a supportive debug culture**: Normalise asking for help and working through issues
- **Connect to professional practice**: Highlight how these skills apply to real game development
- **Document common issues**: Keep notes on frequent problems to improve future sessions

Remember that for many students, this may be their first experience building a complete interactive program from near-scratch. Patience and encouragement are just as important as technical guidance.
---
title: "Using AI as Your Programming Partner: Snake Game Edition"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


## Introduction

Modern programming often involves collaborating with AI tools to enhance productivity, overcome challenges, and explore new ideas. For our Snake game project, you'll learn how to effectively use AI assistants like Claude, ChatGPT, or GitHub Copilot to support your development process.

This guide provides specific prompts and techniques for each stage of development, teaching you not just how to build a game, but how to collaborate with AI in a thoughtful, efficient way.

## Why Use AI in Programming?

- **Accelerate learning** by getting explanations tailored to your understanding
- **Overcome obstacles** when you're stuck or debugging
- **Explore alternative approaches** you might not have considered
- **Enhance creativity** by rapidly prototyping different ideas
- **Focus on higher-level thinking** while AI helps with implementation details

Remember: The goal is to use AI as a collaborative tool that enhances your learning, not as a replacement for understanding the code yourself.

## Getting Started: Describing Your Vision

Before writing any code, you can use AI to help clarify and expand your game concept.

### Prompt 1: Game Concept Exploration

```
I want to build a Snake game in Python using Pygame. The basic concept is:
- Snake moves around the screen controlled by arrow keys
- Snake grows when it eats food
- Game ends when snake hits wall or itself

Can you help me flesh out this concept with:
1. Additional gameplay features that would be fun
2. Visual and audio elements I could consider
3. Potential challenges in implementation and how to address them
4. A difficulty progression system
```

### Prompt 2: Visualizing Your Game

```
I'm creating a Snake game in Python. Can you describe what the game should look like in different states:
1. The start screen
2. During active gameplay
3. When the snake eats food
4. The game over screen

Be specific about colors, layout, and visual elements.
```

## Planning Your Implementation

AI can help you break down the project into manageable steps and think through the architecture.

### Prompt 3: Implementation Planning

```
I'm building a Snake game in Python with Pygame. Can you help me create a step-by-step implementation plan? For each step, explain:
1. What components I'll need to implement
2. The order they should be tackled
3. How the components will interact
4. What potential challenges I might face
```

### Prompt 4: Code Structure Guidance

```
For my Python Snake game, can you suggest how I should structure my code? Specifically:
1. What classes should I create?
2. What main functions will I need?
3. How should I organize game states?
4. What variables will be important to track?

Please explain the reasoning behind your suggestions.
```

## Implementing Core Functionality

As you start coding, AI can help explain concepts and provide implementation examples.

### Prompt 5: Understanding Game Loops

```
I'm struggling to understand how game loops work in Pygame. Can you:
1. Explain the concept of a game loop in simple terms
2. Show me a basic example for a Snake game
3. Explain each part of the code and what it does
4. Suggest best practices for implementing it efficiently
```

### Prompt 6: Snake Movement Implementation

```
I need help implementing the snake movement mechanics. Can you:
1. Show me how to create a snake that moves continuously
2. Explain how to handle direction changes with arrow keys
3. Demonstrate how to make the snake grow when it eats food
4. Explain how to prevent the snake from reversing into itself

Show me the code with detailed comments explaining the logic.
```

## Debugging and Problem-Solving

When you encounter issues, AI can help you troubleshoot effectively.

### Prompt 7: Bug Fixing

```
My Snake game has the following issue: [describe your specific problem].

Here's the relevant code:
```python
# Paste your problematic code here
```

Can you:
1. Identify what might be causing this issue
2. Suggest solutions to fix it
3. Explain why this problem is occurring
4. Recommend how to avoid similar issues in the future
```

### Prompt 8: Code Review

```
Can you review my Snake game implementation and suggest improvements?

```python
# Paste your code here
```

Please look for:
1. Bugs or edge cases I'm not handling
2. Performance issues
3. Ways to make the code more readable or maintainable
4. Python best practices I should follow
```

## Adding Enhancements

AI can help you brainstorm and implement additional features.

### Prompt 9: Creative Feature Expansion

```
I have a working Snake game but want to make it more interesting. Can you suggest:
1. Three unique power-ups I could add (with implementation details)
2. A scoring system that rewards skilled play
3. Visual effects that would enhance the experience
4. Sound effects that would make the game more engaging

Please be specific enough that I can implement these ideas.
```

### Prompt 10: Specific Enhancement Implementation

```
I want to add [specific feature, e.g., "a power-up that temporarily makes the snake move through walls"] to my Snake game. Can you:
1. Show me the code to implement this feature
2. Explain how it integrates with my existing game loop
3. Suggest any additional considerations (timing, graphics, balance)
4. Provide alternatives if this is too complex
```

## Polishing Your Game

AI can help you refine your game to make it more professional.

### Prompt 11: User Experience Improvements

```
My Snake game works, but the player experience needs improvement. Can you suggest:
1. How to make the controls feel more responsive
2. Ways to communicate game state to the player more clearly
3. Transitions between different game screens
4. Small details that would make the game feel more polished
```

### Prompt 12: Performance Optimization

```
My Snake game runs, but sometimes lags or doesn't feel smooth. Here's my current game loop:

```python
# Paste your game loop code
```

Can you suggest:
1. Ways to optimize this code for better performance
2. Common Pygame performance pitfalls to avoid
3. How to test if my optimizations are working
4. What hardware considerations might be affecting performance
```

## Customizing and Making It Your Own

AI can help you put your personal stamp on the project.

### Prompt 13: Theme Customization

```
I want to customize my Snake game with a unique theme instead of the traditional snake. Some ideas I'm considering:
- [Your theme idea 1]
- [Your theme idea 2]

Can you help me:
1. Adapt the snake game mechanics to fit this theme
2. Suggest visual and audio elements that would support the theme
3. Identify any new features that would enhance the theme
4. Point out any implementation challenges specific to this theme
```

### Prompt 14: Code Generation for Complex Features

```
I want to add [complex feature, e.g., "a replay system that records and plays back games"] to my Snake game. This seems complicated, so can you:
1. Generate the code needed for this feature
2. Explain each part of the implementation
3. Show how to integrate it with my existing code
4. Suggest simplifications if the full implementation is too advanced
```

## Learning From the Process

AI can help you reflect on what you've learned and how to apply it in the future.

### Prompt 15: Understanding Core Concepts

```
Now that I've built a Snake game, can you explain:
1. The key programming concepts I've used in this project
2. How these concepts apply to other game types
3. What more advanced concepts build upon these foundations
4. What project would be a good next step to continue learning
```

### Prompt 16: Code Architecture Review

```
I've completed my Snake game. Can you analyze my overall code architecture and explain:
1. What patterns I've used (intentionally or not)
2. How I could restructure this for better maintainability
3. How professional game developers might approach this differently
4. What I should keep in mind for my next, more complex game
```

## Effective AI Collaboration Tips

To get the most out of AI assistance in your programming projects:

1. **Be specific** about what you're trying to achieve
2. **Share your code** when asking for help with specific issues
3. **Ask for explanations**, not just solutions
4. **Break down complex questions** into smaller, focused prompts
5. **Iterate on responses** by asking follow-up questions
6. **Challenge the AI** to provide alternatives or justify recommendations
7. **Verify suggestions** before implementing them
8. **Learn from the AI's approach**, don't just copy its code

## Activity: AI-Assisted Snake Game Development

For this activity, choose at least 5 prompts from this guide to use during your Snake game development process. For each prompt you use:

1. Record the prompt you used (you can modify it to fit your specific needs)
2. Summarize the AI's response and how it helped you
3. Describe what you learned from the interaction
4. Explain how the AI's input influenced your implementation

## Final Reflection Questions

After completing your game with AI assistance, consider these questions:

1. How did using AI change your approach to the development process?
2. Which types of prompts did you find most helpful, and why?
3. In what ways did AI help you learn more effectively?
4. Were there any drawbacks or limitations to using AI in your development process?
5. How would you use AI differently in your next programming project?

Remember, the goal of using AI in learning to program is to enhance your understanding and capabilities, not replace the learning process itself. The best AI collaborations happen when you engage deeply with the suggestions and explanations, not when you simply copy solutions.
---
title: "Mini-Project: Building Your Own Snake Game"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

## Introduction

Now that you've set up your local Python environment and explored various Python mini-projects, it's time to apply what you've learned by building a classic game from scratch! In this activity, you'll create your own version of the Snake game using Pygame. This project will reinforce programming concepts like loops, conditionals, and functions while introducing you to game development principles.

## Objectives
- Build a complete, playable game from starter code
- Apply programming fundamentals in a game development context
- Learn basic game development concepts (game loop, rendering, input handling)
- Customize and extend a project based on your own creative ideas

## Prerequisites
- Completed Activity 1 (Anaconda installation)
- Python and Pygame installed on your computer
- Basic understanding of Python concepts (variables, loops, conditionals, functions)

If you haven't installed Pygame yet, run this command in your Anaconda Prompt or terminal:
```
pip install pygame
```

## Project Overview: Snake Game

The Snake game is a classic arcade game where you control a snake that moves around the screen. The basic gameplay includes:

1. The snake moves continuously in one direction
2. The player changes the snake's direction using arrow keys
3. The snake grows longer when it eats food
4. The game ends if the snake hits the wall or itself
5. The score increases each time the snake eats food

## Getting Started

### Step 1: Download the Starter Code

Download the starter code from our course repository:
- Navigate to: [course-website.edu/resources/snake-game-starter](https://course-website.edu/resources/snake-game-starter)
- Download the `snake_starter.py` file
- Save it to a location you can easily access

The starter code provides the basic structure and some helper functions to get you started.

### Step 2: Understand the Starter Code

Open the starter code in your preferred editor and review it. The code includes:

- Import statements for required libraries
- Game constants (screen size, colors, etc.)
- Basic initialization of Pygame
- A game loop structure
- Comment placeholders for code you'll need to add

```python
# Sections of the starter code:

# 1. Imports and initialization
import pygame
import random
pygame.init()

# 2. Game constants
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 600
BLOCK_SIZE = 20
GAME_SPEED = 15

# Colors
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
GREEN = (0, 255, 0)
RED = (255, 0, 0)

# 3. Screen setup
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Snake Game')
clock = pygame.time.Clock()

# 4. Game loop structure
def game_loop():
    # Game variables will go here
    
    # Main game loop
    game_over = False
    while not game_over:
        # Event handling will go here
        
        # Game logic will go here
        
        # Drawing code will go here
        
        # Update display
        pygame.display.update()
        clock.tick(GAME_SPEED)
    
    pygame.quit()
    quit()

# 5. Start the game
game_loop()
```

## Part 1: Implementing Core Game Functionality

Follow these steps to implement the essential components of the Snake game:

### Step 1: Set Up the Snake and Food

Add the following to your `game_loop()` function:

```python
def game_loop():
    # Game variables
    game_over = False
    
    # Initial snake position (middle of screen)
    x = SCREEN_WIDTH // 2
    y = SCREEN_HEIGHT // 2
    
    # Initial movement direction
    x_change = 0
    y_change = 0
    
    # Snake body (list of segments)
    snake_segments = []
    snake_length = 1
    
    # Generate initial food position
    food_x = round(random.randrange(0, SCREEN_WIDTH - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE
    food_y = round(random.randrange(0, SCREEN_HEIGHT - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE
    
    # Main game loop
    while not game_over:
        # Rest of the code goes here
```

### Step 2: Handle User Input

Add the following inside your main game loop:

```python
# Event handling
for event in pygame.event.get():
    if event.type == pygame.QUIT:
        game_over = True
    
    # Handle key presses
    if event.type == pygame.KEYDOWN:
        if event.key == pygame.K_LEFT:
            x_change = -BLOCK_SIZE
            y_change = 0
        elif event.key == pygame.K_RIGHT:
            x_change = BLOCK_SIZE
            y_change = 0
        elif event.key == pygame.K_UP:
            y_change = -BLOCK_SIZE
            x_change = 0
        elif event.key == pygame.K_DOWN:
            y_change = BLOCK_SIZE
            x_change = 0
```

### Step 3: Update Snake Position

Add this code after the event handling:

```python
# Update snake position
x += x_change
y += y_change

# Check for boundary collisions
if x >= SCREEN_WIDTH or x < 0 or y >= SCREEN_HEIGHT or y < 0:
    game_over = True
```

### Step 4: Draw Game Elements

Add this code to draw the snake, food, and clear the screen:

```python
# Clear the screen
screen.fill(BLACK)

# Draw food
pygame.draw.rect(screen, RED, [food_x, food_y, BLOCK_SIZE, BLOCK_SIZE])

# Draw snake
snake_head = []
snake_head.append(x)
snake_head.append(y)
snake_segments.append(snake_head)

# Remove extra segments if snake is too long
if len(snake_segments) > snake_length:
    del snake_segments[0]

# Check if snake hits itself
for segment in snake_segments[:-1]:
    if segment == snake_head:
        game_over = True

# Draw each segment of the snake
for segment in snake_segments:
    pygame.draw.rect(screen, GREEN, [segment[0], segment[1], BLOCK_SIZE, BLOCK_SIZE])
```

### Step 5: Handle Food Collision and Growth

Add this code to handle when the snake eats food:

```python
# Check if snake eats food
if x == food_x and y == food_y:
    # Generate new food
    food_x = round(random.randrange(0, SCREEN_WIDTH - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE
    food_y = round(random.randrange(0, SCREEN_HEIGHT - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE
    # Increase snake length
    snake_length += 1
```

### Step 6: Test Your Game

Run your game to make sure the basic functionality works:
- The snake should move with arrow keys
- The snake should grow when it eats food
- The game should end when the snake hits the wall or itself

## Part 2: Adding Game Enhancements

Now that you have a working basic game, let's enhance it with additional features. Choose at least TWO of these enhancements to implement:

### Enhancement 1: Add a Score Display

```python
# Add at the beginning of game_loop()
score = 0
font = pygame.font.SysFont(None, 25)

# Add inside your game loop after clearing the screen
def display_score(score):
    score_text = font.render(f"Score: {score}", True, WHITE)
    screen.blit(score_text, [10, 10])

# Update when the snake eats food
if x == food_x and y == food_y:
    food_x = round(random.randrange(0, SCREEN_WIDTH - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE
    food_y = round(random.randrange(0, SCREEN_HEIGHT - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE
    snake_length += 1
    score += 10  # Increase score

# Call in your drawing section
display_score(score)
```

### Enhancement 2: Add a Game Over Screen

```python
# Add at the beginning of game_loop()
def display_message(msg, color):
    font = pygame.font.SysFont(None, 50)
    message = font.render(msg, True, color)
    message_rect = message.get_rect(center=(SCREEN_WIDTH/2, SCREEN_HEIGHT/2))
    screen.blit(message, message_rect)

# Replace the end of your game loop with this
# Outside the main game loop
screen.fill(BLACK)
display_message("Game Over! Press Q to Quit or C to Play Again", RED)
pygame.display.update()

# Wait for user to quit or restart
end_game = False
while not end_game:
    for event in pygame.event.get():
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_q:
                end_game = True
                game_over = True
            if event.key == pygame.K_c:
                game_loop()  # Restart the game
        if event.type == pygame.QUIT:
            end_game = True
            game_over = True
```

### Enhancement 3: Add Speed Progression

```python
# Add inside your game loop where the snake eats food
if x == food_x and y == food_y:
    food_x = round(random.randrange(0, SCREEN_WIDTH - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE
    food_y = round(random.randrange(0, SCREEN_HEIGHT - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE
    snake_length += 1
    score += 10
    
    # Increase game speed every 5 food items
    if snake_length % 5 == 0 and GAME_SPEED < 30:
        GAME_SPEED += 2
```

### Enhancement 4: Add Different Types of Food

```python
# Add at the beginning of game_loop()
food_types = [
    {"color": RED, "points": 10, "probability": 0.7},
    {"color": (255, 255, 0), "points": 20, "probability": 0.3}  # Yellow food worth more points
]
current_food_type = random.choices(food_types, 
                                  weights=[f["probability"] for f in food_types])[0]

# Change the food generation code
def generate_food():
    fx = round(random.randrange(0, SCREEN_WIDTH - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE
    fy = round(random.randrange(0, SCREEN_HEIGHT - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE
    food_type = random.choices(food_types, 
                              weights=[f["probability"] for f in food_types])[0]
    return fx, fy, food_type

# Initialize food
food_x, food_y, current_food_type = generate_food()

# Update drawing code
pygame.draw.rect(screen, current_food_type["color"], [food_x, food_y, BLOCK_SIZE, BLOCK_SIZE])

# Update eating code
if x == food_x and y == food_y:
    food_x, food_y, current_food_type = generate_food()
    snake_length += 1
    score += current_food_type["points"]
```

### Enhancement 5: Add Wall Obstacles

```python
# Add after initializing the snake
obstacles = []
for _ in range(5):  # Create 5 random obstacles
    obs_x = round(random.randrange(0, SCREEN_WIDTH - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE
    obs_y = round(random.randrange(0, SCREEN_HEIGHT - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE
    # Make sure obstacles don't overlap with snake's starting position
    if (obs_x != x or obs_y != y):
        obstacles.append([obs_x, obs_y])

# Add to your drawing code
for obs in obstacles:
    pygame.draw.rect(screen, (0, 0, 255), [obs[0], obs[1], BLOCK_SIZE, BLOCK_SIZE])

# Add to collision detection
# Check for obstacle collisions
for obs in obstacles:
    if x == obs[0] and y == obs[1]:
        game_over = True
```

## Part 3: Creative Customization

Now it's time to make the game your own! Add at least TWO personal touches to your game. Here are some ideas:

1. **Customize the appearance**:
   - Change colors or add a background image
   - Make the snake segments a different shape
   - Add a custom icon or title screen

2. **Add sound effects**:
   - Play a sound when the snake eats food
   - Add background music
   - Play a sound when the game ends

3. **Add gameplay features**:
   - Create power-ups that temporarily make the snake faster or slower
   - Add a "portal" that teleports the snake from one side to the other
   - Create a "time-limited" mode where players must reach a certain score before time runs out

4. **Add difficulty levels**:
   - Create an easy, medium, and hard mode with different speeds
   - Add more obstacles at higher difficulties
   - Make the play area smaller at higher difficulties

## Part 4: Debugging and Testing

As you develop your game, you'll likely encounter bugs or unexpected behavior. Here are some common issues and how to fix them:

1. **Snake doesn't move**:
   - Check that you're updating the snake's position with `x_change` and `y_change`
   - Make sure your game loop is running and updating the display

2. **Snake moves too fast or too slow**:
   - Adjust the `GAME_SPEED` constant
   - Make sure you're calling `clock.tick(GAME_SPEED)` in your game loop

3. **Snake can move backwards into itself**:
   - Add logic to prevent the snake from moving directly opposite its current direction

4. **Food appears inside the snake**:
   - Add a check to make sure new food doesn't spawn on top of the snake

## Submission Guidelines

To complete this activity, submit:

1. Your complete Python code file
2. A short video or screenshots showing your game in action
3. A brief description of:
   - Which enhancements you added
   - What personal touches you added
   - What challenges you faced and how you overcame them

## Extension Challenges (Optional)

If you finish early or want to continue developing your game, here are some advanced challenges:

1. **Two-player mode**: Allow two players to control different snakes on the same screen

2. **High score system**: Save and display the highest scores across game sessions

3. **Custom levels**: Create predefined levels with specific obstacle arrangements

4. **Animation effects**: Add visual effects for eating food, game over, etc.

5. **AI opponent**: Create a computer-controlled snake that tries to get food

Remember, the goal is to have fun while applying what you've learned about Python programming. Don't be afraid to experiment and make the game your own!
---
title: "Activity 1: Setting Up Your Local Python Environment"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


## Introduction

So far, we've been using Google Colab to write and run our Python code online. Now it's time to set up Python on your own computer! This worksheet will guide you through installing Anaconda, a popular Python distribution that includes Python itself plus many useful libraries and tools for data science, visualisation, and more.

## Why Anaconda?

- **All-in-one package**: Includes Python, key libraries, and useful tools
- **Easy to install**: Works on Windows, Mac, and Linux with minimal configuration
- **Includes Jupyter Notebooks**: The same notebook interface we've been using in Colab
- **Package management**: Makes it easy to install additional libraries
- **Industry standard**: Widely used in data science, research, and education

## Part 1: Installing Anaconda

### Step 1: Download the Installer

1. Open your web browser and go to: https://www.anaconda.com/download
2. Select your operating system (Windows, macOS, or Linux)
3. Download the **Anaconda Individual Edition** installer
   - Choose the **Python 3.x** version (not Python 2.x)
   - Note: This is a large download (500MB+) so it may take some time

### Step 2: Run the Installer

**For Windows:**
1. Double-click the downloaded `.exe` file
2. Select "Install for Just Me" (recommended)
3. Choose an installation location (the default is fine)
4. **Important:** Check both boxes for:
   - Add Anaconda to my PATH environment variable
   - Register Anaconda as my default Python
5. Click "Install" and wait for the installation to complete

**For macOS:**
1. Double-click the downloaded `.pkg` file
2. Follow the prompts in the installer
3. Install for "Just Me" (recommended)
4. Use the default installation location
5. At the end, you can choose whether to install VS Code (optional)

**For Linux:**
1. Open Terminal and navigate to the download directory
2. Run: `bash ./Anaconda3-2023.XX-Linux-x86_64.sh` (replace with your version number)
3. Follow the prompts, agreeing to the license terms
4. Allow the installer to initialise Anaconda in your shell

### Step 3: Verify Installation

Let's make sure Anaconda installed correctly:

1. **For Windows**: Click Start, search for and open "Anaconda Navigator"
2. **For macOS**: Open Spotlight (Cmd+Space), type "Navigator" and open Anaconda Navigator
3. **For Linux**: Open a terminal and type `anaconda-navigator`

You should see the Anaconda Navigator home screen with various applications like Jupyter, VS Code, and others.

## Part 2: Exploring the Anaconda Environment

### Step 1: Launch Jupyter Notebook

Jupyter Notebooks are interactive documents where you can write and run code, add explanations, and visualise results.

1. In Anaconda Navigator, click the "Launch" button under Jupyter Notebook
2. Your web browser should open, showing the Jupyter file browser
3. Navigate to a folder where you want to create your first notebook
4. Click the "New" button in the upper right and select "Python 3" to create a new notebook

### Step 2: Create Your First Local Notebook

Let's test your installation by creating a simple notebook:

1. In the first cell of your new notebook, type the following code:
   ```python
   print("Hello from my local Python environment!")
   ```

2. Run the cell by clicking the "Run" button or pressing Shift+Enter
   - You should see the greeting printed below the cell

3. In a new cell, let's verify that some important libraries are installed:
   ```python
   import pandas as pd
   import matplotlib.pyplot as plt
   import numpy as np
   
   print("Pandas version:", pd.__version__)
   print("Matplotlib version:", plt.__version__)
   print("NumPy version:", np.__version__)
   
   # Create a simple plot
   plt.figure(figsise=(8, 4))
   x = np.linspace(0, 10, 100)
   plt.plot(x, np.sin(x))
   plt.title("A Simple Sine Wave")
   plt.show()
   ```

4. Run this cell to make sure all the libraries work and you can create plots

5. Save your notebook by clicking File â†’ Save or pressing Ctrl+S (Cmd+S on Mac)

## Part 3: Installing Additional Packages

One advantage of having a local Python environment is the ability to install any package you need. Let's try installing a new package:

### Step 1: Use Conda to Install a Package

1. Close Jupyter Notebook (File â†’ Close and Halt)
2. Return to Anaconda Navigator
3. Click on the "Environments" tab on the left sidebar
4. In the packages search box, type "pygame" (we'll need this for our game development later)
5. Check the box next to pygame and click "Apply" to install it

### Step 2: Test Your New Package

1. Return to the "Home" tab and launch Jupyter Notebook again
2. Create a new notebook
3. Enter and run the following code to verify pygame is installed:
   ```python
   import pygame
   print("Pygame version:", pygame.version.ver)
   
   # Initialise pygame
   pygame.init()
   
   # Print available pygame modules
   modules = pygame.get_init()
   print("Pygame initialised successfully!")
   
   # Clean up
   pygame.quit()
   ```

## Part 4: Understanding Your New Environment

Let's explore some key components of the Anaconda environment:

1. **Anaconda Navigator**: The graphical interface to manage your Python environment
2. **Jupyter Notebook**: Interactive coding environment for Python (and other languages)
3. **conda**: The package manager (similar to pip) for installing and managing libraries
4. **Environments**: Isolated workspaces that can have different Python versions/packages

## Checkpoint Questions

Answer these questions to check your understanding:

1. What are two advantages of using Anaconda instead of installing Python directly?

2. What is the difference between Jupyter Notebook and Python IDLE?

3. Why might you want to create different environments for different projects?

4. How would you install a new package that isn't currently in your Anaconda installation?

5. What does the following code do in a Jupyter Notebook?
   ```python
   import sys
   print(sys.executable)
   ```

## Next Steps and Troubleshooting

### Common Issues:

- **"Anaconda is not recognised as a command"**: You may need to restart your computer after installation
- **Jupyter doesn't show plots**: Try adding `%matplotlib inline` at the top of your notebook
- **Package installation fails**: Make sure you're connected to the internet and try again
- **Slow performance**: Some older computers may run Jupyter slowly - try closing other applications

### Getting Help:

If you encounter problems:
1. Check the error message carefully
2. Search for the error message online
3. Ask for help in our class forum
4. Visit the Anaconda documentation: https://docs.anaconda.com/

## Submission Guidelines

To complete this activity:

1. Take a screenshot of your running Jupyter Notebook showing the sine wave plot
2. Answer the checkpoint questions in a text document
3. Submit both files via the course platform

Great work setting up your local Python environment! In the next activity, we'll explore some exciting Python projects that build on the fundamentals you've learned so far.
---
title: "Activity 2: Exploring Python Mini-Projects"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


## Introduction

Now that you have set up your local Python environment with Anaconda, it's time to explore some exciting applications of Python beyond the basics we've covered in class. In this activity, you'll download a pack of example code, run different mini-projects, and make modifications to see how Python can be used in various domains.

## Objectives
- Run pre-written Python projects in different domains
- Understand code structure and functionality in real applications
- Make modifications to existing code to customise its behavior
- Explore areas of Python that interest you for future learning

## Getting Started

### Step 1: Download the Example Code Pack

1. Download the example code pack from our course repository:
   - Navigate to: [course-website.edu/resources/python-examples](https://course-website.edu/resources/python-examples)
   - Click on "Download sIP" and save to your computer
   - Extract/unsip the file to a location you can easily find (e.g., Documents folder)

2. Open Anaconda Navigator and launch Jupyter Notebook

3. In Jupyter, navigate to the folder where you extracted the example code pack

### Step 2: Review the Available Examples

The example code pack contains mini-projects in five different domains. Each folder contains a complete working example with detailed comments:

1. **Data Science**: Weather data analysis and visualisation
2. **Web Development**: Simple Flask website
3. **GUI Application**: Interactive desktop application
4. **Automation**: File organisation script
5. **Game Development**: Basic Pygame example

## Part 1: Choose Your First Project

Select at least ONE example that interests you the most (though feel free to explore more if time permits). Follow the specific instructions for your chosen example:

### Option A: Data Science Example

**File**: `data_science/weather_analysis.py`

This example demonstrates how to analyse weather data using pandas and create visualisations with matplotlib.

1. Open the file in Jupyter Notebook or your preferred Python editor

2. Review the code and comments to understand:
   - How data is loaded from a CSV file
   - How pandas is used to clean and analyse the data
   - How matplotlib creates different types of visualisations

3. Run the code to see the analysis and visualisations

4. Modification Tasks:
   - Change the chart type for one of the visualisations (e.g., from line to bar)
   - Add a new calculation (e.g., calculate the temperature range for each month)
   - Customise the appearance of one chart (colors, title, labels)

### Option B: Web Development Example

**File**: `web_dev/flask_app.py`

This example shows how to create a simple website using the Flask framework.

1. Open a terminal/command prompt:
   - Windows: Search for "Anaconda Prompt" in the Start menu
   - Mac/Linux: Open Terminal

2. Navigate to the web_dev directory:
   ```
   cd path/to/example_code_pack/web_dev
   ```

3. Install Flask if you haven't already:
   ```
   pip install flask
   ```

4. Run the Flask application:
   ```
   python flask_app.py
   ```

5. Open your web browser and navigate to: http://127.0.0.1:5000/

6. Review the code to understand:
   - How routes map to different web pages
   - How templates are used for HTML
   - How data is passed between Python and the web pages

7. Modification Tasks:
   - Add a new route and page (e.g., `/about`)
   - Modify the HTML template to change the appearance
   - Add a form that collects user input

### Option C: GUI Application Example

**File**: `gui/weather_app.py`

This example demonstrates a desktop application with a graphical user interface using Tkinter.

1. Open the file in your Python editor

2. Run the application:
   ```
   python weather_app.py
   ```

3. Review the code to understand:
   - How the GUI is structured with frames, labels, and buttons
   - How user input is processed
   - How the application responds to user actions

4. Modification Tasks:
   - Change the colors or font styles
   - Add a new button with a new function
   - Modify the layout of the elements

### Option D: Automation Example

**File**: `automation/organise_files.py`

This example shows how to automate file organisation using Python.

1. Open the file in your Python editor

2. Create a test directory with some sample files (or use the provided test files)

3. Review the code to understand:
   - How the script identifies different file types
   - How files are moved to appropriate folders
   - How the process is automated

4. Run the script on your test directory:
   ```
   python organise_files.py /path/to/test/directory
   ```

5. Modification Tasks:
   - Add a new category of files to organise
   - Modify the script to also rename files based on certain criteria
   - Add logging to record what files were moved

### Option E: Game Development Example

**File**: `games/pygame_example.py`

This example demonstrates basic game development with Pygame.

1. Install Pygame if you haven't already:
   ```
   pip install pygame
   ```

2. Run the game:
   ```
   python pygame_example.py
   ```

3. Play the game to understand its mechanics

4. Review the code to understand:
   - How the game loop works
   - How graphics are drawn to the screen
   - How user input is handled
   - How game physics and collision detection work

5. Modification Tasks:
   - Change the colors or sises of game elements
   - Adjust the speed or behavior of moving objects
   - Add a new game feature (e.g., sound effects, a new type of object)

## Part 2: Deeper Exploration and Modifications

After you've run your chosen example(s) and made basic modifications, select ONE of your examples for deeper exploration:

1. Review the code more carefully, making sure you understand:
   - The overall structure and flow
   - How different functions interact
   - How libraries and modules are used
   - Any advanced Python features being used

2. Complete at least TWO of the following advanced modifications:

   **For Data Science:**
   - Add a new type of analysis or calculation
   - Import a different dataset and adapt the code to work with it
   - Create a new type of visualisation not used in the original code

   **For Web Development:**
   - Add multiple new pages with navigation between them
   - Implement data persistence (store data between sessions)
   - Add dynamic content that changes based on user input

   **For GUI Applications:**
   - Add multiple screens or a tab interface
   - Connect the GUI to an external data source
   - Add data validation and error handling

   **For Automation:**
   - Extend the script to handle multiple directories
   - Add options to customise the organisation rules
   - Create a log file that records all actions taken

   **For Game Development:**
   - Add a scoring system
   - Create different levels or difficulties
   - Add new game mechanics or obstacles

3. Document the changes you've made:
   - What did you change?
   - Why did you make these changes?
   - What challenges did you encounter?
   - How did you solve any problems that came up?

## Part 3: Reflection and Questions

After exploring and modifying the examples, answer the following questions:

1. Which example(s) did you explore? Why did you choose these?

2. What modifications did you make to the code? Describe the before and after.

3. What was the most challenging part of understanding the example code?

4. What new Python features, libraries, or concepts did you learn from these examples?

5. Which area of Python programming (from the examples) most interests you for future learning? Why?

6. How could you apply what you learned from these examples to create a project of your own?

## Submission Guidelines

To complete this activity, submit:

1. Your modified code files (or links to them)
2. Screenshots showing your modified examples running
3. Your answers to the reflection questions
4. Any error messages or challenges you couldn't resolve (if applicable)

## Troubleshooting Tips

- **Missing libraries**: If you encounter "ImportError" or "ModuleNotFoundError", install the required library using pip:
  ```
  pip install library_name
  ```

- **File not found errors**: Check that you're in the correct directory and using the right file path

- **Permission errors**: Some automation scripts may require additional permissions

- **Game doesn't run**: Make sure Pygame is installed correctly and that your display supports the required resolution

If you get stuck, remember:
1. Read error messages carefully
2. Check the comments in the code for hints
3. Search online for specific error messages
4. Ask for help from classmates or the instructor

## Next Steps

After completing this activity, you'll have a better understanding of different Python applications and how to modify existing code. In the next activity, we'll apply these skills to build a complete game from scratch!
---
title: "Beyond the Basics: Your Programming Journey Continues"
subtitle: "Expanding Your Python Horisons"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


# Key Pathways for Growth

- **Diverse Application Areas**
- **Professional Development**
- **Continuous Learning Strategies**
- **Community Engagement**
- **Open Source Contributions**
- **AI-Assisted Programming**

::: {.notes}

Now that you've mastered the fundamentals of Python programming, let's explore exciting directions for your continued learning journey. This guide highlights emerging trends, advanced topics, and practical applications that build upon your programming foundation.

Key Pathways for Growth encompasses diverse application areas, professional development, and continuous learning strategies. Exploring different domains within Python's versatile ecosystem, such as data science, web development, machine learning, automation, GUI applications, and game development, allows programmers to specialise and broaden their skill set. Engaging with the programming community through open source contributions and collaborating on projects fosters growth and knowledge sharing.

AI-assisted programming is an emerging trend that can augment the coding process and improve efficiency. By leveraging AI tools and techniques, programmers can streamline their workflow, catch errors early, and focus on higher-level problem-solving. Incorporating AI-assisted programming into one's development routine can provide valuable support and accelerate learning. Combining these pathwaysâ€”diverse applications, professional development, continuous learning, community engagement, open source contributions, and AI-assisted programmingâ€”creates a powerful framework for sustained growth and success in programming.

This slide serves as a bridge between the introductory concepts and the more advanced topics that lie ahead in your programming journey. As you progress, you'll encounter a diverse range of specialisations and areas where Python can be applied, each offering unique challenges and opportunities for growth.

The following slides will explore various pathways you can pursue, such as data science, web development, machine learning, automation, GUI applications, and game development. These domains showcase the versatility of Python and the endless possibilities it offers. Additionally, the presentation will touch on coding best practices, the collaborative nature of open source, and the emerging field of AI-assisted programming, all of which will contribute to your development as a programmer.

:::

# Why Keep Learning? The Endless Frontier

Programming is a field of continuous growth and evolution:

- **Technology evolves rapidly**: New tools, frameworks, and approaches emerge regularly
- **Career opportunities expand** with each new skill you acquire
- **Problem-solving capabilities grow** as you master more advanced concepts
- **Creative possibilities multiply** when you combine different programming domains
- **Community connections build** as you share your journey with other programmers

The skills you've learned are just the beginning!

::: {.notes}
The rapid evolution of technology presents an exciting challenge for programmers to continuously expand their skills and knowledge. Regularly emerging tools, frameworks, and approaches offer opportunities to solve problems more effectively, explore new creative possibilities, and grow both professionally and personally. Embracing the endless frontier of learning opens doors to cutting-edge career paths and collaborative connections within the programming community.

Each new skill acquired serves as a stepping stone towards tackling increasingly complex challenges and unlocking innovative solutions. By combining expertise across different programming domains, developers can push the boundaries of what's possible and bring groundbreaking ideas to life. The journey of continuous learning is not just about staying relevant in a dynamic industry; it's an invitation to explore uncharted territories, make meaningful contributions, and find fulfillment in the ever-evolving world of programming.
:::

# Python's Versatile Ecosystem: Choose Your Path

Python's popularity stems from its versatility across many domains:

- **Data Science & Analytics**: Analyse data, discover trends, and build predictive models
- **Web Development**: Create interactive websites and web applications
- **Automation**: Build scripts to handle repetitive tasks
- **Game Development**: Design and implement your own games
- **Machine Learning & AI**: Train models to recognise patterns and make predictions
- **Internet of Things (IoT)**: Connect and program physical devices
- **Desktop Applications**: Build software with graphical interfaces

You can specialise or explore multiple areas - Python supports it all!

::: {.notes}
Python offers diverse paths for growth and specialisation, enabling you to pursue your interests and build valuable skills. Whether you're drawn to data science and analytics, web development, automation, game development, machine learning and AI, IoT, or desktop applications, Python provides the tools and libraries to support your journey. Each path opens up exciting possibilities and empowers you to create meaningful solutions in your chosen domain.

As you explore these paths, you'll find a wealth of resources, frameworks, and communities to support your learning and development. From popular libraries like NumPy and Pandas for data analysis, to web frameworks like Django and Flask for building web applications, to machine learning libraries like TensorFlow and PyTorch, Python's ecosystem is rich and constantly evolving. By immersing yourself in your chosen path and leveraging these tools, you can develop expertise, build impressive projects, and contribute to the ever-growing world of Python-powered innovation.
:::

# Data Science: Unlocking Insights from Information

Python is the leading language for data analysis and visualisation.

Key data science workflows:
- **Data acquisition**: Collecting data from files, databases, APIs
- **Data cleaning**: Handling missing values, outliers, inconsistencies
- **Exploratory analysis**: Understanding patterns and relationships
- **Visualisation**: Creating informative charts and graphs
- **Statistical analysis**: Drawing conclusions from data

```python
# Tiny data science example (full code available for download)
import pandas as pd
import matplotlib.pyplot as plt

# Load and explore data
data = pd.read_csv('weather_data.csv')
print(data.head())  # View first few rows

# Create a simple visualisation
data.plot(x='Date', y='Temperature')
plt.title('Temperature Over Time')
plt.show()
```

Essential libraries: pandas, numpy, matplotlib, seaborn, scipy

::: {.notes}
Data science is a powerful field that enables us to extract valuable insights from vast amounts of information. The process begins with data acquisition, where data is collected from various sources such as files, databases, and APIs. This is followed by data cleaning, which involves handling missing values, outliers, and inconsistencies to ensure the data is accurate and reliable. Exploratory analysis is then conducted to understand patterns and relationships within the data, providing a foundation for further investigation.

Visualisation plays a crucial role in data science, allowing us to create informative charts and graphs that communicate insights effectively. Statistical analysis is also employed to draw meaningful conclusions from the data, enabling data-driven decision-making. By combining these techniques, data science empowers organisations to unlock hidden insights, identify opportunities, and solve complex problems, ultimately driving innovation and growth in today's data-driven world.
:::

# Web Development: Bringing Your Ideas Online

Create and deploy web applications using Python frameworks.

What you can build:
- **Personal websites**: Portfolios, blogs, project showcases
- **Web applications**: Interactive tools and services
- **APIs**: Create interfaces for your data and services
- **Dashboards**: Display data in interactive formats
- **E-commerce sites**: Sell products or services online

```python
# Tiny Flask example (full code available for download)
from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def home():
    """Display the homepage with a welcome message."""
    return render_template('index.html', message="Welcome!")

if __name__ == '__main__':
    app.run(debug=True)
```

Popular frameworks: Flask (lightweight), Django (comprehensive), FastAPI (modern)

::: {.notes}
Web development is a vast field that enables you to bring your ideas to life online. Whether you're creating a personal website to showcase your portfolio, blog, or projects, or developing interactive web applications and services, web development provides the tools and technologies to make it happen. You can also create APIs to interface with your data and services, allowing others to integrate with your work seamlessly.

Beyond static websites and applications, web development also allows you to create interactive dashboards that display data in engaging and informative ways. For those looking to sell products or services online, e-commerce sites are another powerful application of web development skills. With the right approach, you can create online stores that are user-friendly, secure, and effective at driving sales. The possibilities are truly endless when it comes to web development, and with the right skills and creativity, you can bring your unique vision to the online world.
:::

# Machine Learning: Teaching Computers to Learn

Python is at the heart of the AI revolution.

Key concepts in machine learning with Python:
- **Data preparation**: Cleaning, splitting into training and testing sets
- **Model training**: Teaching algorithms to recognise patterns in data
- **Making predictions**: Using trained models on new data
- **Evaluation**: Measuring how well your model performs

```python
# Tiny ML example (full code available for download)
from sklearn.ensemble import RandomForestClassifier

# Create and train a model (simplified)
model = RandomForestClassifier()
model.fit(training_data, training_labels)

# Predict and evaluate
predictions = model.predict(test_data)
print(f"Model accuracy: {accuracy_score(test_labels, predictions):.2f}")
```

Popular ML libraries: scikit-learn, TensorFlow, PyTorch, Keras

::: {.notes}
Machine learning is a powerful technique that enables computers to learn from data, rather than being explicitly programmed. The process begins with data preparation, where the data is cleaned and split into training and testing sets. The training set is used to teach the machine learning algorithms to recognise patterns and relationships within the data. Once the model is trained, it can be used to make predictions on new, unseen data.

Evaluating the performance of the trained model is a crucial step in the machine learning process. Various metrics can be used to measure how well the model generalises to new data and how accurately it makes predictions. By iteratively refining the model based on these evaluation results, the performance can be continually improved. Machine learning has diverse applications across industries, from image and speech recognition to recommendation systems and autonomous vehicles.
:::

# Automation: Let Python Do the Work

Build scripts to automate repetitive tasks and workflows.

What you can automate with Python:
- **File organisation**: Sort, rename, and manage files automatically
- **Data processing**: Transform data between formats (CSV, Excel, JSON)
- **Web scraping**: Collect information from websites
- **Scheduled tasks**: Run programs at specific times
- **System maintenance**: Monitor and manage system resources

```python
# Tiny automation example (full code available for download)
import os, shutil

# Function to organise files by extension
def organise_by_type(file_path, extension_map):
    """Move files to folders based on their extension."""
    ext = os.path.splitext(file_path)[1].lower()
    destination = extension_map.get(ext, "Other")
    # Move file to appropriate folder
    # Code simplified for brevity
```

Useful libraries: os, shutil, requests, Beautiful Soup, schedule, PyAutoGUI

::: {.notes}
Python automation simplifies repetitive tasks, saving time and reducing errors. File organisation involves sorting, renaming, and managing files automatically based on specified rules. Data processing allows transforming data between formats like CSV, Excel, and JSON, making it easier to work with different systems. Web scraping enables collecting information from websites, which is useful for data analysis and monitoring. Scheduling tasks to run programs at specific times helps streamline workflows and maintain systems without manual intervention. Python can also monitor and manage system resources, ensuring optimal performance and identifying potential issues.

By leveraging Python's automation capabilities, you can focus on higher-level tasks and problem-solving. Automation is particularly valuable for handling large volumes of data or files, as it eliminates the need for manual processing. Python's extensive libraries and modules support various automation tasks, from file manipulation to web scraping and system management. As you explore automation further, you'll discover more ways to optimise your workflows and increase productivity. Embracing automation is a key skill for any Python programmer looking to work efficiently and tackle complex projects.
:::

# GUI Applications: Creating Software with Interfaces

Build desktop applications with graphical user interfaces.

What you can create:
- **Productivity tools**: Task managers, note-taking apps
- **Data visualisation**: Interactive charts and dashboards
- **Media applications**: Image editors, music players
- **Educational software**: Interactive learning tools
- **Custom utilities**: Tools tailored to specific needs

```python
# Tiny GUI example (full code available for download)
import tkinter as tk

# Create a simple app
root = tk.Tk()
root.title("My First GUI App")

# Add components
label = tk.Label(root, text="Enter city:")
label.pack()

entry = tk.Entry(root)
entry.pack()

button = tk.Button(root, text="Get Weather")
button.pack()

# Start the application
root.mainloop()
```

Popular GUI libraries: Tkinter (built-in), PyQt, Kivy (cross-platform), wxPython

::: {.notes}
GUI applications allow users to interact with software through visual interfaces, making them more accessible and user-friendly. Productivity tools like task managers and note-taking apps help users organise their work and stay on top of their tasks. Data visualisation applications enable users to explore and understand complex data through interactive charts and dashboards. Media applications such as image editors and music players provide creative tools for editing and enjoying multimedia content. Educational software offers interactive learning experiences to engage students and enhance their understanding of various subjects. Custom utilities are tailored to meet specific needs, providing specialised functionality for niche tasks or industries.

These applications showcase the versatility of Python in creating diverse software solutions. With Python's extensive libraries and frameworks, developers can efficiently build GUI applications across various domains. By leveraging Python's simplicity and power, developers can focus on creating intuitive and visually appealing interfaces that cater to the needs of their target users. Whether it's boosting productivity, exploring data, expressing creativity, facilitating learning, or addressing specific requirements, Python empowers developers to create GUI applications that make a meaningful impact in people's lives.
:::

# Game Development: Bringing Imagination to Life

Create interactive games with Python libraries.

What you can build:
- **2D games**: Platformers, pussles, arcade-style games
- **Interactive simulations**: Physics demos, ecosystem models
- **Educational games**: Learning through play
- **Text adventures**: Story-driven interactive fiction
- **Game prototypes**: Test concepts before full development

```python
# Tiny Pygame example (full code available for download)
import pygame

# Initialise and set up display
pygame.init()
screen = pygame.display.set_mode((800, 600))
pygame.display.set_caption("My Game")

# Game loop (simplified)
running = True
while running:
    # Handle events
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
    
    # Draw game elements
    screen.fill((0, 0, 0))  # Black background
    pygame.draw.circle(screen, (255, 0, 0), (400, 300), 50)  # Red circle
    
    # Update the display
    pygame.display.flip()

pygame.quit()
```

Game development libraries: Pygame, Arcade, Panda3D

::: {.notes}
Game development is an exciting field that allows you to bring your imagination to life through interactive experiences. From 2D platformers and puzzles to physics simulations and educational games, there are endless possibilities for creating engaging and entertaining software. Text adventures offer a unique opportunity to craft story-driven interactive fiction, while game prototypes enable you to test out concepts before committing to full development.

Whether you're interested in creating simple arcade-style games or more complex interactive simulations, game development provides a rich canvas for expressing your creativity and problem-solving skills. By leveraging Python's extensive libraries and frameworks, you can streamline the development process and focus on bringing your ideas to life. With the right tools and a passion for game design, you can create immersive experiences that captivate and delight players of all ages.
:::

# Beyond Python: Expanding Your Programming Horisons

While Python is versatile, other languages offer unique strengths:

- **JavaScript**: Essential for web front-end development
- **SQL**: Database queries and management
- **R**: Statistical computing and graphics
- **Java/Kotlin**: Android app development
- **Swift**: iOS app development
- **C/C++**: Performance-critical applications
- **Rust**: Safe systems programming
- **Go**: Modern, efficient concurrent programming

Learning multiple languages expands your perspective and capabilities!

::: {.notes}
Python is a fantastic language to start your programming journey, but there are many other languages worth exploring to expand your skills and tackle diverse projects. JavaScript is essential for web front-end development, allowing you to create interactive and dynamic web pages. SQL is crucial for working with databases, enabling you to query and manage data effectively. R excels at statistical computing and data visualisation, making it a valuable tool for data analysis. Java and Kotlin are the primary languages for Android app development, while Swift is used for creating iOS apps. C and C++ are often employed for performance-critical applications, such as system-level programming or resource-intensive software.

Rust is gaining popularity as a safe and efficient language for systems programming, providing strong memory safety guarantees without compromising performance. Go, developed by Google, is a modern language designed for efficient and concurrent programming, making it well-suited for building scalable and high-performance applications. By learning these languages alongside Python, you'll be equipped to tackle a wide range of programming challenges and contribute to diverse projects across various domains, from web and mobile development to data analysis and systems programming.
:::

# Coding Best Practices: From Good to Great

Level up your programming with professional practices:

- **Version Control**: Master Git for tracking changes and collaboration
- **Testing**: Write tests for your code (unit tests, integration tests)
- **Documentation**: Create clear, helpful documentation for your projects
- **Clean Code**: Organise code to be readable and maintainable
- **Code Reviews**: Learn from feedback on your code
- **Refactoring**: Improve code structure without changing functionality
- **Performance Optimisation**: Make your code faster and more efficient
- **Security**: Protect your applications from vulnerabilities

These practices are universal across programming languages and domains.

::: {.notes}
Version control, testing, documentation, clean code, code reviews, refactoring, performance optimisation and security are key coding best practices to elevate your programming skills. Git is essential for tracking changes and collaborating effectively. Writing unit and integration tests ensures your code works as intended. Clear documentation makes your projects more maintainable. Organising your code to be readable and maintainable is crucial. Code reviews provide valuable feedback to learn and improve.

Refactoring involves restructuring code without changing its behaviour, leading to more efficient and maintainable programs. Optimising performance makes your applications faster and more responsive. Implementing security measures protects your code from vulnerabilities and potential attacks. By adopting these best practices consistently, you can progress from writing good code to creating truly great software projects.
:::

# The Collaborative World of Open Source

Contribute to projects and learn from the global programming community:

- **Finding Projects**: GitHub, GitLab, project websites
- **Getting Started**: Read documentation, understand contribution guidelines
- **First Contributions**: Fix small bugs, improve documentation
- **Communication**: Engage with the community through issue discussions
- **Code Review Process**: Learn from feedback on your pull requests
- **Building Your Portfolio**: Showcase your contributions

Open source participation accelerates learning and connects you with other developers!

::: {.notes}
The collaborative nature of open source software development provides an excellent opportunity for programmers to contribute to meaningful projects and grow their skills. Platforms like GitHub and GitLab host a vast array of open source projects, allowing developers to find initiatives that align with their interests and expertise. To get started, it's crucial to carefully read the project's documentation and familiarise oneself with its contribution guidelines. Making small contributions initially, such as fixing minor bugs or improving documentation, is an ideal way to gain experience and build rapport with the project's community.

Engaging with the community through issue discussions and participating in the code review process are essential aspects of open source collaboration. These interactions provide valuable opportunities to learn from experienced developers and receive constructive feedback on one's work. As contributions accumulate, programmers can showcase their involvement in open source projects as part of their portfolio, demonstrating their skills, teamwork, and dedication to the craft. By actively participating in the open source ecosystem, developers can expand their knowledge, build professional networks, and make a positive impact on the software they use and love.
:::

# AI-Assisted Programming: Your New Coding Partner

Learn to effectively collaborate with AI tools for programming:

- **Code Completion**: Tools like GitHub Copilot suggest code as you type
- **Problem-Solving**: Use AI to brainstorm approaches and debug issues
- **Learning New Concepts**: Get explanations of unfamiliar code or libraries
- **Productivity Boosts**: Generate boilerplate code and common patterns
- **Refactoring Help**: Get suggestions for improving existing code

The key skill: learning to effectively prompt, evaluate, and refine AI-generated code.

::: {.notes}
AI-assisted programming tools like GitHub Copilot can boost developer productivity by suggesting code completions as you type, helping brainstorm problem-solving approaches, and providing explanations for unfamiliar code or libraries. These tools can generate common boilerplate code patterns and offer refactoring suggestions to improve existing code.

By leveraging AI to assist with various programming tasks, developers can save time, overcome challenges more efficiently, and continuously learn new concepts. While AI-assisted programming is not a replacement for fundamental coding skills, it can be a valuable partner in writing software, allowing developers to focus on higher-level problem-solving and creativity.
:::

# Building a Learning Routine: Sustainable Growth

Create habits that support continuous improvement:

- **Coding Projects**: Apply what you learn to personal projects
- **Reading Code**: Study well-written code in open source projects
- **Community Engagement**: Join forums, attend meetups, participate in hackathons
- **Teaching Others**: Solidify your knowledge by explaining concepts
- **Following Industry News**: Stay updated on trends and best practices
- **Structured Learning**: Combine tutorials, books, and online courses
- **Reflection**: Regularly review what you've learned and identify gaps

Remember: Consistent small steps lead to remarkable progress over time!

::: {.notes}
Developing a sustainable learning routine is key to continued growth as a programmer. Apply your knowledge to personal coding projects, study well-written code in open source projects, and engage with the programming community through forums, meetups, and hackathons. Teaching others is also a powerful way to solidify your understanding of concepts. 

Complement your practical learning with structured study through tutorials, books, and online courses. Stay current with industry trends and best practices by following relevant news sources. Regularly reflect on what you've learned and identify areas for further development. By incorporating these diverse learning activities into a consistent routine, you'll foster ongoing skill acquisition and stay motivated on your programming journey.
:::

# Resources to Continue Your Journey

Here are some high-quality resources to explore:

**Books:**
- "Fluent Python" by Luciano Ramalho
- "Python Crash Course" by Eric Matthes
- "Automate the Boring Stuff with Python" by Al Sweigart
- "Clean Code" by Robert C. Martin

**Online Resources:**
- Python Documentation: docs.python.org
- Real Python: realpython.com
- PyBites: pybit.es
- Stack Overflow: stackoverflow.com

**Interactive Learning:**
- Exercism: exercism.org
- HackerRank: hackerrank.com
- LeetCode: leetcode.com
- Codewars: codewars.com

**YouTube Channels:**
- Corey Schafer
- sentdex
- Tech With Tim
- freeCodeCamp

**Complete Code Examples:**
For the more complex code examples mentioned in this presentation, you can download them from our course repository: github.com/python-course/beyond-basics-examples

::: {.notes}
Books on Python and Programming:
"Fluent Python" by Luciano Ramalho, "Python Crash Course" by Eric Matthes, "Automate the Boring Stuff with Python" by Al Sweigart, and "Clean Code" by Robert C. Martin are recommended books for deepening your Python knowledge and learning best coding practices. These books cover a range of topics, from Python fundamentals to advanced concepts, and provide practical examples and exercises to reinforce your learning.

Online Resources and Communities:
The official Python Documentation (docs.python.org) is an indispensable resource for understanding Python's syntax, built-in functions, and standard libraries. Websites like Real Python (realpython.com) and PyBites (pybit.es) offer tutorials, articles, and challenges to help you expand your Python skills. For coding help and advice, Stack Overflow (stackoverflow.com) is a popular Q&A platform. Exercism (exercism.org), HackerRank (hackerrank.com), LeetCode (leetcode.com), and Codewars (codewars.com) provide coding exercises and problems to solve, allowing you to practice and improve your programming abilities. Additionally, YouTube channels like Corey Schafer, sentdex, Tech With Tim, and freeCodeCamp offer video tutorials and courses on various Python and programming topics.
:::

# Final Thoughts: Your Programming Adventure

Remember these key principles as you continue your journey:

- **Everyone starts somewhere**: Even experts were once beginners
- **Learning to learn** is your most valuable skill
- **Building things** teaches more than just reading about them
- **Mistakes are valuable teachers** if you reflect on them
- **The programming community** is supportive and full of resources
- **Your unique perspective** brings value to the field

This is just the beginning of your programming adventure. Where will you go next?

::: {.notes}
Everyone starts somewhere, and even the most accomplished programmers were once beginners. As you continue learning, remember that building projects teaches valuable practical skills beyond just reading about concepts. Embrace mistakes as learning opportunities, reflecting on them to grow. The supportive programming community offers a wealth of resources to help you along the way.

Your unique perspective and experiences bring valuable insights to the field of programming. As you explore various paths like data science, web development, machine learning, and more, find what resonates with you. Establish a sustainable learning routine, collaborate with others through open source, and stay curious about emerging technologies. Your programming adventure is just beginning, and the possibilities are limitless.
:::

---
title: "Connecting the Dots - A 12-Week Retrospective"
subtitle: Bringing it all Together
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# What we will review 

- **The Six-Step Problem-Solving Methodology**
- **Python Fundamentals Toolkit**
- **Modern Development Environment**
- **Real-World Application**
- **AI as a Learning Companion**
- **Project Showcase: The Weather Forecaster**
  
::: {.notes}
This presentation summarises the core concepts covered in the Introduction to Programming unit using Python. We'll revisit our six-step methodology and the foundational programming tools we've learned, all within the Google Colab and GitHub environment, and touch on how we use external libraries and AI in our workflow.

In this slide, we summarise the key themes and learnings from our 12-week journey. We began by introducing the Six-Step Problem-Solving Methodology, a structured approach to tackle complex problems. We then equipped ourselves with the Python Fundamentals Toolkit, learning the essential building blocks of the language. Our Modern Development Environment allowed us to code in the cloud and validate our programs using doctests. Throughout the course, we applied our learnings to Real-World Applications, such as the weather context, to make our code more relatable and meaningful.

AI served as our Learning Companion, guiding us through the intricacies of programming and providing valuable insights. The culmination of our efforts is showcased in the Weather Forecaster project, where we combined all the concepts learned - from user interfaces and conditional logic to loops and functions - to create a functional and practical application. This retrospective highlights the breadth and depth of our learning journey, setting a strong foundation for future programming endeavours.
:::

# The Six-Step Methodology: Cracking the Code of Problem-Solving

**Programming = Thinking + Coding**

Our approach breaks down problem-solving into clear stages:
1. Understand the problem
2. Identify the inputs and outputs
3. Work the problem by hand
4. Write pseudocode
5. Convert to Program
6. Test with a variety of data

::: {.notes}
The six-step methodology is a powerful framework for tackling complex problems in a systematic and structured manner. By breaking down the problem-solving process into distinct phases, this approach helps you organise your thoughts, plan your actions, and execute your solution effectively. The methodology consists of two main phases: the "Thinking" phase, where you build your mental model and plan your approach, and the "Coding" phase, where you translate your ideas into working code.

In the upcoming slides, we will explore each step of the methodology in detail, starting with the "Thinking" phase. You will learn how to analyse problems, break them down into manageable components, and create pseudocode to guide your coding process. We will then transition to the "Coding" phase, where you will discover the fundamental building blocks of Python programming, such as variables, data types, control structures, and functions. Throughout the presentation, we will use the context of weather forecasting to illustrate how these concepts can be applied to real-world problems, culminating in the creation of a fully functional weather forecaster application.
:::

# The "Thinking" Phase: Building Your Mental Model

This is where we focus on truly understanding the problem before writing any code.

1. **Understand the problem**: Restate the problem in your own words. What is the goal?
2. **Identify the inputs and outputs**: What information does the program need (inputs)? What should the program produce or display (outputs)?
3. **Work the problem by hand**: Solve a small, simple example of the problem manually. This helps clarify the logic and steps required.

::: {.notes}
The "Thinking" phase is a crucial step in the problem-solving process, where you build a mental model of the task at hand. This involves analysing the problem statement, identifying key elements, and breaking it down into smaller, manageable parts. By doing so, you gain a clear understanding of the problem's requirements and constraints, which lays the foundation for the subsequent steps in the problem-solving methodology.

Building a mental model also involves considering potential solutions and approaches to the problem. This may include brainstorming ideas, evaluating their feasibility, and selecting the most promising ones to explore further. Throughout this process, it's important to keep an open mind and consider multiple perspectives, as this can lead to more creative and effective solutions. By the end of the "Thinking" phase, you should have a well-defined mental model of the problem and a clear direction for the next steps in the problem-solving process.
:::

# Planning with Pseudocode: Bridging Thought and Code

Translate your manual steps into a semi-structured description using the six fundamental actions a computer can perform:

- **Input**: Getting data from the user or a source
- **Output**: Displaying data to the user or a destination
- **Storage**: Storing data in variables
- **Calculate**: Performing arithmetic or logical operations
- **Make Decision**: Choosing between options based on conditions (if/else)
- **Repeat**: Performing actions multiple times (loops)

Pseudocode helps you outline the logic before coding.

::: {.notes}
Pseudocode acts as a bridge between the thinking and coding phases of problem-solving. It allows you to outline the key components of a program using plain language, focusing on the logic and flow rather than specific syntax. The six main elements of pseudocode are: getting input from the user or a source, displaying output to the user or a destination, storing data in variables, performing calculations or logical operations, making decisions based on conditions using if/else statements, and repeating actions multiple times with loops.

By organising your thoughts into these categories, you can create a clear blueprint for your code before diving into the actual implementation. This helps break down complex problems into manageable steps and ensures that you have a solid plan in place. Pseudocode also serves as a communication tool, allowing you to share your ideas with others in a language-agnostic way. As you transition from pseudocode to actual code, you'll have a roadmap to guide you, making the coding process more structured and efficient.
:::

# The "Coding" Phase: Bringing Ideas to Life

Now we translate our plan into executable code and verify it.

5. **Convert to Program**: Translate your pseudocode steps into actual Python code using the tools and syntax we've learned.
6. **Test with a variety of data**: Run your program with different inputs, including typical cases, edge cases, and potentially invalid inputs, to ensure it works correctly in all scenarios.

::: {.notes}
The "Coding" Phase is where ideas transition from mental models and pseudocode into functional Python programs. This phase involves translating the logical steps and structures outlined in the planning stage into syntactically correct Python code. It requires a solid understanding of Python fundamentals, such as variables, data types, control flow, and functions, which serve as the essential building blocks for crafting working programs.

During the coding phase, programmers utilise their knowledge of Python's syntax and semantics to write code that accurately reflects the intended logic and behaviour of the program. They employ various programming constructs, such as conditional statements (if-else), loops (for, while), and functions, to implement the desired functionality. Attention to detail is crucial in this phase to ensure the code is free of syntax errors and logical inconsistencies. Debugging and testing are integral parts of the coding process, allowing programmers to identify and fix issues, ensuring the program runs as expected.
:::

# Python Fundamentals: Your Coding Toolkit

Getting started with the absolute fundamentals.

```python
# Display a message to the console
print("Hello, world!")  # Output: Hello, world!

# Capture user input (always returned as a string)
name = input("What's your name? ")  # Prompts user and stores their response

# Creating variables to store different types of data
age = 30               # Integer value
greeting = "Hello"     # String value
temperature = 25.5     # Float value
is_raining = False     # Boolean value
```

::: {.notes}
Python Fundamentals: Your Coding Toolkit

Python is a versatile, beginner-friendly programming language that offers a wide range of built-in functions and powerful libraries. This slide focuses on the core elements of Python syntax and semantics, which form the foundation of your coding toolkit. We'll explore data types, variables, operators, and basic control structures like conditionals and loops. These building blocks allow you to create simple programs and express your ideas in code.

As you progress through the course, you'll learn how to combine these fundamental concepts to solve increasingly complex problems. We'll introduce you to functions, which help you organise your code into reusable blocks, and modules, which extend Python's capabilities even further. By mastering the fundamentals covered in this slide, you'll be well-equipped to tackle the upcoming challenges and build your own interactive programs, such as the weather forecaster project.
:::

# Creating Interactive Programs: Inputs and Outputs

Combining `input()` and `print()` for meaningful interaction.

```python
# Ask the user for their name
user_name = input("Please enter your name: ")  # Stores user's name as a string

# Display personalised messages using different techniques
print("Welcome, " + user_name + "!")  # Using string concatenation
print("Welcome,", user_name, "!")     # Using comma separation
print(f"Welcome, {user_name}!")       # Using f-strings (formatted strings)
```

::: {.notes}
Interactive programs engage users by accepting inputs and providing meaningful outputs. Python offers various functions like `input()` to read user input from the console, allowing programs to respond dynamically based on the provided data. Outputs can be displayed using `print()` statements, enabling clear communication between the program and the user.

Combining inputs and outputs empowers developers to create interactive experiences. By prompting users for information and processing it to generate relevant outputs, programs become more engaging and personalised. This interactivity forms the foundation of user-friendly applications, fostering a dialogue between the user and the computer.
:::

# Making Smart Decisions: Conditional Logic

Making your programs respond to different conditions.

```python
temperature = 25  # Variable storing the current temperature

# Decision structure that responds differently based on temperature
if temperature > 30:
    print("It's hot!")              # Runs only if temperature > 30
elif temperature > 20:
    print("It's warm.")             # Runs if first condition is False but temperature > 20
else:
    print("It's cool.")             # Runs if all previous conditions are False
    
# Combining conditions with logical operators
if temperature > 20 and not is_raining:
    print("Great day for outdoor activities!")
```

::: {.notes}
Conditional logic is a fundamental concept in programming that allows your code to make decisions based on certain conditions. By using if, elif, and else statements, you can create branching paths in your program's execution flow. This enables your code to respond intelligently to different inputs or situations, making your programs more dynamic and interactive.

Mastering conditional logic is essential for building robust and flexible programs. It forms the foundation for creating complex decision-making processes, such as those found in weather forecasting applications or interactive menus. By carefully constructing conditional statements and combining them with other programming constructs like loops and functions, you can create powerful and adaptive software solutions that can handle a wide range of scenarios.
:::

# Connecting to Real Life: The Weather Context

Connecting programming concepts to a real-world scenario.

- Using simple weather conditions (cold, warm, rainy)
- Mapping these conditions to numeric thresholds (e.g., temperature ranges)
- Using if-else logic to decide on a weather message based on a temperature input

This helps make abstract conditional logic more tangible and practical.

::: {.notes}
Here are the presenter notes for the slide "Connecting to Real Life: The Weather Context":

In this slide, we explore how to connect our programming concepts to a real-life context, using the example of weather conditions. We start by considering simple weather conditions such as cold, warm, and rainy. These conditions are then mapped to specific numeric thresholds, for example, defining temperature ranges for each condition. This allows us to create a clear link between the real-world concept and the data we can use in our program.

Next, we apply the concept of conditional logic, specifically if-else statements, to make decisions based on the temperature input. By comparing the input temperature to our predefined thresholds, we can determine the appropriate weather message to display. This demonstrates how we can use the logical structures we've learned to create a program that responds intelligently to real-world data, providing meaningful output based on the conditions encountered.
:::

# Building User Interfaces: Simple Menus

Creating user-friendly text-based interfaces.

```python
# Display a menu of options to the user
print("Weather Information Menu:")
print("1. Check Temperature")
print("2. Check Humidity")
print("3. Exit Program")

# Get the user's selection
choice = input("Enter your choice (1-3): ")  # Stores selection as a string

# Take different actions based on the user's choice
if choice == "1":
    print("You selected: Check Temperature")
    # Temperature check code would go here
elif choice == "2":
    print("You selected: Check Humidity")
    # Humidity check code would go here
elif choice == "3":
    print("Exiting program. Goodbye!")
else:
    print("Invalid option. Please try again.")  # Handles unexpected inputs
```

::: {.notes}
Building user interfaces is a crucial aspect of creating interactive programs. Simple menus provide a straightforward way for users to navigate through different options and functionalities. By presenting a list of choices, users can easily select the desired action, making the program more user-friendly and intuitive.

When designing simple menus, it's important to keep the options clear and concise. Each menu item should accurately describe the action it represents, using language that is easily understandable by the target audience. Additionally, numbering or lettering the options can make it easier for users to make their selection. Implementing input validation is also essential to ensure that the program can handle unexpected or invalid user inputs gracefully, providing appropriate feedback and guidance to the user.
:::

# Powering Through Repetition: Loops

Performing actions multiple times efficiently.

```python
# For loop: repeats a specific number of times
for i in range(5):
    print(f"Loop iteration {i}")  # Prints numbered iterations 0 through 4
    
# While loop: repeats as long as a condition is True
count = 0
while count < 3:
    print(f"Count is {count}")  # Displays current count value
    count += 1                  # Increases count by 1 each iteration
    
# Looping through a collection of items
weather_types = ["Sunny", "Rainy", "Cloudy"]
for weather in weather_types:
    print(f"Today's forecast: {weather}")  # Displays each weather type
```

::: {.notes}
Loops are a fundamental programming concept that allow you to execute a block of code repeatedly. They enable you to automate repetitive tasks and process large amounts of data efficiently. Python offers two main types of loops: for loops and while loops. For loops iterate over a sequence of elements, such as a list or a range of numbers, executing the code block for each element. While loops, on the other hand, continue executing the code block as long as a specified condition remains true.

When working with loops, it's important to be mindful of infinite loops, which occur when the loop condition never becomes false, causing the program to run indefinitely. To avoid this, ensure that the loop condition eventually evaluates to false or use control statements like break to exit the loop when appropriate. Loops are incredibly versatile and can be used in various scenarios, such as iterating over data structures, implementing algorithms, and generating patterns or sequences. By mastering loops, you'll be able to write more concise and efficient code, saving time and effort in your programming endeavours.
:::

# Creating Order with Functions: Reusable Code Blocks

Bundling code into reusable, organised units.

```python
# Define a function that can be called multiple times
def greet(name):
    """Says hello to the specified name."""  # Docstring explaining function purpose
    print(f"Hello, {name}!")  # Greets the person by name
    
# Call the function with different arguments
greet("Alice")  # Output: Hello, Alice!
greet("Bob")    # Output: Hello, Bob!

# Function with return value
def calculate_fahrenheit(celsius):
    """Converts Celsius temperature to Fahrenheit."""
    return (celsius * 9/5) + 32  # Formula for temperature conversion
    
# Using the returned value
temp_f = calculate_fahrenheit(25)
print(f"25Â°C equals {temp_f}Â°F")  # Output: 25Â°C equals 77.0Â°F
```

::: {.notes}
Functions are powerful tools that allow you to organise your code into reusable blocks. By defining a function, you can encapsulate a specific task or computation and give it a meaningful name. This promotes code reusability, as you can call the function multiple times from different parts of your program, saving time and reducing duplication. Functions also improve code readability by breaking down complex logic into smaller, more manageable units.

When creating functions, it's crucial to consider the input parameters and the return value. Input parameters allow you to pass data into the function, making it more flexible and adaptable to different scenarios. The return value allows the function to send a result back to the caller, enabling further processing or use of the computed value. By carefully designing the input and output of your functions, you can create modular and reusable code that is easier to understand, test, and maintain.
:::

# Extending Python's Power: Modules and Libraries

Leveraging pre-written code to accomplish more.

```python
# Using the built-in datetime module
import datetime

# Get and display the current date and time
current_time = datetime.datetime.now()  # Creates a datetime object representing now
print(f"Current time is: {current_time}")

# Using specific functions from a module
from random import choice

# Select a random weather condition
conditions = ["Sunny", "Cloudy", "Rainy", "Snowy"]
today = choice(conditions)  # Picks one random item from the list
print(f"Today's forecast: {today}")
```

Third-party libraries (like simple_bot or pandas later) provide powerful tools for specific tasks.

::: {.notes}
Python's extensive collection of modules and libraries empowers developers to tackle complex tasks efficiently. These pre-built code packages offer functionalities ranging from data analysis and machine learning to web development and automation. By leveraging modules and libraries, programmers can save time, reduce code complexity, and focus on solving domain-specific problems.

Incorporating modules and libraries into Python projects is straightforward. The "import" statement allows developers to bring external code into their programs, making the functionalities of the imported module or library accessible. Python's package manager, pip, simplifies the installation process, enabling developers to easily add new capabilities to their projects. With a vast ecosystem of modules and libraries, Python provides a rich toolset for developers across various domains.
:::

# Visualising Data: Bringing Numbers to Life

Using pandas to load and visualise data from CSV files.

```python
# Import the necessary libraries
import pandas as pd
import matplotlib.pyplot as plt

# Load data from a CSV file into a DataFrame
# A DataFrame is like a table or spreadsheet in Python
weather_data = pd.read_csv('weather_records.csv')  # Loads the CSV file

# Display the first 5 rows to get a quick look at our data
print(weather_data.head())  # Shows column names and first few rows

# Create a simple line plot of temperatures over time
weather_data.plot(x='Date', y='Temperature')  # x-axis: Date, y-axis: Temperature
plt.title('Temperature Variations')  # Add a title to the plot
plt.ylabel('Temperature (Â°C)')  # Label for y-axis
plt.grid(True)  # Add grid lines for better readability
plt.show()  # Display the plot

# Create a bar chart comparing different weather measurements
weather_data[['Rainfall', 'Humidity']].mean().plot(kind='bar')  # Bar chart of averages
plt.title('Average Rainfall vs. Humidity')  # Add a title
plt.ylabel('Value')  # Label for y-axis
plt.show()  # Display the plot
```

Visualisation helps us identify patterns, trends, and outliers in data that might not be obvious from looking at raw numbers.

::: {.notes}
Data visualisation transforms raw numbers into meaningful graphics, charts, and diagrams, making complex information easy to understand and interpret. By presenting data visually, patterns, trends, and outliers become immediately apparent, enabling quick insights and data-driven decision making.

Effective data visualisation requires careful consideration of the data, the audience, and the message to be conveyed. Key principles include choosing the right visualisation type for the data, using colour and design elements strategically, and providing clear labels and context. When done well, data visualisation can be a powerful tool for communicating insights and driving action.
:::

# AI as Your Programming Companion

Leveraging AI to accelerate your learning journey.

- AI can help explain concepts, syntax, and error messages
- AI can suggest code examples or alternative approaches
- **Key**: Use AI to understand and refine, not just to get answers
- Critically evaluate AI output â€“ does it make sense? Does it fit the problem?

Think of AI as a powerful assistant that helps you code while you learn.

::: {.notes}
AI can be a valuable programming companion, helping to explain concepts, syntax, and error messages, as well as suggesting code examples and alternative approaches. However, the key is to use AI to understand and refine your own thinking, not just to get answers. Critically evaluate the AI's output, asking yourself whether it makes sense and fits the problem at hand.

When utilising AI as a programming companion, it's important to remember that it is a tool to support your learning and problem-solving process, not a replacement for your own critical thinking. AI can provide valuable insights and suggestions, but ultimately, you need to assess the quality and relevance of its output in the context of your specific programming challenge. By using AI thoughtfully and in combination with your own skills and judgement, you can enhance your programming abilities and tackle more complex problems effectively.
:::

# The Weather Forecaster: Putting It All Together

Our first major project combined these foundational concepts:

- Display a menu of weather checks (Temperature, Humidity, etc.)
- Handle user input for menu selection and weather data (e.g., temperature value)
- Implement decision logic (if-else) to provide a simple forecast message based on the input
- Focus on the Thinking phase (Steps 1-4) before Coding (Steps 5-6)

This project demonstrated how our methodology and Python fundamentals come together to solve real problems.

::: {.notes}
The Weather Forecaster brings together the key concepts and skills covered throughout the course, enabling you to create an interactive program that provides simple weather forecasts based on user input. By displaying a menu of weather checks, handling user input, and implementing decision logic using if-else statements, you'll apply the problem-solving methodology and Python fundamentals to build a functional weather application.

Before diving into coding, focus on the critical thinking phase, which involves understanding the problem, planning your solution, and creating a mental model using pseudocode. Once you have a clear plan, transition to the coding phase, where you'll translate your pseudocode into Python syntax, leveraging your knowledge of inputs, outputs, conditional logic, and simple menus to bring your weather forecaster to life.
:::

# Zero-Installation Development: Coding in the Cloud

We use cloud-based tools to code and manage our files.

**Google Colab:**
- Cloud-based Jupyter notebooks
- Write and run Python in your browser
- Zero installation required
- Ideal for learning and quick prototyping

**GitHub:**
- Version control system
- Store and manage your code files
- Collaborate with others
- Integrates with Google Colab for saving/loading notebooks

::: {.notes}
Cloud-based Jupyter notebooks offer a revolutionary way to code Python directly in your browser without installing any software on your local machine. This zero-installation approach is perfect for learning and quick prototyping, as you can start coding immediately without the hassle of setting up a development environment. The cloud-based platform also comes with a built-in version control system, allowing you to store and manage your code files easily.

Collaboration is another key benefit of coding in the cloud. You can share your notebooks with others, work on projects together in real-time, and benefit from the collective knowledge of the community. The integration with Google Colab further enhances the experience by enabling seamless saving and loading of notebooks, making it easy to pick up where you left off and access your work from any device with an internet connection.
:::

# Validating Your Code: Testing with Doctests

Testing completes our six-step methodology by verifying your code works correctly.

```python
def celsius_to_fahrenheit(celsius):
    """
    Convert Celsius temperature to Fahrenheit.
    
    Formula: F = (C * 9/5) + 32
    
    Examples:
    >>> celsius_to_fahrenheit(0)
    32.0
    >>> celsius_to_fahrenheit(100)
    212.0
    >>> celsius_to_fahrenheit(25)
    77.0
    """
    return (celsius * 9/5) + 32

# Running the tests is as simple as:
if __name__ == "__main__":
    import doctest
    doctest.testmod()  # Runs all doctests in the file
```

Key benefits of doctests:
- **Documentation + Testing**: Tests double as examples that document how to use your functions
- **Clear Expectations**: Shows exactly what inputs produce what outputs
- **Automatic Verification**: Easily check if changes break existing functionality
- **Ties directly to Step 6**: "Test with a variety of data" from our methodology

When your doctests pass, you have confidence your code works as intended!

::: {.notes}
Doctests provide a powerful way to combine documentation and testing in Python. By including examples directly in your function docstrings, you clarify exactly how the function should be used and what outputs to expect for given inputs. This makes your code more readable and maintainable, as the tests serve as a form of living documentation. Doctests also enable you to easily verify that your functions are working as intended, catching any regressions introduced by code changes.

Doctests align perfectly with Step 6 of our problem-solving methodology, which emphasises testing with a variety of data. By incorporating doctests into your development process, you can efficiently validate your code against different scenarios and edge cases. This helps build confidence in your solutions and ensures they handle the expected range of inputs correctly. Doctests are a valuable tool for any programmer looking to write more robust, self-documenting code.
:::

# Beyond the Cloud: Setting Up Your Local Environment

As you progress in your programming journey, you may want to set up a local development environment:

1. **Install Python**: Download and install from python.org
2. **Choose an IDE/Editor**: Options include VS Code, PyCharm, or Sublime Text
3. **Set up version control**: Install Git locally and connect to GitHub
4. **Virtual environments**: Learn to use `venv` to manage project dependencies

Benefits of local development include offline access, better performance for larger projects, and more customisation options.

::: {.notes}
Setting up your local environment is the next step after mastering coding in the cloud. While cloud-based development offers convenience and accessibility, having a local setup provides more control, flexibility, and the ability to work offline. It also allows you to use a wider range of tools and libraries that may not be available in cloud environments.

To set up your local environment, you'll need to install Python on your computer, choose an Integrated Development Environment (IDE) or text editor, and familiarise yourself with the command line interface. Popular IDEs for Python include PyCharm, Visual Studio Code, and Sublime Text. Once your environment is set up, you can start creating and running Python programs locally, leveraging the full capabilities of your machine.
:::

# Your Programming Foundation: Ready for the Next Level

We've covered the essential building blocks of programming:

- **Core Concepts**: Input, Output, Variables, Data Types, Decision Making
- **Problem Solving**: Using the six-step methodology to break down challenges
- **Code Organisation & Reusability**: Introducing Loops and Functions
- **Expanding Capabilities**: Leveraging Modules and Libraries
- **Modern Workflow**: Utilising Google Colab and GitHub for a zero-install environment
- **Accelerated Learning**: Partnering with AI to enhance understanding and coding

These foundational skills and tools prepare you to tackle more complex problems and build increasingly sophisticated applications in your programming journey.

::: {.notes}
This slide summarises the key programming concepts and skills covered in the course, which form a strong foundation for further learning. Core concepts like input/output, variables, data types and decision making are highlighted, along with the six-step problem-solving methodology. Code organisation and reusability are introduced through loops and functions, while modules and libraries expand capabilities.

The modern workflow using Google Colab and GitHub provides a zero-install environment, simplifying the coding process. Partnering with AI is positioned as a way to accelerate learning by enhancing understanding and coding skills. These foundational elements prepare learners to tackle more advanced programming challenges and continue their growth as developers.
:::

Copyright Â© 2017-present, [Encode OSS Ltd](https://www.encode.io/).
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**This software is dual-licensed under the The University of Illinois/NCSA
Open Source License (NCSA) and The 3-Clause BSD License**

# NCSA Open Source License
**Copyright (c) 2019 Kevin Sheppard. All rights reserved.**

Developed by: Kevin Sheppard (<kevin.sheppard@economics.ox.ac.uk>,
<kevin.k.sheppard@gmail.com>)
[http://www.kevinsheppard.com](http://www.kevinsheppard.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal with
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimers.

Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimers in the documentation and/or
other materials provided with the distribution.

Neither the names of Kevin Sheppard, nor the names of any contributors may be
used to endorse or promote products derived from this Software without specific
prior written permission.

**THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH
THE SOFTWARE.**


# 3-Clause BSD License
**Copyright (c) 2019 Kevin Sheppard. All rights reserved.**

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
   may be used to endorse or promote products derived from this software
   without specific prior written permission.

**THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
THE POSSIBILITY OF SUCH DAMAGE.**

# Components

Many parts of this module have been derived from original sources, 
often the algorithm's designer. Component licenses are located with 
the component code.
Copyright Â© 2018, [Encode OSS Ltd](https://www.encode.io/).
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
Copyright Â© 2019, [Encode OSS Ltd](https://www.encode.io/).
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
Copyright Â© 2020, [Encode OSS Ltd](https://www.encode.io/).
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
MIT License

Copyright (c) 2018 - 2024 Isaac Muse <isaacmuse@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
Copyright (C) 2010-2019 Max-Planck-Society
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this
  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.
* Neither the name of the copyright holder nor the names of its contributors may
  be used to endorse or promote products derived from this software without
  specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
BSD 3-Clause License

Copyright (c) 2013-2024, Kim Davies and contributors.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---
title: "Staff Answer Guide: Web Scraping Basics"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

## Overview
This guide provides instructors with expected answers, common student challenges, and grading guidance for the "Web Scraping Basics: A Friendly Introduction for Beginners" notebook. The notebook introduces students to web scraping concepts and techniques using Python, BeautifulSoup, requests, and pandas.

## Learning Objectives Assessment

Students should demonstrate the ability to:
1. Understand web scraping concepts and ethical considerations
2. Use requests library to download web page content
3. Parse HTML using BeautifulSoup to extract specific data elements
4. Organize and clean scraped data using pandas
5. Perform basic data analysis on the collected information

## Expected Code Outputs & Solutions

### Section: Downloading a Web Page

**Expected code execution:**
```python
# Define your headers to identify yourself
headers = {
    'User-Agent': 'Mozilla/5.0 (Educational purpose scraper)',
    'Accept': 'text/html,application/xhtml+xml'
}

# URL of the page we want to scrape
url = 'http://books.toscrape.com/'

# Make a request to the website
response = requests.get(url, headers=headers)

# Check if the request was successful
if response.status_code == 200:
    print(f"Successfully downloaded the page! Content length: {len(response.text)} characters")
else:
    print(f"Failed to download the page. Status code: {response.status_code}")

# Let's see what the raw HTML looks like (just the first 500 characters)
print(response.text[:500])
```

**Expected output:** 
- Success message showing content length (varies, typically 50,000+ characters)
- First 500 characters of HTML code from the page

**Grading notes:**
- Students should include proper headers with a user agent
- The request should be made correctly with `requests.get()`
- Response status code should be checked to verify successful download
- Raw HTML preview should be shown for inspection

### Section: Parsing HTML with BeautifulSoup

**Expected code execution:**
```python
# Create a BeautifulSoup object
soup = BeautifulSoup(response.text, 'html.parser')

# Let's check the title of the page
page_title = soup.title.text
print(f"Page title: {page_title}")
```

**Expected output:**
- Page title: "All products | Books to Scrape - Sandbox"

**Grading notes:**
- Students should correctly create a BeautifulSoup object with appropriate parser
- Page title should be extracted using `.title.text`
- Print statement should display formatted output

### Section: Extracting Book Information

**Expected code execution:**
```python
# Find all book containers on the page
book_containers = soup.find_all('article', class_='product_pod')
print(f"Found {len(book_containers)} books on this page")

# Lists to store our data
titles = []
prices = []
ratings = []

# Extract information from each book container
for book in book_containers:
    # Extract title
    title = book.h3.a['title']
    titles.append(title)

    # Extract price
    price = book.find('p', class_='price_color').text
    prices.append(price)

    # Extract star rating (contained in the class name)
    star_rating = book.find('p', class_='star-rating')['class'][1]
    ratings.append(star_rating)

# Display the first 5 items from each list
for i in range(5):
    print(f"Book {i+1}: {titles[i]}, Price: {prices[i]}, Rating: {ratings[i]}")
```

**Expected output:**
- Message showing number of books found (typically 20 on the first page)
- List of 5 books with their titles, prices, and ratings

**Grading notes:**
- Students should correctly select book containers using `find_all()`
- Book properties should be extracted using appropriate BeautifulSoup methods
- All three data points should be stored in separate lists
- The first 5 entries should be displayed properly

### Section: Converting to a DataFrame

**Expected code execution:**
```python
# Create a DataFrame from the scraped data
books_data = {
    'Title': titles,
    'Price': prices,
    'Rating': ratings
}

books_df = pd.DataFrame(books_data)

# Show the DataFrame
books_df
```

**Expected output:**
- A pandas DataFrame with three columns (Title, Price, Rating) and approximately 20 rows

**Grading notes:**
- Data should be correctly organized into a dictionary structure
- DataFrame should be created properly with all three columns
- DataFrame should be displayed (implicit or explicit)

### Section: Cleaning and Processing Data

**Expected code execution:**
```python
# Clean the price column (remove Â£ symbol and convert to float)
books_df['Price'] = books_df['Price'].str.replace('Â£', '').astype(float)

# Convert ratings to numeric values
rating_mapping = {
    'One': 1,
    'Two': 2,
    'Three': 3,
    'Four': 4,
    'Five': 5
}
books_df['Rating'] = books_df['Rating'].map(rating_mapping)

# Show the updated DataFrame
books_df
```

**Expected output:**
- An updated DataFrame with:
  - Price column containing numeric values without Â£ symbol
  - Rating column converted to integers (1-5)

**Grading notes:**
- Price cleaning should use string replacement and type conversion
- Rating conversion should use a mapping dictionary
- Both columns should be properly overwritten in the DataFrame
- Updated DataFrame should be displayed

### Section: Analyzing the Scraped Data

**Expected code execution:**
```python
# Display basic statistics
books_df.describe()

# Calculate average price by rating
avg_price_by_rating = books_df.groupby('Rating')['Price'].mean().sort_index()
print("Average price by rating:")
avg_price_by_rating
```

**Expected output:**
- Statistical summary of the DataFrame columns
- Average price by rating level (grouped and sorted by rating)

**Grading notes:**
- Basic statistics should be displayed using `describe()`
- Groupby operation should be applied correctly
- Results should be sorted by rating index
- Output should be formatted with appropriate label

### Section: Challenge - Scrape Multiple Pages

**Expected code execution:** 
Students will implement their own solution to scrape multiple pages. A correct implementation should:

```python
all_titles = []
all_prices = []
all_ratings = []

# Loop through multiple pages
for page_num in range(1, 4):  # Pages 1, 2, and 3
    # Construct the URL for each page
    if page_num == 1:
        page_url = 'http://books.toscrape.com/'
    else:
        page_url = f'http://books.toscrape.com/catalogue/page-{page_num}.html'

    # Add a small delay to be polite
    time.sleep(1)

    # Make the request
    response = requests.get(page_url, headers=headers)

    # Check if successful
    if response.status_code == 200:
        print(f"Successfully scraped page {page_num}")

        # Parse the page
        soup = BeautifulSoup(response.text, 'html.parser')

        # Find all book containers on the page
        book_containers = soup.find_all('article', class_='product_pod')
        
        # Extract book information
        for book in book_containers:
            # Extract title
            title = book.h3.a['title']
            all_titles.append(title)

            # Extract price
            price = book.find('p', class_='price_color').text
            all_prices.append(price)

            # Extract star rating
            star_rating = book.find('p', class_='star-rating')['class'][1]
            all_ratings.append(star_rating)
    else:
        print(f"Failed to scrape page {page_num}")

# Create a DataFrame with all the collected data
all_books_df = pd.DataFrame({
    'Title': all_titles,
    'Price': all_prices,
    'Rating': all_ratings
})

# Clean the data
all_books_df['Price'] = all_books_df['Price'].str.replace('Â£', '').astype(float)
all_books_df['Rating'] = all_books_df['Rating'].map(rating_mapping)

# Display the result
print(f"Total books collected: {len(all_books_df)}")
all_books_df.head()
```

**Expected output:**
- Success messages for each page scraped
- DataFrame with approximately 60 books (20 from each page)
- Clean data with proper types

**Grading notes:**
- URL construction should handle the first page differently (base URL vs. pagination)
- Ethical scraping practices should be implemented (delay between requests)
- For loop should iterate through all three pages
- All data should be properly extracted and combined
- Final DataFrame should be created and data should be cleaned

### Section: Saving the Scraped Data

**Expected code execution:**
```python
# Save the DataFrame to a CSV file
books_df.to_csv('scraped_books.csv', index=False)
print("Data saved to 'scraped_books.csv'")
```

**Expected output:**
- Confirmation message that the file was saved

**Grading notes:**
- `.to_csv()` method should be used correctly
- `index=False` should be specified to avoid saving row numbers
- Appropriate filename should be used
- Success message should be displayed

## Common Student Mistakes and Troubleshooting

1. **Connection/HTTP errors**:
   - Problem: Website may block requests or connection issues may occur
   - Solution: Check headers, URL, and internet connection; try alternative sites if needed

2. **HTML structure misinterpretation**:
   - Problem: Students may misunderstand the structure of the HTML and use incorrect selectors
   - Solution: Encourage students to inspect the page source or use browser DevTools to verify selectors

3. **Missing error handling**:
   - Problem: Students often don't include checks for request success or error handling
   - Solution: Emphasize the importance of checking status codes and using try/except blocks

4. **Exceeding rate limits**:
   - Problem: Too many rapid requests without delays
   - Solution: Reinforce the ethical approach with time.sleep() between requests

5. **Incorrect data cleaning**:
   - Problem: Price conversion failures or rating mapping issues
   - Solution: Guide students to check data types and string formatting before conversion

6. **Challenge implementation issues**:
   - Problem: Pagination URLs constructed incorrectly
   - Solution: Provide hint about the different URL structure for page 1 vs. subsequent pages

## Additional Guidance Notes

### Ethical Web Scraping Emphasis

When reviewing student submissions, pay special attention to whether they've implemented ethical scraping practices:
- Appropriate delays between requests
- Proper headers identifying the purpose
- Checking robots.txt (mentioned in the notes)
- Only scraping necessary data

### Extension Ideas for Advanced Students

For students who complete the assignment early or are looking for more challenge:
1. Extract more detailed information (book descriptions, categories, availability)
2. Implement more robust error handling and retry mechanisms
3. Create data visualizations of the scraped information
4. Compare data across different book categories
5. Build a simple command-line interface for the scraper

### Assessment Rubric

| Criterion | Excellent (A) | Satisfactory (B-C) | Needs Improvement (D-F) |
|-----------|---------------|--------------------|-----------------------|
| Code Functionality | All sections work correctly, challenge implemented properly | Minor issues in implementation, challenge attempted | Major functionality issues, challenge not attempted |
| Web Scraping Technique | Correctly uses BeautifulSoup selectors, extracts all data properly | Basic extraction works, but some selectors could be improved | Incorrect selectors, fails to extract required information |
| Data Processing | Clean data transformation, proper handling of types | Basic cleaning implemented with minor issues | Missing or incorrect data cleaning |
| Ethical Practices | Implements all ethical considerations (headers, delays, etc.) | Basic ethical practices with some omissions | No consideration of ethical scraping practices |
| Code Quality | Well-organized, commented, efficient code | Functional code with minor inefficiencies | Poorly structured, inefficient, or uncommented code |

## Website Stability Note

The example website (books.toscrape.com) is a demonstration site designed for scraping practice. However, websites can change their structure or go offline. If students encounter issues with the site, here are some alternatives:
- quotes.toscrape.com (quotes and authors)
- www.scrapethissite.com (designed for practice)
- wikipedia.org (for stable, scrapable content)

## Resource Links for Students

Additional resources to share with students who need more help:
- BeautifulSoup documentation: https://www.crummy.com/software/BeautifulSoup/bs4/doc/
- Web Scraping Ethics Guide: https://towardsdatascience.com/ethics-in-web-scraping-b96b18136f01
- Pandas Data Cleaning Tutorial: https://pandas.pydata.org/pandas-docs/stable/user_guide/text.html
- HTML/CSS Introduction: https://www.w3schools.com/html/
---
title: "Staff Answer Guide: Worksheet 2 - Advanced API Techniques and Authentication"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


This guide provides expected outcomes, common issues, and tips for supporting students as they work through Worksheet 2 on advanced API techniques and authentication with OpenWeatherMap.

## Key Concepts Review

- **HTTP Requests**: Messages sent to servers to retrieve or send data. Students will use the `requests` library to make these directly.
- **JSON**: A standard data format used by most modern APIs that provides structured data.
- **API Keys**: Unique identifiers used to authenticate requests to an API, controlling access and usage limits.
- **Environment Variables**: A secure method for storing sensitive information like API keys.
- **Status Codes**: Numeric codes that indicate the result of an HTTP request (e.g., 200 for success, 404 for not found).

## Activity 1: Direct API Requests to wttr.in

### Expected Code Output Examples

Basic direct request:
```python
import requests

def get_weather_direct(location):
    url = f'https://wttr.in/{location}?format=3'
    response = requests.get(url)
    
    if response.status_code == 200:
        return response.text
    else:
        return f"Failed to fetch data: Status code {response.status_code}"

# Test output for London might look like:
# "London: â›…ï¸  +15Â°C"
```

JSON format request:
```python
def get_weather_json(location):
    url = f'https://wttr.in/{location}?format=j1'
    response = requests.get(url)
    
    if response.status_code == 200:
        weather_data = response.json()
        
        if 'current_condition' in weather_data and weather_data['current_condition']:
            current = weather_data['current_condition'][0]
            current_temp = current['temp_C']
            weather_desc = current['weatherDesc'][0]['value']
            humidity = current['humidity']
            
            print(f"Weather in {location}:")
            print(f"Temperature: {current_temp}Â°C")
            print(f"Conditions: {weather_desc}")
            print(f"Humidity: {humidity}%")
            
            return weather_data
        else:
            print("Weather data has an unexpected format.")
            return None
    else:
        print(f"Failed to fetch data: Status code {response.status_code}")
        return None

# Expected terminal output for Paris:
# Weather in Paris:
# Temperature: 14Â°C
# Conditions: Partly cloudy
# Humidity: 76%
```

Error checking implementation:
```python
def get_weather_with_error_checking(location):
    url = f'https://wttr.in/{location}?format=j1'
    
    headers = {
        'User-Agent': 'Learning Python Weather App'
    }
    
    try:
        response = requests.get(url, headers=headers, timeout=5)
        
        if response.status_code == 200:
            try:
                weather_data = response.json()
                
                if 'current_condition' in weather_data and weather_data['current_condition']:
                    return weather_data
                else:
                    return "Error: Weather data has an unexpected format."
            except ValueError:
                return "Error: Could not parse JSON response."
        else:
            return f"Error: Failed to fetch data. Status code {response.status_code}"
    except requests.exceptions.RequestException as e:
        return f"Error: Request failed. {str(e)}"

# Expected output for invalid location:
# "Error: Failed to fetch data. Status code 404"
```

### Common Issues
- **Network errors**: Students may encounter connection issues or timeouts.
- **JSON parsing**: Students might struggle with understanding nested JSON structure.
- **HTTP status codes**: Students may be unfamiliar with common status codes and their meanings.
- **Missing User-Agent header**: Some students might not add a User-Agent header, which can lead to rate limiting.

### Support Tips
- Emphasize the importance of checking `response.status_code` before trying to access response data.
- Recommend using `response.json()` for JSON responses instead of manual parsing.
- Suggest adding timeout parameters to prevent hanging on slow connections.
- Encourage exploring the response data structure with `print(json.dumps(data, indent=2))` for better visualization.
- Explain the purpose of headers, especially User-Agent, in making more professional API requests.

## Activity 2: Compare Package vs. Direct Requests

### Sample Performance Comparison Results
```
Time with fetch-my-weather: 0.7823 seconds
Time with direct requests: 0.6145 seconds

Comparison of approaches:
1. fetch-my-weather advantages:
   - Easier to use with simpler function calls
   - Built-in error handling (no exceptions)
   - Includes automatic caching to reduce API calls
   - Provides consistent output format

2. Direct requests advantages:
   - More control over the exact request parameters
   - Access to raw response data
   - Better understanding of the underlying process
   - No additional dependencies beyond requests
```

### Important Discussion Points
- The performance difference might vary depending on network conditions and whether caching is active.
- Trade-offs between ease-of-use (package) and flexibility/control (direct).
- The value of understanding what happens "under the hood," even when using convenience packages.

## Activity 3: Understanding API Authentication

### Key Teaching Points
- API keys should never be hardcoded in source code.
- API keys should never be committed to version control systems like Git.
- Environment variables provide a secure way to store and access sensitive information.
- The `.env` file should always be added to `.gitignore`.

### Sample `.env` File
```
OPENWEATHERMAP_API_KEY=a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
```

### Sample `.gitignore` File
```
# Environment variables
.env
.env.*

# Python
__pycache__/
*.py[cod]
*$py.class
```

## Activity 4: Using OpenWeatherMap API with Authentication

### Expected Implementation

```python
import os
import requests
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Get API key from environment variable
api_key = os.environ.get("OPENWEATHERMAP_API_KEY")

if not api_key:
    print("Error: No API key found. Please set the OPENWEATHERMAP_API_KEY environment variable.")
    exit(1)

def get_weather_openweathermap(city):
    # API endpoint for current weather
    url = f"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric"
    
    try:
        # Make the request
        response = requests.get(url, timeout=5)
        
        # Check if the request was successful
        if response.status_code == 200:
            # Parse the JSON response
            data = response.json()
            
            # Extract relevant weather information
            temp = data['main']['temp']
            weather_desc = data['weather'][0]['description']
            humidity = data['main']['humidity']
            wind_speed = data['wind']['speed']
            
            print(f"Weather in {city}:")
            print(f"Temperature: {temp}Â°C")
            print(f"Conditions: {weather_desc}")
            print(f"Humidity: {humidity}%")
            print(f"Wind Speed: {wind_speed} m/s")
            
            return data
        else:
            print(f"Failed to fetch data: Status code {response.status_code}")
            if response.status_code == 401:
                print("This might be due to an invalid API key.")
            elif response.status_code == 404:
                print(f"City '{city}' not found.")
            return None
    except requests.exceptions.RequestException as e:
        print(f"Request error: {str(e)}")
        return None

# Sample output for London:
# Weather in London:
# Temperature: 12.5Â°C
# Conditions: light rain
# Humidity: 82%
# Wind Speed: 4.12 m/s
```

### Common Issues
- **API key setup**: Students may struggle with creating and loading the `.env` file correctly.
- **OpenWeatherMap account creation**: Some students may have difficulties signing up or finding their API key.
- **API rate limits**: Students might hit rate limits if making too many requests.
- **Data structure differences**: OpenWeatherMap's JSON structure differs from wttr.in, causing confusion.

### Support Tips
- Provide step-by-step instructions for signing up for OpenWeatherMap and locating the API key.
- Emphasize the need to install the `python-dotenv` package (`pip install python-dotenv`).
- Help students understand the OpenWeatherMap response structure by printing it with `json.dumps(data, indent=2)`.
- Clarify common status codes they might encounter (401 for authentication issues, 404 for city not found).
- Remind students that free OpenWeatherMap accounts have rate limits (60 calls/minute).

## Extension Activities Guidance

### Extension 1: Weather Forecast with OpenWeatherMap

Key features to look for:
- Using the 5-day forecast endpoint (`/forecast`)
- Organizing forecast data by day or time periods
- Providing meaningful summary of forecast trends

Example implementation outline:
```python
def get_forecast_openweathermap(city):
    # 5-day forecast endpoint (returns forecast in 3-hour increments)
    url = f"https://api.openweathermap.org/data/2.5/forecast?q={city}&appid={api_key}&units=metric"
    
    # Make request and check status
    response = requests.get(url)
    if response.status_code != 200:
        return f"Error: {response.status_code}"
    
    data = response.json()
    
    # Group forecast data by day
    forecasts_by_day = {}
    for forecast in data['list']:
        # Extract date from timestamp (format: "2025-04-14")
        date = forecast['dt_txt'].split(' ')[0]
        
        if date not in forecasts_by_day:
            forecasts_by_day[date] = []
        
        forecasts_by_day[date].append(forecast)
    
    # Display forecast by day
    for date, forecasts in forecasts_by_day.items():
        print(f"\nForecast for {date}:")
        
        # Calculate daily averages
        temps = [f['main']['temp'] for f in forecasts]
        avg_temp = sum(temps) / len(temps)
        
        # Get most common weather condition
        conditions = [f['weather'][0]['description'] for f in forecasts]
        # (Implementation of finding most common condition)
        
        print(f"  Average temperature: {avg_temp:.1f}Â°C")
        print(f"  Conditions: {most_common_condition}")
```

### Extension 2: Compare Data from Multiple Weather APIs

Implementation considerations:
- Creating a function that calls both APIs for the same location
- Highlighting differences in temperature, conditions, and other data points
- Calculating and displaying the variance between services

Example structure:
```python
def compare_weather_apis(city):
    # Get data from wttr.in
    wttr_data = get_weather_json(city)
    
    # Get data from OpenWeatherMap
    openweather_data = get_weather_openweathermap(city)
    
    if wttr_data and openweather_data:
        # Extract key metrics for comparison
        wttr_temp = float(wttr_data['current_condition'][0]['temp_C'])
        ow_temp = openweather_data['main']['temp']
        
        wttr_cond = wttr_data['current_condition'][0]['weatherDesc'][0]['value']
        ow_cond = openweather_data['weather'][0]['description']
        
        # Compare and display differences
        print(f"\nAPI Comparison for {city}:")
        print(f"Temperature:")
        print(f"  wttr.in: {wttr_temp}Â°C")
        print(f"  OpenWeatherMap: {ow_temp}Â°C")
        print(f"  Difference: {abs(wttr_temp - ow_temp):.1f}Â°C")
        
        print(f"Weather Condition:")
        print(f"  wttr.in: {wttr_cond}")
        print(f"  OpenWeatherMap: {ow_cond}")
```

### Extension 3: Create a Weather Dashboard with Data from OpenWeatherMap

Key elements to include:
- Multi-city data display
- Meaningful organization of weather information
- Visual elements (even simple ASCII art or formatting)
- Interactive components (e.g., user can refresh data)

Example dashboard structure:
```python
def create_openweather_dashboard(cities):
    # Display header
    print("\n" + "="*60)
    print(f"OPENWEATHERMAP DASHBOARD - {datetime.now().strftime('%Y-%m-%d %H:%M')}")
    print("="*60)
    
    # Track temperature extremes
    warmest_city = {"name": "", "temp": -100}
    coldest_city = {"name": "", "temp": 100}
    
    # Get and display data for each city
    for city in cities:
        data = get_weather_openweathermap(city)
        
        if data:
            # Extract and format key information
            temp = data['main']['temp']
            feels_like = data['main']['feels_like']
            humidity = data['main']['humidity']
            wind_speed = data['wind']['speed']
            condition = data['weather'][0]['description']
            
            # Update temperature extremes
            if temp > warmest_city["temp"]:
                warmest_city = {"name": city, "temp": temp}
            if temp < coldest_city["temp"]:
                coldest_city = {"name": city, "temp": temp}
            
            # Display city weather with formatting
            print(f"\n{city.upper()}")
            print(f"  Temperature: {temp}Â°C (Feels like: {feels_like}Â°C)")
            print(f"  Conditions: {condition}")
            print(f"  Humidity: {humidity}%")
            print(f"  Wind: {wind_speed} m/s")
    
    # Display temperature extremes
    print("\n" + "-"*60)
    print(f"Warmest city: {warmest_city['name']} ({warmest_city['temp']}Â°C)")
    print(f"Coldest city: {coldest_city['name']} ({coldest_city['temp']}Â°C)")
```

## Reflection Questions - Sample Responses

### Challenges of direct API work:
*Sample response:* "Working directly with APIs required more detailed understanding of HTTP requests, response handling, and JSON parsing. Error handling became more complex as I needed to account for network errors, invalid responses, and unexpected data structures."

### Comparison of API data structures:
*Sample response:* "The wttr.in API returns more detailed forecast data by default and has a different JSON structure than OpenWeatherMap. OpenWeatherMap separates current weather and forecast into different endpoints, while wttr.in includes both in a single response. OpenWeatherMap's response structure is somewhat simpler but may require more API calls to get the same information."

### Thoughts on API security practices:
*Sample response:* "Securing API keys is crucial to prevent unauthorized usage that could result in rate limiting, billing charges, or data breaches. Using environment variables and .env files provides a good balance of security and convenience, keeping sensitive information out of the codebase while still making it accessible to the application."

### Advantages of different approaches:
*Sample response:* "The package approach is ideal for beginners or when rapid development is needed, as it abstracts away complexity. The direct API approach provides more flexibility, control, and understanding of what's happening behind the scenes. For production applications, direct API requests with proper error handling and customization would be preferable, while for quick prototypes or educational purposes, a package might be more suitable."

## Additional Teaching Tips

1. **API Documentation Exploration**: Encourage students to read the OpenWeatherMap API documentation to discover additional endpoints and parameters they could use.

2. **Status Code Reference**: Provide a quick reference of common HTTP status codes (200, 400, 401, 403, 404, 429, 500) and what they indicate.

3. **JSON Visualization**: Recommend tools like [JSON Formatter & Validator](https://jsonformatter.curiousconcept.com/) for better visualization of API responses.

4. **API Testing Tools**: Introduce students to API testing tools like Postman or Insomnia for exploring APIs before coding.

5. **Rate Limiting Discussion**: Explain rate limiting concepts and how to implement backoff strategies for handling rate limits.

6. **Error Handling Progression**: Show the progression from basic status code checking to more robust try/except patterns for handling various error scenarios.

7. **Security Considerations**: Discuss real-world implications of API key leaks and show examples of automated bots that scan GitHub for exposed API keys.

8. **Advanced Authentication Methods**: For interested students, introduce the concept of OAuth and other more complex authentication methods used by APIs.
---
title: "Staff Answer Guide: Extracting Web Tables with Pandas"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

## Overview

This guide provides instructors with expected answers, common student challenges, and grading guidance for the notebook "Extracting Web Tables with Pandas: A Simple Introduction." The notebook teaches students how to use pandas to extract and analyze tabular data from websites.

## Learning Objectives Assessment

Students should demonstrate the ability to:
1. Use `pd.read_html()` to extract HTML tables from web pages
2. Process and clean the extracted data appropriately
3. Perform basic data analysis on the extracted tables
4. Export the cleaned data to a CSV file

## Expected Code Outputs & Solutions

### Section: Using pandas.read_html()

**Expected code execution:**
```python
# URL of a Wikipedia page with tables
url = 'https://en.wikipedia.org/wiki/List_of_countries_by_population_(United_Nations)'

# Extract all tables from the web page
tables = pd.read_html(url)

# Check how many tables were found
print(f"Number of tables found on the page: {len(tables)}")
```

**Expected output:** The number of tables will vary based on the current Wikipedia page structure, but typically between 2-4 tables will be found.

**Grading notes:** 
- Students should correctly import pandas and use the `read_html()` function
- The URL should be properly formatted and enclosed in quotes
- They should store the result in a variable and check the number of tables found

### Section: Exploring the Extracted Tables

**Expected code execution:**
```python
# Let's look at the first table (index 0)
first_table = tables[0]

# Show the first few rows
first_table.head()
```

**Expected output:** A DataFrame display showing the first 5 rows of the first table from the Wikipedia page.

**Grading notes:**
- Students should correctly access the first element of the tables list
- They should use the `.head()` method to preview the data

### Section: Selecting the Right Table

**Expected code execution:**
```python
# Loop through all tables and print their shape (rows x columns)
for i, table in enumerate(tables):
    print(f"Table {i}: Shape = {table.shape} (rows Ã— columns)")
    # Optional: display a small preview of each table
    print(f"Preview of columns: {table.columns.tolist()[:3]}...")
    print("-" * 50)
```

**Expected output:** For each table, information about its dimensions and a preview of column names.

**Grading notes:**
- Students should use enumeration to loop through the tables list
- They should correctly print the shape of each table
- Bonus points if they include additional information like column previews

### Section: Cleaning the Data

**Expected code execution:**
```python
# Make a copy to avoid changing the original
df = population_table.copy()

# Convert population to numeric (removing commas and other characters)
population_column = 'Population'  # Column name might vary
if population_column in df.columns:
    df[population_column] = df[population_column].astype(str).str.replace(',', '').str.extract('(\\d+)').astype(float)

# Show the cleaned table
df.head()
```

**Expected output:** A clean DataFrame with the population column converted to numeric values.

**Grading notes:**
- Students should create a copy of the DataFrame before modifying it
- They should correctly identify and clean the population column
- The cleaning should involve removing commas and converting to numeric data type
- They should handle the case where the expected column might not exist

### Section: Analyzing the Data

**Expected code execution:**
```python
# Get basic statistics
df.describe()

# Find the top 10 countries by population
top_10 = df.head(10)
print("Top 10 countries by population:")
top_10
```

**Expected output:** 
1. Statistical summary of the numeric columns
2. A DataFrame showing the top 10 countries by population

**Grading notes:**
- Students should use the `.describe()` method to generate summary statistics
- They should correctly extract the top 10 countries
- Note: If the table was already sorted by population, using `.head(10)` is sufficient; otherwise students should sort the data first

### Section: Saving the Results

**Expected code execution:**
```python
# Save the DataFrame to a CSV file
df.to_csv('country_populations.csv', index=False)
print("Data saved to 'country_populations.csv'")
```

**Expected output:** A confirmation message that the file was saved.

**Grading notes:**
- Students should use the `.to_csv()` method with the correct filename
- They should set `index=False` to avoid saving the DataFrame index
- No actual file will be created in most online notebook environments, so focus on correct syntax

## Challenge Section Assessment

For the challenge to extract a different table, assess:

1. **Table Selection:** Did the student choose an appropriate Wikipedia page with tabular data?
2. **Extraction Code:** Did they correctly implement `pd.read_html()`?
3. **Processing:** Did they identify and select the correct table from those extracted?
4. **Analysis:** Did they perform any meaningful analysis on the extracted data?

## Common Student Mistakes and Troubleshooting

1. **HTTP errors**: Students may encounter connection issues when accessing URLs
   - Suggestion: Verify the URL is accessible and correctly formatted

2. **Incorrect table indexing**: Students may select the wrong table from the extracted list
   - Suggestion: Emphasize the importance of exploring all tables before selecting one

3. **Data type conversion issues**: Problems with cleaning string-formatted numbers
   - Suggestion: Show examples of step-by-step conversion and error handling

4. **Column naming/access issues**: Wikipedia tables may have multi-level column headers
   - Suggestion: Demonstrate how to flatten or rename complex column structures

5. **Empty tables**: Some webpages may block automated scraping
   - Suggestion: Provide alternative URLs that are known to work with `read_html()`

## Additional Guidance Notes

### Ethical Considerations

Remind students about web scraping ethics:
- Check website's terms of service and robots.txt
- Implement reasonable request rates to avoid overloading servers
- Use data responsibly and cite sources

### Advanced Extensions

For students who finish early:
1. Suggest they try extracting tables from non-Wikipedia sources
2. Encourage them to create visualizations of the extracted data
3. Challenge them to automate the extraction of multiple tables from different pages

### Assessment Rubric

| Criterion | Excellent (A) | Satisfactory (B-C) | Needs Improvement (D-F) |
|-----------|---------------|--------------------|-----------------------|
| Table Extraction | Correctly extracts tables and selects appropriate ones | Extracts tables but may select wrong one | Unable to extract tables |
| Data Cleaning | Thoroughly cleans data, handles edge cases | Basic cleaning but misses some issues | Little/no data cleaning |
| Analysis | Performs meaningful analysis with insights | Basic analysis without deeper insights | Minimal or incorrect analysis |
| Code Quality | Well-organized, commented, efficient code | Functional code with minor inefficiencies | Poorly structured code with errors |
| Documentation | Clear explanation of process and findings | Basic documentation of steps | Little/no documentation |

## Support Resources for Students

Recommend these resources for students who need additional help:
- Pandas documentation on `read_html()`: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_html.html
- Data cleaning tutorials with pandas
- Web scraping ethics guidelines
---
title: "Staff Answer Guide: Worksheet 1 - Introduction to APIs with fetch-my-weather"
author: "Michael Borck"
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---



This guide provides expected outcomes, common issues, and tips for supporting students as they work through Worksheet 1 on API basics with the fetch-my-weather package.

## Key Concepts Review

- **API (Application Programming Interface)**: A set of rules allowing different software applications to communicate with each other. In this worksheet, students use a simplified API to access weather data.
- **fetch-my-weather**: A beginner-friendly Python package that wraps around the wttr.in weather service, providing simplified access to weather data.
- **Pseudocode**: A method for planning code logic without worrying about exact syntax, helping students organize their thoughts before implementation.

## Activity 1: Teaching an LLM About fetch-my-weather

### Expected Outcomes
- Students should successfully upload the documentation to an LLM and receive a coherent summary of the package.
- A good LLM response will cover:
  - Main functionality (weather data retrieval)
  - Key features (caching, error handling, different formats)
  - Basic usage examples

### Common Issues
- **Document upload problems**: Some students may have difficulty uploading documents to LLMs, especially if using free tiers with limited upload capabilities.
- **Poorly formulated prompts**: Students might not get useful responses if their prompts are too vague.

### Support Tips
- Encourage students to be specific in their prompts, asking about particular aspects of the package they're confused about.
- If upload isn't working, suggest they copy key parts of the documentation directly into their prompt.
- Remind students that they can iterate on prompts to get more precise information.

## Activity 2: Using the fetch-my-weather Package

### Expected Code Output Examples

Basic weather retrieval:
```python
import fetch_my_weather

# Get weather for London
london_weather = fetch_my_weather.get_weather(location="London")
print(london_weather)

# Expected output: A WeatherResponse Pydantic model containing weather data for London
```

Compact view:
```python
# Get weather with compact view
compact_weather = fetch_my_weather.get_weather(location="Paris", view_options="1")
print(compact_weather)

# Expected output: A more condensed weather report with fewer forecast days
```

Language options:
```python
# Get weather in Spanish
spanish_weather = fetch_my_weather.get_weather(location="Madrid", lang="es")
print(spanish_weather)

# Expected output: Weather data with text elements in Spanish
```

Moon phase:
```python
# Get moon phase information
moon_phase = fetch_my_weather.get_weather(is_moon=True)
print(moon_phase)

# Expected output: Current moon phase information
```

Error handling example:
```python
# Trying invalid location
result = fetch_my_weather.get_weather(location="NonExistentPlace12345")

# Check for error
if isinstance(result, str) and result.startswith("Error:"):
    print(f"Something went wrong: {result}")
else:
    print("Weather data retrieved successfully")

# Expected output: "Something went wrong: Error: [error message]"
```

### Common Issues
- **Installation problems**: Students may encounter pip installation issues, especially if they have Python environment conflicts.
- **String vs object confusion**: Students might be confused by the return type (Pydantic model by default, string if format="text").
- **Error handling misunderstanding**: Students might expect exceptions rather than error strings.

### Support Tips
- For installation issues, check Python version compatibility and suggest using a virtual environment.
- Explain that `get_weather()` returns different types based on the `format` parameter (default is a Pydantic model).
- Emphasize the beginner-friendly error handling that returns strings instead of raising exceptions.
- Encourage students to explore the structure of the returned data using `print()` and `dir()`.

## Activity 3: Create a Weather Dashboard

### Pseudocode Guidance
Good pseudocode should:
- Be clear and concise
- Show the logical flow of the program
- Handle potential errors
- Include necessary loops and conditions

### Working Implementation Example

```python
import fetch_my_weather
from datetime import datetime

def create_weather_dashboard(city_list):
    # Initialize empty list for storing weather data
    city_weather_data = []
    
    # Get weather data for each city
    for city in city_list:
        weather = fetch_my_weather.get_weather(location=city, format="text")
        
        # Check if we got valid weather data
        if isinstance(weather, str) and not weather.startswith("Error:"):
            city_weather_data.append({"city": city, "weather": weather})
        else:
            print(f"Could not get weather for {city}: {weather}")
    
    # Display the dashboard header
    print("\n" + "="*50)
    print(f"WEATHER DASHBOARD - {datetime.now().strftime('%Y-%m-%d %H:%M')}")
    print("="*50)
    
    # Display weather for each city
    for city_data in city_weather_data:
        print(f"\n{city_data['city'].upper()}")
        print(city_data['weather'])
        print("-"*50)

# Get cities from user
def main():
    print("Welcome to the Weather Dashboard!")
    city_input = input("Enter cities to check (comma-separated): ")
    cities = [city.strip() for city in city_input.split(",")]
    
    # Create the dashboard
    create_weather_dashboard(cities)

if __name__ == "__main__":
    main()
```

### Common Issues
- **Format confusion**: Students might mix JSON and text formats, causing display issues.
- **Error handling**: Students may not properly check for error messages.
- **Input validation**: Poor handling of user input (empty strings, special characters).
- **Parsing text output**: If not using `format="text"`, students might struggle to display the weather data nicely.

### Support Tips
- Suggest using `format="text"` for easy display in a simple dashboard.
- Remind students to check if the result is an error message using `isinstance()` and `startswith()`.
- Encourage good input validation (removing extra spaces, handling empty input).
- For advanced students, suggest using JSON format and accessing specific weather properties.

## Extension Activities Guidance

### Enhanced Weather Dashboard

Key features to look for:
- Color coding (using ANSI color codes or a package like `colorama`)
- Comparison functionality to identify warmest/coldest cities
- Interactive elements (user choice of view options)

Example implementation highlights:
```python
# Color coding example
from colorama import Fore, Style

# Function to get color based on temperature
def get_temp_color(temp):
    if temp < 0:
        return Fore.BLUE
    elif temp < 10:
        return Fore.CYAN
    elif temp < 20:
        return Fore.GREEN
    elif temp < 30:
        return Fore.YELLOW
    else:
        return Fore.RED

# Extract temperature and add color
current_temp = int(current['temp_C'])
colored_temp = f"{get_temp_color(current_temp)}{current_temp}Â°C{Style.RESET_ALL}"
```

### Weather-Based Recommendations

Example implementation approach:
```python
def suggest_activities(weather_data):
    # Extract current conditions
    current = weather_data.current_condition[0]
    temp = float(current.temp_C)
    weather_desc = current.weatherDesc[0].value.lower()
    
    # Outdoor activities
    if temp > 20 and "sun" in weather_desc:
        print("Perfect day for a picnic or hiking!")
    elif "rain" in weather_desc or "shower" in weather_desc:
        print("Indoor day! How about visiting a museum or watching a movie?")
    elif temp < 5:
        print("Very cold today. Stay warm with some indoor activities.")
    # More conditions...
```

## Reflection Questions - Sample Responses

### How did fetch-my-weather make it easier to work with weather data?
*Sample response:* "The fetch-my-weather package simplified access to weather data by handling the complexities of API requests, error handling, and data formatting. It allows beginners to focus on using the data rather than worrying about HTTP requests, status codes, and JSON parsing."

### Value of pseudocode planning:
*Sample response:* "Pseudocode planning helped organize the logical flow of the program before implementation, making the actual coding process smoother. It forced me to think through the necessary steps and potential issues before encountering them in code."

### Learning with LLM assistance:
*Sample response:* "The LLM helped explain complex concepts in simpler terms and provided targeted examples for specific questions. It was particularly helpful in explaining the structure of the returned weather data and suggesting ways to handle different formats."

### Future API interests:
*Sample response:* "After working with weather data, I'm interested in exploring APIs for news, financial data, or social media. I'd also like to learn about APIs that require authentication to access more personalized or restricted data."

## Additional Teaching Tips

1. **Vocabulary Building**: Help students become comfortable with API terminology by consistently using terms like "endpoint," "request," "response," and "parameters."

2. **Visual Explanations**: Use diagrams to show how data flows from the API to their program. A simple flowchart can help visual learners understand the process.

3. **Real-World Connections**: Discuss how APIs are used in mobile apps, websites, and other software students use daily.

4. **Debugging Strategy**: Teach the strategy of printing intermediate results to understand what data is being returned at each step.

5. **Promote Exploration**: Encourage students to experiment with different parameters and locations to see how the output changes.

6. **Error Message Analysis**: Help students understand how to interpret error messages and use them to debug their code.
---
title: "Worksheet 1: Introduction to APIs with fetch-my-weather"
subtitle: Learning API Basics with a Beginner-Friendly Package
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

## Learning Objectives
By the end of this worksheet, you will be able to:
- Understand what APIs are and how they provide access to data
- Use the fetch-my-weather package to retrieve weather information
- Work with an LLM to learn a new Python package
- Create a simple weather dashboard using API data
- Understand the basics of pseudocode and program planning

## Introduction
Web APIs are a foundational element of modern applications, providing a pathway to access data programmatically. In this activity, you'll learn how to fetch and display weather data using a beginner-friendly package called fetch-my-weather.

This first worksheet focuses on the basics of working with APIs through a simplified interface. In a later worksheet, we'll explore more advanced API concepts like authentication and direct API requests.

## Key Concepts
- **API (Application Programming Interface):** A set of rules that allows one piece of software to interact with another.
- **Weather API:** A service that provides weather data through an API.
- **Python Package:** A collection of modules that simplifies certain tasks.
- **LLM (Large Language Model):** AI systems like ChatGPT or Claude that can help explain concepts and assist with coding.

## Using AI Tools Ethically & Effectively
**Transparency:** Always state the use of AI in your work, detailing how and when you used it.

**Critical Evaluation:** AI outputs need to be critically assessed. They are not always correct and may require contextual adjustments.

**Learning Partner:** Utilise AI to deepen your understanding. For instance, you can ask, "Explain the JSON data structure in simple terms" or "Provide an example of how an API might send data."

## Activities

### Activity 1: Teaching an LLM About fetch-my-weather

First, we'll teach an LLM about the package we'll be using, which is a powerful technique for working with new libraries.

**Step 1:** Choose your preferred LLM (Claude, ChatGPT, etc.) and start a new conversation.

**Step 2:** Upload the fetch-my-weather documentation guide to the LLM.

**Step 3:** Ask the LLM to confirm it understands the package by asking it to summarize the key features.

**Example prompt:**
```
I've just shared documentation about the fetch-my-weather package. Could you:
1. Summarize the key features of this package
2. Explain how error handling works in this package
3. Provide a simple example of how to get weather for London
```

### Activity 2: Using the fetch-my-weather Package

Now let's use the package to fetch some weather data!

**Step 1:** Install the fetch-my-weather package.

```python
# Install the package (uncomment and run this once)
# !pip install fetch-my-weather
```

**Step 2:** Get weather for a specific location.

```python
import fetch_my_weather

# Get weather for London
london_weather = fetch_my_weather.get_weather(location="London")
print(london_weather)
```

**Step 3:** Explore different options and parameters.

```python
# Get weather with compact view (fewer forecast days)
compact_weather = fetch_my_weather.get_weather(location="Paris", view_options="1")
print(compact_weather)

# Get weather in a different language
spanish_weather = fetch_my_weather.get_weather(location="Madrid", lang="es")
print(spanish_weather)

# Get moon phase information
moon_phase = fetch_my_weather.get_weather(is_moon=True)
print(moon_phase)
```

**Step 4:** Check for errors without exception handling.

```python
# Try getting weather for an invalid location
result = fetch_my_weather.get_weather(location="NonExistentPlace12345")

# fetch-my-weather returns error messages as strings instead of raising exceptions
if isinstance(result, str) and result.startswith("Error:"):
    print(f"Something went wrong: {result}")
else:
    print("Weather data retrieved successfully")
```

### Activity 3: Create a Weather Dashboard

Let's create a simple weather dashboard for displaying information about multiple cities.

**Step 1:** First, plan your dashboard using pseudocode. Pseudocode is a way to plan your code without worrying about exact syntax.

```
PSEUDOCODE FOR WEATHER DASHBOARD:

FUNCTION CreateWeatherDashboard:
    Initialize empty list called CityWeatherData
    
    FOR EACH city in CityList:
        Request weather data for city
        IF weather data retrieval successful THEN
            Add weather data to CityWeatherData list
        ELSE
            Display error message for this city
        END IF
    END FOR
    
    Display header "WEATHER DASHBOARD"
    Display current date and time
    
    FOR EACH city in CityWeatherData:
        Display city name and weather information
        Add separator line
    END FOR
END FUNCTION

FUNCTION Main:
    Ask user for cities to check
    Call CreateWeatherDashboard
END FUNCTION
```

**Step 2:** Now implement the dashboard based on your pseudocode.

```python
import fetch_my_weather
from datetime import datetime

def create_weather_dashboard(city_list):
    # Initialize empty list for storing weather data
    city_weather_data = []
    
    # Get weather data for each city
    for city in city_list:
        weather = fetch_my_weather.get_weather(location=city, view_options="0")
        
        # Check if we got valid weather data
        if isinstance(weather, str) and not weather.startswith("Error:"):
            city_weather_data.append({"city": city, "weather": weather})
        else:
            print(f"Could not get weather for {city}")
    
    # Display the dashboard header
    print("\n" + "="*50)
    print(f"WEATHER DASHBOARD - {datetime.now().strftime('%Y-%m-%d %H:%M')}")
    print("="*50)
    
    # Display weather for each city
    for city_data in city_weather_data:
        print(f"\n{city_data['city'].upper()}")
        print(city_data['weather'])
        print("-"*50)

# Get cities from user
city_input = input("Enter cities to check (comma-separated): ")
cities = [city.strip() for city in city_input.split(",")]

# Create the dashboard
create_weather_dashboard(cities)
```

## ðŸ§  Intentional Prompting for Learning

If you're using an LLM to help with this worksheet, here are some tips for getting the most out of it:

### What Is Intentional Prompting?

**Intentional prompting** means you:
- Ask the AI to **explain** its reasoning, not just give solutions
- Ask questions that lead to deeper understanding of concepts
- Refine and adapt prompts when the first response isn't quite right
- Use the AI as a **thinking partner**, not just a code vending machine

### Examples of Good Prompts

**âœ… Good prompt:** 
"I'm learning about the fetch-my-weather package. Could you explain how the caching feature works and why it's useful?"

**âœ… Good prompt:** 
"I'm creating a weather dashboard using Python and the fetch-my-weather package. Could you help me understand how I might structure the code to display multiple cities and highlight the warmest one?"

### Your turn: Create an intentional prompt

Try writing your own intentional prompt to ask about something in this worksheet that you'd like to understand better.

*Your response:*
```
# Write your intentional prompt here
```

## Extension Activities

### Extension 1: Enhanced Weather Dashboard

Improve your weather dashboard to include more features:
- Add color coding for temperature ranges
- Display which city is warmest/coldest
- Allow the user to choose between different view options

```python
# Write your enhanced dashboard code here
```

### Extension 2: Weather-Based Recommendations

Create a simple program that recommends activities based on the weather:

```python
import fetch_my_weather

def suggest_activities(weather_data):
    # Add your recommendation logic here
    pass

# Get location from user
city = input("Enter your city: ")
weather = fetch_my_weather.get_weather(location=city)

# Get recommendations
suggest_activities(weather)
```

## Reflection
Consider how you might use what you've learned in your future projects:

- How did the fetch-my-weather package make it easier to work with weather data?
- What was the value of planning with pseudocode before writing the actual code?
- If you used an LLM, how did it help you understand the concepts better?
- What other types of APIs might you want to explore in the future?

*Your response:*
```markdown
# Your reflection here
- Experience with fetch-my-weather:
- Value of pseudocode planning:
- Learning with LLM assistance (if applicable):
- Future API interests:
```

This worksheet provides a gentle introduction to working with APIs through a beginner-friendly package. In the next worksheet, we'll explore making direct API requests and using authenticated APIs.
---
title: "Worksheet 2: Advanced API Techniques and Authentication"
subtitle: Direct API Requests and Working with API Keys
format: 
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

## Learning Objectives
By the end of this worksheet, you will be able to:
- Make direct HTTP requests to web APIs using the requests library
- Understand and parse JSON data from API responses
- Implement basic error checking for API calls
- Work with authenticated APIs using API keys
- Apply security best practices for handling API credentials

## Introduction
In Worksheet 1, we used the fetch-my-weather package to simplify accessing weather data. Now, we'll go "under the hood" to understand how APIs work directly. We'll also learn how to use APIs that require authentication with API keys, a common requirement for many professional services.

This worksheet builds on the foundational knowledge from Worksheet 1, taking you from using a simplified package to understanding the underlying mechanics of API requests.

## Key Concepts
- **HTTP Request:** A message sent to a server to retrieve or send data.
- **JSON (JavaScript Object Notation):** A standard data format used by most modern APIs.
- **API Key:** A unique identifier used to authenticate requests to an API.
- **Environment Variables:** A secure way to store sensitive information like API keys.
- **Status Codes:** Numeric codes that indicate the result of an HTTP request (e.g., 200 for success, 404 for not found).

## Activities

### Activity 1: Direct API Requests to wttr.in

First, let's see what happens "under the hood" by using the requests library to directly access the wttr.in API that fetch-my-weather is built on.

**Step 1:** Make a direct request to the wttr.in API.

```python
import requests

def get_weather_direct(location):
    # Construct the URL for the wttr.in API
    url = f'https://wttr.in/{location}?format=3'
    
    # Make the request
    response = requests.get(url)
    
    # Check if the request was successful using status code
    if response.status_code == 200:
        # Return the text content of the response
        return response.text
    else:
        return f"Failed to fetch data: Status code {response.status_code}"

# Test the function
city = "London"
weather = get_weather_direct(city)
print(weather)
```

**Step 2:** Access the JSON format for more structured data.

```python
import requests

def get_weather_json(location):
    # Request the weather data in JSON format
    url = f'https://wttr.in/{location}?format=j1'
    
    # Make the request
    response = requests.get(url)
    
    # Check if the request was successful
    if response.status_code == 200:
        # Parse the JSON response
        weather_data = response.json()
        
        # Check if the expected data is present
        if 'current_condition' in weather_data and weather_data['current_condition']:
            # Extract and display key information
            current = weather_data['current_condition'][0]
            current_temp = current['temp_C']
            weather_desc = current['weatherDesc'][0]['value']
            humidity = current['humidity']
            
            print(f"Weather in {location}:")
            print(f"Temperature: {current_temp}Â°C")
            print(f"Conditions: {weather_desc}")
            print(f"Humidity: {humidity}%")
            
            return weather_data
        else:
            print("Weather data has an unexpected format.")
            return None
    else:
        print(f"Failed to fetch data: Status code {response.status_code}")
        return None

# Test the function
city = "Paris"
weather_data = get_weather_json(city)
```

**Step 3:** Adding basic error checking.

```python
import requests

def get_weather_with_error_checking(location):
    # Construct the URL for the wttr.in API
    url = f'https://wttr.in/{location}?format=j1'
    
    # Add a user agent to be respectful to the API provider
    headers = {
        'User-Agent': 'Learning Python Weather App'
    }
    
    # Make the request with headers
    response = requests.get(url, headers=headers)
    
    # Check if the request was successful using status code
    if response.status_code == 200:
        # Try to parse the JSON response
        try:
            weather_data = response.json()
            
            # Check if the expected data is present
            if 'current_condition' in weather_data and weather_data['current_condition']:
                return weather_data
            else:
                return "Error: Weather data has an unexpected format."
        except ValueError:
            return "Error: Could not parse JSON response."
    else:
        return f"Error: Failed to fetch data. Status code {response.status_code}"

# Test with a valid location
valid_result = get_weather_with_error_checking("Tokyo")
if isinstance(valid_result, dict):
    print("Successfully retrieved weather data for Tokyo")
    
# Test with an invalid location
invalid_result = get_weather_with_error_checking("NonExistentPlace12345")
if isinstance(invalid_result, str) and invalid_result.startswith("Error:"):
    print(invalid_result)
```

::: {.callout-note}
**Looking Ahead:** In future modules, you'll learn about more advanced error handling using Python's try/except blocks. This approach allows for more robust handling of unexpected situations, including network errors, JSON parsing issues, and other exceptions that may occur. For advanced students interested in exploring this concept early, research "Python exception handling" and "try except blocks" to get a head start!
:::

### Activity 2: Compare Package vs. Direct Requests

Now that you've used both a third-party package (fetch-my-weather) and direct API requests, let's compare the two approaches:

```python
import time
import fetch_my_weather
import requests

def measure_performance():
    city = "London"
    
    # Measure time for fetch-my-weather
    start_time = time.time()
    fetch_my_weather.get_weather(location=city)
    package_time = time.time() - start_time
    
    # Measure time for direct request
    start_time = time.time()
    requests.get(f'https://wttr.in/{city}?format=j1')
    direct_request_time = time.time() - start_time
    
    print(f"Time with fetch-my-weather: {package_time:.4f} seconds")
    print(f"Time with direct requests: {direct_request_time:.4f} seconds")
    
    # Analyze the differences
    print("\nComparison of approaches:")
    print("1. fetch-my-weather advantages:")
    print("   - Easier to use with simpler function calls")
    print("   - Built-in error handling (no exceptions)")
    print("   - Includes automatic caching to reduce API calls")
    print("   - Provides consistent output format")
    
    print("\n2. Direct requests advantages:")
    print("   - More control over the exact request parameters")
    print("   - Access to raw response data")
    print("   - Better understanding of the underlying process")
    print("   - No additional dependencies beyond requests")

# Run the comparison
measure_performance()
```

### Activity 3: Understanding API Authentication

Many APIs require authentication to:
1. Identify who is making the request
2. Control access to data
3. Limit the number of requests (rate limiting)
4. Track usage for billing purposes

Let's learn about API keys and how to use them securely.

#### API Keys and Security Best Practices

API keys are sensitive credentials that should be protected:

- **Never hardcode API keys in your source code**
- **Never commit API keys to version control systems like Git**
- **Use environment variables** to store API keys
- Consider using dedicated secrets management tools for production systems

**Example of poor security practice:**
```python
# DON'T DO THIS
api_key = "1234567890abcdef"
response = requests.get(f"https://api.example.com/data?key={api_key}")
```

**Better approach:**
```python
# DO THIS INSTEAD
import os
from dotenv import load_dotenv

# Load API key from .env file (which is NOT committed to Git)
load_dotenv()
api_key = os.environ.get("WEATHER_API_KEY")

response = requests.get(f"https://api.example.com/data?key={api_key}")
```

#### Setting Up a `.env` File
1. Create a file named `.env` in your project directory
2. Add your API keys in the format: `VARIABLE_NAME=value`
3. Add `.env` to your `.gitignore` file to prevent it from being committed

**Example `.env` file:**
```
OPENWEATHERMAP_API_KEY=your_api_key_here
```

**Example `.gitignore` file:**
```
.env
__pycache__/
*.pyc
```

### Activity 4: Using OpenWeatherMap API with Authentication

Now let's apply what we've learned to access the OpenWeatherMap API, which requires an API key.

**Step 1:** Sign up for a free OpenWeatherMap API key:
1. Visit [OpenWeatherMap](https://openweathermap.org/api) and sign up for a free account
2. Retrieve your API key from your account dashboard

**Step 2:** Create a `.env` file to store your API key securely.

**Step 3:** Use the OpenWeatherMap API with your key:

```python
import os
import requests
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Get API key from environment variable
api_key = os.environ.get("OPENWEATHERMAP_API_KEY")

if not api_key:
    print("Error: No API key found. Please set the OPENWEATHERMAP_API_KEY environment variable.")
    exit(1)

def get_weather_openweathermap(city):
    # API endpoint for current weather
    url = f"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric"
    
    # Make the request
    response = requests.get(url)
    
    # Check if the request was successful
    if response.status_code == 200:
        # Parse the JSON response
        data = response.json()
        
        # Check if the expected data is present
        if 'main' in data and 'weather' in data and data['weather']:
            # Extract relevant weather information
            temp = data['main']['temp']
            weather_desc = data['weather'][0]['description']
            humidity = data['main']['humidity']
            wind_speed = data['wind']['speed']
            
            print(f"Weather in {city}:")
            print(f"Temperature: {temp}Â°C")
            print(f"Conditions: {weather_desc}")
            print(f"Humidity: {humidity}%")
            print(f"Wind Speed: {wind_speed} m/s")
            
            return data
        else:
            print("Weather data has an unexpected format.")
            return None
    else:
        print(f"Failed to fetch data: Status code {response.status_code}")
        if response.status_code == 401:
            print("This might be due to an invalid API key.")
        elif response.status_code == 404:
            print(f"City '{city}' not found.")
        return None

# Get city from user
city = input("Enter a city name: ")
weather_data = get_weather_openweathermap(city)
```

**Step 4:** Explore the API documentation to find other endpoints and parameters:
1. Look at the [OpenWeatherMap API documentation](https://openweathermap.org/api)
2. Find at least one other endpoint or parameter you can add to your request
3. Modify your code to use this new feature

## Extension Activities

### Extension 1: Weather Forecast with OpenWeatherMap

Extend your code to fetch a 5-day forecast instead of just the current weather.

```python
# Write your forecast code here using the OpenWeatherMap forecast endpoint
```

### Extension 2: Compare Data from Multiple Weather APIs

Create a script that compares weather data from both wttr.in and OpenWeatherMap for the same location.

```python
# Write your comparison code here
```

### Extension 3: Create a Weather Dashboard with Data from OpenWeatherMap

Build a more detailed weather dashboard that uses data from OpenWeatherMap.

```python
# Write your dashboard code here
```

## Reflection
Consider how the direct API approach differs from using a package:

- What challenges did you encounter when working directly with APIs?
- How does the OpenWeatherMap API differ from wttr.in in terms of data structure?
- Why is it important to secure API keys, and what methods did you learn to do this?
- What advantages does each approach (package vs. direct) offer for different situations?

*Your response:*
```markdown
# Your reflection here
- Challenges of direct API work:
- Comparison of API data structures:
- Thoughts on API security practices:
- Advantages of different approaches:
```

This worksheet has introduced you to more advanced API concepts, including direct requests and authentication. These skills form the foundation for working with a wide range of APIs in your future projects.
---
title: "Mastering Error Handling in Network Requests"
subtitle: "Ensuring Robust Applications through Effective Error Management"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction to Error Handling

* Understanding the importance of error handling in network requests
* Common types of errors encountered during network communication
* The impact of unhandled errors on applications

::: {.notes}
In this presentation, we will explore the fundamental concepts of error handling in network requests. Error handling is crucial for building robust applications that can gracefully manage unexpected issues during network communication, such as timeouts or loss of connectivity. We'll look at common types of errors and discuss the negative impacts of unhandled errors, which can range from minor user frustration to complete application failure. This knowledge is essential for ensuring application reliability and a smooth user experience.
:::

# Types of Network Errors

* Timeout errors
* Connection errors
* HTTP status codes (400 and 500 series errors)
* DNS lookup failures

::: {.notes}
There are several types of network errors that can occur when your application tries to communicate over the internet. Timeout errors happen when a request takes too long to get a response. Connection errors may occur if the network is down or unstable. HTTP errors are represented by status codes; for example, 404 for 'Not Found' or 500 for 'Internal Server Error'. DNS lookup failures take place when the domain name cannot be resolved to an IP address. Understanding these errors is the first step in handling them effectively.
:::

# Basic Principles of Error Handling

* Preventing errors before they occur
* Catching and managing errors when they occur
* Logging errors for further analysis
* Informing users appropriately

::: {.notes}
Effective error handling involves several key principles. Firstly, prevent errors where possible by using validations and checks before making a request. If an error does occur, catch it programmatically to prevent the application from crashing and manage the error gracefully. Logging errors is crucial for diagnosing issues and improving the system. Finally, ensure that users are informed with clear, concise, and helpful messages about what went wrong and possibly how to resolve it or that it is being handled.
:::

# Implementing Error Handling in Python

* Using try-except blocks
* Handling specific exceptions
* Creating custom exceptions for better control
* Utilising libraries like Requests for simplified error management

```python
import requests
try:
    response = requests.get('https://api.example.com/data')
    response.raise_for_status()
except requests.exceptions.HTTPError as errh:
    print(f'HTTP Error: {errh}')
except requests.exceptions.ConnectionError as errc:
    print(f'Connection Error: {errc}')
except requests.exceptions.Timeout as errt:
    print(f'Timeout Error: {errt}')
except requests.exceptions.RequestException as err:
    print(f'Error: {err}')
```

::: {.notes}
In Python, error handling is typically managed using try-except blocks. This allows you to catch specific exceptions and handle them accordingly. For example, using the Requests library, you can manage different types of errors such as HTTP errors, connection problems, or timeouts. This code example demonstrates how to handle these errors separately to provide more targeted responses. Creating custom exceptions can also provide further control and clarity in your error management strategy.
:::

# Best Practices in Error Reporting

* Keep error messages informative but non-technical
* Use logging to capture detailed error information
* Provide users with guidance on next steps if applicable

::: {.notes}
When an error occurs, how it is reported can significantly affect the user experience. It is important to keep error messages clear and helpful without exposing technical details that could confuse the user or expose security vulnerabilities. Logging should be used to capture detailed error information which helps in debugging and improving the application. Where possible, provide users with guidance or actions they can take to recover from the error.
:::

# Handling Errors in Web Applications

* Server-side vs client-side error handling
* Implementing retries and fallbacks
* Designing for fault tolerance

::: {.notes}
In web applications, error handling should be considered both on the server-side and the client-side. On the server-side, you might implement retries or use fallback servers. On the client-side, you can design the user interface to be fault-tolerant, possibly showing cached data if new data can't be retrieved. Implementing these strategies ensures that your application can handle errors gracefully and maintain a good user experience even under suboptimal conditions.
:::

# Workshop: Simulating and Handling Errors

* Step-by-step guide to simulating common network errors
* Applying learned strategies to handle these errors
* Interactive discussion on error handling techniques

::: {.notes}
During our workshop, we will simulate common network errors and apply the error handling strategies we've discussed. This hands-on approach helps in understanding how to implement these techniques in real-world scenarios. Participants will also have the opportunity to discuss and share their approaches to error handling, fostering a deeper understanding of best practices and innovative strategies.
:::

# Conclusion and Further Resources

* Recap of key points on error handling
* Importance of continuous learning and improvement in error management
* Additional resources for deeper learning

::: {.notes}
In conclusion, effective error handling is essential for developing robust applications. We've covered the types of errors you might encounter, basic principles for managing these errors, and specific techniques using Python. Remember, the landscape of network communication is ever-evolving, and continuous learning is key to staying ahead. For further reading, refer to the Python Requests Library Documentation and other resources provided in this course.
:::---
title: "Navigating JSON in Python: A Beginner's Guide"
subtitle: "Understanding and Utilising JSON for Web Data in Python"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


# Introduction to JSON and Python

* What is JSON and why is it important?
* Basics of JSON structure: Objects and Arrays
* How Python interacts with JSON

::: {.notes}
JSON, which stands for JavaScript Object Notation, is a lightweight data-interchange format that is easy for humans to read and write, and easy for machines to parse and generate. It is commonly used to transmit data between a server and web applications. Python provides built-in libraries for parsing JSON, allowing developers to easily manipulate data, which is crucial for tasks such as data analysis, web scraping, and API interactions. This slide introduces the fundamental aspects of JSON and its significance in web development and data exchange.
:::

# JSON Syntax Overview

* JSON Objects: Key-value pairs enclosed by curly braces
* JSON Arrays: Ordered list of values enclosed by square brackets
* Data types in JSON: string, number, object, array, boolean, null

::: {.notes}
JSON syntax closely resembles the way objects are built in JavaScript. However, it is language-independent and can be used with many programming languages, including Python. Understanding the syntax is the first step to mastering JSON usage in Python. This slide explains the different components of JSON, such as objects and arrays, and the types of data that JSON can hold. This foundational knowledge will help in parsing and generating JSON data effectively.
:::

# Working with JSON in Python

* Using the `json` module
* Reading JSON data with `json.load()` and `json.loads()`
* Writing JSON data with `json.dump()` and `json.dumps()`

::: {.notes}
Python's `json` module is a part of the standard library and provides a simple way to encode and decode JSON data. Specifically, `json.loads()` parses JSON from a string format, while `json.load()` parses JSON from a file. Conversely, `json.dumps()` converts Python objects into a JSON string, and `json.dump()` writes Python objects to a file in JSON format. This slide provides practical code examples to demonstrate how to use these functions, which will be critical for any tasks involving JSON data manipulation.
:::

# Practical Example: Parsing JSON from a Web API

* Fetching JSON data from an API using the `requests` library
* Parsing JSON data to Python objects
* Example: Accessing weather data from an online API

::: {.notes}
This slide shows a practical example of how to use Python to fetch and parse JSON data from a web APIâ€”an essential skill in many development tasks, especially in web and mobile applications. We use the `requests` library to send a request to a web API, which returns data in JSON format that we then parse into Python objects using the `json` module. This example will focus on fetching real-time weather data, aligning with our course project.
:::

# Handling JSON Data in Python Applications

* Common use cases: Config files, data storage, API interaction
* Tips for working efficiently with JSON in Python
* Security considerations when handling JSON data

::: {.notes}
JSON is widely used in various applications, from serving as configuration files in software applications to storing data in databases and interacting with web APIs. This slide discusses how to handle JSON data efficiently in Python, including best practices and security considerations, such as validating and sanitising JSON data to prevent security vulnerabilities like injection attacks.
:::

# Error Handling and Debugging

* Common JSON parsing errors in Python
* Using try-except blocks for robust error handling
* Debugging tips for working with JSON data

::: {.notes}
Error handling is crucial when working with external data formats like JSON. This slide covers common errors such as misformatted JSON strings and how to use Python's try-except blocks to handle these errors gracefully, ensuring the application remains robust and user-friendly. We'll also provide some debugging tips that can help beginners troubleshoot issues when working with JSON data.
:::

# Best Practices and Performance Tips

* Efficient parsing of large JSON files
* When to use `json.load()` vs. `json.loads()`
* Performance considerations: Memory usage and speed

::: {.notes}
As developers often deal with large volumes of data, understanding how to parse large JSON files efficiently is important. This slide provides best practices and performance tips, including choosing the right function for the task, considerations for memory usage, and techniques to enhance the speed of reading and writing JSON data. These tips are crucial for optimising performance in real-world Python applications.
:::

# Conclusion: Mastering JSON in Python

* Recap of key points: JSON structure, parsing, error handling
* Further learning resources and next steps
* Encouragement to explore and experiment with JSON in Python projects

::: {.notes}
In conclusion, we've covered the essential aspects of working with JSON in Python, from basic syntax and parsing methods to error handling and performance optimisation. Encouraging further exploration and experimentation, attendees are reminded to utilise the resources provided and to engage with the community for continued learning. This understanding is not only vital for personal development but also for contributing effectively to any future projects involving web data.
:::

# Questions and Discussion

* Open floor for questions
* Discussion on potential project ideas involving JSON
* Feedback on the presentation

::: {.notes}
This final slide provides an opportunity for interaction and feedback. It allows attendees to ask questions to clarify any doubts and discuss potential project ideas that involve using JSON. This interaction is crucial for reinforcing learning and encouraging practical application of the concepts covered in the presentation.
:::---
title: "Unlocking the Digital Universe: APIs and Web Scraping"
subtitle: "A Beginner's Guide to Accessing Online Data Efficiently"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


# Introduction to APIs and Web Scraping

* Understanding APIs and Web Scraping
* Importance in digital data retrieval
* Overview of today's session

::: {.notes}
Welcome to your introduction to APIs and Web Scraping! Today, we will explore how these tools allow us to harness vast amounts of data from the internet efficiently. APIs (Application Programming Interfaces) and web scraping are fundamental for anyone looking to retrieve, analyse, and use web data effectively. This session will cover the basics, setting the stage for more advanced topics.
:::

# What is an API?

* Definition: A set of rules that allows programs to communicate with each other
* Examples: Social media APIs, weather data APIs
* Uses: Data retrieval, automation, integration

::: {.notes}
An API, or Application Programming Interface, acts like a bridge between different software applications, allowing them to interact without user intervention. For instance, when you use a weather app, it retrieves data from a weather API to provide you with real-time updates. APIs are ubiquitous in software development, enabling functionalities such as pulling live data into applications or automating tasks.
:::

# Introduction to Web Scraping

* Definition: Extracting data from websites
* Tools: Python libraries like BeautifulSoup, Scrapy
* Legal and ethical considerations

::: {.notes}
Web scraping involves programmatically gathering data from the internet, specifically from web pages. Tools like BeautifulSoup and Scrapy in Python make this process accessible even for beginners. However, it's crucial to consider legal and ethical implications, such as respecting copyright and terms of service of websites, to avoid potential legal issues.
:::

# How APIs Work

* Sending requests from your application
* Receiving responses in formats like JSON, XML
* Common protocols: REST, SOAP

::: {.notes}
APIs work by processing requests and sending back responses. When you request data, such as the latest weather updates, the weather API processes this request and sends back data, often in JSON or XML format. Most modern APIs use the REST protocol due to its simplicity and effectiveness over the web.
:::

# Basic Web Scraping Example

* Python code to scrape data
* Simple example using BeautifulSoup

```python
from bs4 import BeautifulSoup
import requests

url = 'http://example.com/'
response = requests.get(url)
soup = BeautifulSoup(response.text, 'html.parser')

print(soup.find('h1').text)
```

::: {.notes}
Here's a basic example of web scraping using Python. We use the BeautifulSoup library to parse HTML data. After sending a request to the website, we receive HTML content, which BeautifulSoup helps us navigate to extract specific pieces like headings, paragraphs, etc. This example simply prints the text inside the first heading tag (`<h1>`) of the webpage.
:::

# Comparing APIs and Web Scraping

* When to use each method
* Advantages and limitations
* Ethical considerations

::: {.notes}
Choosing between APIs and web scraping depends on your needs and the availability of data. APIs are preferred when available, as they are more stable and efficient. Web scraping is a good alternative when no API is available but requires careful handling to ensure it does not violate terms of service or copyright laws.
:::

# Practical Applications

* Real-time data integration in apps
* Automating repetitive tasks
* Enhancing data-driven decision making

::: {.notes}
Both APIs and web scraping have practical applications in various fields. For example, integrating real-time weather data into a travel app enhances user experience by providing current conditions. They also automate repetitive tasks, such as daily reports of stock prices, freeing up time for more complex analyses.
:::

# Conclusion

* Recap of key points
* Encouragement to explore further
* Resources for deeper learning

::: {.notes}
Today, we've covered the basics of APIs and web scraping, essential tools for modern data retrieval and application integration. I encourage you to explore these technologies further. Delve into the provided resources and experiment with building small projects to grasp their power and potential fully.
:::

# Further Resources

* [Python Requests Library Documentation](https://requests.readthedocs.io/en/latest/)
* [JSON Data in Python: A Practical Introduction](https://realpython.com/python-json/)
* [Understanding APIs for Beginners](https://www.smashingmagazine.com/2018/01/understanding-using-rest-api/)

::: {.notes}
For those eager to learn more, these resources are excellent starting points. They provide in-depth tutorials and explanations that can help reinforce todayâ€™s topics and expand your understanding and skills in working with APIs and web scraping.
:::---
title: "Securing API Access: A Beginner's Guide"
subtitle: "Understanding Authentication Mechanisms for Web APIs"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


# Introduction to API Security

* Importance of securing APIs
* Overview of authentication and authorisation
* What you'll learn in this presentation

::: {.notes}
Welcome to our session on securing API access! As APIs become a critical part of web and mobile applications, ensuring that these interfaces are secure is paramount. This presentation will explore the fundamental concepts of authentication and authorisation, focusing on how they help protect data and systems from unauthorised access. By the end, you'll understand the various mechanisms available to secure API access and why they are critical in today's digital landscape.
:::

# What is an API?

* Definition of API (Application Programming Interface)
* Role of APIs in modern software
* Examples of API usage

::: {.notes}
API stands for Application Programming Interface, a set of rules that allows different software entities to communicate with each other. APIs play a crucial role in modern software development by enabling applications to interact seamlessly, whether retrieving data from a server or sending data to be processed. Common examples include pulling real-time data from weather services or integrating with social media platforms to post updates directly from an app.
:::

# Why Secure an API?

* Protect sensitive data
* Ensure data integrity
* Prevent unauthorised access

::: {.notes}
Securing an API is essential for several reasons. Primarily, it helps protect sensitive data from being exposed to unauthorised users. Furthermore, security measures ensure the integrity of the data being exchanged, preventing malicious actors from altering it. Lastly, robust security prevents unauthorised access, ensuring that only legitimate users can interact with the API, thus maintaining the overall system's reliability and trustworthiness.
:::

# Basic Authentication

* Simplest form of API authentication
* Utilises a username and password
* Suitable for less critical data

::: {.notes}
Basic Authentication is the simplest form of securing an API. It works by sending a username and password with each API request, usually encoded in Base64. While this method is easy to implement, it is less secure compared to other methods and is generally recommended for scenarios where security demands are lower, such as accessing non-sensitive data.
:::

# Token-Based Authentication

* More secure than basic authentication
* Uses access tokens
* Example: OAuth 2.0

::: {.notes}
Token-based authentication is a more secure alternative to basic authentication. In this method, the user first logs in using their credentials to receive a token. This token is then used for subsequent requests to the API. OAuth 2.0 is a popular framework that utilises tokens, providing robust security for accessing resources. This method is widely used due to its scalability and security features, especially in applications that require handling sensitive data.
:::

# API Keys

* Simple way to control access
* Unique to each user or application
* Limitations: potential for leakage

::: {.notes}
API keys are another common method for authenticating API requests. Each key is unique to a user or application and is included in the request to authenticate the user. While API keys are simple to use and implement, they must be kept secure. If an API key is leaked, it can provide an attacker access to the API, potentially leading to data breaches.
:::

# Best Practices for API Security

* Use HTTPS for secure communication
* Regularly rotate and manage credentials
* Implement rate limiting to prevent abuse

::: {.notes}
To enhance API security, it is crucial to follow best practices. Always use HTTPS to encrypt data transmitted between the client and the server, ensuring that sensitive information is protected from interceptors. Regularly rotating and managing credentials, such as passwords and API keys, helps mitigate the risk of unauthorised access. Additionally, implementing rate limiting on your API can prevent abuse and help manage the load on your infrastructure.
:::

# Conclusion

* Importance of robust API security
* Review of authentication methods
* Encouragement to implement best practices

::: {.notes}
We've covered the critical aspects of API security and discussed various authentication methods to protect your data and systems. Remember, implementing robust security measures is not just a technical requirement but a crucial element in maintaining trust and reliability in your applications. I encourage you to use these practices to ensure your APIs are secure and efficient.
:::

# Further Resources

* [Python Requests Library Documentation](https://requests.readthedocs.io/en/latest/)
* [Understanding APIs for Beginners](https://www.smashingmagazine.com/2018/01/understanding-using-rest-api/)
* [OAuth 2.0 Authorization Framework](https://oauth.net/2/)

::: {.notes}
For those interested in diving deeper into API security or needing specific guidance on implementing these concepts in Python, these resources will be invaluable. They provide detailed documentation and tutorials that can help you better understand and implement secure API strategies in your projects.
:::---
title: "Mastering Debugging: Human Insight, AI Assistance"
subtitle: "Navigating Complex Code with Confidence in the AI Era"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---


# Introduction

* Debugging in the Age of AI
* Understanding the importance of debugging
* Overview of advanced debugging techniques

::: {.notes}

Welcome! Debugging is an essential skill for every developer â€“ it's the art of being a code detective. In this session, we'll explore advanced debugging techniques. But more importantly, we'll discuss how your human intuition and analytical skills, when combined with the capabilities of modern AI tools, can make you exceptionally effective at pinpointing and resolving even the most complex software issues. We're moving beyond basic fixes to understand root causes, with AI as a powerful investigative partner.
:::



# What is Debugging in the Age of AI?**

* **Core Definition:** Still the process of identifying, analysing, and resolving defects in software.
* **New Challenges & Opportunities:**
    * AI can generate code (and bugs!) rapidly.
    * AI can suggest fixes, but are they superficial or foundational?
* **Human's Role is Elevated:** From just fixing to *deeply understanding* why bugs occur and ensuring robust solutions, even when AI assists.
* **Basic vs. Advanced Debugging (AI Context):**
    * Basic: Quick fixes, perhaps AI-suggested, for obvious errors.
    * Advanced: Systematic investigation of complex issues, using tools and critical thinking, with AI providing targeted support (e.g., explaining complex tracebacks, suggesting hypotheses).

::: {.notes}
Debugging is still about finding and fixing bugs. However, the landscape is changing with AI.
* AI can generate vast amounts of code, which means more potential for bugs, but also more opportunities for AI to *help find* them.
* AI tools can often propose quick fixes. The challenge for you, the developer, is to determine if an AI's suggestion truly solves the root problem or just patches a symptom.
* This elevates your role. It's not just about making the error message go away; it's about deep understanding. Advanced debugging, therefore, involves a systematic, human-led investigation where AI acts as a knowledgeable assistant, perhaps explaining an obscure error message or helping you understand a complex piece of code before you even start the debugger.
:::



# Key Advanced Debugging Techniques

* **Strategic `print()` Statements & Logging:** Still your first line of detailed inquiry.
    * *AI Assist:* "Based on this error and code, where would `print()` statements be most effective for tracing variable `x`?"
* **Breakpoints & Stepping Through Code (Debuggers):** Pause execution, inspect state, understand flow line-by-line.
    * *AI Assist:* "At this breakpoint, variable `foo` is `None`. What are common reasons for this in such a function?" or "Explain this section of the call stack."
* **Conditional Breakpoints:** Pause only when specific conditions are met (e.g., `loop_counter > 1000`).
    * *AI Assist:* "Help me formulate a condition for a breakpoint that triggers if this list ever becomes empty."
* **Watch Expressions & Call Stack Navigation:** Track specific variables; understand the path to the current error.
    * *AI Assist:* "Explain the role of function `bar()` in this call stack leading to the error."
* **Code Profiling & Performance Analysis:** Identify bottlenecks or excessive resource usage that might indicate or cause bugs.
    * *AI Assist:* "This function is unexpectedly slow. What are common performance pitfalls I should look for using a profiler?"

::: {.notes}
Let's look at some powerful techniques. Remember, AI doesn't replace these; it can make you more effective when using them.
* **Strategic `print()`/Logging:** Before even launching a full debugger, targeted print statements can give you quick insights. You can even ask AI where the most informative print statements might go.
* **Debuggers (Breakpoints & Stepping):** This is where you truly become a code detective, stopping time to examine the crime scene. Set a breakpoint, run your code, and when it pauses, inspect variable values. Step through line by line. If you see a variable with an unexpected value at a breakpoint, you can ask an AI to brainstorm reasons why that might happen in that specific code context. Or, if the call stack (the list of functions that led to this point) is confusing, AI can help explain it.
* **Conditional Breakpoints:** Super useful for bugs that only appear after many iterations or under specific circumstances. AI can help you think through the logic for these conditions.
* **Watch Expressions & Call Stack:** Modern debuggers let you 'watch' specific variables or expressions as they change. Understanding the call stack is vital, and AI can help decipher complex ones.
* **Profilers:** Sometimes bugs aren't just errors but performance issues that break functionality (e.g., a timeout). Profilers help find slow code. AI can suggest what to look for.
Your human insight guides where to look; AI can help interpret what you find or suggest avenues for investigation.
:::



# Tools for Advanced Debugging (AI Integration)**

* **Integrated Development Environments (IDEs):** PyCharm, VS Code, etc., offer powerful built-in debuggers.
    * Features: Breakpoint management, variable inspection, step controls, call stack view.
* **AI-Integrated IDEs/Tools:**
    * **Inline Code Explanation/Suggestions:** AI like GitHub Copilot can explain selected code or suggest fixes *within* your editor.
    * **AI-Powered Error Analysis:** Tools that analyse tracebacks and offer more sophisticated explanations or troubleshooting steps.
    * **AI Chat for Debugging:** Dedicated AI chat interfaces where you can paste code/errors and ask for debugging help.
* **Choosing the Right Combination:** Leverage your IDE's debugger for control, and AI tools for insights and suggestions.

::: {.notes}

Your IDE (like PyCharm, VS Code, Spyder, etc.) is your primary debugging command center, with its built-in debugger offering fine-grained control.
* **AI Integration is Key:** Many IDEs are now integrating AI directly. GitHub Copilot, for example, can explain code snippets or even suggest fixes as you type. Other tools might offer more detailed AI analysis of error messages. You might use an AI chat interface side-by-side with your debugger, feeding it information from your debugging session to get hypotheses or explanations. The goal is to use these tools in concert: the IDE debugger for control and detailed inspection, and AI for accelerating understanding and idea generation.
:::



# A Case Study (AI-Assisted Workflow)**

* **Scenario:** (Use a slightly more complex but still understandable example than just `a+b` vs `a*b`. Perhaps a list processing error, an off-by-one, or a simple state-related bug).

* **Step-by-Step (Illustrative):**
    1. **The Bug Appears:** Program produces unexpected output or crashes with a traceback.
    2. **Initial Human Analysis:** Read error. Form initial thoughts.
    3. **AI for Error Explanation:** "Explain this `IndexError` and traceback in the context of my list processing function `[code snippet]`."
    4. **Strategic `print()`/Logging (Human + AI):** "Where should I add prints to see the list's state before the error?"
    5. **Debugger Time (Human Control):** Set breakpoints based on insights. Step through.
    6. **AI for Hypothesis at Breakpoint:** "At this breakpoint, `my_list` is `[1,2]` but I expected `[1,2,3]`. What could have removed an element before this line in my function `[code snippet]`?"
    7. **AI for Solution Brainstorming:** "I think the bug is related to `[specific line/logic]`. Can you suggest ways to fix this potential off-by-one error?"
    8. **Human Implements & Verifies:** Critically review AI's idea, implement a fix, and *test thoroughly* (ideally with pre-existing unit tests, or write a new one).
* **Lessons:** AI speeds up understanding and idea generation, but human controls the process and validates the outcome.

::: {.notes}

Let's walk through a hypothetical debugging session. Imagine a function that's supposed to process a list of items but sometimes misses the last item or throws an error.
1.  You run it, and it either crashes or gives the wrong result.
2.  You look at the error (if any) or the incorrect output.
3.  You could paste the error and relevant code into an AI and ask for an explanation of what the error *means* generally, or what it might mean in *your specific code*.
4.  Based on this, or your own intuition, you add `print` statements. Or ask AI, "Where are good places to print the list and loop index to understand what's happening?"
5.  The prints narrow it down, so you fire up the debugger, setting a breakpoint just before the suspected problematic line.
6.  You step through. At a breakpoint, you see the state isn't what you expect. You could describe this state and the code to an AI and ask for potential reasons *why* it's in that state.
7.  Once you have a strong hypothesis (e.g., "I think my loop condition is wrong"), you can ask AI to suggest fixes for *that specific kind of problem*.
8.  Crucially, you evaluate AI's suggestions. Does it make sense? Does it address the root cause? You implement the fix, and then you *test it thoroughly*, ideally with unit tests we discussed in Module 1. This AI-assisted workflow allows you to combine your analytical skills with AI's rapid information processing and pattern matching.
:::



# Debugging Best Practices (for the AI Era)**

* **Systematic Approach:** Don't just guess. Form hypotheses (use AI to help brainstorm), test them (with `print`, debugger, or by asking AI to evaluate a hypothesis against the code), and iterate.
* **Understand, Don't Just Swap Code:** If AI suggests a fix, understand *why* it works before applying it.
* **Reproduce the Bug Consistently:** Before fixing, know how to make it happen reliably.
    * *AI Assist:* "Help me identify the conditions or inputs that might be causing this intermittent bug."
* **Keep a Log (Physical or Digital):** Note what you've tried, your theories, AI prompts, and AI's useful (or not useful) responses. This prevents going in circles.
* **Write a Test for the Bug:** Once found and fixed, write a test case that *would have caught this bug*. This prevents regressions.
    * *AI Assist:* "I fixed this bug `[describe bug and fix]`. Help me write a `pytest` test case that specifically targets this scenario."
* **Regular Code Reviews (Human + AI?):** Humans discuss logic. AI can spot potential issues or suggest areas for clarification.

::: {.notes}

Effective debugging relies on good habits:
* **Systematic Approach:** Avoid randomly changing code. Develop a theory about the bug, then test that theory. AI can help you develop theories by explaining parts of the code or suggesting potential causes for an observed behavior.
* **Understand the Fix:** If an AI gives you a code snippet that fixes the bug, don't just paste it in. Figure out *why* it's the correct solution. This is how you learn.
* **Reproduce Consistently:** It's hard to fix a bug you can't reliably trigger. AI might help you brainstorm conditions or inputs that lead to an intermittent bug.
* **Keep a Log:** Debugging complex issues can take time. Jot down what you've tried, what you observed, and even key AI interactions.
* **Test for the Bug:** This is crucial. Once you've fixed a bug, add a test that specifically covers that scenario. AI can be very helpful here: "I found a bug where X happened. I fixed it by doing Y. Can you help me write a unit test that would have failed before my fix and passes now?"
* **Code Reviews:** Having another human look at your code is invaluable. AI tools are also emerging that can provide automated code review feedback, spotting potential issues or areas for improvement.
:::



# Common Pitfalls in Debugging (AI Edition)**

* **Fixing Symptoms, Not Root Causes:**
    * *AI Risk:* AI might suggest a narrow fix that handles a specific case but misses the underlying systemic issue. Human critical thinking is needed to ask "why?" repeatedly.
* **Overlooking Simple Solutions:** Sometimes it *is* just a typo! Don't jump to complex AI queries immediately.
* **Not Replicating the Environment:** Bug appears in production but not locally. (AI less helpful here, more about environment setup).
* **Misinterpreting AI Suggestions:** Applying AI advice without fully understanding its implications for your specific codebase.
* **"Black Box" AI Fixes:** Accepting an AI fix that works but you don't understand. This creates unmaintainable code.
* **Ignoring Version Control:** Not using branches for debugging attempts; makes it hard to revert changes (AI or human-made).

::: {.notes}

Even with AI, pitfalls await:
* **Symptom vs. Root Cause:** This is a big one with AI. An AI might see an error and suggest a way to prevent *that specific error instance* (e.g., adding a null check) without addressing *why* the value is null in the first place. Your job is to dig deeper for the root cause.
* **Overlooking the Obvious:** Before crafting a complex AI prompt, double-check for simple typos or basic logical errors yourself!
* **Environment Mismatches:** A classic. AI can't easily solve this; it requires careful comparison of environments.
* **Misinterpreting AI:** AI communicates in language, but its "understanding" of code isn't human. Ensure its suggestions make sense in *your* full context.
* **"Black Box" Fixes:** If AI fixes something and you don't know why the fix works, you've learned little, and that part of the code is now a mystery to you. This is technical debt.
* **Version Control:** Always use Git or similar. Create branches for experimental fixes (whether suggested by AI or your own). If it doesn't work, you can easily revert.
:::



# Integrating Debugging with Testing (Synergy with AI)**

* **Effective Testing Minimises Debugging:** Fewer bugs escape to later stages.
* **Tests Help Reproduce Bugs:** A failing test *is* a reproducible bug.
* **Test-Driven Debugging (TDD style):**
    1. Identify a bug.
    2. Write a test that *fails* because of this bug. (AI can help draft this test: "Write a test that demonstrates bug X in function Y.")
    3. Debug and fix the code until the test passes.
* **AI for Post-Fix Test Generation:** "I fixed bug X by changing Y. Help me write tests to ensure this fix works and doesn't break other things."
* **Debugging Informs Future Tests:** Understanding a bug helps you write better tests to prevent similar issues. AI can help generalise from a specific bug to broader test case ideas.

::: {.notes}

Debugging and testing are two sides of the same quality coin.
* Good tests, as we discussed in Module 1, catch many bugs early, reducing the time you spend in complex debugging sessions.
* When a bug *does* occur, a failing test is the best way to reproduce it consistently.
* Consider "Test-Driven Debugging": When you find a bug, first write a test that specifically triggers it and fails. Then, debug your code until that new test (and all others) pass. AI can assist in drafting that initial failing test: "I have a bug where my function `process_items` fails if the input list is empty. Can you help me write a `pytest` test that shows this failure?"
* After you've fixed a bug (with or without AI's help in finding the fix), ask AI to help you write robust tests around that fix to prevent it from recurring (regression testing).
Understanding why a bug occurred often gives you insights into what other kinds of tests you should be writing. AI can help you take a specific bug instance and brainstorm related test scenarios.
:::



# Conclusion: Becoming a Code Detective in the AI Era

* Advanced debugging is about deep investigation and understanding, not just quick fixes.
* AI tools are powerful *assistants*, not replacements for your analytical skills and critical judgment.
* Master traditional techniques (`print`, debuggers) to effectively guide and verify AI suggestions.
* **Practice the Human-AI Workflow:** Investigate -> Hypothesise (with AI) -> Verify (with tools) -> Implement (with understanding) -> Test.
* Continuous learning in both debugging techniques and effective AI interaction is key.
* **Call to Action:** Embrace debugging as a challenging but rewarding part of development. Use every tool, including your brain and AI, to master it!

::: {.notes}

In conclusion, mastering advanced debugging in this AI era means becoming a skilled investigator who knows how to use every tool at their disposal â€“ including powerful AI assistants.
* It's about the deep dive, the root cause analysis. AI can help you get there faster, explain complexities, and offer ideas, but your critical thinking steers the ship.
* Your proficiency with fundamental techniques like `print` statements and interactive debuggers actually makes you *better* at using AI, because you can provide it with more precise information and better evaluate its responses.
* Focus on practicing that collaborative workflow: your initial investigation, using AI to explore possibilities or explain roadblocks, using debuggers to confirm, understanding and implementing solutions, and finally, testing your fixes.
Debugging will always be part of software development. By combining your growing expertise with the evolving capabilities of AI, you'll be well-equipped to tackle any bug that comes your way.
:::
---
title: "Strategic Test Design: Guiding Quality in AI-Assisted Development"
subtitle: "Ensuring Software Reliability Through Human Insight and AI Collaboration"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Introduction

* Test Design with AI
* What is a Test Case
* Effective Test Design
* Common Pitfalls
* Tools and Resources
* Strategic Design in an AI World

::: {.notes}

Welcome! In our previous modules, we explored testing frameworks and debugging, increasingly seeing AI as a powerful assistant. Now, we focus on a critical human skill: **strategic test design**. Even if AI can help write code or even draft test cases, *you* define what success looks like. This session is about how to thoughtfully design effective test cases that ensure software quality, especially when collaborating with AI tools. We'll learn how your strategic thinking guides the entire quality assurance process.
:::



# The Power of Test Design in the AI Era

* **Why Test Design Matters:** Defines "correctness" for both human and AI-generated code.
* **Human as the Strategist:** You decide *what* to test, *why* it's important, and *how thoroughly*.
* **AI as the Tactical Assistant:** AI can help generate test ideas, data, or boilerplate, but your design guides its efforts.
* **Effective test cases:** Ensure AI modifications are actual improvements, not just changes.

::: {.notes}

In an era where AI can generate code and even suggest tests, the human role of **designing** those tests becomes paramount.
* A well-designed test case is a clear specification of expected behavior. This is crucial whether a human or an AI wrote the underlying code.
* As the developer, you bring the domain knowledge and understanding of user needs. You are the strategist who decides what aspects of the software are critical to test and what constitutes a meaningful test.
* AI can then act as a powerful tactical assistant, helping you flesh out these strategies by generating test scenarios, suggesting edge cases, or even drafting initial test code based on your design.
* Ultimately, your test design is what validates that any changes, whether human or AI-driven, truly meet the quality bar. Today, we'll cover how to design these vital test cases, integrating AI as a collaborative tool.
:::



# What is a Test Case? (AI Context)

* **Definition:** A set of inputs, execution conditions, test steps, and expected results developed for a particular objective (e.g., to verify compliance with a specific requirement).
* **Core Components:**
    * Test Case ID / Name
    * Preconditions / Setup
    * Test Steps (Actions)
    * Test Data (Inputs)
    * **Expected Results** (Crucial for defining success)
    * Actual Results & Status (Pass/Fail)
    * Postconditions / Teardown
* **AI Assistance in Component Generation:**
    * AI can help draft initial test steps based on a feature description.
    * AI can suggest varied test data (valid, invalid, edge cases).
    * **Human role:** Critically review and refine AI suggestions, especially expected results.

::: {.notes}

A test case is essentially a formal recipe for verifying a piece of functionality. It specifies everything needed to run a test and determine if the software behaves as expected.
* The **expected result** is perhaps the most critical component you define â€“ itâ€™s your assertion of what "correct" means.
* While the core components remain the same, AI can now assist in their creation. For instance, given a user story or a function signature, you could ask an AI: "Suggest test steps and typical test data for a function that does X." Or, "What are some edge case inputs for a feature that validates email addresses?"
* Your crucial role is to then take these AI-generated suggestions, critically review them, refine them (especially the expected results to ensure they align perfectly with requirements), and ensure they form a coherent and effective test.
:::



# Principles of Effective Test Design (Human-Guided, AI-Refined)

* **Clear, Concise, Unambiguous:** Easy to understand and execute by anyone (or any automated tool).
    * *AI Assist:* "Can you make these AI-generated test steps clearer and more concise?"
* **Traceable to Requirements:** Each test case should clearly map to a specific requirement or user story.
    * *AI Assist (Conceptual):* AI might help identify which requirements lack test case ideas (though this is more advanced).
* **Repeatable & Consistent:** Produces the same results every time if the software hasn't changed.
* **Independent & Isolated:** One test case failure shouldn't cascade or affect others unnecessarily.
    * *AI Assist:* "Review this set of test cases. Are there any obvious dependencies between them that I should try to remove?"
* **Covers Likely Failure Points & Edge Cases:** Goes beyond the "happy path."
    * *AI Assist:* "What are common failure points or edge cases for a [type of feature, e.g., 'file upload'] feature?"
* **Maintainable:** Easy to update as the software evolves.
    * *AI Assist:* Help refactor test cases when underlying code changes, but human confirms logic.

::: {.notes}

Effective test cases aren't just thrown together; they follow key principles.
* **Clear and Unambiguous:** If AI generates draft test steps, review them. Are they easy for another human (or you, in six months) to understand? You can even ask another AI instance to "rephrase these test steps for maximum clarity."
* **Traceable:** This ensures you're testing what matters.
* **Repeatable:** Essential for reliable automation.
* **Independent:** This helps pinpoint exactly where a failure lies. AI might help spot potential dependencies if you ask it to review a test suite description.
* **Covers Failure Points/Edge Cases:** This is where AI can shine as a brainstorming partner. Prompt it: "For a user registration form, what are some typical edge cases or invalid inputs I should design test cases for?"
* **Maintainable:** As your software changes, your tests will need to change. AI can help with the mechanical aspects of refactoring tests, but you must ensure the *logic* of the updated test remains sound.
:::



# A Spectrum of Tests: Types & AI Brainstorming

* **Functional Test Cases:** Verify specific actions/functions of the software.
    * *AI Assist:* "For a 'shopping cart checkout' feature, list key functional test cases."
* **User Interface (UI) Test Cases:** Ensure UI elements look and work correctly.
    * *AI Assist:* "What are common UI test cases for a web login form?" (May lead to more specialised UI testing tools).
* **Performance Test Cases:** Evaluate speed, responsiveness, stability under load.
    * *AI Assist (Conceptual):* "What aspects of this [architecture description] should be performance tested?"
* **Security Test Cases:** Assess vulnerabilities and protection.
    * *AI Assist (Conceptual):* "What are common security vulnerabilities I should design test cases for related to user authentication?"
* **Usability Test Cases:** How easy and intuitive is the system to use?
    * *AI Assist:* Can AI analyse a UI description and suggest usability heuristic violations to test for? (Emerging area)
* **Choosing the right types:** Your strategy dictates the mix, AI can help explore options.

::: {.notes}

There are many different types of tests, each focused on a different aspect of quality.
* **Functional tests** are often the most common â€“ does the feature do what it's supposed to do? AI can be great at generating a list of functional scenarios based on a feature description.
* **UI tests** focus on the visual and interactive aspects. AI might help list common UI elements to check on a given screen type.
* **Performance and Security testing** are specialised domains. While AI might not design these complex tests end-to-end for a beginner, it can certainly help you brainstorm *what aspects* to consider testing based on your application's nature. For example, "What are typical performance metrics to test for a real-time data dashboard?"
* **Usability testing** is about the user experience. Emerging AI capabilities might even analyse UI mockups for potential usability issues that you could then design tests around.
Your understanding of the project's risks and priorities will determine which types of tests are most important. AI can then assist in brainstorming specific cases within those types.
:::



# Test Case Design: A Human-AI Collaborative Workflow

1. **Identify Testable Requirements/Scenarios (Human Lead):** What feature or behavior needs testing? Understand the core goal.
2. **Define Test Objectives (Human Lead):** What specific aspect of the requirement will this test case verify?
3. **Brainstorm with AI (Collaborative):**
    * "Given this feature `[description]`, suggest different test scenarios (happy path, negative paths, edge cases)."
    * "What are important preconditions for testing `[feature]`?"
4. **Detail Test Steps (AI Drafts, Human Refines):**
    * Prompt AI: "For the scenario `[specific scenario]`, draft the test steps."
    * Human: Review for clarity, completeness, accuracy. Add necessary detail.
5. **Specify Test Data (AI Suggests, Human Validates):**
    * Prompt AI: "Suggest valid and invalid input data for these test steps."
    * Human: Select appropriate data, ensure it covers boundaries and edge cases.
6. **Define Expected Outcomes (Human Critical, AI can Verify Consistency):**
    * Human: Based on requirements, *you* define the precise expected outcome. This is critical.
    * AI Assist: "If I input X according to these steps, and the requirement is Y, what should the expected outcome be?" (Use AI to check your logic or for simple cases).
7. **Review and Refine (Human Lead):** Does the complete test case meet all principles of effectiveness? Is it unambiguous?

::: {.notes}

Let's look at a practical, AI-augmented workflow for designing a test case:
1.  **You start by identifying what needs to be tested** based on project requirements or user stories. You understand the *why*.
2.  **You define the specific objective** for a particular test case. What single thing is it trying to prove?
3.  **Now, bring in your AI partner for brainstorming.** Describe the feature and ask for different test scenarios â€“ happy paths, what happens if things go wrong, what are the tricky edge cases. Ask about necessary preconditions.
4.  **For a chosen scenario, ask AI to draft the sequence of test steps.** Then, *you* review, edit, and refine these steps. Are they logical? Complete? Easy to follow?
5.  **Need test data? AI can suggest a range of inputs.** "For these steps, give me examples of valid inputs, invalid inputs that should cause an error, and boundary values." You then curate and select the most relevant data.
6.  **Defining the expected outcome is largely a human task, rooted in the requirements.** However, for straightforward logic, you might describe the input and steps to an AI and ask, "Given these inputs and steps, and assuming the function should calculate a 5% discount, what should the output be?" This can act as a sanity check.
7.  **Finally, you review the entire test case.** Is it clear? Does it meet all the principles we discussed? This iterative process, with AI handling some of the generation and you providing the strategic oversight and critical evaluation, can be very powerful.
:::



# Example: Weather Dashboard Test Design with AI
* **Scenario:** Checking weather updates for a user-entered location.
* **AI-Assisted Design Steps:**
    * **Human Objective:** Verify correct real-time weather is shown for a valid city, and graceful error for an invalid city.
    * **AI Brainstorm Scenarios:**
        * Prompt: "Suggest test scenarios for a weather dashboard's location search."
        * *AI Output (example):* Valid city, misspelled city, non-existent city, city with special characters, empty input.
    * **Human Selects Scenario:** "Test with a valid, known city."
    * **AI Drafts Test Steps:**
        * Prompt: "Draft test steps for searching 'Perth, Australia' on a weather dashboard and verifying the temperature."
    * **Human Refines Steps & Expected Result:**
        1. Navigate to dashboard.
        2. Enter "Perth, Australia" in search.
        3. Click "Search."
        4. **Expected:** Weather details for Perth displayed. Temperature shown is within +/- 2 degrees of actual current Perth temperature (requires external check or mock for automation).
    * **AI Suggests Edge Case Data:**
        * Prompt: "Suggest invalid city names that might cause errors."
        * *AI Output (example):* "Xys123", "   ", "!@#$"
    * **Human Designs Negative Test:** Test with "Xys123", expect "City not found" message.

::: {.notes}

Let's apply this to our weather dashboard example.
* Our objective is to check that it shows correct weather for real cities and handles bad input well.
* We could ask an AI: "What are different test scenarios I should consider for the location search feature of a weather dashboard?" The AI might suggest testing with valid cities, misspelled ones, completely fake names, empty inputs, etc.
* We pick a scenario: "Display weather for Perth, Australia." We can ask the AI to "Draft the test steps to search for 'Perth, Australia' and verify the displayed temperature."
* The AI might give us basic steps. We then refine them and, importantly, define a precise expected result. For real-time data like weather, the expected result might be "Temperature displayed is within an acceptable range of the *actual* current temperature," which for automated tests often involves more advanced techniques like mocking or service virtualisation, or a manual check.
* Then we might ask AI for examples of invalid city names. We'd use these to design negative test cases, defining the expected error message like "City not found." This shows how AI can help explore the test space more thoroughly.
:::



# Common Pitfalls in Test Design (AI Era Perspective)**
* **Traditional Pitfalls:**
    * Overly complex test cases (hard to maintain).
    * Testing multiple features in one test (hard to isolate faults).
    * Ambiguity in expected outcomes (leads to incorrect pass/fail).
* **New AI-Related Pitfalls:**
    * **Over-reliance on AI-Generated Scenarios:** AI might miss nuanced business logic or critical-but-unobvious edge cases if not prompted with enough context.
    * **Superficial Test Cases:** AI might generate many "shallow" tests that hit lines of code but don't deeply validate behavior or complex interactions.
    * **Bias in AI Suggestions:** AI's training data might lead it to suggest tests that reflect common patterns but miss unique aspects of *your* application.
    * **Lack of Critical Review:** Accepting AI-generated test cases without thorough human validation of their relevance, steps, and *especially expected outcomes*.
    * **"Quantity over Quality" Illusion:** AI can generate many tests quickly, but if they aren't well-designed and meaningful, they provide false confidence.

::: {.notes}

While AI helps, some classic pitfalls remain, and new ones emerge.
* Traditional issues like overly complex tests or ambiguous expected results still apply. Clear, focused human design is the antidote.
* **AI-Specific Pitfalls:**
    * **Over-reliance:** Don't assume AI will think of everything. If your application has very specific or unusual business rules, you need to guide the AI or design those test cases yourself.
    * **Superficial Tests:** AI might generate tests that seem to cover the code but don't actually verify the critical logic paths or interactions. Your deep understanding is needed to ensure tests have substance.
    * **Bias:** An AI is trained on vast amounts of data. If your problem is unique, the AI's "common" suggestions might not be the best fit.
    * **Lack of Critical Review:** This is the biggest risk. If you blindly accept AI-generated test cases, especially their expected results, you could be institutionalising misunderstandings or even testing for the wrong thing.
    * **Quantity over Quality:** AI can churn out test ideas. Your job is to curate these into a *high-quality, effective* set, not just a large one.
:::



# Tools and Resources (AI Included)**
* **Your Brain!** (Critical thinking, domain knowledge, strategic planning)
* **Requirements Documents / User Stories:** The source of truth for what to test.
* **Diagramming/Flowchart Tools:** To visualise complex logic and identify test paths.
* **Python Testing Frameworks:** `doctest`, `unittest`, `pytest` (to implement the designed tests).
* **Test Case Management Tools:** (e.g., TestRail, sephyr, Jira with plugins) for larger projects.
* **AI Development Assistants:**
    * **LLMs (ChatGPT, Claude, Gemini, etc.):** For brainstorming scenarios, drafting steps, suggesting data, explaining concepts.
    * **IDE-Integrated AI (e.g., GitHub Copilot):** For inline suggestions and explanations during test code implementation.
* **Further Reading & Communities:** Blogs, forums, testing certifications.

::: {.notes}

Your primary tool for test design is your own analytical ability and understanding of the project.
* Requirements are your foundation.
* Visual tools can help map out complex logic.
* The frameworks we discussed (Module 1) are where you'll implement these designs.
* For larger scale efforts, dedicated test management tools help organise and track test cases.
* **And now, AI tools are a significant resource.** Use LLMs for brainstorming, getting initial drafts, or understanding complex requirements. Use AI integrated into your IDE to help as you write the actual test code.
* And, as always, continuous learning from online resources and communities is key.
:::



#  Conclusion: You Are the Test Strategist
* Effective test case design is a critical human skill, amplified by AI.
* Your strategic thinking ensures that AI's tactical assistance is directed effectively.
* Well-designed tests are the ultimate verifier of quality for both human and AI-generated code.
* **Embrace the Human-AI Collaboration:** Use AI to explore more scenarios, generate drafts faster, and learn, but *you* own the design and quality.
* **Encouragement:** Practice strategic test design. The more you do it, the better you'll become at guiding AI and ensuring truly robust software.

::: {.notes}

To conclude, while AI offers exciting new capabilities for assisting in test generation, the role of the human as the **test strategist and designer** is more critical than ever.
* It's your understanding of the requirements, the user, and the potential risks that shapes an effective testing strategy.
* AI can help you execute parts of that strategy much faster, explore more ground, and even overcome writer's block when thinking of test scenarios.
* But the ultimate responsibility for ensuring that tests are meaningful, comprehensive, and correctly define "quality" rests with you. Well-designed tests are your best tool for ensuring that all code, no matter its origin, meets the mark.
So, practice designing test cases thoughtfully. Experiment with how AI can assist you, and always remember that your critical judgment is the most valuable asset in the pursuit of software quality. Happy designing!
:::# Python Programming: Your Journey from Novice to Coder

This presentation summarizes the core concepts covered in the Introduction to Programming unit using Python. We'll revisit our six-step methodology and the foundational programming tools we've learned, all within the Google Colab and GitHub environment, and touch on how we use external libraries and AI in our workflow.

# The Six-Step Methodology: Cracking the Code of Problem-Solving

**Programming = Thinking + Coding**

Our approach breaks down problem-solving into clear stages:
1. Understand the problem
2. Identify the inputs and outputs
3. Work the problem by hand
4. Write pseudocode
5. Convert to Program
6. Test with a variety of data

# The "Thinking" Phase: Building Your Mental Model

This is where we focus on truly understanding the problem before writing any code.

1. **Understand the problem**: Restate the problem in your own words. What is the goal?
2. **Identify the inputs and outputs**: What information does the program need (inputs)? What should the program produce or display (outputs)?
3. **Work the problem by hand**: Solve a small, simple example of the problem manually. This helps clarify the logic and steps required.

# Planning with Pseudocode: Bridging Thought and Code

Translate your manual steps into a semi-structured description using the six fundamental actions a computer can perform:

- **Input**: Getting data from the user or a source
- **Output**: Displaying data to the user or a destination
- **Storage**: Storing data in variables
- **Calculate**: Performing arithmetic or logical operations
- **Make Decision**: Choosing between options based on conditions (if/else)
- **Repeat**: Performing actions multiple times (loops)

Pseudocode helps you outline the logic before coding.

# The "Coding" Phase: Bringing Ideas to Life

Now we translate our plan into executable code and verify it.

5. **Convert to Program**: Translate your pseudocode steps into actual Python code using the tools and syntax we've learned.
6. **Test with a variety of data**: Run your program with different inputs, including typical cases, edge cases, and potentially invalid inputs, to ensure it works correctly in all scenarios.

# Python Fundamentals: Your Coding Toolkit

Getting started with the absolute fundamentals.

```python
# Display a message to the console
print("Hello, world!")  # Output: Hello, world!

# Capture user input (always returned as a string)
name = input("What's your name? ")  # Prompts user and stores their response

# Creating variables to store different types of data
age = 30               # Integer value
greeting = "Hello"     # String value
temperature = 25.5     # Float value
is_raining = False     # Boolean value
```

# Creating Interactive Programs: Inputs and Outputs

Combining `input()` and `print()` for meaningful interaction.

```python
# Ask the user for their name
user_name = input("Please enter your name: ")  # Stores user's name as a string

# Display personalized messages using different techniques
print("Welcome, " + user_name + "!")  # Using string concatenation
print("Welcome,", user_name, "!")     # Using comma separation
print(f"Welcome, {user_name}!")       # Using f-strings (formatted strings)
```

# Making Smart Decisions: Conditional Logic

Making your programs respond to different conditions.

```python
temperature = 25  # Variable storing the current temperature

# Decision structure that responds differently based on temperature
if temperature > 30:
    print("It's hot!")              # Runs only if temperature > 30
elif temperature > 20:
    print("It's warm.")             # Runs if first condition is False but temperature > 20
else:
    print("It's cool.")             # Runs if all previous conditions are False
    
# Combining conditions with logical operators
if temperature > 20 and not is_raining:
    print("Great day for outdoor activities!")
```

# Connecting to Real Life: The Weather Context

Connecting programming concepts to a real-world scenario.

- Using simple weather conditions (cold, warm, rainy)
- Mapping these conditions to numeric thresholds (e.g., temperature ranges)
- Using if-else logic to decide on a weather message based on a temperature input

This helps make abstract conditional logic more tangible and practical.

# Building User Interfaces: Simple Menus

Creating user-friendly text-based interfaces.

```python
# Display a menu of options to the user
print("Weather Information Menu:")
print("1. Check Temperature")
print("2. Check Humidity")
print("3. Exit Program")

# Get the user's selection
choice = input("Enter your choice (1-3): ")  # Stores selection as a string

# Take different actions based on the user's choice
if choice == "1":
    print("You selected: Check Temperature")
    # Temperature check code would go here
elif choice == "2":
    print("You selected: Check Humidity")
    # Humidity check code would go here
elif choice == "3":
    print("Exiting program. Goodbye!")
else:
    print("Invalid option. Please try again.")  # Handles unexpected inputs
```

# Powering Through Repetition: Loops

Performing actions multiple times efficiently.

```python
# For loop: repeats a specific number of times
for i in range(5):
    print(f"Loop iteration {i}")  # Prints numbered iterations 0 through 4
    
# While loop: repeats as long as a condition is True
count = 0
while count < 3:
    print(f"Count is {count}")  # Displays current count value
    count += 1                  # Increases count by 1 each iteration
    
# Looping through a collection of items
weather_types = ["Sunny", "Rainy", "Cloudy"]
for weather in weather_types:
    print(f"Today's forecast: {weather}")  # Displays each weather type
```

# Creating Order with Functions: Reusable Code Blocks

Bundling code into reusable, organized units.

```python
# Define a function that can be called multiple times
def greet(name):
    """Says hello to the specified name."""  # Docstring explaining function purpose
    print(f"Hello, {name}!")  # Greets the person by name
    
# Call the function with different arguments
greet("Alice")  # Output: Hello, Alice!
greet("Bob")    # Output: Hello, Bob!

# Function with return value
def calculate_fahrenheit(celsius):
    """Converts Celsius temperature to Fahrenheit."""
    return (celsius * 9/5) + 32  # Formula for temperature conversion
    
# Using the returned value
temp_f = calculate_fahrenheit(25)
print(f"25Â°C equals {temp_f}Â°F")  # Output: 25Â°C equals 77.0Â°F
```

# Extending Python's Power: Modules and Libraries

Leveraging pre-written code to accomplish more.

```python
# Using the built-in datetime module
import datetime

# Get and display the current date and time
current_time = datetime.datetime.now()  # Creates a datetime object representing now
print(f"Current time is: {current_time}")

# Using specific functions from a module
from random import choice

# Select a random weather condition
conditions = ["Sunny", "Cloudy", "Rainy", "Snowy"]
today = choice(conditions)  # Picks one random item from the list
print(f"Today's forecast: {today}")
```

Third-party libraries (like simple_bot or pandas later) provide powerful tools for specific tasks.

# Visualizing Data: Bringing Numbers to Life

Using pandas to load and visualize data from CSV files.

```python
# Import the necessary libraries
import pandas as pd
import matplotlib.pyplot as plt

# Load data from a CSV file into a DataFrame
# A DataFrame is like a table or spreadsheet in Python
weather_data = pd.read_csv('weather_records.csv')  # Loads the CSV file

# Display the first 5 rows to get a quick look at our data
print(weather_data.head())  # Shows column names and first few rows

# Create a simple line plot of temperatures over time
weather_data.plot(x='Date', y='Temperature')  # x-axis: Date, y-axis: Temperature
plt.title('Temperature Variations')  # Add a title to the plot
plt.ylabel('Temperature (Â°C)')  # Label for y-axis
plt.grid(True)  # Add grid lines for better readability
plt.show()  # Display the plot

# Create a bar chart comparing different weather measurements
weather_data[['Rainfall', 'Humidity']].mean().plot(kind='bar')  # Bar chart of averages
plt.title('Average Rainfall vs. Humidity')  # Add a title
plt.ylabel('Value')  # Label for y-axis
plt.show()  # Display the plot
```

Visualization helps us identify patterns, trends, and outliers in data that might not be obvious from looking at raw numbers.

# AI as Your Programming Companion

Leveraging AI to accelerate your learning journey.

- AI can help explain concepts, syntax, and error messages
- AI can suggest code examples or alternative approaches
- **Key**: Use AI to understand and refine, not just to get answers
- Critically evaluate AI output â€“ does it make sense? Does it fit the problem?

Think of AI as a powerful assistant that helps you code while you learn.

# The Weather Forecaster: Putting It All Together

Our first major project combined these foundational concepts:

- Display a menu of weather checks (Temperature, Humidity, etc.)
- Handle user input for menu selection and weather data (e.g., temperature value)
- Implement decision logic (if-else) to provide a simple forecast message based on the input
- Focus on the Thinking phase (Steps 1-4) before Coding (Steps 5-6)

This project demonstrated how our methodology and Python fundamentals come together to solve real problems.

# Zero-Installation Development: Coding in the Cloud

We use cloud-based tools to code and manage our files.

**Google Colab:**
- Cloud-based Jupyter notebooks
- Write and run Python in your browser
- Zero installation required
- Ideal for learning and quick prototyping

**GitHub:**
- Version control system
- Store and manage your code files
- Collaborate with others
- Integrates with Google Colab for saving/loading notebooks

# Validating Your Code: Testing with Doctests

Testing completes our six-step methodology by verifying your code works correctly.

```python
def celsius_to_fahrenheit(celsius):
    """
    Convert Celsius temperature to Fahrenheit.
    
    Formula: F = (C * 9/5) + 32
    
    Examples:
    >>> celsius_to_fahrenheit(0)
    32.0
    >>> celsius_to_fahrenheit(100)
    212.0
    >>> celsius_to_fahrenheit(25)
    77.0
    """
    return (celsius * 9/5) + 32

# Running the tests is as simple as:
if __name__ == "__main__":
    import doctest
    doctest.testmod()  # Runs all doctests in the file
```

Key benefits of doctests:
- **Documentation + Testing**: Tests double as examples that document how to use your functions
- **Clear Expectations**: Shows exactly what inputs produce what outputs
- **Automatic Verification**: Easily check if changes break existing functionality
- **Ties directly to Step 6**: "Test with a variety of data" from our methodology

When your doctests pass, you have confidence your code works as intended!

# Beyond the Cloud: Setting Up Your Local Environment

As you progress in your programming journey, you may want to set up a local development environment:

1. **Install Python**: Download and install from python.org
2. **Choose an IDE/Editor**: Options include VS Code, PyCharm, or Sublime Text
3. **Set up version control**: Install Git locally and connect to GitHub
4. **Virtual environments**: Learn to use `venv` to manage project dependencies

Benefits of local development include offline access, better performance for larger projects, and more customization options.

# Your Programming Foundation: Ready for the Next Level

We've covered the essential building blocks of programming:

- **Core Concepts**: Input, Output, Variables, Data Types, Decision Making
- **Problem Solving**: Using the six-step methodology to break down challenges
- **Code Organization & Reusability**: Introducing Loops and Functions
- **Expanding Capabilities**: Leveraging Modules and Libraries
- **Modern Workflow**: Utilizing Google Colab and GitHub for a zero-install environment
- **Accelerated Learning**: Partnering with AI to enhance understanding and coding

These foundational skills and tools prepare you to tackle more complex problems and build increasingly sophisticated applications in your programming journey.
---
title: "Python Testing Frameworks: Your Quality Toolkit in the Age of AI"
subtitle: "Building Reliable Code with Human Insight and AI Assistance"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
    toc: false
    colorlinks: true
  docx:
    toc: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

# Focus of Today's Presentation:
    * Core concepts of Python testing frameworks (`doctest`, `unittest`, `pytest`).
    * How to leverage AI as your testing assistant.
    * Building a foundation for writing reliable code.

::: {.notes}
Welcome! AI tools are becoming powerful assistants in software development, you might wonder about the role of traditional practices like testing. This session introduces Python testing frameworks, not just as historical tools, but as essential components of your modern development toolkit. We'll explore how these frameworks, combined with your critical thinking and AI assistance, help you build reliable, maintainable, and high-quality Python applications. Our focus will be on understanding foundational concepts and how they are *amplified*, not replaced, by AI.

Today, we'll explore foundational Python testing frameworks like `doctest` for simple, documentation-based tests, and the more structured `unittest` and `pytest`. Crucially, we'll discuss how you can intelligently partner with AI to make your testing efforts more effective and efficient.

:::



# The "Why Test?" in the Age of AI**

* AI generates code, but who verifies its correctness and intent? **You do, with tests!**
* Testing provides the "ground truth" for AI-assisted refactoring and modifications.
* AI can *help write tests faster*, increasing your ability to build a safety net.
* Understanding testing fundamentals makes you a better collaborator with AI tools.

::: {.notes}

You've probably seen AI tools that can write code, suggest bug fixes, and even explain complex algorithms. So, why dedicate time to learning about testing frameworks? The answer is crucial: AI is a powerful assistant, but it's not infallible.
* When AI generates code, tests are what confirm it actually does what's intended and doesn't have subtle bugs.
* If you ask AI to refactor code, how do you know the new code still works? A solid test suite provides that confidence.
* AI can significantly speed up the process of writing tests, but *you* still need to understand what makes a good test and what needs to be tested.
:::



# Why Testing *Still* Matters (Enhanced)**

  * **Ensures Reliability & Quality:** Catches bugs before users (or AI-generated code) introduce them widely.
  * **Facilitates Safer Changes:** Refactor code (yours or AI's) with confidence, knowing tests guard against regressions.
  * **Acts as Living Documentation:** Tests clearly show how code is intended to be used â€“ invaluable for human and AI understanding.
  * **Provides a Safety Net:** AI-driven development can be fast; tests ensure speed doesn't compromise stability.
  * **Reduces Debugging Time:** Well-tested code leads to fewer, easier-to-diagnose bugs.

::: {.notes}

The fundamental benefits of testing haven't disappeared with AI; they've become even more pronounced.
* **Reliability and Quality:** Whether code is written by a human or an AI, it can have bugs. Tests are your first line of defense.
* **Safer Changes:** Imagine AI suggests a major refactor. Without tests, deploying that change is a high-risk gamble. With tests, it's a calculated, verifiable step.
* **Living Documentation:** Well-written tests, especially `doctests`, clearly demonstrate how your functions are supposed to work. This is vital for team members and even for AI tools trying to understand or modify your code later.
* **Safety Net:** As development cycles potentially speed up with AI assistance, having a robust test suite ensures you're not just moving fast but also maintaining stability. AI can even help *build* this safety net faster.
* **Reduced Debugging:** Fewer bugs make it into later stages, and when they do, tests often help pinpoint the cause much quicker.
:::



# Introduction to `doctest` â€“ Simple, Integrated Testing**

* Write tests directly in your function's docstrings.
* Examples look like interactive Python sessions.
* Excellent for simple functions and ensuring documentation is accurate.
* **AI Assistance:**
    * Prompt AI: "Generate `doctest` examples for this Python function, including edge cases."
    * AI can help ensure your documented examples are also effective tests.

::: {.notes}

Our first stop is `doctest`, a wonderfully simple way to integrate tests directly into your code's documentation. The tests are written as if you're typing them into a Python interpreter right in the docstring. This not only tests your code but also provides clear, executable examples of how to use it.
:::

# Doctest Example:
    ```python
    def add(a, b):
        """
        Adds two numbers.
        >>> add(2, 3)
        5
        >>> add(-1, 1)
        0
        """
        return a + b

import doctest
doctest.testmod()
```

::: {.notes}
* **AI Power-Up:** If you have a function, you can ask an AI, "Can you write some `doctest` examples for this function that cover typical usage and a couple of edge cases?" The AI can help you quickly populate your docstrings with useful tests. Always review these suggestions to ensure they accurately reflect the function's intent and cover meaningful scenarios. This is a great way to ensure your documentation is always up-to-date and correct because it *is* the test!
:::



# Introduction to `unittest`**

* Part of Python's standard library.
* Organises tests into classes and methods.
* Supports test automation, setup/teardown for tests.
* Follows xUnit style (familiar if you've seen JUnit, NUnit).
* **AI Assistance:**
    * Prompt AI: "Write `unittest` test cases for this Python function."
    * AI can help generate the class structure and assertion methods.

::: {.notes}

Next is `unittest`, Python's built-in framework that provides a more formal structure for your tests. It's an "xUnit" style framework, meaning tests are organised into classes that inherit from `unittest.TestCase`, and individual test scenarios are methods within those classes that typically start with `test_`. This structure is great for managing larger test suites and for tests that require setup (e.g., creating a temporary database) or cleanup after they run.
:::

# unittest example
    ```python
    import unittest

    class TestSum(unittest.TestCase):
        def test_sum(self):
            self.assertEqual(sum([1, 2, 3]), 6, "Should be 6")

    if __name__ == '__main__':
        unittest.main()
    ```

::: {.notes}
* **AI Power-Up:** Provide your function to an AI and ask, "Write `unittest` test cases for this function." AI can help generate the boilerplate `TestClass` structure, suggest appropriate `self.assert...` methods (like `assertEqual`, `assertTrue`, etc.), and even propose different test methods for various scenarios. Remember to critically review the generated tests: Do they cover the right conditions? Are the assertions meaningful?
:::



# Introduction to `pytest`**

* Popular third-party framework (install via `pip install pytest`).
* Simple, less verbose syntax (often just functions).
* Powerful features: fixtures, rich plugin ecosystem, detailed reporting.
* Easier to start with for many; scales well.
* **AI Assistance:**
    * Prompt AI: "Write `pytest` tests for this Python function."
    * AI can generate concise test functions and suggest fixture usage.

::: {.notes}
`pytest` is a widely adopted third-party testing framework loved for its simplicity and power. It often requires less boilerplate code than `unittest` â€“ you can frequently write tests as simple functions. `pytest` has a very expressive way of handling test setup and dependencies using "fixtures," and its plugin architecture allows for extensive customisation and integration with other tools.

:::

# pytest example

    ```python
    # import pytest # Not needed if pytest runs the file

    def test_sum():
        assert sum([1, 2, 3]) == 6, "Should be 6"
    ```

::: {.notes}
* **AI Power-Up:** As with `unittest`, you can ask an AI, "Write `pytest` tests for this Python function." AI tools are generally good at generating the straightforward `assert` statements that `pytest` favors. You might also ask, "Can you show me how to use a `pytest` fixture to provide test data for this function?" This helps you learn more advanced features with AI guidance. Always ensure the AI-suggested tests align with your function's logic and cover necessary cases.
:::



# Comparing `doctest`, `unittest`, and `pytest` (AI Lens)**

* **`doctest`:**
    * Pros: Simple, in-documentation, great for examples.
    * Cons: Less suited for complex tests or setup/teardown.
    * *AI Fit:* Excellent for AI to quickly populate docstrings with verifiable examples.
* **`unittest`:**
    * Pros: Standard library, xUnit structure, good for complex scenarios.
    * Cons: Can be verbose.
    * *AI Fit:* AI can generate boilerplate, suggest assertion methods, and help structure test classes.
* **`pytest`:**
    * Pros: Concise, powerful fixtures, rich ecosystem, less boilerplate.
    * Cons: Third-party (needs install).
    * *AI Fit:* AI excels at generating simple `assert` style tests; can help introduce fixture concepts.
* **Your Choice:** Depends on project, team, and complexity. AI can help you get started with *any* of them.

::: {.notes}

So, `doctest`, `unittest`, or `pytest`?
* **`doctest`** is fantastic for simple functions where tests also serve as clear documentation. AI can rapidly generate these examples for you.
* **`unittest`** is robust, part of Python itself, and its structured approach is beneficial for larger projects or when you need sophisticated setup/teardown. AI can lessen the burden of its verbosity by generating initial test structures.
* **`pytest`** often hits a sweet spot with its concise syntax and powerful features like fixtures, making it a favorite for many. AI can easily generate basic `pytest` tests and help you explore more advanced features.
The choice often comes down to the project's needs and team preference. The good news is that AI can assist you in writing tests regardless of the framework, lowering the barrier to entry for all of them. You might even use `doctest` for simple examples and `pytest` or `unittest` for more complex integration tests within the same project.
:::



# Writing Effective Test Cases (AI-Enhanced)**

* **Keep Tests Small & Focused:** One distinct behavior or scenario per test.
    * *AI Assist:* "Break down testing for this complex function into smaller, focused test cases."
* **Use Descriptive Names:** Clearly state what's being tested and the expected outcome.
    * *AI Assist:* "Suggest descriptive names for these `pytest` test functions based on what they test."
* **Test Positive & Negative Scenarios:** Verify correct behavior with valid inputs AND graceful handling of invalid inputs/errors.
    * *AI Assist:* "For this function, suggest `doctest` examples for both valid inputs and common error-inducing inputs."
* **Focus on Behavior, Not Implementation:** Test *what* the code does, not *how* it internally does it (makes tests less brittle).
    * *AI Assist (with caution):* "Write tests for the public API of this class, focusing on its observable behavior." (Requires careful prompting).
* **Human Review is Crucial:** AI generates; you validate, refine, and ensure tests are meaningful.

::: {.notes}

Regardless of the framework, effective tests share common qualities. And AI can help achieve them!
* **Small & Focused:** Each test should ideally check one specific thing. If a test fails, you'll know exactly where the problem lies. You can ask AI to help decompose testing for a complex piece of code.
* **Descriptive Names:** Good names make your test suite readable. AI can suggest names if you provide the test code or its purpose.
* **Positive & Negative Tests:** Don't just test the "happy path." What happens with bad data? Or edge cases? AI is great at brainstorming these: "What are some edge cases or invalid inputs I should test for this login function?"
* **Behavior, Not Implementation:** Test the "contract" of your function â€“ given these inputs, expect these outputs or side effects. Avoid testing internal private methods directly, as this makes your tests fragile if you refactor. Prompt AI carefully here.
* **Always, always review AI-generated tests.** Does it actually test what you intend? Is it clear? Is it robust? You are the final arbiter of test quality.
:::



# Navigating Pitfalls in Testing (Even with AI)
* **Testing Internal Implementation:** (As mentioned) Makes tests brittle.
    * *AI Risk:* AI might do this if not prompted to focus on public interfaces/behavior.
* **Skipping "Simple" Functions/Code:** "Obvious" code can still have bugs.
    * *AI Solution:* AI can generate tests for simple code so quickly, there's less reason to skip!
* **Non-Isolated Tests (Flaky Tests):** Tests that depend on each other or shared state.
    * *AI Risk:* AI might not automatically ensure isolation; human design of test structure and fixtures (for `pytest`/`unittest`) is key.
* **Ignoring Edge Cases:** Focusing only on typical inputs.
    * *AI Solution:* Actively prompt AI: "What are the edge cases for this function that I should test?"
* **Blindly Trusting AI Output:** Generated tests might be incomplete, incorrect, or test the wrong thing. **Critical human review is essential.**

::: {.notes}

While testing is powerful, there are common traps.
* **Testing Internals:** If you change how a function works internally (refactor) but its external behavior remains the same, tests focused on internals will break unnecessarily.
* **Skipping "Simple" Code:** Famous last words! AI can help by making it trivial to generate basic tests for these, removing the excuse.
* **Flaky Tests:** These are tests that sometimes pass and sometimes fail without code changes, often due to external dependencies or shared state. Designing for test isolation is a human skill, though AI might help refactor to improve it if asked specifically.
* **Ignoring Edge Cases:** These are the unusual inputs â€“ empty lists, seros, maximum values â€“ where bugs often hide. AI can be a great partner in brainstorming these.
* **The Biggest AI-Era Pitfall: Blind Trust.** Never assume AI-generated tests are perfect. They are a starting point. You must understand them, review them, and ensure they meet your quality standards and truly validate your code's intended behavior. Your critical thinking is the most important part of the process.
:::



# The Human-AI Partnership in Testing
* **You (the Developer):**
    * Understand requirements and intended behavior.
    * Design the overall testing strategy.
    * Critically evaluate and refine AI-generated tests.
    * Ensure tests are meaningful and maintainable.
    * Own the quality.
* **AI (the Assistant):**
    * Generates initial test code/examples rapidly.
    * Suggests edge cases and scenarios.
    * Helps explain framework syntax or concepts.
    * Can refactor tests for clarity (under your guidance).
    * Handles boilerplate.
* **Goal:** Leverage AI to do more thorough testing, faster, allowing you to focus on high-level design and critical thinking.

::: {.notes}

So, what does this all mean for you? Testing in the AI era is a partnership.
* You bring the deep understanding of what the software *should* do, the context, and the critical judgment. You design the strategy â€“ what needs testing and how thoroughly.
* AI brings speed, the ability to handle repetitive tasks like generating boilerplate test code, and a knack for suggesting things (like edge cases) you might have overlooked.
When you effectively combine your strengths with AI's capabilities, you can achieve a higher level of software quality and a more efficient testing process. You're still in the driver's seat; AI is your co-pilot.
:::



# Conclusion: Embarking on Your AI-Assisted Testing Journey
* Testing is more crucial than ever for verifying human *and* AI-generated code.
* Mastering a testing framework (`doctest`, `unittest`, `pytest`) is a key skill.
* Learn to prompt AI effectively to assist in your testing workflow.
* **Practice is key:** Write tests for your projects, experiment with AI assistance, and critically review the results.
* Explore further: Test-Driven Development (TDD), Behavior-Driven Development (BDD), advanced fixture usage, coverage tools (topics for future learning!).
* **Call to Action:** Start integrating testing, with AI as your partner, *early and often* in your development.

::: {.notes}

To wrap up, the core message is this: in an era where AI can generate and modify code at an unprecedented rate, the ability to write and understand tests is not just relevant â€“ it's a cornerstone of responsible and effective software development.
* Frameworks like `doctest`, `unittest`, and `pytest` provide the tools. Your intellect provides the strategy. AI provides the acceleration.
* The key is to practice. Take the functions you write and try to test them. Use `doctest` for simple cases. Experiment with `pytest` or `unittest`. Ask an AI to help you generate tests, then critically review and improve them.
* There's always more to learn â€“ concepts like Test-Driven Development, where you write tests *before* code, or tools for measuring test coverage, are exciting next steps.
But for now, focus on integrating these foundational testing practices, augmented by thoughtful AI collaboration, into your work. This will make you a stronger, more confident Python developer.
:::
---
title: "Supercharge Your Functions with Data"
subtitle: "Using Parameters, Arguments, and Defaults to Create Dynamic Code"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Passing Information to Functions

Welcome to Module 2! In this module, we'll learn how to send data into your functions. This allows you to make your functions more dynamic and flexible.

::: {.notes}
Passing information to functions is a fundamental concept in programming. Functions can accept input values, known as arguments, which are used within the function to perform specific tasks or calculations. These arguments are defined as parameters in the function definition, specifying the expected input values.

When calling a function, you provide the necessary arguments, which can be literals, variables, or expressions. The arguments are passed to the corresponding parameters in the function, allowing the function to operate on the provided values. By utilising parameters and arguments effectively, you can create reusable and modular code that can be easily customised for different scenarios.
:::

# Objectives

- Understand the difference between parameters and arguments.
- Learn how positional arguments work.
- Discover how to assign default values to parameters.

::: {.notes}
Presenter notes for "Objectives" slide:

This slide outlines the key learning objectives for the section on passing information to functions. Firstly, we'll clarify the distinction between parameters and arguments, which are often used interchangeably but have different meanings. Parameters are the variables defined in a function's definition, whereas arguments are the actual values passed to the function when it's called. Understanding this difference is crucial for working effectively with functions.

Next, we'll explore how positional arguments work. In Python, the order in which arguments are passed matters, and this is determined by the position of the corresponding parameters in the function definition. We'll look at examples to illustrate this concept. Lastly, we'll learn how to assign default values to parameters, which allows us to provide a fallback value if an argument isn't passed. This can make our functions more flexible and easier to use in different contexts.
:::

# Parameters vs. Arguments

- **Parameters:**  
  These are placeholders in your function definition. They represent the data your function needs.
- **Arguments:**  
  These are the actual values you pass into your function when you call it.
  
For example, in:
  
```python
def add_numbers(a, b):
    result = a + b
    print("The sum is", result)
```

`a` and `b` are parameters. When you call `add_numbers(3, 4)`, 3 and 4 are arguments.

::: {.notes}
Parameters are variables defined in a function declaration that receive values when the function is called. They act as placeholders for the values that will be passed to the function, allowing it to work with different data each time it is invoked. Parameters are specified within the parentheses of the function declaration, and they can have default values assigned to them.

Arguments, on the other hand, are the actual values passed to a function when it is called. These values are supplied within the parentheses of the function call and are used to replace the corresponding parameters in the function definition. The number and order of arguments must match the number and order of parameters in the function declaration unless default values are provided for the parameters.
:::

# Positional Arguments

- Arguments are passed into functions based on their order.
- The first argument goes to the first parameter, the second to the second parameter, and so on.
- This is why it is important to keep the order consistent when calling your function.

::: {.notes}
Positional arguments are passed into functions based on their order. The first argument corresponds to the first parameter, the second argument to the second parameter, and so forth. It is crucial to maintain consistency in the order of arguments when calling a function to ensure the intended behaviour and avoid unexpected results.

When using positional arguments, the position of each argument determines which parameter it is assigned to within the function. This means that if the order of the arguments is changed when calling the function, the values will be assigned to different parameters, potentially leading to errors or incorrect outputs. Therefore, it is important to be mindful of the order and provide the arguments in the same sequence as the function's parameter list.
:::

# Default Parameter Values

- You can assign a default value to a parameter in your function definition.
- This allows the function to be called even if one or more arguments are missing.
- Example:
  
```python
def describe_person(name, age=18):
    print(name + " is " + str(age) + " years old.")
```

In this function, if you don't provide an age, it defaults to 18.

::: {.notes}
Default parameter values allow functions to be called even when one or more arguments are not provided. In the function definition, a default value can be assigned to a parameter, which will be used if the corresponding argument is missing when the function is called. This provides flexibility and convenience, as it eliminates the need to specify every argument if some have suitable default values.

Here's an example to illustrate the concept: def greet(name, greeting="Hello"): print(f"{greeting}, {name}!") In this function, the "greeting" parameter has a default value of "Hello". If the function is called with only one argument, like greet("Alice"), the default value will be used, and the output will be "Hello, Alice!". However, if both arguments are provided, such as greet("Bob", "Hi"), the specified value will override the default, resulting in "Hi, Bob!".
:::

# Activity: Create Your Own Function

**Task:**  
Create a function named `describe_person` that takes two parameters: `name` and `age`.  
- Set the default value of `age` to 18.
- Inside the function, print a message that says, for example, "Alice is 18 years old."  
- Experiment by calling the function with both one and two arguments.

Take a moment to write your own version of `describe_person`.

::: {.notes}
In this activity, you will create your own function and experiment with passing arguments to it. Set the default value of the `age` parameter to 18, so that if no age is provided when calling the function, it will use 18 as the default. Inside the function, print a message that includes the name and age, such as "Alice is 18 years old."

After creating your function, call it with both one and two arguments to observe the difference in behaviour. First, call the function with just a name argument, and notice that the default age of 18 is used. Then, call the function again with both a name and an age argument, and see how the function uses the provided age instead of the default value. This practice will help solidify your understanding of how default parameter values work in functions.
:::

# Example Answer

Here's one way to write the function:

```python
def describe_person(name, age=18):
    print(name + " is " + str(age) + " years old.")

# Calling the function with both arguments
describe_person("Alice", 25)

# Calling the function with just the name; age defaults to 18
describe_person("Bob")
```

When you run this code, you'll see personalised messages based on the arguments you provide.

Happy coding, and enjoy exploring how passing information to functions can make your code more powerful!

::: {.notes}
The example answer demonstrates a basic function that takes two parameters, num1 and num2, and returns their sum. The function uses positional arguments, where the order of the arguments matters when calling the function. To use the function, you simply call it with two numbers, like add_numbers(5, 3), and it will return the result 8.

The example also shows how to set default parameter values. In this case, num2 has a default value of 10. This means that if you call the function with only one argument, like add_numbers(7), it will assume num2 is 10 and return 17. Default parameter values provide flexibility and allow the function to be called with fewer arguments when needed.
:::

---
title: "Unlocking Results with Returning Values"
subtitle: "How Your Functions Share Their Results with Your Code"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Unlocking Results with Returning Values

Welcome to Module 3! In this module, you'll learn how functions process data and send results back to your programme using the `return` statement.

::: {.notes}
The "Unlocking Results with Returning Values" slide serves as an introduction to the concept of using return statements in functions to produce output. It sets the stage for the subsequent slides, which will delve into the specifics of how the return statement works and provide examples to illustrate its usage.

The slide is part of a larger presentation that covers the fundamentals of returning values from functions. The other slides in the presentation include "The return Statement", which explains the syntax and purpose of the return statement; "Simple Arithmetic Example", which demonstrates how to use the return statement in a basic arithmetic function; "Activity: Calculate the Area of a Circle", which provides a hands-on exercise for learners to practice using the return statement; and "Recap", which summarises the key points covered in the presentation.
:::

# The return Statement

- **Purpose:**  
  The `return` statement sends a value back to the part of your code that called the function.
- **Why use it?**  
  Instead of printing a result immediately, returning a value lets you store and use that result later.
- **Key Difference:**  
  - **Printing:** Displays a value on the screen.  
  - **Returning:** Provides a value that can be used elsewhere in your code.

::: {.notes}
The return statement serves two main purposes in programming. It allows you to exit a function and optionally send a value back to the caller. Using return is beneficial when you need to terminate a function's execution early or when you want to provide a result that can be utilised in other parts of your code.

It's important to distinguish between printing and returning values. Printing simply displays a value on the screen for informational purposes. In contrast, returning a value using the return statement makes it available for further use and processing within your program, enabling more flexible and modular code design.
:::

# Simple Arithmetic Example

Consider a function that adds two numbers:

```python
def add_numbers(a, b):
    return a + b

result = add_numbers(5, 3)
print("The sum is", result)
```

- Here, `add_numbers` processes the numbers and returns the sum.
- We then store this result in the variable `result` and print it.

::: {.notes}
The slide "Simple Arithmetic Example" demonstrates how the `add_numbers` function processes the input numbers and returns their sum. This returned value is then assigned to the variable `result`, allowing us to store and utilise the computed sum for further operations or output.

By printing the `result` variable, we can display the sum of the numbers to the user, showcasing the successful execution of the `add_numbers` function and the returned value. This example highlights the importance of returning values from functions, enabling us to capture and work with the results of computations performed within the function's scope.
:::

# Activity: Calculate the Area of a Circle

**Your Task:**

- Create a function named `calculate_area` that:
  - Accepts one parameter: `radius`.
  - Calculates the area of a circle using the formula:  
    _Area = Ï€ Ã— radiusÂ²_  
    (You can use 3.14 as an approximation for Ï€.)
  - Returns the calculated area.
- Call your function and print the result.

**Example:**

```python
def calculate_area(radius):
    area = 3.14 * radius * radius
    return area

circle_area = calculate_area(5)
print("The area of the circle is", circle_area)
```

- Experiment with different radii to see how the area changes.

::: {.notes}
In this activity, you will create a function called `calculate_area` that takes the radius of a circle as a parameter. The function will use the well-known formula for calculating the area of a circle, which is Ï€rÂ², where Ï€ (pi) is approximately 3.14159 and r is the radius. Once the area is calculated, the function will return the result.

To test your function, call it with different radii and print the returned values. This will allow you to observe how the area changes as the radius is altered. By experimenting with various radii, you will gain a better understanding of the relationship between the radius and the area of a circle.
:::

# Recap

- The `return` statement lets a function send data back to the calling code.
- This technique allows you to use the results of a function in other parts of your programme.
- Practice writing functions that return values to become more confident in your coding skills.

Happy coding, and enjoy exploring the power of returning values from your functions!

::: {.notes}
In this slide, we recap the key points about returning values from functions. The `return` statement allows a function to send data back to the calling code, enabling you to use the results of the function in other parts of your programme. This is a powerful technique that can make your code more modular and reusable.

To become more confident in your coding skills, it's recommended that you practise writing functions that return values. By doing so, you'll gain a better grasp of how to structure your code and how to pass data between different parts of your programme. With time and practice, you'll find that using functions with return values becomes second nature and greatly improves the efficiency and readability of your code.
:::

---
title: "Unlock the Power of Functions"
subtitle: "Your First Step to Organised Python Code"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Welcome to Functions in Python

Welcome to our introduction to functions! In this module, you'll learn how functions help make your Python code more organised and easier to manage.

::: {.notes}
Welcome to Functions in Python! Functions are a fundamental concept in programming that allow you to organise your code into reusable blocks. By defining a function, you can encapsulate a specific task or computation, making your code more modular, readable, and maintainable.

In this presentation, we will explore what functions are, why they are useful, and how to define and call them in Python. We will cover the syntax for defining a function, including the def keyword, function name, parameters, and return values. Additionally, we will discuss how to call a function and pass arguments to it. By the end of this presentation, you will have a solid foundation in working with functions in Python.
:::

# What is a Function?

- A function is a reusable block of code that performs a specific task.
- Think of it like a mini-program that you can call whenever you need it.
- Using functions helps you avoid writing the same code over and over.

::: {.notes}
A function is a reusable block of code that performs a specific task, like a mini-program that you can call whenever you need it. By using functions, you can avoid writing the same code repeatedly, making your programs more efficient and easier to maintain.

Functions are a fundamental concept in programming and are essential for writing modular, reusable code. In this presentation, we'll explore why functions are useful, how to define and call them in Python, and see some examples of how they can be used to streamline your code.
:::

# Why Use Functions?

- **Organisation:** Break your code into manageable pieces.
- **Reusability:** Write a piece of code once and use it many times.
- **Clarity:** Make your programme easier to read and understand.

::: {.notes}
Functions are an essential tool for organising code into manageable pieces, making it more readable and understandable. By breaking down a programme into smaller, self-contained functions, each responsible for a specific task, the overall structure becomes clearer and easier to follow. This modular approach helps to reduce complexity and makes the code more maintainable, as changes can be made to individual functions without affecting the rest of the programme.

Functions also promote code reusability, allowing a piece of code to be written once and used multiple times throughout the programme. This eliminates the need for duplicating code, saving time and effort, and reducing the likelihood of errors. By encapsulating a specific task within a function, it can be called whenever that functionality is needed, leading to more efficient and streamlined code. Additionally, well-defined functions with clear input and output parameters make the code more self-explanatory and easier for other developers to understand and collaborate on.
:::

# Defining a Function

- Functions are defined with the keyword `def`.
- The basic syntax is:
  ```python
  def function_name():
      # code goes here
  ```
- Remember: The code inside the function must be indented.

::: {.notes}
Here are the presenter notes for the "Defining a Function" slide:

To define a function in Python, we use the `def` keyword followed by the function name and parentheses. Inside the parentheses, we can specify parameters that the function accepts. After the parentheses, we add a colon to indicate the start of the function block. The basic syntax is shown on the slide, where `function_name` is a descriptive name for the function and `parameter1`, `parameter2`, etc. are optional parameters that the function can receive.

It's crucial to remember that the code inside the function must be indented. Python uses indentation to define code blocks, so all the statements that are part of the function must be indented consistently, typically with four spaces or a tab. This indentation distinguishes the function body from the rest of the code. Failing to indent properly will result in syntax errors.
:::

# Calling a Function

- After you define a function, you need to call it to make it run.
- Example:
  ```python
  def say_hello():
      print("Hello, everyone!")
  
  say_hello()  # This line calls the function
  ```
- **Note:** The function definition must appear before you call the function.

::: {.notes}
After defining a function in Python, you must call it to execute the code within the function. The function call instructs Python to run the code inside the function, allowing you to utilise the function's functionality. For example, if you have defined a function named `greet()`, you can call it by simply writing `greet()` in your Python script.

It is crucial to remember that the function definition must appear before the function call in your Python script. Python reads the script from top to bottom, so if you attempt to call a function before it has been defined, you will encounter an error. By ensuring that your functions are defined before they are called, your script will execute smoothly and without issues.
:::

# Recap

- A function is a way to bundle code that performs a task.
- Defining and calling functions makes your code less repetitive and more organised.
- In your upcoming lab, you'll get hands-on experience writing and using functions!

Take a moment to review these ideas, and get ready to explore functions in our lab session. Happy coding!

::: {.notes}
Here are the presenter notes for the "Recap" slide:

Functions are a fundamental concept in Python programming that allow you to encapsulate code performing a specific task into a reusable unit. By defining functions, you can avoid repetition in your code and improve its overall structure and readability. Functions also promote modular design, as you can break down complex problems into smaller, more manageable parts.

In the upcoming lab, you will gain practical experience in defining and invoking functions. This hands-on practice will reinforce your understanding of how functions work and how they can be effectively used to solve problems. By writing and using functions yourself, you will develop a deeper appreciation for their benefits and learn how to incorporate them into your own Python programs.
:::

# Activity: Create Your Own Greeting Function

Try writing your very own function! Remember our early "Personalise Greeting" from labs? Now, lets make it a function?.  

**Task:**  
- Write a function named `greet()` that:
  - Uses the `input()` function to ask the user for their name.
  - Prints a personalised greeting message (for example, "Hello, [name]!").

Take a few minutes to try it out!

::: {.notes}
In this activity, you will create your own personalised greeting function called `greet()`. The function will use the built-in `input()` function to prompt the user to enter their name. Once the user has provided their name, the function will store it in a variable for further use.

After obtaining the user's name, the `greet()` function will print a customised greeting message. The message will incorporate the user's name, creating a personalised experience. For instance, if the user enters "Alice" as their name, the function will output "Hello, Alice!" or a similar greeting tailored to the user.
:::

# Answer: A Personalised Greeting Function

Here's one way to write the `greet()` function using the `input()` function inside it:

```python
def greet():
    name = input("Enter your name: ")
    print("Hello, " + name + "!")
    
greet()  # Calling the function to see it in action
```

In this solution, when you call `greet()`, the programme asks for your name and then prints a greeting just for you. Enjoy experimenting with your own greetings!

::: {.notes}
To create a personalised greeting function, we can modify the simple greeting function to accept a name parameter. Inside the function, we concatenate the "Hello" string with the provided name to create a customised greeting message. Finally, we print this personalised message when the function is called.

When calling the personalised greeting function, we pass in the desired name as an argument. This allows us to reuse the function with different names, generating unique greetings for each person. By utilising parameters, we can create flexible and reusable functions that adapt their behaviour based on the input provided.
:::

---
title: "Broaden Your Horizons with Modules"
subtitle: "Using External Libraries to Elevate Your Python Programmes"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Expanding Your Code with Modules

Welcome to Module 4! In this module, you'll learn how to import and use external modules to extend the capabilities of your code. For business information students, using modules like `datetime` can be very practical.

::: {.notes}
Modules are an essential part of expanding your code in Python. They allow you to access pre-written code and functionality, saving you time and effort. By importing modules, you can leverage the work of other developers and avoid reinventing the wheel. Modules also help keep your code organised and maintainable, as you can separate different parts of your program into distinct modules.

In this slide, we'll explore the basics of importing modules and discuss why they are so useful. We'll also look at a simple demonstration using the datetime module to show how easy it is to start using modules in your own code. By the end of this section, you'll have a good understanding of how to use modules to expand the capabilities of your Python programs.
:::

# Objectives

- Understand what modules are and why they are useful.
- Learn the basics of import syntax.
- See how pre-written libraries can simplify your coding tasks.

::: {.notes}
Modules are self-contained units of code that can be imported into your Python programs to provide additional functionality. By breaking code into modules, you can make your programs more organised, easier to understand, and simpler to maintain. Modules also allow you to reuse code across multiple projects, saving time and effort.

In this presentation, we will cover the basics of import syntax, which is how you bring modules into your code. We will also explore how using pre-written libraries can simplify coding tasks and help you avoid reinventing the wheel. By the end of this presentation, you should have a solid understanding of what modules are, how to import them, and why they are such a valuable tool for Python programmers.
:::

# Import Syntax Basics

- **Using `import module`:**  
  This imports the entire module.  
  Example:
  ```python
  import datetime
  now = datetime.datetime.now()
  print("Current date and time:", now)
  ```
- **Using `from module import function`:**  
  This imports only the specific function you need.  
  Example:
  ```python
  from datetime import datetime
  now = datetime.now()
  print("Current date and time:", now)
  ```
- Choose the method based on your needs and the size of the module.

::: {.notes}
There are two main methods for importing modules in Python. The first method is using the `import module` syntax, which imports the entire module and requires you to prefix each function or variable with the module name when using them. The second method is using the `from module import function` syntax, which allows you to import specific functions or variables from a module directly into your namespace, so you can use them without the module prefix.

When deciding which method to use, consider the size of the module and your specific needs. If you only require a few functions from a large module, it may be more efficient to import them individually using the `from module import function` syntax. However, if you need to use many functions or variables from a module, or if you want to avoid potential naming conflicts, it may be better to use the `import module` syntax and prefix each function or variable with the module name.
:::

# Why Import Modules?

- **Reusability:**  
  Use pre-written, well-tested code to perform common tasks.
- **Organisation:**  
  Keep your code clean by separating functionality into different modules.
- **Efficiency:**  
  Save time by leveraging libraries that handle complex tasks for you.
- **Business Relevance:**  
  Modules like `datetime` are essential for tasks such as time-stamping transactions or scheduling.

::: {.notes}
Importing modules in Python allows for reusability of code, enabling developers to leverage pre-existing functions and classes without having to write everything from scratch. This promotes organisation by keeping code modular and easy to maintain, as related functionality can be grouped together in separate modules. Efficiency is also improved, as importing modules reduces development time and allows for the use of optimised code written by experienced programmers.

From a business perspective, importing modules is highly relevant as it enables rapid development of robust, maintainable applications. By leveraging existing code, businesses can save time and resources, allowing them to focus on their core competencies and deliver value to their customers more quickly. Additionally, using well-established modules can help ensure the reliability and security of the application, which is crucial for businesses operating in today's digital landscape.
:::

# Simple Demonstration with the Datetime Module

Let's see a simple example using the `datetime` module:

```python
from datetime import datetime

# Get the current date and time
current_time = datetime.now()
print("Current date and time:", current_time)
```

This code snippet imports the `datetime` function from the datetime module, gets the current date and time, and prints it out. This can be very useful in business applications where tracking the current time is essential.

::: {.notes}
This slide demonstrates how to use the datetime module in Python to work with dates and times. The datetime module provides classes for manipulating dates and times, allowing you to perform operations such as formatting dates, calculating time differences, and handling time zones.

By importing the datetime module, you can easily create datetime objects representing specific dates and times. You can then use the various methods and attributes provided by the datetime classes to extract information like the year, month, day, hour, minute, and second from these objects. The datetime module also supports arithmetic operations on dates and times, enabling you to add or subtract time intervals and compare dates.
:::

# Activity: Explore a Module

**Your Task:**

- Write a small script that imports the `datetime` module.
- Use it to display:
  - The current date.
  - The current time.
- Experiment with formatting the output using the module's features (for example, displaying just the date or time).

Take some time to explore how modules can make your code more powerful and applicable to real-world business scenarios.

Happy coding, and enjoy expanding your Python skills with modules!

::: {.notes}
In this activity, you will explore the `datetime` module by writing a small script that imports it. The script should use the module to display the current date and time. Experiment with formatting the output using the module's features, such as displaying just the date or time.

The `datetime` module is a powerful tool for working with dates and times in Python. By learning how to use this module, you will be able to incorporate date and time functionality into your programs, which can be useful for a wide range of applications, such as scheduling, logging, and data analysis.
:::

---
title: "First Command: print()"
subtitle: "Displaying Output on the Screen"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# In this module, you will learn

  - How to display output using print()
  - Common mistakes to avoid
  - Best practices for using print()

::: {.notes}
This module will cover the fundamentals of displaying output using the `print()` function in Python. You will learn how to effectively use `print()` to show results, messages, and other information to users, which is a critical skill for any Python programmer.

The module will also discuss common mistakes to avoid when working with `print()`, such as forgetting to include parentheses or quotation marks, or using incompatible data types. Additionally, you will learn best practices for using `print()`, including how to format output, use escape characters, and print multiple items efficiently.
:::

# Introduction to `print()`

- `print()` is used to display output on the screen.
- Basic syntax: `print("Hello, World!")`
- Always use **parentheses** with `print()`.
- **Strings** must be enclosed in quotation marks.

::: {.notes}
`print()` is a fundamental function in Python used to display output on the screen. Its basic syntax is `print("Hello, World!")`, where the desired output is enclosed in parentheses and surrounded by quotation marks if it is a string. It is crucial to always use parentheses with `print()`, as failing to do so will result in an error.

When working with `print()`, it is important to keep in mind that strings must be enclosed in either single or double quotation marks. Forgetting to include quotation marks or mismatching them is a common error that can prevent the code from running correctly. By following these basic guidelines and being mindful of syntax, you can effectively use `print()` to display output and communicate information to the user.
:::

# Why `print()` is Important

- Helps check if your code is working.
- Debugging tool: find mistakes and track errors.
- Outputs text to the screen for user interaction.

::: {.notes}
print() is a fundamental function in Python that helps developers check if their code is working as expected. It serves as a valuable debugging tool, allowing programmers to identify mistakes, track errors, and gain visibility into the execution flow of their programs. By strategically placing print() statements throughout the code, developers can output relevant information and variable values, making it easier to pinpoint issues and resolve them efficiently.

Moreover, print() plays a crucial role in facilitating user interaction by outputting text to the screen. Whether it's displaying prompts, results, or messages, print() enables effective communication between the program and the user. By leveraging print() to provide meaningful output, developers can create interactive and user-friendly applications that engage and inform users throughout the execution process.
:::

# Common Errors with `print()`

1. **Missing Parentheses**
   - âŒ `print "Hello"`
   - âœ… `print("Hello")`
2. **Missing Quotation Marks**
   - âŒ `print(Hello)`
   - âœ… `print("Hello")`
3. **Case Sensitivity**
   - âŒ `Print("hello")`
   - âœ… `print("hello")`
4. **Misspellings**
   - âŒ `pint("Hello")`
   - âœ… `print("Hello")`
5. **Indentation Errors**
   - âŒ `    print("Hello")` (extra spaces)
   - âœ… `print("Hello")` (no extra spaces)

::: {.notes}
This slide  highlights several mistakes that programmers often make when using the `print()` function in Python. These errors include forgetting to use parentheses, omitting quotation marks around string literals, capitalising the function name, misspelling `print()`, and adding extra spaces before the function call. Each incorrect example is marked with a cross emoji, while the correct usage is indicated with a tick emoji.

To avoid these common pitfalls, programmers should pay close attention to the syntax of the `print()` function. The function name should be written in lowercase letters, followed by a set of parentheses containing the value or variable to be printed. String literals must be enclosed in either single or double quotation marks. Proper indentation is also crucial in Python, so any leading spaces before the `print()` function call should be removed. By keeping these guidelines in mind, programmers can ensure that their `print()` statements work as intended and produce the desired output.
:::

# Fix the Errors

- Identify and correct common mistakes in the following lines:
  ```python
  PRINT("Hello")
  print(Hello)
  pint("Hello")
  print("Missing parenthesis"
      print("Indentation error!")
  ```
- What errors do you see?
- Correct and run the fixed code.

::: {.notes}
This slide, focuses on identifying and correcting common mistakes in the provided lines of code. The presenter should guide the audience through the process of analysing the code snippets, encouraging them to spot the errors independently before revealing the solutions.

After discussing the errors and their potential fixes, the presenter should demonstrate running the corrected code to showcase the expected output. This hands-on approach will help reinforce the importance of attention to detail and the impact of even small errors on the functionality of the code.
:::

# Best Practices for `print()`

- Always use **parentheses** with `print()`.
- Enclose text in **quotation marks**.
- Watch out for **indentation errors**.
- **Spell `print` correctly** (avoid typos like `pint`).
- Keep your code **clean and readable**.

::: {.notes}
Always use parentheses when calling the `print()` function in Python. This is the correct syntax and ensures your code will run without errors. Enclose the text you want to print in quotation marks, either single or double quotes. Be careful with indentation, as incorrect indentation can lead to errors in Python. Remember, consistent indentation is crucial for defining code blocks.

Watch out for common typos when writing `print()`, such as `pint()`. These mistakes can cause frustrating errors that are easily avoided by double-checking your code. Aim to write clean and readable code by using clear variable names, adding comments where necessary, and following Python's style guidelines (PEP 8). This will make your code easier to understand and maintain, both for yourself and others who may work with your code in the future.
:::

# Key Takeaways: Working with print()

**Remember These Core Points**:
- print() displays output on your screen
- Always use parentheses and correct quotation marks
- Case sensitivity matters: print(), not Print()

**Next Steps**:
- Practice identifying and fixing common errors
- Start using print() in your own code
- Build confidence with this fundamental command

::: {.notes}
print() is a fundamental command in Python that displays output on the screen. To use it effectively, always include parentheses and the correct quotation marks around the text or variables you want to display. Python is case-sensitive, so make sure to write print() and not Print(). As you start incorporating print() into your own code, take the time to practice identifying and fixing common errors, such as missing parentheses or quotation marks.

Building confidence with print() is key to progressing in Python. Once you understand how to use this command correctly, you'll be able to display useful information for debugging and communicating with users. Don't be afraid to experiment with print() in your code, as it's a valuable tool for understanding what your program is doing at each step. With practice, you'll soon be using print() with ease and reaping the benefits of this essential Python command.
:::

---
title: "Setting Up Your Tools"
subtitle: "Colab Noteboooks & GitHub"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# In this module

- Learn essential tools for Python development
- Master Google Colab for cloud-based coding
- Understand GitHub for version control
- Discover how AI can accelerate your learning
- Get hands-on practice with real examples

::: {.notes}
In this module, you'll gain essential skills for Python development using powerful tools like Google Colab and GitHub. You'll learn how to create and run Python code in the cloud with Colab, and how to use GitHub for version control and collaboration. By the end of this module, you'll have hands-on experience with real-world examples and be ready to apply these tools to your own projects.

Throughout the module, we'll explore how AI can accelerate your Python learning journey. You'll discover practical examples of integrating AI into your workflow, and learn about AI tools specifically designed for Python development and learning. By leveraging these cutting-edge technologies, you'll be well-equipped to tackle complex problems and build innovative solutions with Python.
:::

# What is Google Colab?

- Cloud-based Jupyter Notebook environment
- No installation required
- Free GPU access for AI projects
- Ideal for learning Python in a browser

::: {.notes}
Google Colab is a cloud-based Jupyter Notebook environment that allows users to write and execute Python code directly in their web browser, without the need for any local installation. This makes it an ideal platform for learning Python, as users can start coding immediately without worrying about setting up a development environment. Additionally, Google Colab offers free access to GPUs, which is particularly useful for AI and machine learning projects that require significant computational power.

One of the key advantages of using Google Colab is its simplicity and accessibility. Users only need a Google account to get started, and they can create, save, and access their notebooks from anywhere with an internet connection. This makes it easy for learners to collaborate on projects, share their work, and learn from others in the community. Furthermore, Google Colab integrates seamlessly with other Google services, such as Google Drive and Google Sheets, allowing users to import and export data easily.
:::

# Getting Started - Google Account Required

- A **Google Account** is required to use Google Colab.
- Sign in at [colab.research.google.com](https://colab.research.google.com).
- Notebooks are stored in Google Drive.
- Can be shared and collaborated on in real-time.

::: {.notes}
To use Google Colab, you must have a Google Account. Sign in at colab.research.google.com to access the platform. Once you're signed in, your notebooks will be stored in your Google Drive, making it easy to access them from anywhere.

One of the great features of Google Colab is its collaborative capabilities. You can share your notebooks with others and work on them together in real-time, just like you would with a Google Doc. This makes it an excellent tool for team projects and group learning.
:::

# Creating Your First Notebook

- Go to Google Colab.
- Click **File > New Notebook**.
- A new notebook with a code cell will appear.
- Start writing Python code!

::: {.notes}
To create your first notebook in Google Colab, simply navigate to the Google Colab website and click on "File" in the top menu, then select "New Notebook". This will open a fresh notebook with a code cell ready for you to start writing Python code straight away.

The process of creating a new notebook in Google Colab is quick and easy, allowing you to dive right into coding without any setup or installation required. With the notebook open, you can immediately begin experimenting with Python code, exploring libraries, and building your projects in a user-friendly, cloud-based environment.
:::

# Running Your First Python Code

- Click inside a code cell.
- Type: `print("Hello, World!")`
- Press **Shift + Enter** to execute the code.
- See the output immediately!

::: {.notes}
Running your first Python code in Google Colab is straightforward. Simply click inside a code cell and type the line `print("Hello, World!")`. Once you've entered the code, press **Shift + Enter** to execute it. The output will appear immediately below the code cell, allowing you to see the results of your code instantly.

Google Colab provides an intuitive and user-friendly environment for running Python code. With the ability to execute code directly in the browser, you can quickly test and iterate on your Python scripts without the need for any additional setup. This makes it an ideal platform for beginners learning Python or for experienced developers who want to prototype ideas rapidly.
:::

# Saving and Accessing Notebooks

- Notebooks are auto-saved in **Google Drive**.
- Download as `.ipynb` or `.py` for offline use.
- Shareable via link for collaboration.
- We will be using GitHub

::: {.notes}
Google Colab notebooks are automatically saved in Google Drive, providing a convenient and secure storage solution. Users have the option to download the notebooks in either `.ipynb` or `.py` format for offline use, allowing for flexibility in working environments. The notebooks can also be easily shared with others via a shareable link, facilitating seamless collaboration among team members.

While Google Colab offers built-in saving and sharing features, the course will also utilise GitHub as an additional platform for notebook management. GitHub provides version control and collaborative features that complement Google Colab's functionality. By integrating GitHub into the workflow, users can effectively track changes, manage multiple versions of their notebooks, and collaborate with others on a larger scale.
:::

# Why Use GitHub?

- **Version control** â€“ Keep track of code changes over time.
- **Collaboration** â€“ Work with peers and instructors.
- **Backup & Accessibility** â€“ Access notebooks from any device.
- **Integration with Google Colab** â€“ Save directly from Colab to GitHub.

::: {.notes}
GitHub is an essential tool for version control, collaboration, backup, and accessibility when working with code. It allows you to keep track of changes to your code over time, ensuring that you can easily revert to previous versions if needed. GitHub also facilitates seamless collaboration with peers and instructors, enabling you to work together on projects and share your code with others.

In addition to its version control and collaboration features, GitHub provides a reliable backup solution for your code and notebooks. By storing your work on GitHub, you can access your notebooks from any device with an internet connection, giving you the flexibility to work from anywhere. Furthermore, GitHub integrates seamlessly with Google Colab, allowing you to save your notebooks directly from Colab to your GitHub repository, streamlining your workflow and ensuring that your work is always up to date.
:::

# Setting Up GitHub in Google Colab

- A **GitHub account** is required ([Sign up](https://github.com/))
- Authorize **Google Colab** to access GitHub.
- Create a new **repository** or use an existing one.

::: {.notes}
Setting up GitHub in Google Colab is a straightforward process that requires a GitHub account. If you don't have one, you can easily sign up on the GitHub website. Once you have an account, you need to authorise Google Colab to access your GitHub repositories. This allows seamless integration between the two platforms, enabling you to save and manage your Colab notebooks using version control.

After linking your GitHub account, you can either create a new repository or use an existing one to store your Colab notebooks. Creating a dedicated repository for your Colab projects helps keep your work organised and easily accessible. With GitHub set up, you're ready to start saving, sharing, and collaborating on your Colab notebooks, leveraging the power of version control and the convenience of cloud-based development.
:::

# Connecting Google Colab to GitHub

- Open **Google Colab**.
- Click **File > Save a Copy in GitHub**.
- Select a repository and add a commit message.
- Click **OK** to upload.

::: {.notes}
To connect Google Colab to GitHub, start by opening Google Colab in your web browser. Once the Colab interface loads, click on the "File" menu and select "Save a Copy in GitHub" from the dropdown options. This will initiate the process of linking your Colab notebook to a GitHub repository.

After selecting "Save a Copy in GitHub", a new window will appear prompting you to choose a repository where you want to save your notebook. Select the desired repository from the list and enter a commit message to describe the changes you're making. Once you've chosen the repository and added a commit message, click the "OK" button to finalise the upload process and establish the connection between your Colab notebook and the selected GitHub repository.
:::

# Retrieving and Updating Notebooks from GitHub

- Open a **GitHub repository**.
- Click on the **notebook file (.ipynb)**.
- Click **Open in Colab** to edit.
- After modifications, **save back to GitHub**.

::: {.notes}
To retrieve and update notebooks from GitHub, start by opening the GitHub repository containing your notebook files. Locate the specific notebook you wish to edit, identifiable by the .ipynb file extension, and click on it. GitHub will display a preview of the notebook's contents. To make changes, click the "Open in Colab" button, which will launch the notebook in Google Colab, a cloud-based Python development environment.

Once you've made the necessary modifications to your notebook in Google Colab, save the changes by clicking the "File" menu and selecting "Save a copy in GitHub". This action will commit the updated notebook back to your GitHub repository, ensuring that the latest version is accessible for future reference or collaboration. By following these steps, you can seamlessly retrieve notebooks from GitHub, make edits in Google Colab, and push the changes back to the repository, streamlining your workflow and facilitating effective version control.
:::

# Best Practices for Saving Notebooks

- Write **clear commit messages** (e.g., "Updated data analysis section").
- Regularly **push updates** to GitHub to prevent data loss.
- Use **branches** for experimental changes before merging into the main repository.
- Keep notebooks **organized** within folders in your repository.

::: {.notes}
When saving notebooks in Google Colab, it's important to follow best practices to ensure your work is organised, secure, and easily accessible. Write clear commit messages that concisely describe the changes you've made, such as "Updated data analysis section", to help you and your collaborators understand the progress of your project. Regularly push updates to GitHub to prevent data loss and maintain a backup of your work in case of any unexpected issues with Google Colab.

To keep your repository clean and manageable, use branches for experimental changes before merging them into the main repository. This allows you to test new ideas without affecting the main codebase. Additionally, keep your notebooks organised within folders in your repository, making it easier to navigate and find specific files when needed. By following these best practices, you'll create a more efficient and productive workflow while collaborating with others on your Google Colab projects.
:::

# Common Issues and Fixes

- **Can't access Google Colab?** Check if you're logged into a Google Account.
- **Code not running?** Check for syntax errors in your Python code.
- **Authorization errors** â€“ Ensure Google Colab has GitHub access.
- **Repository not showing?** â€“ Refresh Colab or check GitHub permissions.
- **Failed to save?** â€“ Check internet connection or re-authenticate.

::: {.notes}
This slide covers common issues you may encounter when working with Google Colab and GitHub, along with their respective solutions. If you can't access Google Colab, the first step is to ensure you're logged into a valid Google Account. Code not running is often due to syntax errors in your Python code, so double-check for any mistakes. Authorization errors can be resolved by granting Google Colab access to your GitHub account. If your repository isn't showing up, try refreshing Colab or verifying your GitHub permissions.

Lastly, if you're unable to save your work, check your internet connection and re-authenticate if necessary. These troubleshooting tips should help you overcome the most frequent obstacles and maintain a smooth workflow between Google Colab and GitHub. Don't hesitate to refer back to this slide if you run into any of these issues during your hands-on practice session or future projects.
:::

# Hands-on Practice

- Save a sample notebook to GitHub.
- Retrieve and modify it from GitHub.
- Commit changes with a clear message.
- Open your updated notebook in Colab.

::: {.notes}
Save a sample notebook to your GitHub repository, then retrieve and modify it from GitHub. When committing changes, use a clear and descriptive message to document the modifications made. Once the changes are committed, open the updated notebook in Google Colab to confirm the changes have been successfully applied.

This hands-on practice reinforces the concepts covered in the previous slides, such as setting up GitHub in Google Colab, connecting Google Colab to GitHub, and retrieving and updating notebooks from GitHub. By following best practices for saving notebooks and providing clear commit messages, you can effectively manage your notebooks and collaborate with others on your Python projects.
:::

# How AI Can Accelerate Your Python Learning

- **AI-Powered Code Suggestions:**  
  Tools like GitHub Copilot and ChatGPT offer real-time code completions and ideas.
  
- **Instant Explanations & Debugging:**  
  Use AI to explain error messages, clarify complex code segments, and suggest fixes.
  
- **Generate & Refactor Code:**  
  Let AI propose code samples or refactor existing code to improve efficiency.
  
- **Access to Summarized Documentation:**  
  Quickly get overviews of Python libraries and algorithms to enhance understanding.


---

::: {.notes}
* AI can provide intelligent code suggestions as you type, helping you write Python code faster and more efficiently. It can recommend relevant libraries, functions, and syntax based on your context, reducing the need for manual lookups and speeding up your coding process.

* AI can explain code snippets, identify potential bugs, and suggest fixes, saving you time in debugging. It can generate and refactor code based on your requirements, handle repetitive tasks, and provide summarized documentation, making it easier to understand and use new libraries or frameworks in your Python projects.
:::

# Practical Examples: Integrating AI in Your Workflow

- **Debugging Assistance:**  
  Paste error messages into ChatGPT for step-by-step debugging help.
  
- **Real-Time Code Suggestions:**  
  Use GitHub Copilot in Google Colab to get instant code completions and alternative approaches.
  
- **Learning New Libraries:**  
  Ask AI for concise summaries and usage examples when exploring unfamiliar Python libraries.
  
- **Interactive Q&A Sessions:**  
  Engage with AI to answer questions about Python syntax, logic, and best practices during your coding sessions.

::: {.notes}
Practical examples of integrating AI into your Python workflow include debugging assistance, where AI can help identify and fix errors in your code, saving you time and frustration. AI can also provide real-time code suggestions, offering intelligent recommendations as you type, which can improve your coding efficiency and help you discover new ways to solve problems. When learning new libraries, AI can quickly provide relevant documentation, usage examples, and answers to your questions, accelerating your learning process. Interactive Q&A sessions with AI allow you to dive deeper into Python concepts, clarify doubts, and receive personalised explanations tailored to your level of understanding.

By leveraging these AI-powered tools and techniques, you can streamline your Python development process, overcome challenges more easily, and expand your knowledge at a faster pace. Whether you're a beginner or an experienced programmer, integrating AI into your workflow can help you write better code, learn new concepts efficiently, and solve complex problems with greater ease. As you continue to explore the possibilities of AI in Python development, you'll find even more ways to enhance your productivity and take your skills to the next level.
:::

# AI Tools for Python & Learning

| AI Tool | Coding (Python) | Setup Difficulty |
|---|---|---|
| ChatGPT (OpenAI) | Excellent | Easiest (Sign up) |
| Gemini (Google) | Good | Easiest (Google account) |
| LLaMA (Meta AI) | Good | Medium (Technical setup) |
| Claude (Anthropic) | Good | Easiest (Sign up) |
| GitHub Copilot | Excellent | Easy (Extension install) |
| Perplexity.ai | Good | Easiest (Web access) |
| Bing (Microsoft) | Good | Easiest (Built-in) | 
| Leo (Brave) | Basic | Easiest (Built-in) |
| Bard (Google) | Good | Easiest (Google account) |
| Hugging Face | Varies | Medium (Technical knowledge) |
| DeepSeek AI | Excellent | Medium (Technical knowledge) |
| Phi (Microsoft) | Good | Medium (Technical knowledge) |

**Disclaimer:** This infographic is for informational purposes only.  The AI landscape is constantly changing.  Verify the information and consider your specific needs before choosing an AI model or tool.  This is not an exhaustive list, and other excellent AI models and tools are available.  Always review the terms of service and privacy policies of the respective providers.

::: {.notes}
AI tools like ChatGPT can accelerate your Python learning by providing instant explanations, code examples, and troubleshooting help. These AI assistants can answer your Python questions, clarify concepts, and even help you write and debug code. They're like having a personal Python tutor available 24/7.

Integrating AI into your Python workflow can boost your productivity and capabilities. For example, you can use AI to auto-generate boilerplate code, refactor existing code, and even get AI-powered code suggestions and completions as you type. AI can also help with tasks like data analysis, visualisation, and machine learning in Python.
:::

# Key Takeaways

  - Google Colab for cloud-based Python development
  - GitHub for version control and collaboration
  - Saving and retrieving work from GitHub
  - Access to powerful AI coding assistants
  - Enhanced learning through AI-powered tools
  - Faster development with intelligent suggestions

::: {.notes}
In this slide, we've highlighted the key takeaways from our exploration of using Google Colab and GitHub for Python development. Google Colab provides a cloud-based platform that allows you to write and run Python code without the need for local setup, while GitHub enables version control and collaboration, making it easy to save, retrieve, and share your work with others. By leveraging these tools, you can access powerful AI coding assistants that offer intelligent suggestions and help accelerate your development process.

Moreover, we've discussed how AI-powered tools can enhance your learning experience by providing tailored guidance and real-time feedback. These tools can help you grasp complex concepts more quickly and efficiently, enabling you to focus on applying your knowledge to practical projects. As you continue your Python journey, remember to take advantage of these resources to streamline your workflow and unlock new possibilities in your programming endeavours.
:::

# Next Steps

Start practising with these tools by creating your first notebook and connecting it to GitHub. Remember that mastering these foundational tools will accelerate your Python learning journey.

::: {.notes}
- Explore the wealth of resources available, such as online tutorials, coding challenges, and open-source projects to continue honing your Python skills and expanding your knowledge of AI applications
- Consider joining coding communities, attending workshops or conferences, and collaborating with others to stay motivated, learn from shared experiences, and discover new opportunities to apply your skills in real-world projects
:::

---
title: "Introduction to AI-First Python"
subtitle: "Build real-world business projects with AI-assisted learning!"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# In this module, you will learn

- Learn Python with AI-powered assistance
- Focus on practical, hands-on coding
- Build real business applications
- Master essential development tools
- Make learning efficient and engaging

::: {.notes}
In this module, you'll learn Python through AI-powered assistance that focuses on practical, hands-on coding. You'll build real business applications while mastering essential development tools, making the learning process efficient and engaging.

The AI-first approach will guide you in applying Python to solve real-world problems, providing support and feedback along the way. By working on concrete projects, you'll gain valuable experience and a deep understanding of Python's capabilities in a business context.
:::

# AI-First Python: Build real-world business projects with AI-assisted learning!

- Learn Python efficiently and effectively
- Build long-term programming skills
- Engage in hands-on coding
- Make learning fun and interactive

::: {.notes}
Learn Python programming efficiently and effectively through our AI-assisted course, designed to help you build long-term coding skills for real-world business applications. Our hands-on approach ensures you actively engage in the learning process, making it both fun and interactive.

This course employs a flipped classroom methodology, providing you with the tools and best practices needed to study, practice, and master Python programming. With AI as your coding assistant, you'll develop the knowledge and skills required to tackle complex business projects, while our focus on active learning ensures lasting results.
:::

# Why Python?!

- **Easy to learn** â€“ Simple syntax, beginner-friendly
- **Powerful** â€“ Used in data science, web dev, AI, etc.
- **Widely used** â€“ Popular in industry and academia

::: {.notes}
Python is an excellent language for beginners and experienced programmers alike. Its simple, intuitive syntax makes it easy to learn, even for those with no prior coding experience. Despite its beginner-friendly nature, Python is a powerful language used in various domains such as data science, web development, and artificial intelligence, demonstrating its versatility and robustness.

Python's widespread popularity in both industry and academia is a testament to its usefulness and practicality. Many leading companies and educational institutions have adopted Python, ensuring that skills acquired in this language are highly sought-after in the job market. Python's extensive library ecosystem and supportive community further contribute to its appeal, providing developers with a wealth of resources and tools to tackle diverse challenges efficiently.
:::

# Python for Business Applications

- Automate repetitive tasks (e.g., sending emails to customers)
- Process and analyse data
- Build AI-powered business tools

::: {.notes}
Python is a versatile language that can be used to automate repetitive tasks in business, such as sending emails to customers, saving time and reducing errors. It also provides powerful libraries for processing and analysing data, enabling businesses to gain valuable insights and make data-driven decisions.

Furthermore, Python can be used to build AI-powered business tools, such as chatbots and recommendation systems, which can improve customer experience and streamline operations. With its simplicity, flexibility, and extensive ecosystem, Python is an excellent choice for developing business applications that leverage the power of AI.
:::

# Course Projects & Expectations

- Hands-on projects from Day 1
- Build real-world Python applications (e.g., a program to analyse sales data)
- Learn through practical problem-solving

::: {.notes}
In this module, you'll engage in practical projects from the very beginning, enabling you to apply your Python skills to real-world business scenarios. For instance, you might develop a program to analyse sales data, allowing you to gain valuable insights while honing your coding abilities through hands-on experience.

By focusing on practical problem-solving, you'll acquire a deep, lasting understanding of Python and its applications in a business context. This approach will equip you with the confidence and expertise to tackle a wide range of challenges in your professional life, as you'll have the opportunity to learn by doing and see the tangible results of your efforts.
:::

# A Flipped Classroom Approach!

- Watch short tutorials before class
- Code during class with guidance
- Collaborate with peers
- Immediate feedback for better learning

::: {.notes}
In this flipped classroom approach, students watch short tutorial videos before class to gain a foundational understanding of the concepts. Class time is then dedicated to coding practice with guidance from the instructor, allowing for immediate feedback and clarification of any questions. This active learning approach promotes better retention and application of the material.

Collaboration with peers is also encouraged in this flipped classroom model. Students work together during class to solve problems and share insights, fostering a supportive learning environment. The combination of self-paced tutorials, hands-on coding practice, and peer collaboration creates a well-rounded learning experience that caters to different learning styles and provides immediate feedback for optimal growth.
:::

# Tools You'll Use

- **Google Colab** â€“ Cloud-based Python coding
- **GitHub** â€“ Version control & collaboration (track changes, work together)
- **Class Resources** â€“ Guides, videos, and exercises

::: {.notes}
In this slide, we will introduce the key tools you'll be using throughout the course. Google Colab is a cloud-based Python coding environment that allows you to write and run Python code directly in your web browser, making it easy to get started without the need for local setup. GitHub is a version control and collaboration platform that enables you to track changes to your code, work together with others on projects, and manage your codebase effectively.

Finally, we'll provide you with a range of class resources, including guides, videos, and exercises, to support your learning journey. These resources are designed to help you grasp the concepts, apply them in practice, and reinforce your understanding of Python programming for business applications.
:::

# Active Learning for Lasting Results

- Hands-on learning boosts retention
- Read less, do more
- Build confidence, not frustration

::: {.notes}
Active learning is a powerful approach that emphasises hands-on engagement and practical application, resulting in improved retention of knowledge. By prioritising active participation over passive reading, learners develop a deeper understanding of the subject matter and build confidence in their abilities. This approach minimises frustration by providing opportunities for practical experience and real-world problem-solving.

Incorporating active learning strategies, such as hands-on projects, coding exercises, and collaborative activities, creates a dynamic and engaging learning environment. Learners are encouraged to apply their knowledge in meaningful ways, reinforcing key concepts and developing practical skills. By focusing on active participation, learners are better equipped to tackle real-world challenges and develop a strong foundation in the subject matter.
:::

# AI as Your Coding Assistant

- AI can help you generate and refine code (e.g., suggest better ways to write your code)
- Use AI for debugging and optimisation (e.g., help you find and fix errors)
- AI-assisted learning boosts efficiency

::: {.notes}
AI can help you write better code, find and fix errors, and boost your efficiency as a programmer. It can suggest improvements to your code, assist with debugging, and provide optimisation recommendations.

Leveraging AI as your coding assistant is a powerful way to accelerate your learning and development process. By using AI-powered tools, you can get real-time feedback, quickly identify and resolve issues, and ultimately write higher-quality code in less time.
:::

# Best Practices for Learning

- Use a **physical keyboard** (not mobile devices)
- Pay attention to **syntax and formatting** (e.g., proper indentation makes your code easier to read)
- Follow industry standards for clean code

::: {.notes}
Using a physical keyboard, rather than mobile devices, can significantly improve your coding experience and productivity. A full-size keyboard allows for faster and more accurate typing, which is crucial when working with complex code structures. Additionally, using a physical keyboard reduces the likelihood of making errors caused by small screen sizes and touch input on mobile devices.

Paying attention to syntax and formatting, such as proper indentation, is essential for writing clean and readable code. Following industry standards for code formatting not only makes your code easier to understand for yourself but also for other developers who may work with your code in the future. Well-formatted code is more maintainable, reduces the likelihood of errors, and demonstrates professionalism in your work.
:::

# Study, Practice, Rest!

- Study a topic for 5-10 min
- Practise coding for 10-15 min
- Take breaks to absorb learning

::: {.notes}
To maximise your learning effectiveness, employ a structured approach of focused study sessions, coding practice, and rest breaks. Begin by dedicating 5-10 minutes to studying a specific topic, ensuring you grasp the fundamental concepts and principles. Follow this with 10-15 minutes of hands-on coding practice, applying the knowledge you've just acquired to solidify your understanding through practical implementation.

Equally important to the study and practice sessions are the breaks in between. These intervals allow your brain to process and absorb the new information, facilitating the transfer of knowledge from short-term to long-term memory. By striking a balance between focused learning and restorative rest, you optimise your cognitive performance and enhance your overall learning outcomes.
:::

# Let's Get Started!

- Start coding from Day 1
- Ask questions, collaborate, and experiment
- Learning is a journeyâ€”enjoy it!

::: {.notes}
Let's dive into the exciting world of coding with an AI-first approach to learning Python! From day one, you'll be hands-on, writing code and building real-world business projects. Don't be afraid to ask questions, collaborate with your peers, and experiment with different solutions. Remember, making mistakes is a natural part of the learning process.

Learning to code is a lifelong journey, and this course is just the beginning. Embrace the challenges, celebrate your successes, and most importantly, have fun along the way! With the power of AI-assisted learning, you'll be amazed at how quickly you can progress from a beginner to a confident Python programmer. Get ready to unlock a world of possibilities and embark on an unforgettable learning adventure!
:::

# Key Takeaways: AI-First Python Course

- Learn Python through hands-on coding with AI assistance
- Use modern tools including Google Colab for cloud coding and GitHub for version control
- Follow a flipped classroom model: watch short tutorials before class, code during sessions with instructor guidance
- Practice in short, focused sessions (5-10 min study + 10-15 min coding) for optimal learning
- Leverage AI assistance for code generation, debugging, and optimisation to accelerate your learning journey

::: {.notes}
This slide highlights the key elements of the AI-First Python course, which focuses on hands-on coding with AI assistance using modern tools like Google Colab and GitHub. The course follows a flipped classroom model, where students watch short tutorials before class and then code during sessions with instructor guidance.

For optimal learning, the course encourages students to practice in short, focused sessions of 5-10 minutes of study followed by 10-15 minutes of coding. AI assistance is leveraged for code generation, debugging, and optimisation, accelerating the learning journey.
:::

---
title: "Week 1 FAQ"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

1. What is the core philosophy of the AI-First Python course?
The AI-First Python course focuses on building real-world business projects through hands-on coding and AI-assisted learning. The aim is to develop long-term programming skills in an efficient and engaging manner, moving away from passive learning towards active problem-solving. It ensures youâ€™re not just memorising concepts but applying them practically from day one.

2. Why should I learn Python?
Python is an excellent choice because it is easy to learn with its simple syntax and beginner-friendly nature. It is also a powerful and versatile language used in data science, web development, and artificial intelligence. Its widespread use in both industry and academia ensures a strong community, abundant resources, and plentiful job opportunities.

3. How will this course prepare me for real-world applications?
This course emphasizes real-world business applications, covering areas such as automating repetitive tasks (e.g., email automation), processing and analysing data, and building AI-powered business tools. Youâ€™ll work on projects that directly align with business needs, ensuring the skills learned are immediately applicable in a professional setting. For instance, you might build a program to analyse sales data.

4. What is the "Flipped Classroom" approach used in this course?
The flipped classroom model involves watching short tutorials before class and then using class time for hands-on coding exercises with guidance from the instructor and collaboration with peers. This approach allows for immediate feedback and a more interactive learning experience, enabling you to apply what you've learned through practical challenges. It allows you to come to class prepared with questions and ready to apply your knowledge.

5. What tools will I be using in this course?
You will primarily use Google Colab for cloud-based Python coding, which eliminates the need for local installations. GitHub will be used for version control and collaborative coding, helping you track changes and work effectively in teams. You'll also be provided with comprehensive course resources, including guides, videos, and exercises.

6. How does AI assist in learning within this course?
AI is integrated to help generate and refine code, providing suggestions for improvement, and to assist in debugging and optimisation by identifying and helping fix errors. This AI-assisted learning boosts efficiency by providing personalised feedback and adapting to your learning pace.

7. What strategies should I adopt to maximise my learning in this course?
Adopting a structured approach which includes using a physical keyboard for accurate input, paying close attention to syntax and formatting for readable code, and adhering to industry standards for clean code. Itâ€™s beneficial to study in short bursts (5-10 minutes), followed by coding practice (10-15 minutes), and taking regular breaks to absorb the learning effectively.

8. What if I get stuck or have questions during the course?
This course encourages active participation through asking questions, collaborating with peers, and experimenting with different approaches. You're encouraged to start coding from day one and not hesitate to seek help or advice from instructors or classmates. The learning process is viewed as a journey, and support will be available throughout.

9. What are Google Colab and GitHub, and why are they useful for Python development?
Google Colab is a cloud-based Jupyter Notebook environment, allowing you to write and run Python code in your browser without requiring any local installation. It even offers free GPU access, which is particularly helpful for AI and machine learning projects. GitHub is a version control and collaboration platform, essential for tracking code changes over time, working with others, backing up your work, and accessing your projects from anywhere. Using these tools together provides a powerful, accessible, and collaborative environment for learning and developing Python.

10. How do I get started with Google Colab?
You need a Google Account to use Google Colab. Simply sign in at colab.research.google.com. Once logged in, your notebooks are automatically stored in Google Drive, making them accessible from any device. To create a new notebook, click "File" then "New Notebook." A code cell will appear, ready for you to start writing Python code.

11. How do I run Python code in Google Colab?
Click inside a code cell, type your Python code (e.g., print("Hello, World!")), and press Shift + Enter to execute the code. The output will appear directly below the code cell. This makes testing and iterating on your code quick and easy.

12. How do I save my Google Colab notebooks and access them later?
Google Colab notebooks are automatically saved in your Google Drive. You can also download them as .ipynb or .py files for offline use. Furthermore, you can save a copy directly to GitHub for version control and collaboration.

13. How do I connect Google Colab to GitHub?
First, you need a GitHub account. Then, in Google Colab, click "File" > "Save a Copy in GitHub." You'll be prompted to authorise Google Colab to access your GitHub account. Select the desired repository and add a commit message, then click "OK" to upload the notebook.

14. How do I retrieve and update notebooks from GitHub using Google Colab?
Open the GitHub repository containing the notebook. Click on the .ipynb file you want to edit. On the GitHub page, click "Open in Colab". This will open the notebook in Google Colab. After making changes, save the updated notebook back to GitHub by going to "File" and selecting "Save a copy in GitHub." Remember to include a descriptive commit message.

15. What are some best practices for saving notebooks to GitHub from Google Colab?
Write clear and concise commit messages to describe the changes you've made. Regularly push updates to GitHub to prevent data loss. Use branches for experimental changes before merging them into the main repository. Keep notebooks organised within folders in your repository for easy navigation.

16. How can AI tools accelerate my Python learning and development process?
AI tools like ChatGPT and GitHub Copilot can provide real-time code suggestions, instant explanations of code and errors, and generate/refactor code to improve efficiency. They can also provide summaries of Python libraries and algorithms, helping you quickly understand complex concepts. By integrating AI into your workflow, you can write code faster, debug more efficiently, and learn new concepts more easily.


17. What is the primary function of print() in Python?
The print() function is primarily used to display output on the screen. This could be text, the value of a variable, or the result of a calculation. It's a fundamental way for your Python code to communicate information to the user or to you, the programmer.

18. What is the correct syntax for using the print() function?
The correct syntax is print(), with parentheses. If you want to display text, it should be enclosed in quotation marks (either single or double) inside the parentheses, for example, print("Hello, World!"). It is also possible to insert a variable name or names between the parenthesis to print out the value of the specified variable.

19. Why is the print() function considered important for programmers?
The print() function is important for several reasons. It helps in checking if your code is working as expected, it is a debugging tool to find mistakes and track errors by displaying variable values at different stages, and it outputs text to the screen, facilitating user interaction by displaying prompts, results, or messages.

20. What are some common errors to avoid when using print()?
Common errors include: forgetting parentheses (e.g., print "Hello" instead of print("Hello")), missing quotation marks around strings (e.g., print(Hello) instead of print("Hello")), incorrect capitalisation (e.g., Print("Hello") instead of print("Hello")), misspelling the function name (e.g., pint("Hello") instead of print("Hello")), and unintended indentation.

21. How does case sensitivity affect the use of print()?
Python is case-sensitive. Therefore, print() must be written in lowercase. Using Print(), PRINT(), or any other variation will result in an error.

22. Are there any specific formatting techniques or best practices when using print()?
Yes, always use parentheses, enclose text in quotation marks, watch out for indentation errors (especially leading spaces), and spell print correctly. Additionally, aim for clean and readable code by using clear variable names and following style guidelines.

23. Why is using parentheses important with print()?
Using parentheses with print() is crucial as it's part of the correct function syntax in Python 3. Forgetting them will lead to a SyntaxError. The parentheses enclose the arguments or values you want to display.

24. What are the next steps to take after understanding the basics of print()?
Practice identifying and fixing common errors when using print(), begin incorporating print() statements into your own code for debugging and displaying information, and continue building confidence with this fundamental command through consistent practice.
### **ðŸš€ How to Create a Free Google Gemini (Formerly Bard) Account**  
Google Gemini is an AI-powered chatbot similar to ChatGPT, and it's free to use with a Google account.

---

### **ðŸ“Œ Step 1: Go to the Google Gemini Website**  
1. Open your web browser and go to **[https://gemini.google.com](https://gemini.google.com)**.  
2. Click **â€œSign Inâ€** (top right corner).

---

### **ðŸ“Œ Step 2: Sign in with Your Google Account**  
âœ… If you already have a **Gmail account**, simply log in.  
âœ… If you **donâ€™t have a Google account**, click **â€œCreate accountâ€** and follow the instructions.

---

### **ðŸ“Œ Step 3: Agree to the Terms of Use**  
1. Read Google's **terms & conditions** for using Gemini.  
2. Click **â€œAgree & Continueâ€** to proceed.

---

### **ðŸ“Œ Step 4: Start Using Google Gemini**  
1. After signing in, youâ€™ll be directed to **Geminiâ€™s chat interface**.  
2. Type your **question or prompt** in the text box and hit **Enter**.  
3. Google Gemini will generate a responseâ€”ask follow-up questions to refine your results.

---

### **ðŸ“Œ Optional: Use Gemini on Mobile**  
- Gemini is available in the **Google app** (iOS & Android).  
- You can access it by searching for **Gemini** in Google Assistant.

---

### **ðŸš€ Tips for Using Google Gemini Effectively**  
âœ… **Use clear prompts:** _"Explain CSS Grid vs. Flexbox with examples."_  
âœ… **Ask for improvements:** _"Make this JavaScript function more efficient."_  
âœ… **Use it for coding help, explanations, and brainstorming ideas.**  
âœ… **Compare outputs with ChatGPT** for different AI perspectives.

---

### **ðŸš€ Need Help?**  
If you have trouble accessing Gemini:  
- **Ensure your Google account is active.**  
- **Some regions may not support Gemini yet.**  
- **Use a VPN** if Gemini is unavailable in your country.  
# ðŸš€ AI Models & Tools Comparison: Infographic Guide (v1.1 - *Illustrative Example - Subject to Change*)

**ðŸ“Œ Overview**

This infographic provides a side-by-side comparison of major AI models and tools to help users understand their strengths, weaknesses, and best use cases.  **Note:** The AI landscape is rapidly evolving.  This information is for illustrative purposes and should be verified before making decisions.

---

## ðŸ“Œ AI Models Comparison

| AI Model/Tool | Description | Text Gen. (Creative) | Text Gen. (Factual) | Coding (Python) | Context Window | Multimodal | Cost (API) | Data Privacy | Example Use Cases |
|---|---|---|---|---|---|---|---|---|---|
| ChatGPT (OpenAI) | Large language model accessible via web interface and API. | High | High | Excellent | 8,192 tokens (GPT-3.5) / 32,768 tokens (GPT-4) | No (GPT-3.5) / Yes (GPT-4) | Varies (usage-based) | OpenAI data policies | Creative writing, chatbots, code generation, translation |
| Claude (Anthropic) | Large language model focused on helpful and harmless responses. | Medium | High | Good | 100,000 tokens | No | Varies (usage-based) | Anthropic data policies | Summarization, long-form content, legal documents, customer support |
| Gemini (Google) | Multimodal large language model integrated with Google services. | Medium | Very High | Good | Varies | Yes (text, images, code) | Varies (usage-based) | Google data policies | Fact-checking, research, image analysis, Google Docs integration |
| LLaMA (Meta AI) | Open-source large language model for research and development. | Medium | Medium | Good | Varies (model size dependent) | No | N/A (base model) | User-controlled (local) | Custom AI model development, research, fine-tuning |
| Phi (Microsoft) | Lightweight large language model designed for efficiency. | Medium | Medium | Good | Varies | No | N/A (base model) | User-controlled (local) | Edge AI applications, resource-constrained devices |
| Groq AI | Focuses on low-latency AI inference. | N/A | High (for specific tasks) | Limited | N/A | No | Varies (usage-based) | Groq data policies | Fast Q&A, API integrations, real-time applications |
| DeepSeek AI | Designed for research and complex problem-solving. | Medium | Very High (for specific domains) | Excellent | Varies | No | Varies (usage-based) | DeepSeek data policies | Scientific research, technical analysis, complex reasoning |

**Key Considerations:**

* **Context Window:**  Indicates how much previous text the model can consider. Larger windows enable better understanding of long conversations or documents.
* **Multimodal:**  Indicates the ability to process different data types (text, images, code).
* **Cost (API):**  Refers to the pricing for accessing the model via API.  Pricing models vary.
* **Data Privacy:**  Refers to the data handling practices of the provider.  Review their privacy policies.
* **LLaMA and Phi:** These are base models, not end-user applications.  They require technical expertise to use.  Ollama is a tool that helps run these models locally.

---

## ðŸ“Œ AI Tool Setup & Performance Comparison

| AI Tool | Setup Difficulty | Performance Speed | Best Feature | Best For |
|---|---|---|---|---|
| ChatGPT (Web) | âœ… Easiest (Sign up) | âš¡ Medium | Coding assistance, general-purpose AI | Learning, coding, research, general tasks |
| ChatGPT (API) | âš ï¸ Medium (API key required) | âš¡ Fast | Integration into applications | Custom applications, automation |
| Claude (Web) | âœ… Easiest (Sign up) | âš¡ Medium | Long context window | Writing, summarization, legal applications |
| Claude (API) | âš ï¸ Medium (API key required) | âš¡ Fast | Integration into applications | Custom applications, long-form content processing |
| Gemini (Web) | âœ… Easiest (Google account) | âš¡ Medium | Google integration, multimodal | Research, fact-checking, multimodal tasks |
| Gemini (API) | âš ï¸ Medium (API key required) | âš¡ Fast | Integration into applications | Custom applications, multimodal processing |
| Groq AI | âœ… Easiest (Web-based) | ðŸš€ Ultra-fast | Low-latency inference | Real-time applications, fast Q&A |
| LLaMA (Local - Ollama) | âš ï¸ Medium (Technical setup) | âš¡ Fast (with GPU) | Runs offline, customizable | AI research, custom model development |
| Phi (Local - Ollama) | âš ï¸ Medium (Technical setup) | âš¡ Fast (with GPU) | Lightweight, efficient | Edge AI, low-power devices |
| DeepSeek AI (API) | âš ï¸ Medium (Technical setup) | âš¡ Fast | Research-focused, deep reasoning | Scientific research, technical analysis |

---

## ðŸš€ Final Takeaways: Which AI Should You Use? (Illustrative Examples)

* **Need AI for coding/debugging?** â†’ ChatGPT
* **Want AI for social media/chat apps?** â†’  (Consider specific features within social media platforms.  No single "Meta AI" tool.)
* **Need AI for long-form writing/summaries?** â†’ Claude
* **Looking for fact-checking & research?** â†’ Gemini
* **Need ultra-fast AI responses?** â†’ Groq AI
* **Want a customizable offline AI?** â†’ LLaMA (requires technical expertise) or Phi (requires technical expertise)
* **Best AI for research?** â†’ DeepSeek AI, LLaMA (for custom models)

**Disclaimer:** This infographic is for informational purposes only.  The AI landscape is constantly changing.  Verify the information and consider your specific needs before choosing an AI model or tool.  This is not an exhaustive list, and other excellent AI models and tools are available.  Always review the terms of service and privacy policies of the respective providers.### **ðŸš€ How to Create and Use Groq AI Chatbot**  

**Groq AI** is an ultra-fast AI chatbot designed for **real-time responses, coding assistance, and AI-powered research**. It utilizes **LLama-based AI models (Metaâ€™s LLaMA)** for efficient text generation.

---

### **ðŸ“Œ Step 1: Access Groq AI**  
You can use Groq AI via:  
âœ… **Web App**: Visit **[https://chat.groq.com](https://chat.groq.com/)**.  
âœ… **API Access**: Available for developers via **Groq API** (may require setup).  

---

### **ðŸ“Œ Step 2: Sign Up for a Free Account**  
1. Go to **[https://chat.groq.com](https://chat.groq.com/)**.  
2. Click **"Sign Up"** or **"Sign In"**.  
3. Choose to sign in using:  
   - **Google Account**  
   - **Email & Password**  
4. Verify your email (if required) and log in.  

---

### **ðŸ“Œ Step 3: Start Chatting with Groq AI**  
Once logged in, **enter a prompt** in the chat window and start interacting.

âœ… **Example Prompts:**  
- _"Explain how CSS media queries work for responsive design."_  
- _"Generate an optimized JavaScript function for sorting an array."_  
- _"What are the benefits of using headless WordPress?"_  

---

### **ðŸ“Œ Step 4: Using Groq AI for Web Development**  
âœ… **Code Generation:** _"Write a React component for a dynamic contact form."_  
âœ… **Debugging Assistance:** _"Why is my Python Flask app throwing a 500 error?"_  
âœ… **AI Code Comparison:** _"Compare AI-generated code vs. human-written code for efficiency."_  
âœ… **AI-Enhanced Research:** _"Summarize the differences between GraphQL and REST APIs."_  

---

### **ðŸ“Œ Step 5: Optional â€“ Groq API for Developers**  
For **developers**, Groq AI offers API integration:  
1. Visit **[https://groq.com](https://groq.com/)**.  
2. Sign up for API access.  
3. Use API keys to integrate AI-powered text generation into applications.  

---

### **ðŸš€ Tips for Using Groq AI Effectively**  
âœ… **Use detailed prompts** (_e.g., â€œExplain CSS Grid with a real-world exampleâ€_).  
âœ… **Ask for code optimization** (_e.g., â€œImprove the efficiency of this JavaScript functionâ€_).  
âœ… **Use it as a debugging assistant** to fix errors in web development projects.  

---

### **ðŸ“Œ Troubleshooting Access Issues**  
- **Ensure Groq AI is available in your region** (some AI tools have restricted access).  
- **Try different browsers** if the chat interface is slow.  
- **Clear cache & cookies** if login issues occur.  
---
title: "GitHub Account Creation and Sign-In Process"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## # [GitHub](https://github.com/)


### 1. Click on Sign up

Go to https://github.com

![Step 1 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/47a79e8c-9093-48ec-868a-feab89e37873/f7344edd-7bfc-4691-8049-1b6081288248.png?crop=focalpoint&fit=crop&fp-x=0.9376&fp-y=0.0902&fp-z=2.8881&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=877&mark-y=148&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTImaD0xMDImZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 2. Type "student@student.curtin.edu.au"

Type in your email

![Step 2 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/4c24dd5d-150c-425d-8b14-c2a8149ac8f5/2afef3d7-b4cc-4359-a172-73d543ca500c.png?crop=focalpoint&fit=crop&fp-x=0.7504&fp-y=0.2156&fp-z=2.3838&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=114&mark-y=334&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz05NzImaD05OSZmaXQ9Y3JvcCZjb3JuZXItcmFkaXVzPTEw)


### 3. Type password
![Step 3 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/aabf347a-f761-41b9-9b21-05557f107fd0/e6dcf7e8-3ea8-40ee-8994-2031d92f7165.png?crop=focalpoint&fit=crop&fp-x=0.7504&fp-y=0.3075&fp-z=2.3838&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=114&mark-y=335&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz05NzImaD05NyZmaXQ9Y3JvcCZjb3JuZXItcmFkaXVzPTEw)


### 4. Type in your username
![Step 4 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/5ad4edfa-0b93-4fec-8fe7-f768917efde1/d2608ae5-7aac-4ddf-8480-771de8b03d92.png?crop=focalpoint&fit=crop&fp-x=0.7504&fp-y=0.4451&fp-z=2.3838&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=114&mark-y=335&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz05NzImaD05NyZmaXQ9Y3JvcCZjb3JuZXItcmFkaXVzPTEw)


### 5. Click on "Continue"
![Step 5 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/cb701707-920d-47a4-b735-b7c5929094c8/51cc2806-f36e-4df3-8e44-afa1934673c3.png?crop=focalpoint&fit=crop&fp-x=0.7504&fp-y=0.5595&fp-z=2.3838&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=114&mark-y=324&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz05NzImaD0xMTgmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 6. Choose way to verify human
![Step 6 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/e99a80f7-b9f0-4ce6-9418-75cebc4f1b75/9b3ca3d0-3dcf-40c8-a6ce-da2ee7a48eb1.png?crop=focalpoint&fit=crop&fp-x=0.7504&fp-y=0.2405&fp-z=2.3880&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=115&mark-y=328&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz05NjkmaD0xMTAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 7. Solve each puzzle and click on "Submit"
![Step 7 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/9a3f1091-101c-4bb0-aa16-bac87b5353e1/3bd5ba5f-759d-4259-a7b0-a2853622c39b.png?crop=focalpoint&fit=crop&fp-x=0.5000&fp-y=0.5000&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=697&mark-y=377&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTMlMkNGRjc0NDImdz00MDYmaD00NiZmaXQ9Y3JvcCZjb3JuZXItcmFkaXVzPTEw)


### 8. Paste verification code into input

Check your email for a verification code sent from GitHub

![Step 8 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/77890b81-5b1b-4500-bc34-550fafc196c5/36cab33b-c6a3-49b8-98b8-daced862a933.png?crop=focalpoint&fit=crop&fp-x=0.5000&fp-y=0.5000&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=697&mark-y=174&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTMlMkNGRjc0NDImdz01NCZoPTYzJmZpdD1jcm9wJmNvcm5lci1yYWRpdXM9MTA%3D)


### 9. Account verified, now sign in.
![Step 9 screenshot](https://images.tango.us/workflows/fafaf1a0-0172-4f99-a0f8-6000539c3279/steps/26ffa374-82e5-4dc7-bf46-a6a2c7aa3044/6a4ca10b-c2ea-483e-84ac-615ae0d958eb.png?crop=focalpoint&fit=crop&fp-x=0.5000&fp-y=0.3850&fp-z=2.0263&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=365&mark-y=347&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz00NzEmaD03MiZmaXQ9Y3JvcCZjb3JuZXItcmFkaXVzPTEw)

<br/>

***
Created with [Tango.ai](https://tango.ai?utm_source=markdown&utm_medium=markdown&utm_campaign=workflow%20export%20links)---
title: "Creating a Google Account and Using Google Colab"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## # [Google Workspace](https://workspace.google.com/intl/en-US/gmail/)


### 1. Click on Create an account
![Step 1 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/27d53aa6-d468-49f6-9eb0-b38822043b61/60e32f47-4d46-4545-acca-9c90719a96ad.png?crop=focalpoint&fit=crop&fp-x=0.9114&fp-y=0.0358&fp-z=2.7948&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=655&mark-y=15&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz00OTUmaD0xMjQmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 2. Click on For my personal use
![Step 2 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/43d403c5-7c25-4caf-b4ef-5942093656b9/78a81256-c7f2-4a42-94c0-29a0eeb92103.png?crop=focalpoint&fit=crop&fp-x=0.9125&fp-y=0.0844&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=659&mark-y=122&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz00OTEmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


## # [Create your Google Account](https://accounts.google.com/lifecycle/steps/signup/name?continue=https://mail.google.com/mail/&ddm=1&dsh=S-1090162785:1740322070569541&ec=asw-gmail-globalnav-create&flowEntry=SignUp&flowName=GlifWebSignIn&service=mail&theme=glif&TL=ADgdZ7Qa5W0h1tXCNUsZcbnrZzmN2uwKRxytYYs7s_lT8EAM_ez81VGJ9gR8xMrl)


### 3. Type First Name & Last Name
![Step 3 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/2c0f9ac7-a8ae-4750-bcb7-86becefae6e8/fdfd7203-5eda-4fc5-b40a-3b67ed27ce83.png?crop=focalpoint&fit=crop&fp-x=0.6717&fp-y=0.4081&fp-z=2.0672&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=214&mark-y=328&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NzEmaD0xMTAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 4. Click on Next
![Step 4 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/cd77bedf-e83c-415c-9678-33177e3c1243/9c33494f-2cdc-4996-8585-8f829b70bdba.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6208&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 5. Type "BorckPython"
![Step 5 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/da0106d5-457d-406b-a36b-43ebe3a45855/215029b1-2470-4d03-8421-8d778da160a4.png?crop=focalpoint&fit=crop&fp-x=0.6717&fp-y=0.4879&fp-z=2.0672&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=214&mark-y=328&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NzEmaD0xMTAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 6. Click on Next
![Step 6 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/a77d8e02-789d-4851-8470-5ffd93be0d53/283fae06-2eef-4021-b9da-55ca1e2b5b18.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6335&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 7. Enter Date of Birth
![Step 7 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/f2f20489-9d9a-4061-9add-7ea552486a7d/2003125e-1f7d-4ff4-a126-84064367d92a.png?crop=focalpoint&fit=crop&fp-x=0.7784&fp-y=0.3965&fp-z=2.7074&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=442&mark-y=311&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0zMTcmaD0xNDQmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 8. Select Male from Gender
![Step 8 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/4ecb120b-4b21-4991-a163-179886f17fc2/d45d5104-9c59-43d5-b0e9-73f4088d659b.png?crop=focalpoint&fit=crop&fp-x=0.6717&fp-y=0.4798&fp-z=2.0609&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=212&mark-y=325&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NzYmaD0xMTcmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 9. Click on Next
![Step 9 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/5025d1e5-4c70-4813-bdf2-4d6440e9cddc/c6ff37e0-fb25-49a6-9210-1323a0e67554.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6312&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 10. Select preferred Gmail email
![Step 10 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/2e82d4de-82c2-4e89-9cc9-07327a118066/f2f045a6-6ae6-470d-b317-6a010406db64.png?crop=focalpoint&fit=crop&fp-x=0.5266&fp-y=0.4497&fp-z=3.0087&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=563&mark-y=346&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NSZoPTc1JmZpdD1jcm9wJmNvcm5lci1yYWRpdXM9MTA%3D)


### 11. Click on Next
![Step 11 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/c9558428-78c4-4b24-8bfe-5847cd43943a/c24f118e-1c0b-46a1-974f-a8c827bc0a65.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6347&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 12. Create your password
![Step 12 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/1cfefb37-b241-46f6-8771-78da3376f768/b00768fe-3be0-4f64-93f7-46684f309ee2.png?crop=focalpoint&fit=crop&fp-x=0.6717&fp-y=0.3873&fp-z=2.0672&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=214&mark-y=328&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NzEmaD0xMTAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 13. Type password
![Step 13 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/ee980eea-d41a-462b-bc20-285950c75224/a002d396-62f6-4318-9a34-fffc227ce832.png?crop=focalpoint&fit=crop&fp-x=0.6717&fp-y=0.4798&fp-z=2.0672&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=214&mark-y=328&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NzEmaD0xMTAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 14. Click on Next
![Step 14 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/2fdb68f3-89cb-4c0e-a16c-fc87b0a64805/5e153823-7ace-4174-b8e2-904b8bd8b69b.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6405&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 15. Type Type phone number
![Step 15 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/cac10587-d034-4632-87bf-8e40370bd32b/1c477aa1-7a9d-4280-892b-42f6aece956c.png?crop=focalpoint&fit=crop&fp-x=0.6924&fp-y=0.4445&fp-z=2.3713&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=275&mark-y=315&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz02NDkmaD0xMzcmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 16. Click on Next
![Step 16 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/b01a40a7-fd1b-4abd-a902-23836ae57216/9ad04491-c2b9-4305-a68f-90ea4074f932.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6208&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 17. Type verification code received on phone
![Step 17 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/1608afd8-096e-4eb1-addc-7646a1a82e81/d3121b38-e113-4945-8704-0a64906b51de.png?crop=focalpoint&fit=crop&fp-x=0.6876&fp-y=0.4671&fp-z=2.2124&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=229&mark-y=324&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NDEmaD0xMTgmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 18. Click on Next
![Step 18 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/9ac0d391-0375-4a84-ba25-d86d2dd566c8/d65e5287-aca8-4b2f-9950-a0d98d90a050.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6208&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 19. Type recovery email
![Step 19 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/8a28b067-d41d-4425-805d-dc5d9703ac38/ecdd3412-bdce-4da6-8ae8-1ac5c8d903b6.png?crop=focalpoint&fit=crop&fp-x=0.6717&fp-y=0.4081&fp-z=2.0672&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=214&mark-y=328&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03NzEmaD0xMTAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 20. Click on Next
![Step 20 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/17897263-54b2-4027-9a02-59612abe1846/5ca37222-cf31-40ae-bb2e-1184ee3bcde4.png?crop=focalpoint&fit=crop&fp-x=0.7515&fp-y=0.6208&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=337&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz01MjYmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 21. Click on Next
![Step 21 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/0052447b-cedf-490e-be0a-07d67f51643f/c56fb416-f16b-4a28-8294-c91539f0fab5.png?crop=focalpoint&fit=crop&fp-x=0.7965&fp-y=0.6197&fp-z=2.8130&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=492&mark-y=323&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0yMTcmaD0xMjAmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


### 22. Click on I agree
![Step 22 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/3ec7ffb3-d7e1-41bc-8130-368e7a18a4a9/a045950d-a54c-4cc3-9f10-5e937e35b46c.png?crop=focalpoint&fit=crop&fp-x=0.7799&fp-y=0.8058&fp-z=3.8797&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=425&mark-y=301&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz0zNTEmaD0xNjUmZml0PWNyb3AmY29ybmVyLXJhZGl1cz0xMA%3D%3D)


## # [Brave Search](https://search.brave.com/search?q=google+colab&source=desktop)


### 23. Check working, visit Google Colab.  Search for Google Colab
![Step 23 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/0aff7d2d-8321-444a-8730-aec343a66e8c/2e6f70c2-e576-4e03-941f-d998ca06926f.png?crop=focalpoint&fit=crop&fp-x=0.3796&fp-y=0.2110&fp-z=1.3042&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=229&mark-y=168&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTQlMkNGRjc0NDImdz03MzAmaD04NyZmaXQ9Y3JvcCZjb3JuZXItcmFkaXVzPTEw)


## # [Welcome To Colab - Colab](https://colab.research.google.com/)


### 24. Click on highlight
![Step 24 screenshot](https://images.tango.us/workflows/507c3eaa-a7a0-41f7-9bc9-1ccb9dcc7a14/steps/37b07b60-2994-4fec-a6f4-77029e6a42dd/5ab7819b-1d11-4954-bd43-2f9a6923f055.png?crop=focalpoint&fit=crop&fp-x=0.2570&fp-y=0.8260&fp-z=2.6129&w=1200&border=2%2CF4F2F7&border-radius=8%2C8%2C8%2C8&border-radius-inner=8%2C8%2C8%2C8&blend-align=bottom&blend-mode=normal&blend-x=0&blend-w=1200&blend64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL21hZGUtd2l0aC10YW5nby13YXRlcm1hcmstdjIucG5n&mark-x=470&mark-y=389&m64=aHR0cHM6Ly9pbWFnZXMudGFuZ28udXMvc3RhdGljL2JsYW5rLnBuZz9tYXNrPWNvcm5lcnMmYm9yZGVyPTYlMkNGRjc0NDImdz0yNTkmaD01OCZmaXQ9Y3JvcCZjb3JuZXItcmFkaXVzPTEw)

<br/>

***
Created with [Tango.ai](https://tango.ai?utm_source=markdown&utm_medium=markdown&utm_campaign=workflow%20export%20links)**ðŸš€ Beginnerâ€™s Guide to Setting Up Local AI Models**

### **ðŸ“Œ Introduction**
Running AI models locally allows you to use powerful language models without relying on cloud services like ChatGPT or Gemini. However, local AI models require **dedicated software and sometimes hardware optimizations** to run efficiently on consumer-grade computers.

---

## **1ï¸âƒ£ Understanding Local AI Models**
Unlike cloud-based models, local AI models require:
âœ… A **model file** (LLaMA, Phi, DeepSeek, etc.).  
âœ… An **inference engine** to run the model locally.  
âœ… Optional **quantization** to reduce memory usage on lower-end hardware.  

Popular models you can run locally include:
- **LLaMA (Meta AI)** â€“ Open-source alternative to GPT-4.
- **Phi (Microsoft)** â€“ Small-scale efficient AI.
- **DeepSeek AI** â€“ Optimized for technical research.

---

## **2ï¸âƒ£ Software Required to Run Local AI Models**
### **ðŸ”¹ Option 1: Ollama (Easiest Setup) â€“ Mac, Linux, Windows**
**Ollama** is an easy-to-use tool for running local AI models with a simple command-line interface.

**Installation Steps:**
1. Download **Ollama** from: [https://ollama.com](https://ollama.com)
2. Install it and open a terminal.
3. Run a model by typing:
   ```sh
   ollama run llama2
   ```
4. You can also install other models:
   ```sh
   ollama pull phi
   ```
5. Start chatting locally!

**Pros:** âœ… Simple, works on all platforms. âœ… Automatically downloads models.
**Cons:** âŒ Limited UI, mostly command-line-based.

---

### **ðŸ”¹ Option 2: LM Studio (GUI-Based) â€“ Mac & Windows**
If you prefer a graphical interface, **LM Studio** is an excellent tool for running local AI models with an easy-to-use UI.

**Installation Steps:**
1. Download LM Studio: [https://lmstudio.ai](https://lmstudio.ai)
2. Install and open it.
3. Choose a **LLaMA-compatible model** and click **Download**.
4. Run the model and chat with it directly.

**Pros:** âœ… Easy-to-use UI. âœ… Works without the command line.
**Cons:** âŒ Limited advanced features compared to CLI tools.

---

### **ðŸ”¹ Option 3: Text-Generation-WebUI (Advanced Users) â€“ Windows, Linux**
For those who want **maximum customization**, Text-Generation-WebUI provides a **web interface** to run multiple AI models.

**Installation Steps:**
1. Install Python (3.10+) and Git.
2. Clone the repository:
   ```sh
   git clone https://github.com/oobabooga/text-generation-webui.git
   ```
3. Navigate to the directory:
   ```sh
   cd text-generation-webui
   ```
4. Install dependencies:
   ```sh
   pip install -r requirements.txt
   ```
5. Run the server:
   ```sh
   python server.py
   ```
6. Open **localhost:5000** in your browser and start chatting.

**Pros:** âœ… Full control over settings. âœ… Supports many AI models.
**Cons:** âŒ Harder to set up. âŒ Requires Python & command-line experience.

---

## **3ï¸âƒ£ Optimizing Models for Lower-End Hardware (Quantization)**
Running large AI models on **consumer hardware** can be challenging. **Quantization** helps reduce RAM and VRAM requirements.

### **ðŸ”¹ How to Use Quantized Models**
1. Download a **quantized version** of a model from [Hugging Face](https://huggingface.co/).
2. Use tools like **GGUF format** (Ollama, LM Studio) to load the smaller model.
3. Example command to run a quantized LLaMA model:
   ```sh
   ollama run llama2-7b-gguf
   ```

### **ðŸ”¹ Recommended Quantized Models**
- **LLaMA 2 7B GGUF** (Fits on 16GB RAM machines)
- **Phi-2 4-bit GGUF** (Efficient on lower-end laptops)
- **DeepSeek Lite GGUF** (Optimized for research use)

---

## **4ï¸âƒ£ Troubleshooting Common Issues**
### **ðŸ”¹ My model is too slow!**
- Try a **smaller model size** (7B instead of 13B/30B).
- Use a **quantized model (GGUF, GPTQ, 4-bit)**.
- Ensure **GPU acceleration is enabled** if available.

### **ðŸ”¹ The model is running out of memory!**
- Use **GGUF models** to reduce RAM usage.
- Close other background applications.
- Upgrade RAM if frequently using large models.

### **ðŸ”¹ I need an easier solution!**
- Use **Ollama or LM Studio** instead of command-line tools.

---

## **5ï¸âƒ£ Final Recommendations: Which Tool Should You Use?**
| **User Type** | **Recommended Tool** |
|--------------|--------------------|
| **Beginners (No coding required)** | **LM Studio (GUI-based)** |
| **Casual users (Command-line only)** | **Ollama** |
| **Advanced users (Full control over settings)** | **Text-Generation-WebUI** |
| **Developers & AI researchers** | **Manual setup with Hugging Face models** |

---

### **ðŸš€ Next Steps**
âœ… Install a tool like **Ollama or LM Studio**.
âœ… Download an **optimized AI model** (LLaMA, Phi, DeepSeek).
âœ… Start experimenting with **local AI without cloud dependency**!

Would you like a **quick-reference cheat sheet** for running AI models locally? ðŸš€

### **ðŸš€ How to Create and Use Meta AI Chatbot (Meta.ai)**  

Meta AI is an AI-powered chatbot available through **Facebook, Instagram, Messenger, and WhatsApp**. It integrates into Metaâ€™s ecosystem and allows users to ask questions, generate text, and get assistance.

---

### **ðŸ“Œ Step 1: Access Meta AI**  
There are **multiple ways** to use Meta AI:

âœ… **Facebook**: Open **Facebook Messenger** and search for **Meta AI**.  
âœ… **Instagram**: Open your DMs and search for **Meta AI**.  
âœ… **WhatsApp**: Available in some regionsâ€”search for **Meta AI** in chats.  
âœ… **Meta Website**: Go to **[https://about.fb.com/technology/meta-ai/](https://about.fb.com/technology/meta-ai/)** for more details.

---

### **ðŸ“Œ Step 2: Log in with Your Meta Account**  
1. Open **Messenger, Instagram, or WhatsApp**.  
2. **Search for "Meta AI"** in the chat search bar.  
3. **Start a conversation** by typing a message.  

**Note:** If Meta AI is not available in your country, you may need to wait for wider rollout.

---

### **ðŸ“Œ Step 3: Ask a Question**  
- Type any question or request, such as:  
  _"Explain how CSS Flexbox works."_  
  _"Generate a JavaScript function to fetch API data."_  
- Meta AI will provide an instant response, and you can refine the query by asking follow-up questions.

---

### **ðŸ“Œ Step 4: Use Meta AI for Web Development Help**  
âœ… **Get coding assistance:** _"Write a responsive navbar in HTML/CSS."_  
âœ… **Debugging:** _"Why is my JavaScript function not working?"_  
âœ… **AI-powered research:** _"Explain the differences between WordPress and static site generators."_  

---

### **ðŸ“Œ Step 5: Optional â€“ Enable Meta AI in Chats (If Available)**  
Meta AI can be **enabled in group chats** on Messenger & WhatsApp:  
1. Start a new chat or group.  
2. Type `@Meta AI` to tag the chatbot in a conversation.  
3. Ask for information, summaries, or assistance.  

---

### **ðŸš€ Tips for Using Meta AI Effectively**  
âœ… **Use clear, specific prompts** (_e.g., â€œExplain JavaScript closures with examplesâ€_).  
âœ… **Ask for real-world use cases** (_e.g., â€œHow do businesses use AI for marketing?â€_).  
âœ… **Experiment with follow-up questions** to refine responses.  

---

### **ðŸ“Œ Troubleshooting Access Issues**  
- If **Meta AI is not showing up**, it may not be available in your region yet.  
- **Try updating your Messenger/Instagram app** to see if the feature is available.  
- Check Metaâ€™s official announcements for updates: **[https://about.fb.com/technology/meta-ai/](https://about.fb.com/technology/meta-ai/)**.  
# How to Create a GitHub Account

Creating a GitHub account is essential for storing, managing, and collaborating on your Python projects. Follow these step-by-step instructions to set up your account.

---

## Step 1: Go to the GitHub Sign-Up Page
1. Open your web browser and go to [GitHub Sign-Up](https://github.com/join).
2. You will see a form asking for personal details.

---

## Step 2: Enter Your Information
1. **Username** â€“ Choose a unique GitHub username. This will be your public identity.
2. **Email Address** â€“ Enter a valid email address.
3. **Password** â€“ Create a strong password (at least 8 characters, including letters, numbers, and symbols).
4. Click **Continue** to proceed.

---

## Step 3: Verify Your Account
1. You may need to solve a simple puzzle to prove youâ€™re human.
2. Once verified, click **Create Account**.

---

## Step 4: Customize Your GitHub Experience
1. Choose whether you want to receive **product updates and announcements**.
2. Click **Continue** to proceed.

---

## Step 5: Verify Your Email Address
1. Open your email inbox and look for a **GitHub verification email**.
2. Click the **Verify Email** button in the email.
3. Your account is now confirmed!

---

## Step 6: Set Up Your GitHub Profile
1. After verifying your email, you will be taken to your GitHub homepage.
2. Click on your **profile picture (top-right corner)** > **Settings**.
3. Add a **profile picture, bio, and location** (optional but recommended).
4. Set your **visibility preferences**.

---

## Step 7: Create Your First Repository (Optional, but Recommended)
1. Click on the **New Repository** button.
2. Give your repository a **name** (e.g., `my-first-repo`).
3. Choose the visibility:
   - **Public** (anyone can see it).
   - **Private** (only you and invited collaborators can see it).
4. Check **Add a README file** (recommended for project descriptions).
5. Click **Create Repository**.

---

## Step 8: Install Git (Optional, for Advanced Users)
1. If you plan to use Git locally, download and install Git from [git-scm.com](https://git-scm.com/).
2. Configure Git on your computer:
   ```bash
   git config --global user.name "Your Name"
   git config --global user.email "your-email@example.com"
   ```
3. Now you can **clone**, **push**, and **pull** repositories using Git commands.

---

## Next Steps
Now that you have a GitHub account, you can:
- Create and manage repositories.
- Collaborate with others on coding projects.
- Use GitHub to submit assignments or track your progress.

Youâ€™re all set! ðŸš€ Happy coding!

# How to Create a Google Account

Creating a Google Account is necessary to access Google Colab, Google Drive, and other services required for this course. Follow these step-by-step instructions to set up your account.

---

## Step 1: Go to the Google Account Sign-Up Page
1. Open your web browser and go to [accounts.google.com/signup](https://accounts.google.com/signup).
2. You will see a form asking for personal details.

---

## Step 2: Enter Your Information
1. **First Name & Last Name** â€“ Enter your real or preferred name.
2. **Username** â€“ Choose a unique email address (e.g., `yourname@gmail.com`).
   - If your preferred username is taken, try adding numbers or variations.
3. **Password** â€“ Create a strong password (at least 8 characters, a mix of letters, numbers, and symbols).
4. **Confirm Password** â€“ Re-enter the password to verify.
5. Click **Next** to continue.

---

## Step 3: Verify Your Identity
1. **Phone Number (Optional, but Recommended)** â€“ Enter your phone number for account recovery.
2. **Recovery Email (Optional, but Recommended)** â€“ If you have another email, add it to help recover your account if needed.
3. **Date of Birth** â€“ Select your birthdate.
4. **Gender** â€“ Choose your gender or select "Rather not say."
5. Click **Next** to proceed.

---

## Step 4: Agree to Googleâ€™s Terms
1. Read Googleâ€™s Privacy Policy and Terms of Service.
2. Scroll down and click **I Agree** to accept the terms.

---

## Step 5: Verify Your Email (If Required)
1. If you entered a phone number, Google may send a verification code.
2. Check your text messages and enter the **6-digit code** sent by Google.
3. Click **Verify**.

---

## Step 6: Access Your New Google Account
1. Once verified, youâ€™ll be taken to your new Google Account homepage.
2. From here, you can access **Google Drive, Google Colab, and Gmail**.
3. To confirm your account is active, go to [Google.com](https://www.google.com) and click your profile icon in the top-right corner.

---

## Next Steps
Now that you have a Google Account, you can:
- Log in to **Google Colab** at [colab.research.google.com](https://colab.research.google.com).
- Store files in **Google Drive** at [drive.google.com](https://drive.google.com).
- Use **Gmail** for email communication.

Congratulations! ðŸŽ‰ Youâ€™re ready to start using Googleâ€™s services for your learning journey!

### **ðŸš€ How to Create and Use Anthropic's Claude AI Chatbot**  

Claude AI, developed by **Anthropic**, is an advanced AI assistant similar to ChatGPT and Google Gemini. It is designed for **natural conversations, research, and coding assistance**.

---

### **ðŸ“Œ Step 1: Access Claude AI**  
Claude is available via:  
âœ… **Web App**: Go to **[https://claude.ai](https://claude.ai/)**.  
âœ… **Slack Integration**: Available as a chatbot in **Slack workspaces** (if enabled).  
âœ… **API Access**: Developers can integrate Claude via API (**paid access**).  

---

### **ðŸ“Œ Step 2: Sign Up for a Free Account**  
1. Go to **[https://claude.ai](https://claude.ai/)**.  
2. Click **â€œSign Upâ€** and enter your **email address**.  
3. Choose a **strong password** and confirm your email.  

âœ… **Alternative:** If your workspace uses Claude in **Slack**, you may be able to access it directly within a Slack chat.

---

### **ðŸ“Œ Step 3: Start Using Claude AI**  
Once logged in, you can **start a chat session** by entering a question or request.  

âœ… **Example Prompts:**  
- _"Explain how CSS Grid works."_  
- _"Write a Python script to scrape a webpage."_  
- _"Compare SQL vs. NoSQL databases."_  

---

### **ðŸ“Œ Step 4: Using Claude AI for Web Development**  
âœ… **Code Generation:** _"Create a responsive navbar using HTML, CSS, and JavaScript."_  
âœ… **Debugging Help:** _"Why is my JavaScript fetch request returning an error?"_  
âœ… **AI Code Comparison:** _"Compare the efficiency of this AI-generated function vs. my manually written version."_  
âœ… **Learning & Documentation:** _"Summarize the main differences between React and Vue.js."_  

---

### **ðŸ“Œ Step 5: Optional â€“ Claude AI API (For Developers)**  
Claude AI also provides an API for integration into applications.  
1. Visit **[Anthropicâ€™s API Docs](https://www.anthropic.com/)**.  
2. Sign up for API access (**may require payment**).  
3. Use API keys to integrate Claude into your own projects.  

---

### **ðŸš€ Tips for Using Claude AI Effectively**  
âœ… **Use detailed prompts** (_e.g., â€œExplain CSS Flexbox with a real-world exampleâ€_).  
âœ… **Ask for structured responses** (_e.g., "List the pros and cons of using Tailwind CSS"_).  
âœ… **Experiment with follow-up questions** to refine AI-generated responses.  

---

### **ðŸ“Œ Troubleshooting Access Issues**  
- **Claude may not be available in all regions**â€”check [Claude.ai](https://claude.ai/) for availability.  
- If **Claude is slow or unavailable**, try accessing it during off-peak hours.  
- Ensure your **browser is updated** for the best experience.  
### **ðŸš€ How to Create a Free OpenAI ChatGPT Account**
You can create a free OpenAI ChatGPT account to access AI-powered text generation, coding assistance, and learning support. Follow these steps:

---

### **ðŸ“Œ Step 1: Visit OpenAI's Website**
1. Open your web browser and go to **[https://openai.com](https://openai.com)**.  
2. Click on **â€œSign Upâ€** (top right corner).

---

### **ðŸ“Œ Step 2: Register Your Account**
You can sign up using:
- **Email Address**
- **Google Account**
- **Microsoft Account**
- **Apple ID**

âœ… **Recommended:** Using Google/Microsoft makes login faster.

1. If signing up with an **email**, enter your email address and click **Continue**.
2. Choose a **strong password** and click **Continue**.
3. Open your email and click the **verification link** sent by OpenAI.

---

### **ðŸ“Œ Step 3: Verify Your Phone Number**
1. Enter a **valid phone number** (this is required for security).
2. OpenAI will send you a **verification code via SMS**.
3. Enter the code to confirm your identity.

âœ… **Tip:** Use a personal number (Google Voice or VoIP numbers may not work).

---

### **ðŸ“Œ Step 4: Access Free ChatGPT**
1. Once verified, youâ€™ll be directed to **ChatGPTâ€™s main page**.
2. You can now start using **ChatGPT Free (GPT-3.5)**.
3. Click **â€œNew Chatâ€** and enter your question or prompt.

---

### **ðŸ“Œ Optional: Upgrade to GPT-4 (Paid)**
- OpenAI offers **ChatGPT Plus ($20/month)** for **GPT-4 access**.
- This is **not required** but provides **better responses**.

---

### **ðŸ“Œ Step 5: Start Using ChatGPT**
âœ… Ask coding questions, generate text, debug code, and more!  
âœ… Save **useful responses** in notes or documents.  
âœ… Experiment with **different prompts** to get the best results.

---

### **ðŸš€ Need Help?**
- If you encounter issues, visit OpenAIâ€™s **[Support Page](https://help.openai.com/)**.
- Some regions may **block OpenAI** (use a VPN if needed).

Would you like **sample AI prompts** to help students get started with ChatGPT? ðŸš€---
title: "Tutor Guide â€“ Course Overview"
subtitle: "Empowering Students to Build Strong Python Foundations"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## Introduction & Purpose

This guide provides an overview of the course structure, expectations, and key workflows to support tutors in effectively guiding students through the learning process. It outlines:

- The **pedagogical approach** (flipped classroom, AI-assisted learning, and progressive difficulty).
- **Key workflows**, including Google Colab and GitHub usage.
- **AI expectations**, ensuring students engage meaningfully with AI tools.
- **Assessment structure**, including quizzes and project submissions.
- **Support resources** for tutors and students.

By following this guide, tutors can provide a consistent learning experience that helps students build a strong Python foundation while adapting to modern AI-assisted development workflows.

## Slow Start & Increasing Task Difficulty

The first three to four weeks of the course progress very slowly, which may feel frustrating for students with some programming experience. Iâ€™ll acknowledge this in class and apologise in advance to those students.

However, itâ€™s crucial to establish a habit of engaging with the notebooks early. The first two to three weeks focus on sequence, selection, repetition, variables, and data types. While AI could generate answers for everything, students need to develop the discipline to use AI as a learning tool rather than just a shortcut to solutions.

Once we move beyond the basics, task difficulty will increase significantly. At that stage, students who have engaged consistently with the notebooks will have a more intuitive understanding of AI-generated code, making it easier to refine and apply in meaningful ways. This will be critical for success later in the course.

## Google Colab & GitHub Workflow
Students should follow this process to set up their workflow:

1. **Log into GitHub first.**
2. **Open the provided Colab notebook** (linked from the public GitHub repository).
3. **Use the â€œOpen in Colabâ€ button** to launch the notebook in their browser.
4. **Save a copy to their GitHub repository.** (Some students may need to run a cell before saving.)
5. **Confirm that their changes are properly saved in GitHub.**

This workflow will be used throughout the semester, so itâ€™s crucial to establish it early.

## AI Usage & Expectations
AI is encouraged throughout the course, but students must demonstrate understanding rather than just copying AI-generated code. The primary goal is **learning and comprehension**, not just producing a working solution.

### AI Use in Assessments
- **Final projects allocate only 10-15% of marks to working code.**
- The majority of marks come from:
  - Proper use of GitHub.
  - Clear understanding of concepts.
  - Adherence to best practices in coding.
- **Copying AI-generated code without modifications is a baseline fail.** Students must refine AI output, ensuring it aligns with course standards.

AI usage guidelines are embedded throughout the course materials, and students will receive structured support on how to use AI effectively.

## Course Structure & Materials
This unit follows a **flipped classroom model** with AI-assisted learning. Weekly content is released progressively to keep materials aligned with the course pace and student engagement.

### Lecture & Lab Materials
- **Students engage with flipped content before labs.**
- Weekly lecture content is available in multiple formats:
  - **HTML** (with a table of contents for easy navigation).
  - **PowerPoint & PDF** (downloadable for offline use).
  - **Audio & Video** (Google NotebookLM generates a podcast version; a video version will follow).
- Students can choose the format that best suits their learning style.

### Traditional Lectures vs. Flipped Model
- If you are running a **traditional lecture**, use the **â€œBefore the Labâ€** materials.
- This content is designed to function as a **mini-lecture split into 2-4 sections** for better engagement.

## Tutor Notes & Weekly Quizzes
- **Tutor notes** for each week are uploaded to the STAFF-MATERIAL section on Blackboard.
- If anything is unclear or missing, please let me know.

### Lab Exit Quizzes
- **Required for the first eight weeks.**
- **Access:** The quiz activates at the end of the scheduled lab session.
- **Restrictions:**
  - Access is controlled via Blackboard groups.
  - IP filtering ensures students complete it in their designated lab.
  - (For the first few weeks, quizzes may remain open for longer to resolve technical issues.)
- **Encourage students to complete the quiz independently**, using AI if needed.
- Quizzes can be attempted multiple times.

## Project & Notebook Submission
- **Students do not submit weekly notebooks.**
- Notebooks are for **learning purposes** but contribute to the final project.
- **Lab sessions introduce notebooks,** but students are expected to complete unfinished work independently.

**Expected Weekly Time Commitment:**
- **Total: ~10 hours per unit per week.**
  - **Contact Hours:** ~3 hours (labs + support).
  - **Independent Study:** ~7 hours (review, practice, and research).

Encourage students to **pace themselves and engage actively** with the material, rather than just focusing on task completion.
---
title: "Tutor Guide â€“ Week 1: Python Fundamentals and Chatbot Project"
subtitle: "Empowering Students to Build Strong Python Foundations"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

### Introduction for Tutors

Welcome to your tutor guide for Week 1! The purpose of these notes is to provide you with background information, key learning outcomes, and a suggested timeline for delivering the material. Please note that, for this week, the tasks are very basic, and the instructions provided in the student notebooks are detailed and self-explanatory. As such, a separate staff version of the notebooks has not been created. Your role is to support and facilitate student learning, ensuring that everyone builds a solid foundation in Python fundamentals.

### Background & Preparation

- **Accounts Setup:**  
  Ensure all students have created both a Google account and a GitHub account prior to the lab. These accounts are **critical** for accessing course materials and submitting assignments throughout the course.

- **Flipped Content Overview:**  
  Normally, students are expected to complete the flipped content before coming to lab. Since this is the first week, dedicate the first **5 minutes** of the session to explain the flipped learning model and emphasise that, from Week 2 onward, pre-lab preparation is mandatory.

- **Pacing:**  
  The first 3â€“4 weeks are intentionally slow-paced to establish a strong grasp of fundamental programming concepts, such as:
  - **Sequence:** The order in which code executes.
  - **Selection:** The use of conditional statements (if-elif-else).
  - **Repetition:** Looping constructs (e.g., while loops).
  - **Data and Values:** Understanding basic data types in Python.



### Learning Outcomes

By the end of this session, students should be able to:
- Use the Python `print()` function to produce output.
- Identify and fix basic syntax and formatting errors in Python code.
- Write clean, readable code by effectively using formatting, blank lines, and comments.
- Modify a simple AI Chatbot script to personalise its responses.
- Appreciate the evolution from static output (using `print()`) to more interactive programming approaches.



### Two-Hour Lab Session â€“ Suggested Timings

1. **Introduction & Flipped Content Overview (5 minutes):**  
   - Explain the flipped classroom model.
   - Stress that all subsequent weeks require pre-lab content completion.

2. **Accounts Check (10 minutes):**  
   - Verify that all students have set up their Google and GitHub accounts.

3. **Worksheet 1: Hello Python (15 minutes):**  
   - Walk through the "Hello Python" notebook.
   - Demonstrate code execution and address any questions.

4. **Worksheet 2: Fixing Mistakes (15 minutes):**  
   - Guide students in identifying and correcting errors.
   - Emphasise reading error messages and using AI for clarifications if needed.

5. **Worksheet 3: Making Code Clear and Readable (15 minutes):**  
   - Highlight the importance of formatting and commenting.
   - Allow time for students to experiment with different formatting options.

6. **Project: Simple AI Chatbot (20 minutes):**  
   - Introduce the starter code and review the conversation flow.
   - Discuss modification tasks, encouraging creativity and personalisation.
   - Remind students that the focus is on mastering the `print()` function and building a strong foundation.

7. **Optional Extension Activity (Optional, 5 minutes):**  
   - Briefly present the advanced extension section.
   - Stress that this section is entirely optional and intended for those curious about more advanced concepts.
   - Reiterate that the fundamentals must be mastered first.
   - complete in own time as required

8. **Wrap-Up & Q&A & Quiz (10 minutes):**  
   - Summarise key concepts covered in the session.
   - Open the floor for questions and clarifications.
   - Remind students to complete the flipped content before the next lab session.
   - **Lab Exit Quiz (5 mins)**
      - Active in the last 30 mins of the sessison (maybe discuss earlier)
      - log in and Complete the Quiz
      - Work Independently (using AI is ok)
      - Submit on Time
      - Can redo the quiz as many times as they like




### Additional Notes for Tutors

- **Emphasise Fundamentals:**  
  Although the tasks are simple, the goal is to build a solid understanding of the basics. Encourage students to work through problems on their own before relying on AI for answers.

- **Friendly and Supportive Tone:**  
  Use humour and relatable examples to keep the session engaging. Reinforce that making mistakes is a natural part of learning.

- **Pacing and Interaction:**  
  Monitor student progress carefully. Some may require more time on certain sections, so be prepared to revisit concepts as needed. Encourage active participation and discussion.

- **Extension Activity Caution:**  
  Remind students that the optional extension activity is only for those who are curious about more advanced topics. Make it clear that the primary focus is on mastering the fundamentals through the basic exercises.

- **Lab Exit Quiz**
  During the final 30 minutes of the lab session, the lab exit quiz will become active. This is a multiple-choice quiz designed to assess the students' understanding of the material covered in today's session. Please instruct the students to:

  - Log in and Complete the Quiz: Ensure they have access to the quiz platform (via their Google/GitHub accounts if applicable) and that they complete all the questions before the lab ends.
  - Work Independently: Remind students that the quiz is an individual assessment. Encourage them to rely on their understanding of the concepts rather than external help during this time.
  - Submit on Time: Emphasise that the quiz is timed and must be submitted before the session concludes.
  - Redo the quiz as many time as they like

By following these guidelines, you'll help ensure that students build a robust foundation in Python programming while staying engaged and motivated for future, more challenging tasks.

Happy teaching!---
title: "GitHub Repository Setup Guide for Python Course"
author: "Michael Borck"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


## **Step 1: Create a GitHub Repository**
1. **Go to GitHub**: [https://github.com](https://github.com) and log in.
2. Click the **"+" (plus icon)** at the top-right and select **"New repository"**.
3. **Repository Name**: Choose a meaningful name, e.g., `python-beginners-course`.
4. **Description** (Optional): "This repository contains materials for the beginner's Python course."
5. **Visibility**:
   - Public (if you want anyone to access it).
   - Private (if it's for enrolled students only).
6. **Initialize the repository**:
   - Check **"Add a README file"** (recommended for an overview).
   - Check **".gitignore"** and select **"Python"** (prevents unnecessary files from being tracked).
7. Click **"Create repository"**.

---

## **Step 2: Clone the Repository (For Local Use)**
(If students want to work locally before pushing to GitHub)

1. **Copy the Repository URL**: On the repository page, click the **"Code"** button and copy the HTTPS or SSH link.
2. **Open Terminal or Git Bash** (on Windows/Mac/Linux).
3. Run:
   ```bash
   git clone <repository_url>
   cd python-beginners-course
   ```

---

## **Step 3: Connect Google Colab to GitHub**
1. **Open Google Colab**: [https://colab.research.google.com](https://colab.research.google.com/)
2. **Sign in** with your Google account.
3. Click **"File" > "Open Notebook"**.
4. Select the **GitHub tab** and authorize Colab to access your GitHub account.
5. Choose the repository and the notebook file you want to work on.
6. Click **"Open"** to start editing.

---

## **Step 4: Save Colab Notebooks to GitHub**
1. In Google Colab, after making changes, go to:
   - **File > Save a copy in GitHub**.
2. Select the correct repository and branch.
3. Add a commit message (e.g., "Added loops lesson").
4. Click **OK** to push the changes.

---

## **Step 5: Commit & Push Changes (Command Line)**
(For those who cloned the repository and made local changes)

1. Open Terminal or Git Bash in the repo folder.
2. Add files to staging:
   ```bash
   git add .
   ```
3. Commit changes with a message:
   ```bash
   git commit -m "Added week 1 exercises"
   ```
4. Push changes to GitHub:
   ```bash
   git push origin main
   ```

---

## **Step 6: Pull Changes (To Sync with the Latest Version)**
If changes were made remotely (e.g., by the instructor), students should **pull** updates before making new edits:

```bash
git pull origin main
```

---

## **Bonus: Create Student Submission Folders (Optional)**
If students are required to submit assignments:
- **Option 1**: Each student forks the main repo and submits a pull request.
- **Option 2**: Create a `submissions/` folder where students upload their `.ipynb` files.

---

### âœ… **Now your GitHub repository is ready for use with Google Colab!**  
