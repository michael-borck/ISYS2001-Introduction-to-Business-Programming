---
author: Michael Borck
format:
  docx:
    highlight-style: github
    toc: false
  html:
    embed-resources: true
    toc: true
    toc-expand: 2
  pdf:
    colorlinks: true
    toc: false
  pptx:
    reference-doc: ../../_assets/template.pptx
title: 'Mastering Python''s Data Structures: Unleashing Weather Insights'
---

# Copyright
![](../../_assets/curtin-copy-right.png)

# Acknowledgement of Country
I acknowledge the traditional custodians of the land on which I work and live,
and recognise their continuing connection to land, water and community. I pay
respect to Elders past, present and emerging.

![](../../_assets/ack_country.png)

# Agenda

1. Introduction to Data Structures
2. Lists and Tuples
3. Dictionaries and Sets
4. Weather Data Analysis Example
5. Practical Applications
6. Summary and Conclusion

# Introduction to Data Structures

- What are data structures?
- Why are they important?
  - Efficient data organisation and manipulation
  - Fundamental in programming
- Python's built-in data structures
- Role in solving complex problems

# Lists: Dynamic and Versatile

- Ordered, mutable sequences
- Characteristics:
  - Store various data types
  - Accessed by index
  - Flexible sise
- Syntax: `[1, 'apple', 3.14]`

## List Operations

- Adding elements: `append()`, `insert()`
- Removing elements: `remove()`, `pop()`
- Slicing and indexing
- Sorting and reversing
- List comprehensions

# Tuples: Immutable Collections

- Ordered, immutable sequences
- Key features:
  - Similar to lists, but unchangeable
  - Defined using parentheses
  - Faster than lists for read-only operations
- Syntax: `(1, 'apple', 3.14)`

## Tuple Operations

- Accessing elements by index
- Slicing and concatenation
- Unpacking tuples
- Converting to/from lists
- Use cases: return values, dictionary keys

# Dictionaries: Key-Value Mappings

- Unordered, mutable mappings
- Structure:
  - Key-value pairs
  - Keys must be unique and immutable
- Fast value retrieval
- Syntax: `{'name': 'John', 'age': 30}`

## Dictionary Operations

- Adding and updating key-value pairs
- Accessing values by key
- `get()` method for safe access
- Iterating over keys, values, and items
- Dictionary comprehensions

# Sets: Unique Element Collections

- Unordered, mutable collections of unique elements
- Key features:
  - No duplicates allowed
  - Fast membership testing
  - Mathematical set operations
- Syntax: `{1, 2, 3}`

## Set Operations

- Adding and removing elements
- Union, intersection, difference
- Checking subset and superset relationships
- Eliminating duplicates from other collections
- Set comprehensions

# Weather Data Analysis Example

## Scenario
Analysing temperature data for a weather station

## Data Structure Choice
- Lists: Store daily temperature readings
- Dictionaries: Organise data by date and location
- Sets: Track unique observation dates

## Sample Data
```python
weather_data = {
    '2023-08-01': {'temp': [22.5, 23.1, 24.0, 23.8, 22.9], 'location': 'City A'},
    '2023-08-02': {'temp': [21.8, 22.7, 23.5, 23.1, 22.0], 'location': 'City A'},
    # ... more data ...
}
```

# Calculating Averages

```python
def calculate_average_temp(temperatures):
    return sum(temperatures) / len(temperatures) if temperatures else None

avg_temps = {date: calculate_average_temp(data['temp']) 
             for date, data in weather_data.items()}
```

- Demonstrates use of dictionaries and list operations
- Handles potential empty lists
- Uses dictionary comprehension for concise code

# Finding Extremes

```python
def find_temp_extremes(temperatures):
    return (min(temperatures), max(temperatures)) if temperatures else (None, None)

temp_extremes = {date: find_temp_extremes(data['temp']) 
                 for date, data in weather_data.items()}
```

- Shows tuple usage for returning multiple values
- Utilises min() and max() functions
- Demonstrates error handling for empty lists

# Extracting Specific Information

```python
hot_days = {date for date, data in weather_data.items() 
            if max(data['temp']) > 25}

city_a_data = {date: data for date, data in weather_data.items() 
               if data['location'] == 'City A'}
```

- Utilises set and dictionary comprehensions
- Demonstrates filtering data based on conditions
- Shows how to combine different data structures

# Practical Applications

1. Data Analysis and Visualisation
   - Pandas for data manipulation
   - Matplotlib/Seaborn for plotting

2. Database Management
   - Using dictionaries to represent database records
   - Lists for query results

3. Machine Learning and AI
   - NumPy arrays (built on lists) for efficient computations
   - Dictionaries for feature engineering

4. Web Development and APIs
   - JSON data (similar to dictionaries) for data exchange
   - Lists for handling multiple records

# Summary and Conclusion

- Explored Python's core data structures:
  - Lists: Dynamic, ordered collections
  - Tuples: Immutable, ordered collections
  - Dictionaries: Key-value mappings
  - Sets: Unique element collections
- Applied these structures to weather data analysis
- Demonstrated practical coding examples
- Discussed real-world applications

## Key Takeaway
Mastering these data structures is crucial for efficient and effective Python programming across various domains.

# Questions and Discussion

- What other data structures might be useful for weather analysis?
- How might we optimise our code for larger datasets?
- Any specific areas you'd like to explore further?

Thank you for your attention!

---
title: "ISYS2001 Introduction to Business Programming with AI-Assisted Coding"
format:
   pdf: default
---

## Course Description

This course introduces students to business programming using Python, with a
focus on AI-assisted coding techniques. Students will learn practical
applications in data analysis, automation, and visualisation while leveraging AI
tools to enhance their coding skills. The course utilises Jupyter Notebooks,
Google Colab, and GitHub for collaborative coding and version control,
integrating AI-powered coding assistants throughout the learning process. The
course culminates in an AI-assisted project that lays the foundation for
advanced development in the subsequent Business Development course.

## Weekly Schedule

1. Introduction to Python, Jupyter Notebooks, and AI-assisted coding tools
2. Basic Python syntax, data types, and AI-generated code snippets
3. Control structures, functions, and AI-powered code completion
4. Lists, dictionaries, file handling, and AI-assisted debugging
5. Introduction to data analysis with pandas and AI-enhanced data cleaning
6. Data visualisation with matplotlib and AI-suggested plot improvements
7. Web scraping basics with AI-assisted parsing techniques
8. Introduction to API usage and AI-powered API integration
9. Introduction to VSCode, script development, and AI code refactoring
10. Project work: Developing a modular dashboard application with AI assistance
11. AI-enhanced testing and debugging techniques
12. Final project presentations and AI-assisted code review

## Project Focus

Students will develop a modular dashboard application (e.g., for weather data or
stock market analysis) using functional programming paradigms and AI-assisted
coding techniques. This project will serve as the foundation for further
development in the advanced course, demonstrating the integration of AI tools in
the software development process.


## Assessment and Project Integration

1. **Modular Library Development** In the introductory course, students will
   create a modular library for data retrieval and processing. In the advanced
   course, they will refactor this library using OOP principles and expand its
   functionality.

2. **Open Source Contribution** Introduce students to open source contribution
   in the advanced course by having them contribute to a class-wide open source
   project hosted on GitHub. This project could be an extension of their
   dashboard applications or a new collaborative project.

3. **Code Review and Collaboration** Implement peer code reviews in both
   courses, with more advanced techniques introduced in the second course. This
   will help students understand the importance of code quality and
   collaboration in software development.

4. **Portfolio Development** Encourage students to maintain a portfolio of their
   projects on GitHub, starting from the introductory course and expanding it in
   the advanced course. This will showcase their progress and provide a valuable
   resource for future job searches.

5. **Industry-Inspired Challenges** Introduce real-world programming challenges
   inspired by industry problems in both courses, with increasing complexity in
   the advanced course. This will help students understand the practical
   applications of their skills.

By implementing this plan, students will experience a more cohesive learning
journey across both courses, gaining practical skills that are directly
applicable to real-world business programming scenarios. The gradual
introduction of more advanced tools and concepts will help smooth the transition
between the courses, while the continuous project development will reinforce
learning and demonstrate the students' growing capabilities.

Clarifying "functional programming": In the introductory unit, "functional
programming" refers to using functions rather than the more formal concept of
pure functions. It it important to clarify this for students to avoid confusion
with the more advanced functional programming paradigm.


## Assessment and Project Integration

1. **AI-Assisted Modular Library Development**: Students will create a modular
   library for data retrieval and processing, utilising AI tools for code
   generation and optimisation.

2. **Open Source Contribution with AI Collaboration**: Introduce students to
   open source contribution, incorporating AI-assisted code review and
   improvement suggestions.

3. **AI-Enhanced Code Review and Collaboration**: Implement peer code reviews
   augmented by AI-powered code analysis tools.

4. **AI-Integrated Portfolio Development**: Encourage students to maintain a
   portfolio of their projects on GitHub, showcasing both their coding skills
   and their ability to effectively use AI coding assistants.

5. **Industry-Inspired AI Coding Challenges**: Introduce real-world programming
   challenges that incorporate AI-assisted problem-solving techniques.

## Course Outline


@tbl-course-outline provides a comprehensive overview of the course structure, with
examples and exercises that progressively build towards the final weather
dashboard project while aligning with each week's learning objectives.


| Week | Topic | Examples/Exercises |
|------|-------|---------------------|
| 1 | Introduction to Python and Jupyter Notebooks | 1. Print "Hello, Weather!" <br> 2. Basic arithmetic with temperature values <br> 3. Create a simple weather variable and print it |
| 2 | Basic Python syntax and data types | 1. Prompt for temperature input and format output with degree symbol <br> 2. Convert temperature between Celsius and Fahrenheit <br> 3. Create variables for different weather conditions (sunny, rainy, etc.) |
| 3 | Control structures and functions | 1. Use if-else to categorise temperature as hot or cold <br> 2. Create a function to convert Kelvin to Celsius <br> 3. Use a loop to print a 5-day temperature forecast |
| 4 | Lists, dictionaries, and file handling | 1. Create a list of daily temperatures and calculate the average <br> 2. Use a dictionary to store weather data for different cities <br> 3. Read/write weather data from/to a text file |
| 5 | Introduction to data analysis with pandas | 1. Load weather data from a CSV file into a pandas DataFrame <br> 2. Calculate average monthly temperatures using pandas <br> 3. Count the number of rainy days in a month |
| 6 | Data visualisation with matplotlib | 1. Create a line plot of temperature over time <br> 2. Make a bar chart of rainfall amounts for different cities <br> 3. Generate a pie chart of weather conditions (sunny, cloudy, rainy) |
| 7 | Web scraping basics | 1. Extract current temperature from a weather website <br> 2. Scrape a 5-day forecast table from a weather page <br> 3. Extract and display weather warnings or alerts |
| 8 | Introduction to API usage | 1. Fetch current weather data from OpenWeatherMap API <br> 2. Retrieve and display weather icons from the API <br> 3. Get and parse a 5-day forecast from the API |
| 9 | Introduction to VSCode and script development | 1. Convert Jupyter notebook code to a Python script in VSCode <br> 2. Create a simple command-line interface for the weather dashboard <br> 3. Implement error handling for API requests |
| 10 | Project work: Developing a modular dashboard application | 1. Create separate functions for data fetching, processing, and display <br> 2. Implement a basic caching system to reduce API calls <br> 3. Add user input for choosing different cities |
| 11 | Testing and debugging techniques | 1. Write docstring tests for the temperature conversion function <br> 2. Use assert statements to validate API response data <br> 3. Implement try-except blocks for error handling |
| 12 | Final project presentations and code review | 1. Refine and optimise the dashboard based on peer feedback <br> 2. Add final touches like color-coding based on temperature <br> 3. Prepare a brief presentation showcasing the dashboard features |

: Course outline with examples and exercises for each week, leading to the final project. {#tbl-course-outline}

## SFIA Skills Alignment

| SFIA Skill | Description | Level | Why/How |
|------------|-------------|-------|---------|
| Programming/software development (PROG) | Designing, coding, verifying, testing, documenting, amending and refactoring programs/scripts. Includes applying agreed standards and tools to achieve well-engineered outcomes. | 2-3 | Core skill for the course; students will be coding in Python throughout |
| Data science (DATS) | Applying mathematics, statistics, data mining and predictive modelling techniques to gain insights, predict behaviours and generate value from data. | 2-3 | Relevant for data analysis with pandas and the weather dashboard project |
| Data visualisation (VISL) | Facilitating understanding of data by displaying concepts, ideas, and facts using graphical representations. | 2-3 | Directly applicable to the data visualisation component using matplotlib |
| Quality assurance (QUAS) | Determining compliance with organisational directives, standards and procedures, and identifying non-compliances, non-conformances and abnormal occurrences. | 2-3 | Relevant for testing and debugging techniques covered in the course |
| Methods and tools (METL) | Ensuring that appropriate methods and tools for the planning, development, testing, operation, management and maintenance of systems are adopted and used effectively throughout the organisation. | 2-3 | Applicable for using Jupyter Notebooks, Google Colab, and GitHub |
| Emerging technology monitoring (EMRG) | Identifying and assessing new and emerging technologies, products, services, methods and techniques. | 2-3 | Relevant for the AI-assisted coding aspects of the course |
| Problem management (PBMG) | Identifying and resolving issues to prevent recurrence. | 2-3 | Relevant for debugging and problem-solving techniques in programming |

:This table aligns the SFIA skills with the course content, focusing on the introductory nature of the course (hence the lower skill levels) while covering the key areas of programming, data analysis, visualisation, and the use of various tools and methodologies.{#tbl-sfia-skills} 

## Summary of Changes

The refreshed Introduction to Business Programming course now incorporates
AI-assisted coding techniques throughout the curriculum. Students will learn to
leverage AI tools to enhance their coding skills, improve problem-solving
abilities, and increase productivity. The weather dashboard application project
now includes AI-assisted development, allowing students to experience firsthand
how AI can augment the software development process.

Key additions include the integration of AI coding assistants in daily
programming tasks, AI-enhanced debugging and testing techniques, and the use of
AI for code optimisation and refactoring. The course emphasises the "Tour Guide"
approach to AI-assisted programming, where students act as navigators, setting
the direction and strategic thinking, while collaborating with AI tools for code
suggestions and problem-solving.

The assessment strategy now includes evaluation of students' ability to
effectively use AI tools in their coding process, promoting a balance between
leveraging AI assistance and developing fundamental programming skills. This
AI-driven focus prepares students for the evolving landscape of software
development, where AI tools are becoming increasingly integral to the coding
process.



---
title: "ISYS2001 Introduction to Business Programming"
subtitle: "An Ai Driven Focus"
format:
   pdf: default
---

Based on the course structure and project focus you've provided, I've updated the markdown table to include AI-related concepts and tasks for each week. This integration aims to enhance the learning experience by incorporating AI-assisted programming techniques throughout the course:

| Week | Topic | Examples/Exercises | AI-Related Concepts and Tasks |
|------|-------|---------------------|--------------------------------|
| 1 | Introduction to Python and Jupyter Notebooks | 1. Print "Hello, Weather!" <br> 2. Basic arithmetic with temperature values <br> 3. Create a simple weather variable and print it | - Introduction to AI-assisted coding <br> - Setting up AI coding environment (e.g., GitHub Copilot, ChatGPT) <br> - Use AI to generate simple Python statements |
| 2 | Basic Python syntax and data types | 1. Prompt for temperature input and format output with degree symbol <br> 2. Convert temperature between Celsius and Fahrenheit <br> 3. Create variables for different weather conditions (sunny, rainy, etc.) | - Use AI to suggest variable names and data types <br> - Ask AI to explain Python syntax rules <br> - Compare AI-generated code with manual code |
| 3 | Control structures and functions | 1. Use if-else to categorise temperature as hot or cold <br> 2. Create a function to convert Kelvin to Celsius <br> 3. Use a loop to print a 5-day temperature forecast | - Use AI to generate function templates <br> - Ask AI to suggest different loop structures <br> - Practice refining AI-generated control structures |
| 4 | Lists, dictionaries, and file handling | 1. Create a list of daily temperatures and calculate the average <br> 2. Use a dictionary to store weather data for different cities <br> 3. Read/write weather data from/to a text file | - Use AI to generate list and dictionary operations <br> - Ask AI for file handling code snippets <br> - Collaborate with AI to design data structures |
| 5 | Introduction to data analysis with pandas | 1. Load weather data from a CSV file into a pandas DataFrame <br> 2. Calculate average monthly temperatures using pandas <br> 3. Count the number of rainy days in a month | - Use AI to generate pandas import statements and basic operations <br> - Ask AI for pandas data manipulation techniques <br> - Collaborate with AI to clean and preprocess data |
| 6 | Data visualisation with matplotlib | 1. Create a line plot of temperature over time <br> 2. Make a bar chart of rainfall amounts for different cities <br> 3. Generate a pie chart of weather conditions (sunny, cloudy, rainy) | - Use AI to generate matplotlib code templates <br> - Ask AI for customization options in plots <br> - Collaborate with AI to design effective visualizations |
| 7 | Web scraping basics | 1. Extract current temperature from a weather website <br> 2. Scrape a 5-day forecast table from a weather page <br> 3. Extract and display weather warnings or alerts | - Use AI to suggest web scraping libraries and methods <br> - Ask AI to generate HTML parsing code <br> - Collaborate with AI to handle different webpage structures |
| 8 | Introduction to API usage | 1. Fetch current weather data from OpenWeatherMap API <br> 2. Retrieve and display weather icons from the API <br> 3. Get and parse a 5-day forecast from the API | - Use AI to generate API request templates <br> - Ask AI to explain API authentication methods <br> - Collaborate with AI to parse and structure API responses |
| 9 | Introduction to VSCode and script development | 1. Convert Jupyter notebook code to a Python script in VSCode <br> 2. Create a simple command-line interface for the weather dashboard <br> 3. Implement error handling for API requests | - Use AI to suggest VSCode extensions for Python development <br> - Ask AI for best practices in script organization <br> - Collaborate with AI to implement error handling strategies |
| 10 | Project work: Developing a modular dashboard application | 1. Create separate functions for data fetching, processing, and display <br> 2. Implement a basic caching system to reduce API calls <br> 3. Add user input for choosing different cities | - Use AI to suggest modular design patterns <br> - Ask AI for caching implementation ideas <br> - Collaborate with AI to design user input validation |
| 11 | Testing and debugging techniques | 1. Write docstring tests for the temperature conversion function <br> 2. Use assert statements to validate API response data <br> 3. Implement try-except blocks for error handling | - Use AI to generate test cases <br> - Ask AI for debugging strategies <br> - Collaborate with AI to refine error messages and logging |
| 12 | Final project presentations and code review | 1. Refine and optimise the dashboard based on peer feedback <br> 2. Add final touches like color-coding based on temperature <br> 3. Prepare a brief presentation showcasing the dashboard features | - Use AI to suggest code optimizations <br> - Ask AI for presentation structure ideas <br> - Reflect on the role of AI in the development process |

This updated schedule integrates AI-assisted programming throughout the course, allowing students to leverage AI tools while developing their programming skills. It encourages a balance between using AI assistance and understanding the underlying concepts, promoting critical thinking and problem-solving abilities alongside AI collaboration.

Citations:
[1] https://www.manning.com/books/learn-ai-assisted-python-programming
[2] https://stackoverflow.blog/2024/04/03/developers-with-ai-assistants-need-to-follow-the-pair-programming-model/
[3] https://www.oreilly.com/library/view/learn-ai-assisted-python/9781633437784AU/
[4] https://www.deeplearning.ai/short-courses/pair-programming-llm/


## Blended Approach to Microlearning and Lecture for Week 1

Based on the information provided and educational best practices, I would recommend using a combination of microlearning videos and a shortened lecture for Week 1, rather than completely replacing the lecture with online microlearning. Here's why:

1. Blended approach benefits:
Combining microlearning with a traditional lecture leverages the strengths of both methods. Microlearning provides flexibility, engagement, and focused content, while the lecture allows for in-depth explanations, context-setting, and immediate interaction[1][5].

2. Introduction and context:
Week 1 is crucial for setting the tone of the course and providing an overview. A lecture allows you to introduce yourself, explain the course structure, and address any initial questions or concerns students may have[3].

3. Varied learning styles:
Offering both microlearning videos and a lecture caters to different learning preferences. Some students may benefit more from self-paced online content, while others may prefer face-to-face instruction[2].

4. Gradual transition:
Introducing microlearning alongside a traditional lecture helps students transition into this new learning method, especially if they're not familiar with it[7].

5. Reinforcement and retention:
Using microlearning videos before or after the lecture can reinforce key concepts and improve retention. This aligns with the spaced repetition principle, which is known to enhance learning[4][5].

6. Engagement and interaction:
While microlearning is excellent for engagement, a live lecture provides opportunities for immediate questions, discussions, and peer interactions that can't be fully replicated in online formats[6].

Suggested approach:
1. Create short microlearning videos (3-5 minutes each) covering key concepts for Week 1.
2. Assign these videos as pre-lecture material for students to watch.
3. Conduct a shortened lecture (30-45 minutes) that builds upon the microlearning content, provides context, and allows for Q&A.
4. Use the remaining time for interactive activities or a brief introduction to the lab component.

This approach combines the benefits of microlearning (flexibility, focused content, improved retention) with the advantages of traditional lectures (context, interaction, immediate feedback). It also sets the stage for gradually increasing the use of microlearning throughout the course as students become more comfortable with this method[8].

Citations:
[1] https://elearningindustry.com/benefits-of-microlearning-case-studies
[2] https://www.i3-technologies.com/en/blog/stories/education/exploring-microlearning-examples-benefits-and-drawbacks/
[3] https://ponchoelearning.com.au/microlearning-vs-traditional-learning/
[4] https://www.researchgate.net/publication/324552176_The_Effectiveness_of_Microlearning_to_Improve_Students%27_Learning_Ability
[5] https://www.ispringsolutions.com/blog/benefits-of-microlearning
[6] https://knowledgeone.ca/infographic-microlearning-benefits-and-disadvantages/
[7] https://link.springer.com/article/10.1007/s11042-020-09523-z
[8] https://www.arist.co/post/microlearning-research-benefits-and-best-practices


Based on the information provided and the research on blended learning and microlearning in higher education, I would recommend a blended approach for most weeks, but not necessarily every week. Here's why:

1. Flexibility and variety: A blended approach combining microlearning and traditional lectures offers flexibility and caters to different learning styles. This variety can help maintain student engagement throughout the course.

2. Gradual transition: Introducing microlearning gradually allows students to adapt to this new learning method, especially if they're not familiar with it. Starting with a more traditional approach and slowly increasing the use of microlearning can be beneficial.

3. Content-dependent approach: Some topics may be better suited for traditional lectures, while others may benefit more from microlearning. The complexity of the subject matter should guide the choice of teaching method.

4. Reinforcement and retention: Using microlearning to supplement traditional lectures can improve knowledge retention. Short, focused content can be used to reinforce key concepts introduced in lectures.

5. Time for interaction: Maintaining some face-to-face lecture time allows for immediate questions, discussions, and peer interactions that can't be fully replicated in online formats.

6. Balanced workload: A blended approach can help balance the workload for both students and instructors. While microlearning can be time-efficient, creating high-quality microlearning content can be resource-intensive.

Recommendation:
1. Start with a more traditional lecture-based approach in the first few weeks, gradually introducing microlearning elements.
2. For most weeks, use a blended approach that combines microlearning with shortened lectures.
3. Reserve some weeks for fully traditional lectures, especially for complex topics that require in-depth explanations and discussions.
4. Use microlearning for review weeks or to reinforce key concepts throughout the course.
5. Be flexible and adjust the balance based on student feedback and the specific needs of each topic.

This balanced approach allows you to leverage the benefits of both methods while mitigating their respective drawbacks, providing a rich and effective learning experience for your students.

Citations:
[1] https://elearningindustry.com/pros-cons-blended-learning-at-college
[2] https://link.springer.com/article/10.1007/s11042-020-09523-z
[3] https://www.researchgate.net/publication/230390603_The_effectiveness_and_experiences_of_blended_learning_approaches_to_computer_programming_education
[4] https://educationaltechnologyjournal.springeropen.com/articles/10.1186/s41239-022-00379-x
[5] https://elearningindustry.com/the-benefits-of-microlearning-for-higher-education
[6] https://dl.acm.org/doi/abs/10.1145/3587103.3594159
[7] https://varthana.com/school/benefits-of-microlearning-for-higher-education



Based on the best practices and the content for Week 1, I would recommend creating 10-12 microlearning modules. This number allows for a comprehensive coverage of the week's topics without overwhelming the students. Each module should be 3-5 minutes long, focusing on a single concept or skill.

Here's a suggested list of microlearning modules for Week 1:

1. Introduction to Python: What is Python and why use it?
2. Setting up your Python environment
3. Introduction to Jupyter Notebooks
4. Basic Python syntax: Variables and data types
5. Printing in Python: Your first "Hello, Weather!" program
6. Basic arithmetic operations in Python
7. Working with temperature values: A practical example
8. Creating and using weather-related variables
9. Introduction to AI-assisted coding tools
10. Setting up GitHub Copilot or ChatGPT for coding assistance
11. Using AI to generate simple Python statements
12. Best practices for AI-assisted coding

This set of modules covers the essential topics for Week 1, including both Python basics and an introduction to AI-assisted coding. The number of modules allows students to spread their learning throughout the week, complementing the 1-hour lecture and 2-hour tutorial.

For the tuition pattern:
- Students can watch 5-6 modules before the lecture
- The 1-hour lecture can reinforce key concepts and address questions
- The remaining modules can be viewed before or during the 2-hour tutorial
- The tutorial can focus on hands-on practice and applying the concepts learned in the modules

This approach provides a good balance between self-paced learning through microlearning modules and instructor-led sessions for clarification and practice. It also allows for flexibility, as students can revisit the modules as needed throughout the week.

Citations:
[1] https://elearningindustry.com/design-a-great-microlearning-experience-5-best-practices
[2] https://www.udemy.com/course/micro-learning-python-programming/
[3] https://www.udemy.com/course/introduction-to-ai-tools-for-coders-and-programmers/
[4] https://www.qualee.com/blog/the-9-best-practices-of-microlearning

Based on your input, I understand that Week 1 is unique since you can't effectively communicate with the cohort until the first lecture. However, you still plan to produce 10-12 microlearning modules for Week 1 and will use that first lecture to set up and manage expectations for the subsequent weeks. Here's a suggested approach for Week 1 microlearning modules:

1. Introduction to Python and AI-assisted programming (3-5 minutes)
2. Setting up the AI-powered IDE (3-5 minutes)
3. Basic Python syntax: Variables and data types (3-5 minutes)
4. Simple "Hello, Weather!" program (3-5 minutes)
5. Basic arithmetic with temperature values (3-5 minutes)
6. Creating weather-related variables (3-5 minutes)
7. Introduction to AI coding tools (e.g., GitHub Copilot, ChatGPT) (3-5 minutes)
8. Using AI to generate simple Python statements (3-5 minutes)
9. Best practices for AI-assisted coding (3-5 minutes)
10. Overview of the course structure and expectations (3-5 minutes)
11. Introduction to Jupyter Notebooks (3-5 minutes)
12. Navigating and using Google Colab (3-5 minutes)

These modules cover the essential topics for Week 1, including both Python basics and an introduction to AI-assisted coding. They also provide an overview of the course structure and tools that will be used throughout the semester.

During your first lecture, you can:

1. Introduce yourself and the course
2. Explain the concept of microlearning and how it will be used throughout the semester
3. Guide students through accessing and using the microlearning modules
4. Set expectations for weekly workload and participation
5. Introduce the concept of AI-assisted programming and its role in the course
6. Explain the "Tour Guide" pair programming style with AI
7. Discuss the weather dashboard project that students will work on throughout the semester
8. Address any initial questions or concerns

This approach allows you to provide students with valuable content before the first lecture while still using that face-to-face time to set the tone for the course and manage expectations for the coming weeks.

Citations:
[1] https://link.springer.com/article/10.1007/s12528-024-09408-2
[2] https://www.linkedin.com/pulse/microlearning-higher-education-guide-go-learning-world-edugate-eg-qlikf
[3] https://www.reddit.com/r/learnprogramming/comments/e1q45q/first_week_of_programming_am_i_the_exception_or/
[4] https://peer.asee.org/integrating-microlearning-instructional-approach-into-an-introductory-data-management-course.pdf
[5] https://www.taotesting.com/blog/how-to-use-micro-learning-to-drive-student-engagement-in-higher-education/
[6] https://files.eric.ed.gov/fulltext/EJ1310066.pdf
[7] https://education.nsw.gov.au/teaching-and-learning/curriculum/professional-learning/mathematics-3-6-microlearning
[8] https://www.qualee.com/blog/the-9-best-practices-of-microlearning
[9] https://www.howtocode.io/posts/the-self-taught-developer/how-to-manage-your-expectations-while-teaching-yourself-how-to-code
[10] https://www.igi-global.com/chapter/microlearning-as-a-solution-to-challenges-in-teaching-and-learning-introductory-programming-courses/340432
[11] https://practera.com/microlearning-the-key-to-student-engagement/
[12] https://codetribe.com/blog/2020/07/09/10-tips-first-year-teaching-computer-science/
[13] https://education.nsw.gov.au/teaching-and-learning/curriculum/professional-learning/english-k-2
[14] https://www.gettingsmart.com/2017/03/05/three-ways-to-use-microlearning-in-higher-education-classrooms/
[15] https://education.nsw.gov.au/campaigns/inclusive-practice-hub/all-resources/primary-resources/other-pdf-resources/programming-guide

---
title: SFIA Skills Alignment
format:
    docx: default
---

| SFIA Skill | Description | Level | Why/How |
|------------|-------------|-------|---------|
| Programming/software development (PROG) | Designing, coding, verifying, testing, documenting, amending and refactoring programs/scripts. Includes applying agreed standards and tools to achieve well-engineered outcomes. | 2-3 | Core skill for the course; students will be coding in Python throughout |
| Data science (DATS) | Applying mathematics, statistics, data mining and predictive modelling techniques to gain insights, predict behaviours and generate value from data. | 2-3 | Relevant for data analysis with pandas and the weather dashboard project |
| Data visualisation (VISL) | Facilitating understanding of data by displaying concepts, ideas, and facts using graphical representations. | 2-3 | Directly applicable to the data visualisation component using matplotlib |
| Quality assurance (QUAS) | Determining compliance with organisational directives, standards and procedures, and identifying non-compliances, non-conformances and abnormal occurrences. | 2-3 | Relevant for testing and debugging techniques covered in the course |
| Methods and tools (METL) | Ensuring that appropriate methods and tools for the planning, development, testing, operation, management and maintenance of systems are adopted and used effectively throughout the organisation. | 2-3 | Applicable for using Jupyter Notebooks, Google Colab, and GitHub |
| Emerging technology monitoring (EMRG) | Identifying and assessing new and emerging technologies, products, services, methods and techniques. | 2-3 | Relevant for the AI-assisted coding aspects of the course |
| Problem management (PBMG) | Identifying and resolving issues to prevent recurrence. | 2-3 | Relevant for debugging and problem-solving techniques in programming |

:This table aligns the SFIA skills with the course content, focusing on the introductory nature of the course (hence the lower skill levels) while covering the key areas of programming, data analysis, visualisation, and the use of various tools and methodologies.{#tbl-sfia-skills} 


# Weekly Journal Marking Rubric

## Criteria

| Criteria      | Fail                                                                                                                                 | Pass                                                                                                                                           | Credit                                                                                                                                     | Distinction                                                                                                                              | High Distinction                                                                                                                            |
|---------------|-------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|
| **Consistency** | Submissions are sporadic or non-existent. Fewer than half of the required drafts are submitted by the deadlines.                  | Most drafts are submitted on time, with only minor delays. At least half of the weekly tasks are submitted as drafts.                           | Drafts are submitted consistently each week with only one or two exceptions.                                                              | Drafts are submitted on time every week. Any delays are well-communicated and justified.                                                 | Drafts are submitted on time every week without exception. Extra effort is evident in maintaining consistent submission ahead of schedule. |
| **Completeness** | Many weekly tasks are incomplete or missing entirely. Reflective writing is lacking or absent. Incomplete understanding of the assignment requirements.            | Most tasks are complete, including basic reflective writing. The work may cover only the basic requirements.                          | All tasks are complete with satisfactory coverage and reflective writing on all required aspects.                               | All tasks are completed with thorough detail and reflective insights, demonstrating a deep understanding in responses.         | All tasks are completed with exceptional detail, creativity, reflective depth, and insight that exceeds standard requirements.   |



---
title: MARKING GUIDE - Reflective Journals
subtitle: ISYS2002 Introduction to Business Programming
format:
    pdf:
      toc: true
      colorlinks: true
    docx:
      toc: true
      highlight-style: github
    html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

### General Guidelines for Giving Feedback

Providing constructive and effective feedback is crucial for student
learning, especially in courses that involve practical skills like programming.
Here's some general guidance for markers on how to give feedback to students:

1. **Be Specific and Constructive:**
   - **Specificity:** Avoid vague feedback. Instead, specify exactly what the
     student did well or needs to improve. For example, if a student's Python
     notebook has errors, point out the specific lines or logic that caused the
     issue.
   - **Constructiveness:** Feedback should not just criticise but also guide.
     Offer suggestions on how they can improve, such as recommending resources
     or techniques to master difficult concepts.

2. **Balance Positives and Negatives:**
   - **Positive Reinforcement:** Always try to find something positive to say,
     even in work that needs significant improvement. This encourages students
     and makes them more receptive to criticism.
   - **Critical Feedback:** Balance your feedback by also pointing out areas
     that need improvement, but do so in a way that motivates and educates.

3. **Encourage Self-Reflection:**
   - Ask questions in your feedback that encourage students to reflect on their
     own learning processes. For example, "What do you think went wrong here?"
     or "How could this code be improved for efficiency?"
   - Encouraging self-assessment helps students develop critical thinking and
     self-learning skills.

4. **Use Clear and Respectful Language:**
   - Avoid jargon unless you are sure the student understands it. Use clear,
     straightforward language.
   - Always maintain a respectful and professional tone, even when providing
     negative feedback.

5. **Offer Examples and Resources:**
   - When possible, provide examples that clearly illustrate high-quality work
     or correct approaches to problems.
   - Recommend specific resources such as tutorials, books, or lectures that can
     help the student understand the concepts better.

6. **Follow-Up:**
   - Offer to discuss the feedback in more detail if the student has questions
     or needs further clarification. This can be through office hours, emails,
     or scheduled appointments.
   - Checking back on progress after feedback shows students that you are
     invested in their improvement and success.

### Feedback Examples

Below are examples of feedback comments for journals submitted by beginner
programmers, categorised into poor, good, and best levels based on the quality
of their reflective writing and the functionality of attached Python notebooks.
These comments aim to provide constructive feedback to help students understand
their performance and areas for improvement.

#### Poor Journal Feedback

**Feedback for Reflective Writing:** "Your journal entries need more depth in
reflecting on the learning process. It's important to not only describe what you
did but also to consider what you learned from the experience, the challenges
you faced, and how you can apply this knowledge in the future. Try to make your
reflections more personal and insightful."

**Feedback for Python Notebooks:** "The attached Python notebooks contain
several errors that prevent them from running successfully. It looks like you
might be struggling with some basic concepts. I recommend reviewing the recent
modules on Python syntax and looping structures. Please visit the learning
resources section for additional tutorials to help you understand these concepts
better."

#### Good Journal Feedback

**Feedback for Reflective Writing:** "Your journal entries show a good
understanding of the topics covered each week. You've done well describing the
activities and summarising the content. To enhance your reflections, try to
include more about your personal learning experience, such as any difficulties
you encountered and how you overcame them. Reflecting on these experiences can
provide deeper insights into your learning process."

**Feedback for Python Notebooks:** "Your Python notebooks are mostly functional,
but there are a few minor errors that could be easily fixed. It seems like you
understand the basic programming concepts, which is great. To improve, make sure
to test your code thoroughly before submission and consider edge cases that
might cause errors. Keep practising, and you'll continue to improve."

#### Best Journal Feedback

**Feedback for Reflective Writing:** "Excellent reflective writing! You have not
only detailed what you have learned each week but also critically analysed how
these new skills can be applied to real-world problems. Your reflections show a
deep understanding of the learning material and a thoughtful consideration of
your personal growth as a programmer. Keep up the great work!"

**Feedback for Python Notebooks:** "Your Python notebooks are well-organised,
cleanly coded, and function flawlessly. It’s clear that you have put a lot of
effort into understanding the course material and applying it effectively in
your code. Your ability to incorporate advanced features and maintain
readability is impressive. Excellent job on demonstrating your programming
skills!"

These examples aim to guide students on how they can improve their submissions
and recognize the strengths and weaknesses in their current work.

### Example Feedback Template

If you are stuck, here's a template that can help structure your feedback:

>Great effort on [specific task]. I noticed that you [mention something done well], which shows your understanding of [specific concept]. This is a great approach because [reason why it was good].
>
>I would like to see some improvement in [area of improvement]. Currently,[describe the issue briefly]. You might find it helpful to review [specific resource or topic]. For example, [give a brief example of how to improve].
>
>If you have any questions about this feedback or need further assistance, please don't hesitate to reach out.


#### Assessing Consistency

- **Check Creation Date:** Verify that each journal entry was created on or
  before the due date listed in the teaching schedule of the Unit Outline.
  Journals are due the night before the Monday listed.
  - **Identifying Dates:** The date displayed under the journal title is the
    creation date. If two dates are shown, the first is the creation date and
    the second is the last edited date, which you should ignore.
  - **Scoring:** Award 100% for consistency if all creation dates are valid.
    Deduct 15% for each late journal entry, then select the appropriate mark in
    the "Consistency" row of the rubric.

#### Assessing Completeness

- **Review Journal Content:** Focus on the body of the journal and any attached
  evidence of learning. Assess engagement with the topic and functionality of
  included notebooks.
   - **Notebook Functionality:** It’s acceptable if some notebooks have minor
     issues. Generally, the majority should be functional.
   - **Sampling:** Randomly check a few notebooks across the six entries. If
     they function properly and the journal entry is satisfactory, award full
     marks. Otherwise, subtract 5-15% for each incomplete week.
   - **Scoring:** Select the appropriate mark on the "Completeness" row in the
     rubric.

#### Accessing and Using the Rubric

- **Locate the Rubric:** The rubric is located in the grade centre.
   - Navigate to the grade centre, find the student, and hover over the icon
     under 'Reflective Journal'.
   - Click the down arrow that appears and select 'Mark User Activity'. This
     opens the student's journal.
- **Review Journals:** The student’s latest journal entry appears in the centre,
  with other entries shown towards the bottom right. Inspect all journals to
  make your assessment.
  Journal' link, located at the top right below the student’s name and next to
- **Complete the Rubric:** The rubric can be accessed by clicking the 'Weekly
  'used for marking'.
   - Repeat this process for each student.

These steps will guide you through the assessment process for each student’s
weekly journal submissions. Please ensure accuracy and fairness in your
evaluations.

---
title: "Psuedo Code for Analysis - Staff Answer Key"
author: "ISYS2001 Introduction to Business Programming"
format:
  pdf:
    toc: true
    number-sections: false
    colorlinks: true
  docx:
    toc: true
    number-sections: false
    highlight-style: github
  html:
    toc: true
    toc-expand: 2
    embed-resources: true
---

## Introduction

These notes are staff-in-confidence please DO NOT share with the students.  They
provide one way to achieve the tasks, even though I risk influencing your
guidance to the students. They may be wrong, but are provided for your
understand.  It is expected to be read in conjunction with the assignment
specification. The aim is to provide a structured approach to the analysis tasks
in the simulation assignments, guiding students through the process of exploring
different scenarios and analysing the results. The pseudo code outlines the
steps to follow and the functions to implement for each task, helping students
understand the impact of various factors on the simulated systems.

## Stock Market Simulation (and Resource Price FLuctuations) Analysis - Staff Answer Key

Here is some pseudo code for each task in the analysis, followed by the adjusted
guidance on how to conduct visual analysis using the `StockMarketSimulation`
class. This approach provides structured yet open-ended guidance to encourage
student experimentation and learning.

> This is very similar to resource price fluctuations, but with a different
> context. The pseudo code is structured to guide students through the analysis
> process, helping them understand the impact of different factors on stock
> prices and investment strategies.  Apply the same strategies to resource price
> fluctuations.

#### 1. Investigate the Impact of Volatility 

   - Objective: Explore how different levels of volatility affect stock price
     fluctuations and the potential for investment gains or losses.

```python
# Pseudo code for analysing the impact of different volatility levels on stock price stability

volatility_levels = [0.01, 0.02, 0.05]  # Different levels of volatility to test
for volatility in volatility_levels:
    sim = StockMarketSimulation(start_price=100, days=365, volatility=volatility, drift=0.001)
    prices = sim.run_simulation()
    plot_prices(prices)  # Visualise stock price fluctuations for each volatility level
    print_statistics(prices)  # Function to print or calculate statistical metrics (mean, std, max drawdown)
```

#### 2. Simulate a Major Market Event   

   - Objective: Analyse the immediate and long-term effects of a major market
     event on stock prices.

```python
# Pseudo code for simulating and analysing a major market event

event_days = [50, 150, 250]  # Days to simulate a market event
event_impacts = [0.1, -0.1]  # Positive for beneficial, negative for detrimental impacts
for day in event_days:
    for impact in event_impacts:
        sim = StockMarketSimulation(start_price=100, days=365, volatility=0.02, 
                                    drift=0.001, event_day=day, event_impact=impact)
        prices = sim.run_simulation()
        plot_prices(prices, event_day=day)  # Visualise with the event day marked
        analyse_event_impact(prices, day)  # Analyse and compare before and after event prices
```

#### 3. Develop and Test Trading Strategies

   - Objective: Develop simple trading strategies and test their effectiveness
     over the simulation period.

```python
# Pseudo code for developing and testing trading strategies based on stock price trends

strategies = ['moving_average_crossover', 'buy_and_hold', 'contrarian']
for strategy in strategies:
    sim = StockMarketSimulation(start_price=100, days=365, volatility=0.02, drift=0.001)
    prices = sim.run_simulation()
    strategy_results = apply_strategy(prices, strategy)  # Apply and analyse strategy
    plot_strategy_results(strategy_results)  # Visualise effectiveness of strategies
```

**Auxiliary Functions to Implement**

- **print_statistics(prices)**: function to print or calculate statistical metrics (mean, std, max drawdown)
- **analyse_event_impact(prices, day)**: Analyse and compare before and after event prices 
- **apply_strategy(strategy)**: apply and analyse strategy
- **plot_strategy_results(strategy_results)**: Visualise effectiveness of strategies 


## Product Popularity Simulation Analysis - Staff Answer Key

Here's the pseudo code for each of the tasks in the analysis section of your
product popularity simulation assignment. This will help students structure
their experiments and analyses effectively.

#### 1. Examine How Changes in Growth Rate and Marketing Impact Affect Demand

  - Objective: Investigate how different settings for natural growth rate and
    ongoing marketing efforts influence the overall demand for a product.

```python
# Pseudo code for analysing changes in growth rate and marketing impact

growth_rates = [0.01, 0.02, 0.03]  # Different growth rates to test
marketing_impacts = [0.05, 0.1, 0.15]  # Different marketing impacts to test

for growth_rate in growth_rates:
    for marketing_impact in marketing_impacts:
        sim = ProductPopularitySimulation(start_demand=500, days=180, growth_rate=growth_rate,
                                          marketing_impact=marketing_impact)
        demand = sim.run_simulation()
        plot_demand(demand)  # Visualise the demand curve for each combination
        print_demand_statistics(demand)  # Function to print or calculate demand statistics
```

#### 2. Simulate a Major Marketing Campaign and Analyse Its Effect on Demand Growth

  - Objective: Analyse how a significant promotional campaign affects the demand
    for a product both immediately and over time.

```python
# Pseudo code for simulating and analysing a major marketing campaign

promotion_days = [30, 60, 90]  # Days to start the promotion campaign
promotion_effects = [0.2, 0.5, 0.7]  # Different levels of campaign effectiveness

for day in promotion_days:
    for effect in promotion_effects:
        sim = ProductPopularitySimulation(start_demand=500, days=180, growth_rate=0.02,
                                          marketing_impact=0.1, promotion_day=day, promotion_effectiveness=effect)
        demand = sim.run_simulation()
        plot_demand(demand, promotion_day=day)  # Visualise with the campaign day marked
        analyse_campaign_effect(demand, day)  # Analyse and compare before and after campaign demand
```

#### 3. Explore Different Marketing Strategies and Their Cost-Effectiveness

  - Objective: Explore various marketing strategies and evaluate their return on
    investment (ROI) based on the increase in demand relative to the costs.

```python
# Pseudo code for exploring and comparing different marketing strategies

strategies = ['social_media_boost', 'discount_offers', 'influencer_partnerships']
costs = {'social_media_boost': 1000, 'discount_offers': 500, 'influencer_partnerships': 1500}

for strategy in strategies:
    # Assume different effectiveness and costs for each strategy
    sim = ProductPopularitySimulation(start_demand=500, days=180, growth_rate=0.02,
                                      marketing_impact=0.1, promotion_day=30, promotion_effectiveness=strategy_effectiveness(strategy))
    demand = sim.run_simulation()
    plot_demand(demand)  # Visualise effectiveness of strategies
    total_cost = costs[strategy]
    evaluate_roi(demand, total_cost)  # Calculate and display the ROI of each strategy
```

**Auxiliary Functions to Implement**

- **print_demand_statistics(demand)**: Calculates and prints statistics like
  mean demand, peak demand, etc.
- **analyse_campaign_effect(demand, promotion_day)**: Compares demand levels
  before and after the promotional campaign to assess its impact.
- **strategy_effectiveness(strategy)**: Returns a hypothetical effectiveness
  value based on the strategy type.
- **evaluate_roi(demand, cost)**: Calculates return on investment by comparing
  the increase in demand against the strategy cost.


# Weather Dashboard Project

Welcome to the Weather Dashboard Project, a 10-session project-based course in Python. This repository contains the necessary materials to complete the project, including worksheets, cheat sheets, source code, and slides.

## Project Overview

In this project, you will create a weather dashboard that fetches data from OpenWeatherMap API, manages data with CSV, visualizes data with Matplotlib, and builds a dashboard with Jupyter Widgets. You will also learn how to scrape data from websites and use APIs (optional).

## Repository Structure

* `slides`: Slides for each session, including notes and examples.
* `worksheets`: Worksheets for each session, including exercises and quizzes.
* `cheatsheets`: Cheat sheets for each session, summarizing key concepts and syntax.
* `code`: Source code for each session, including examples and exercises.
* `data`: Sample data used in the project.
* `docs`: This README file and other documentation.

## Getting Started

1. Clone this repository to your local machine.
2. Follow the instructions in each session's worksheet to complete the exercises and quizzes.
3. Use the cheat sheets to review key concepts and syntax.
4. Run the code in each session to see examples and exercises in action.
5. Use the slides to review the material and take notes.

## Contributing

Contributions are welcome! If you'd like to contribute to this project, please create a new issue or pull request with your suggested changes.

## License

This project is licensed under the MIT License. See `LICENSE` for details.


# calculator

Title: The Future of LLMs: From RAG Pipelines to AI Agents

Abstract: This paper explores the evolution of Large Language Models (LLMs) towards AI Agents, discussing the challenges and limitations of current LLM-based agents. We examine the concept of Retrieval-Augmented Language Models (RAG) and its applications in creating more efficient and effective AI agents. The paper also delves into the various types of agents, including Routing Agents, Query Planning Agents, and Tool Using Agents, highlighting their strengths and limitations. Finally, we discuss the future of LLMs and AI agents, including the potential for more advanced concepts like KV Caching and LLM compiler & OS.

Introduction: Large Language Models (LLMs) have revolutionized the field of natural language processing, enabling applications such as language translation, text summarization, and question answering. However, current LLM-based agents face significant challenges, including limitations in long-term planning, generalized human alignment, and knowledge limitation. To overcome these challenges, researchers have proposed the concept of Retrieval-Augmented Language Models (RAG), which combines the strengths of LLMs with the capabilities of retrieval-based models.

RAG Pipelines: RAG pipelines consist of three main components: the parametric part (LLMs), the non-parametric part (retrieval-based models), and the semi-parametric system. The parametric part is responsible for generating text, while the non-parametric part retrieves relevant information from a vast knowledge base. The semi-parametric system combines the strengths of both parts, enabling more efficient and effective language processing.

Types of Agents: Several types of agents have been proposed to leverage the capabilities of RAG pipelines. Routing Agents, for example, can route user queries to the most relevant data sources, while Query Planning Agents can break down complex queries into sub-questions and synthesize the results. Tool Using Agents can utilize external tools and APIs to gather more accurate information.

Challenges and Limitations: Despite the advancements in LLM-based agents, several challenges and limitations remain. For instance, LLM-based agents often struggle with long-term planning, generalized human alignment, and knowledge limitation. To overcome these challenges, researchers have proposed various techniques, such as KV Caching and LLM compiler & OS.

Future Directions: The future of LLMs and AI agents holds much promise, with potential applications in areas such as natural language processing, computer vision, and robotics. The development of more advanced concepts like KV Caching and LLM compiler & OS could further enhance the capabilities of LLM-based agents.

Conclusion: In conclusion, the future of LLMs and AI agents is promising, with potential applications in various domains. However, significant challenges and limitations remain, and researchers must continue to address these challenges to unlock the full potential of LLM-based agents.

References:

[1] Solving Production Issues in Modern RAG Systems-I [2] Solving Production Issues in Modern RAG Systems-II [3] Next for LLMs and RAG AI Agentic Workflows [4] RAG 2.0: Retrieval-Augmented Language Models [5] Prompting Guide for LLM Agents [6] KV Caching and LLM compiler & OS [7] AutoGPT: A Framework for Building AI Agents [8] Llama Index: A Framework for Connecting Custom Data Sources to Large Language Models [9] GPT Engineer: Automating Code Generation for Development Tasks [10] DemoGPT: Autonomous AI Agent for Creating Interactive Streamlit Apps



### Academic Research Paper: Evolution and Challenges in Retrieval-Augmented Generation Systems

#### Abstract
In recent years, advancements in large language models (LLMs) have been complemented by the development of Retrieval-Augmented Generation (RAG) systems. These systems enhance the capabilities of LLMs by providing additional, relevant context, which aids in generating more precise responses. This paper summarizes the RAG system's integral role, the technical framework required to implement such systems, the main challenges faced, and potential solutions that may guide future developments.

#### Introduction
The swiftly evolving field of artificial intelligence has seen significant interest in the enhancement of LLMs through RAG systems. These systems are particularly relevant in customizing AI responses in corporate environments, where proprietary data is frequently utilized. RAG systems strive to incorporate contextual data dynamically into LLMs, thereby refining their output and making them more applicable to specific user queries.

#### RAG System Overview
The RAG system integrates a semi-parametric approach, where the parametric portion consists of the underlying LLM, and the non-parametric part includes external data sources, facilitating a more tailored response generation. In practice, the RAG pipeline involves splitting textual data into chunks, converting these into embeddings, and storing them in a vector database. These embeddings are then used by the LLM to generate informed and contextually relevant responses.

#### Challenges in RAG Implementation
Developing and maintaining RAG systems involves numerous challenges:
1. **Quality of Retrieval:** Often, retrieval mechanisms may fetch irrelevant data or miss crucial information, leading to suboptimal response generation.
2. **Scalability:** As data volumes increase, maintaining system performance without substantial delays or bottlenecks is a critical concern.
3. **Response Relevance and Bias:** Ensuring the relevance of responses and mitigating any inherent bias or toxicity from training data remains a formidable task.
4. **Updated Information:** Keeping the retrieved information current and relevant, especially in rapidly changing domains, is essential for the system’s reliability.

#### Proposed Solutions
Several strategies can be employed to address these challenges:
- **Enhanced Data Cleaning:** Implementing robust data preprocessing methods to improve data quality and relevancy.
- **Advanced Prompting Techniques:** Utilizing sophisticated prompts that guide the LLM in acknowledging uncertainties and limitations in its responses.
- **Hyperparameter Tuning:** Adjusting parameters such as chunk size and the number of top-k retrieved documents to optimize both performance and relevance.
- **Dynamic Updating of Information:** Regularly updating the stored embeddings to reflect the most current information available.
- **Use of Sophisticated Reranking Algorithms:** Applying advanced algorithms to rerank the retrieved data, ensuring that the most relevant information is used in response generation.

#### Conclusion
RAG systems represent a significant advancement in the utilization of LLMs, providing a framework through which more specific and contextually aware responses can be generated. However, the integration of these systems in real-world applications involves navigating several technical and practical challenges. Future research should focus on refining these systems, enhancing their scalability, and improving the accuracy and relevance of the generated responses. Continuous improvement in these areas will be crucial as we strive to optimize the practical deployment of AI technologies in specific domains.

#### References
1. Documentation on hyperparameter tuning in RAG systems.
2. Recent scholarly papers on RAG system failures and their mitigation strategies.

#### Future Research Directions
Investigating the potential of new technologies such as continuous learning systems, where LLMs can dynamically update their knowledge base, is a promising area. Moreover, exploring the integration of multi-modal data sources into RAG systems could further enhance their efficacy and applicability across various AI-driven applications.

By pursuing these advanced strategies and solutions, researchers and practitioners can address the current limitations and expand the utility of RAG systems in diverse AI applications, marking a step forward in the tailored use of large language models.

### Acknowledgements
The author thanks the contributors of the base articles and papers that provided foundational insights and data, which greatly assisted the research, although they may not agree with all of the interpretations/conclusions of this paper.

### General Feedback for Reflective Journals

#### Pass (50-64%)

**Strengths:**
- **Consistency:** You have submitted journal entries regularly, which shows a good effort in maintaining the habit of reflection.
- **Basic Reflection:** Your journal entries touch on the activities and topics covered each week, indicating an understanding of the course content.

**Areas for Improvement:**
- **Depth of Reflection:** Your reflections tend to be descriptive rather than analytical. Try to go beyond summarizing what you did and think more about what you learned and how it affected your understanding or skills.
- **Connection to Learning:** There is room for improvement in linking your reflections to your overall learning journey and personal growth as a programmer.

**Suggestions:**
- **Enhance Depth:** Aim to include more personal insights and critical thoughts in your reflections. Discuss challenges you faced, how you overcame them, and what you might do differently in the future.
- **Specific Examples:** Provide specific examples from your weekly experiences to illustrate your points. This will help to deepen your reflection and make it more meaningful.

#### Credit (65-74%)

**Strengths:**
- **Regular Submissions:** You have consistently submitted your journal entries on time, demonstrating good discipline.
- **Clear Understanding:** Your reflections show a clear understanding of the weekly topics and activities. You effectively describe what you learned each week.

**Areas for Improvement:**
- **Personal Insight:** While you describe your learning activities well, there is room to add more personal insights and reflections on your growth as a programmer.
- **Critical Analysis:** Your reflections could benefit from more critical analysis of the challenges you faced and how you addressed them.

**Suggestions:**
- **Deepen Reflections:** Try to include more detailed reflections on your personal experiences, such as specific difficulties you encountered and how you overcame them.
- **Link to Future Learning:** Reflect on how the week's learning can be applied to future programming tasks or projects. This will help to show a deeper understanding of the material.

#### Distinction (75-84%)

**Strengths:**
- **Thorough Reflections:** Your journal entries are thorough and well thought out, showing a deep understanding of the weekly material.
- **Personal Connection:** You effectively connect your reflections to your personal learning journey, discussing both successes and challenges.

**Areas for Improvement:**
- **Broader Implications:** While your reflections are detailed, consider discussing the broader implications of what you learned each week and how it connects to other areas of programming or future learning.

**Suggestions:**
- **Expand Horizons:** Reflect on how the skills and concepts you are learning can be applied to other areas of your studies or future career. This will help to show a more comprehensive understanding.
- **Continual Improvement:** Identify specific areas where you want to improve and set goals for future weeks. This will demonstrate a proactive approach to your learning.

#### High Distinction (85-100%)

**Strengths:**
- **Insightful Reflections:** Your journal entries are insightful and demonstrate a deep and critical understanding of the weekly topics. You provide excellent personal insights and connect your learning to real-world applications.
- **Consistent Excellence:** You have consistently submitted high-quality reflections that show thoughtful consideration of your learning process and personal growth.

**Areas for Improvement:**
- **Advanced Challenges:** Consider reflecting on more advanced challenges or exploring more complex aspects of the material to push your understanding even further.

**Suggestions:**
- **Advanced Application:** Think about how you can apply what you have learned in innovative or advanced ways. This could involve integrating multiple concepts or exploring new areas of programming.
- **Peer Feedback:** Engage with your peers to exchange feedback on your reflections. This can provide new perspectives and further enhance your learning.




### Revised Feedback

Your journal entries are in-depth, showcasing both what you learned and the challenges you faced, along with how you addressed them. It's great to see that the introduction to business programming is benefiting you in other units as well. Just a note: Task 4 under the Sundae Winner lab work is missing the code. The rest of your code looks good and includes helpful comments. Keep up the great work!

---

Great job maintaining consistency with your reflective journal. It's wonderful to hear you're following the lectures and enjoying the course. Consider reflecting on any challenges you faced and how you overcame them. What areas would you like to improve in your learning? If you have any questions or need further assistance, please don’t hesitate to reach out.

---

It's great to see your progress throughout the weeks. However, I noticed that some reflective journal entries are missing. I would love to understand what might have caused this. If you have any questions or need further assistance, please don’t hesitate to reach out.

---

Your reflective writing does a good job of detailing what you've learned in class. However, I would like to hear more about your personal feelings towards the unit, any challenges you might be facing, and whether you're enjoying the unit so far. Also, there are a couple of journal entries missing. If you have any questions or need further assistance, please don’t hesitate to reach out.

---

Your journal entries effectively detail your learning journey, highlighting both challenges and the solutions you've applied, which is the essence of reflective journaling. It's great that you took the time to catch up on missed lessons. Excellent effort with the code and student homework. In the future, please try to submit your journals weekly by the deadline. If you have any questions or need further assistance, please don’t hesitate to reach out.

---

Your first week's journal entry is quite detailed, and I was looking forward to reading about your experiences in the other weeks. However, I noticed you haven't attached any lab activities and only have one journal entry. Is there a specific reason for this? If you have any questions or need further assistance, please don’t hesitate to reach out.


---

Your journal entries are thorough and reflective, capturing both your learning experiences and the challenges you faced. It's impressive to see how you've applied concepts from the course to other areas. One small thing: Task 4 under the Sundae Winner labwork is missing the code. Your other code submissions are well-commented and clear. Keep up the great work!

---

You've been very consistent with your journal entries, which is commendable. It's great to see you engaged with the lectures and enjoying the course. Perhaps you could add more detail about any challenges you encountered and how you dealt with them. If you need any assistance or have questions, feel free to reach out.

---

Your progress over the weeks is evident and impressive. However, there are a few missing journal entries. I'd be interested to know what challenges you might have faced in completing them. If you need any help, please don’t hesitate to ask.

---

Your reflective writing clearly outlines what you have learned. To improve, try including your personal feelings about the unit, any challenges you faced, and whether you're enjoying the course. Also, ensure that you complete all journal entries. If you need any assistance, let me know.

---

Your journal entries do a good job of detailing your learning journey, including the challenges you faced and the solutions you applied. You've done well to catch up on any missed lessons. Going forward, please aim to submit your journals on time each week. If you have any questions or need further assistance, feel free to reach out.

---

Your first journal entry is detailed and insightful. I was looking forward to reading about your experiences in the following weeks, but it seems there are no further entries or attached lab activities. Is there a reason for this? If you need any help or have questions, please let me know.

---

Your journal entries reflect a strong understanding of the material and the challenges you faced. It's great to see how you're applying what you've learned. One suggestion: ensure all your code submissions are complete, as Task 4 under the Sundae Winner labwork was missing. Otherwise, excellent work!

---

You've done a great job staying consistent with your journal entries. It's clear you're engaged with the course material and enjoying the lectures. To add more depth, consider discussing any challenges you faced and how you overcame them. If you have any questions or need help, don’t hesitate to reach out.

---

Your journal entries demonstrate your learning progress well. However, I noticed some entries are missing. It would be helpful to understand what might have caused this and how I can support you. If you need assistance, please ask.

---

Your reflective writing shows a good grasp of the material. To improve, try including more personal insights about your experiences, challenges, and enjoyment of the course. Also, make sure to complete all your journal entries. If you need help or have any questions, feel free to reach out.

---

Your journal entries provide a detailed account of your learning, including the challenges and how you addressed them. This is exactly what reflective journaling is about. Well done on catching up with missed lessons and homework. In the future, try to submit your journals by the deadline each week. If you have any questions or need further assistance, feel free to reach out.

---

These comments are designed to provide clear, constructive, and positive feedback, helping students recognize their strengths and areas for improvement while encouraging them to continue their reflective practice.

# ISYS2001 Introduction to Business Programming 

### Extended Learning portfolio Semester 1 2023

Welcome to the final assessment repository for ISYS2001 Introduction to Business Programming. This repository contains the necessary materials for the assessment, including the assessment instructions, sample questions, and staff answers.

## Assessment Instructions

The assessment is designed to evaluate your understanding and application of the concepts covered in ISYS2001 Introduction to Business Programming. Please carefully read the instructions before proceeding.

### Google Colab

1. Click on `assessment_questions.ipynb` to view the notebook in the repository

2. Click on 'Open in Colab' button

3. In Colab, Implement your solutions for each question in the programming language specified in the question.

5. Once you have completed your solutions, save to your private repository.


### Local Jupyter Notebook Installation

1. Clone this repository to your local machine using the following command:
   ```
   git clone https://github.com/michael-borck/isys2001-elp-s1-2023
   ```

2. Once you have cloned the repository, navigate to the `isys2001-elp-s1-2023` folder. This folder contains the sample questions for the assessment.

3. Open the `assessment_questions_s1_2023.ipynb` file to view the questions.

4. Implement your solutions for each question in the programming language specified in the question.

5. Once you have completed your solutions, save to your private repository.


# worksheet-isys2001-s1-2023
This repos stores all the worksheets from the ISYS2001 Introduction to Business Programming 


# Business Programming with Python


# weathervista
A simple app to display weather information about a city in the world


BSD 3-Clause License

Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later)  
Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)  
Copyright 2004 Manfred Stienstra (the original version)

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


Copyright © 2019, [Encode OSS Ltd](https://www.encode.io/).
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


**This software is dual-licensed under the The University of Illinois/NCSA
Open Source License (NCSA) and The 3-Clause BSD License**

# NCSA Open Source License
**Copyright (c) 2019 Kevin Sheppard. All rights reserved.**

Developed by: Kevin Sheppard (<kevin.sheppard@economics.ox.ac.uk>,
<kevin.k.sheppard@gmail.com>)
[http://www.kevinsheppard.com](http://www.kevinsheppard.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal with
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimers.

Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimers in the documentation and/or
other materials provided with the distribution.

Neither the names of Kevin Sheppard, nor the names of any contributors may be
used to endorse or promote products derived from this Software without specific
prior written permission.

**THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH
THE SOFTWARE.**


# 3-Clause BSD License
**Copyright (c) 2019 Kevin Sheppard. All rights reserved.**

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
   may be used to endorse or promote products derived from this software
   without specific prior written permission.

**THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
THE POSSIBILITY OF SUCH DAMAGE.**

# Components

Many parts of this module have been derived from original sources, 
often the algorithm's designer. Component licenses are located with 
the component code.


Extensions allow extending the debugger without modifying the debugger code. This is implemented with explicit namespace
packages.

To implement your own extension:

1. Ensure that the root folder of your extension is in sys.path (add it to PYTHONPATH) 
2. Ensure that your module follows the directory structure below
3. The ``__init__.py`` files inside the pydevd_plugin and extension folder must contain the preamble below,
and nothing else.
Preamble: 
```python
try:
    __import__('pkg_resources').declare_namespace(__name__)
except ImportError:
    import pkgutil
    __path__ = pkgutil.extend_path(__path__, __name__)
```
4. Your plugin name inside the extensions folder must start with `"pydevd_plugin"`
5. Implement one or more of the abstract base classes defined in `_pydevd_bundle.pydevd_extension_api`. This can be done
by either inheriting from them or registering with the abstract base class.

* Directory structure:
```
|--  root_directory-> must be on python path
|    |-- pydevd_plugins
|    |   |-- __init__.py -> must contain preamble
|    |   |-- extensions
|    |   |   |-- __init__.py -> must contain preamble
|    |   |   |-- pydevd_plugin_plugin_name.py
```

Copyright © 2020, [Encode OSS Ltd](https://www.encode.io/).
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


BSD 3-Clause License

Copyright (c) 2013-2024, Kim Davies and contributors.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


MIT License

Copyright (c) 2023 Oleh Prypin <oleh@pryp.in>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


# README FIRST

Please do not add new templates for nbconvert here.

In order to speed up the distribution of nbconvert templates and make it
simpler to share such contributions, we encourage [sharing those links on our
wiki
page](https://github.com/ipython/ipython/wiki/Cookbook:%20nbconvert%20templates).


## Template skeleton

This directory contains the template skeleton files.

Do not modify the contents of the `../latex/skeleton` folder. Instead,
if you need to, make modifications to the files in this folder and then run
`make` to generate the corresponding latex skeleton files in the
`../latex/skeleton` folder.

If you would like to share your resulting templates with others, we encourage
[sharing those links on our wiki
page](https://github.com/ipython/ipython/wiki/Cookbook:%20nbconvert%20templates).


PyZMQ's CFFI support is designed only for (Unix) systems conforming to `have_sys_un_h = True`.


MIT License

Copyright (c) 2018 - 2023 Isaac Muse <isaacmuse@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


# License

## PyMdown Extensions

The MIT License (MIT)

Copyright (c) 2014 - 2023 Isaac Muse

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

## SuperFences

`superfences.py` is derived from Python Markdown's fenced_code extension.

```
Fenced Code Extension for Python Markdown
 =========================================
This extension adds Fenced Code Blocks to Python-Markdown.
See <https://python-markdown.github.io/extensions/fenced_code_blocks/>
for documentation.
Original code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/).
All changes Copyright 2008-2014 The Python Markdown Project
License: [BSD](http://www.opensource.org/licenses/bsd-license.php)
```

## Highlight

`highlight.py` is derived from Python Markdown's CodeHilite extension.

```
CodeHilite Extension for Python-Markdown
 ========================================
Adds code/syntax highlighting to standard Python-Markdown code blocks.
See <https://python-markdown.github.io/extensions/code_hilite/>
for documentation.
Original code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/).
All changes Copyright 2008-2014 The Python Markdown Project
License: [BSD](http://www.opensource.org/licenses/bsd-license.php)
```

## Gemoji Index

`gemoji_db.py` is generated from Gemoji's source code: @github/gemoji.

```
Copyright (c) 2013 GitHub, Inc.

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
```

## EmojiOne Index

`emoji1_db.py` is generated from EmojiOne's source code: @Ranks/emojione

```
EmojiOne Non-Artwork

Applies to the JavaScript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above.
License: MIT
Complete Legal Terms: http://opensource.org/licenses/MIT
```


# Implementation Notes for Internationalization of Jupyter Notebook

The implementation of i18n features for jupyter notebook is still a work-in-progress:

- User interface strings are (mostly) handled
- Console messages are not handled (their usefulness in a translated environment is questionable)
- Tooling has to be refined

However…

## How the language is selected ?

1. `jupyter notebook` command reads the `LANG` environment variable at startup,
   (`xx_XX` or just `xx` form, where `xx` is the language code you're wanting to
   run in).

Hint: if running Windows, you can set it in PowerShell with `${Env:LANG} = "xx_XX"`.
if running Ubuntu 14, you should set environment variable `LANGUAGE="xx_XX"`.

2. The preferred language for web pages in your browser settings (`xx`) is
   also used. At the moment, it has to be first in the list.

## Contributing and managing translations

### Requirements

- _pybabel_ (could be installed `pip install babel`)
- _po2json_ (could be installed with `npm install -g po2json`)

**All i18n-related commands are done from the related directory :**

```
cd notebook/i18n/
```

### Message extraction

The translatable material for notebook is split into 3 `.pot` files, as follows:

- _notebook/i18n/notebook.pot_ - Console and startup messages, basically anything that is
  produced by Python code.
- _notebook/i18n/nbui.pot_ - User interface strings, as extracted from the Jinja2 templates
  in _notebook/templates/\*.html_
- _noteook/i18n/nbjs.pot_ - JavaScript strings and dialogs, which contain much of the visible
  user interface for Jupyter notebook.

To extract the messages from the source code whenever new material is added, use the
`pybabel` command:

```shell
pybabel extract -F babel_notebook.cfg -o notebook.pot --no-wrap --project Jupyter .
pybabel extract -F babel_nbui.cfg -o nbui.pot --no-wrap --project Jupyter .
pybabel extract -F babel_nbjs.cfg -o nbjs.pot --no-wrap --project Jupyter .
```

After this is complete you have 3 `.pot` files that you can give to a translator for your favorite language.

### Messages compilation

After the source material has been translated, you should have 3 `.po` files with the same base names
as the `.pot` files above. Put them in `notebook/i18n/${LANG}/LC_MESSAGES`, where `${LANG}` is the language
code for your desired language ( i.e. German = "de", Japanese = "ja", etc. ).

_notebook.po_ and _nbui.po_ need to be converted from `.po` to `.mo` format for
use at runtime.

```shell
pybabel compile -D notebook -f -l ${LANG} -i ${LANG}/LC_MESSAGES/notebook.po -o ${LANG}/LC_MESSAGES/notebook.mo
pybabel compile -D nbui -f -l ${LANG} -i ${LANG}/LC_MESSAGES/nbui.po -o ${LANG}/LC_MESSAGES/nbui.mo
```

_nbjs.po_ needs to be converted to JSON for use within the JavaScript code, with _po2json_, as follows:

```
po2json -p -F -f jed1.x -d nbjs ${LANG}/LC_MESSAGES/nbjs.po ${LANG}/LC_MESSAGES/nbjs.json
```

When new languages get added, their language codes should be added to _notebook/i18n/nbjs.json_
under the `supported_languages` element.

### Tips for Jupyter developers

The biggest "mistake" I found while doing i18n enablement was the habit of constructing UI messages
from English "piece parts". For example, code like:

```javascript
var msg = "Enter a new " + type + "name:";
```

where `type` is either "file", "directory", or "notebook"....

is problematic when doing translations, because the surrounding text may need to vary
depending on the inserted word. In this case, you need to switch it and use complete phrases,
as follows:

```javascript
var rename_msg = function (type) {
  switch (type) {
    case "file":
      return _("Enter a new file name:");
    case "directory":
      return _("Enter a new directory name:");
    case "notebook":
      return _("Enter a new notebook name:");
    default:
      return _("Enter a new name:");
  }
};
```

Also you need to remember that adding an "s" or "es" to an English word to
create the plural form doesn't translate well. Some languages have as many as 5 or 6 different
plural forms for differing numbers, so using an API such as ngettext() is necessary in order
to handle these cases properly.

### Known issues and future evolutions

1. Right now there are two different places where the desired language is set. At startup time, the Jupyter console's messages pay attention to the setting of the `${LANG}` environment variable
   as set in the shell at startup time. Unfortunately, this is also the time where the Jinja2
   environment is set up, which means that the template stuff will always come from this setting.
   We really want to be paying attention to the browser's settings for the stuff that happens in the
   browser, so we need to be able to retrieve this information after the browser is started and somehow
   communicate this back to Jinja2. So far, I haven't yet figured out how to do this, which means that if the ${LANG} at startup doesn't match the browser's settings, you could potentially get a mix
   of languages in the UI ( never a good thing ).

1. We will need to decide if console messages should be translatable, and enable them if desired.

1. The keyboard shortcut editor was implemented after the i18n work was completed, so that portion
   does not have translation support at this time.

1. Babel's documentation has instructions on how to integrate messages extraction
   into your _setup.py_ so that eventually we can just do:

   ```
   ./setup.py extract_messages
   ```

I hope to get this working at some point in the near future. 5. The conversions from `.po` to `.mo` probably can and should be done using `setup.py install`.

Any questions or comments please let me know @JCEmmons on github (emmo@us.ibm.com)


BSD 3-Clause License

Copyright (c) 2009-2012, Brian Granger, Min Ragan-Kelley

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




# Contributing Guidelines

Hello and thank you for your interest in contributing to the Introductory Business Programming with Python: Revision Notebooks. 

Before contributing, please take a moment to review these guidelines to make the process easy and effective for everyone involved.

## Getting Started

1. Fork this repository to your own account.

2. Clone the forked repository to your local system.

   ```bash
   git clone https://github.com/{your-username}/{repo-name}.git
   ```

3. Add the original repository as an upstream repository.

   ```bash
   git remote add upstream https://github.com/{original-owner}/{repo-name}.git
   ```

4. If you cloned a while ago, get the latest changes from upstream.

   ```bash
   git pull upstream main
   ```

## Making Changes

1. Create a new branch for your changes.

   ```bash
   git checkout -b my-feature-branch
   ```

2. Make the changes in your feature branch.

3. Commit your changes using a descriptive commit message.

   ```bash
   git commit -a -m "Add some feature"
   ```

4. Push your commits to your forked repository.

   ```bash
   git push origin my-feature-branch
   ```

## Submitting Changes

1. On GitHub, navigate to your forked repository.

2. Click the `New pull request` button at the top.

3. Select the branch you made the changes in to compare with the original repository's main branch.

4. Review your changes and add a descriptive pull request message.

5. Click `Create pull request`.

## Important Notes

- Please ensure that your code has proper comments explaining what it does.
- Write clear, descriptive commit messages.
- If you're proposing a large change, it's usually a good idea to create an issue to discuss it first.

Thanks again for your interest in contributing, and we look forward to seeing your proposed changes and discussions!


# Introductory Business Programming with Python: Revision Notebooks

Welcome to this repository, a curated set of Python notebooks to help you revise an introductory course on business programming. Each notebook corresponds to a topic in the course and is designed to provide a thorough revision of the concepts in an interactive and practical manner. 

## Table of Contents

1. [Introduction](revision_01_notebooks.ipynb)
2. [Getting Help](revision_02_getting_help.ipynb)
3. [Data Types and Variables](revision_03_data_types_variables.ipynb)
4. [Error Explanations](revision_04_error_explanations.ipynb)
5. [If-Else and Try-Except](revision_05_if_else_try_except.ipynb)
6. [Loops](revision_06_loops.ipynb)
7. [Development Practices](revision_07_development.ipynb)
8. [Functions](revision_08_functions.ipynb)
9. [Testing](revision_09_testing.ipynb)
10. [Databases](revision_10_databases.ipynb)
11. [Using the Web](revision_11_using_the_web.ipynb)
12. [Data Visualisation](revision_12_visualisation.ipynb)
13. [User Interfaces](revision_13_user_interfaces.ipynb)

## Usage

To use these notebooks, you will need to have Jupyter Notebook installed. If not installed, you can install it with this command:

```bash
pip install notebook
```

Then, you can clone this repository and start Jupyter notebook from the command line:

```bash
git clone https://github.com/{username}/{repo-name}.git
cd {repo-name}
jupyter notebook
```

Then navigate to the `.ipynb` file you want to work with.

## Contributing

Contributions are very welcome! Please read the [Contributing Guide](CONTRIBUTING.md) to get started.

## Support

If you need help with anything, feel free to [open an issue](https://github.com/{username}/{repo-name}/issues/new).

## License

This project is licensed under the [MIT License](LICENSE.md).


# Business Report Example with Python Notebook

Welcome to our GitHub repository! This repository demonstrates how to use a Python notebook (Jupyter Notebook) to create a comprehensive and interactive business report. We provide a basic structure to the repository and guide you through the step-by-step process of creating such a report, which includes data analysis, data visualization, report writing, and presenting results in a readable and professional format.

## Table of Contents

- [Installation](#installation)
- [File Structure](#file-structure)
- [Usage](#usage)
- [Contributing](#contributing)
- [License](#license)

Of course, here's how you can modify the Installation section to include instructions on how to use Google Colab as an alternative:

## Installation

To get started, you'll need to install Jupyter Notebook. If you haven't installed it yet, we recommend installing it via Anaconda, which includes Python, Jupyter Notebook, and other commonly used packages for scientific computing and data science.

You can download Anaconda [here](https://www.anaconda.com/distribution/). For more detailed installation instructions, visit the [official Jupyter installation guide](https://jupyter.org/install).

Certainly! Here's how you can modify the instructions to use a GitHub personal access token for authentication instead:

### Alternative: Google Colab

If you prefer not to install anything, Google Colaboratory (also known as Colab) is a great alternative. It's a free Jupyter notebook environment that runs entirely in the cloud. It includes many of the most popular Python libraries, so it's perfect for this project.

To get started with Google Colab:

1. Go to [Google Colab](https://colab.research.google.com/)
2. Click on `File` > `Open notebook`
3. Click on the `GitHub` tab
4. Enter the URL of this repository

Next, clone this repository to your Google Colab environment using:

```python
!pip install -q import-ipynb
import import_ipynb
from getpass import getpass
import os

# This will prompt for the GitHub personal access token
token = getpass('Enter your personal access token for GitHub')

os.environ['GITHUB_AUTH'] = token

!git clone https://$GITHUB_AUTH@github.com/YourUsername/YourRepoName.git
```

**Note:** You can create a personal access token by going to your GitHub settings -> Developer settings -> Personal access tokens -> Generate new token. Make sure to copy your new personal access token when it's generated as you won't be able to see it again. For more information, check the [official GitHub documentation](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token).

After you have cloned the repository, you can open the notebook:

```python
%cd YourRepoName/notebooks/
!ls -l
```

Now, you can open your notebook file (`.ipynb`) within Google Colab and execute the code.

## File Structure

This repository is structured as follows:

- `data/` - Contains the dataset files used for the report.
- `images/` - Contains any images used in the notebook.
- `notebooks/` - Contains the Jupyter notebooks (`.ipynb` files).
  - `business_report.ipynb` - The main notebook containing the full report with code, analysis, and results.
- `src/` - Contains any additional Python scripts used in the project.
- `requirements.txt` - Lists the Python dependencies required for this project.
- `README.md` - Provides an overview of the project (the file you're reading right now).

## Usage

Open the `business_report.ipynb` file in Jupyter Notebook:

```
jupyter notebook ./notebooks/business_report.ipynb
```

You can execute each cell in the notebook by selecting it and pressing `Shift+Enter`. This will run the contents of the current cell and move to the next one.

The notebook contains detailed comments explaining what each cell does, and markdown cells providing a narrative to the report.

## Contributing

Contributions are always welcome! Please read the [contribution guidelines](CONTRIBUTING.md) first.

## License

This project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details.


# ISYS2001 Introduction to Business Programming - Mock Final Assessment

Welcome to the mock final assessment repository for ISYS2001 Introduction to Business Programming. This repository contains the necessary materials for the assessment, including the assessment instructions, sample questions, and staff answers.

## Assessment Instructions

The assessment is designed to evaluate your understanding and application of the concepts covered in ISYS2001 Introduction to Business Programming. Please carefully read the instructions before proceeding.

### Google Colab

1. Click on `assessment_questions.ipynb` to view the notebook in the repository

2. Click on 'Open in Colab' button

3. In Colab, Implement your solutions for each question in the programming language specified in the question.

5. Once you have completed your solutions, save to your private repository.


### Local Jupyter Notebook Installation

1. Clone this repository to your local machine using the following command:
   ```
   git clone https://github.com/michael-borck/isys2001-ELP-mock
   ```

2. Once you have cloned the repository, navigate to the `isys2001-ELP-mock` folder. This folder contains the sample questions for the assessment.

3. Open the `assessment_questions.ipynb` file to view the questions.

4. Implement your solutions for each question in the programming language specified in the question.

5. Once you have completed your solutions, save to your private repository.


## Staff Answers

In the `staff_answer` folder of this repository, you will find the staff's solutions to the sample questions. The staff answers are provided to help you compare your solutions and learn from them. However, please note that the staff answers are not the only correct solutions, and alternative solutions may exist.

Please refrain from directly copying the staff answers. It is important to understand the concepts and implement your own solutions to demonstrate your understanding.

## Additional Resources

If you need any clarification on the assessment questions or encounter any issues, please refer to the following resources:

- **Lecture Slides:** Review the lecture slides and class materials for the topics covered in the assessment.
- **Textbook:** Consult the recommended textbook for additional explanations and examples.
- **Course Instructor:** Reach out to your course instructor or teaching assistant for any clarifications or assistance.

Good luck with your mock final assessment! We hope this exercise helps you prepare for the actual examination. If you have any further questions, feel free to ask for assistance.


# ISYS2001

# text_summariser

# ISYS2001 Worksheets

A home for the various worksheets in ISYS2001 Introduction to Programming


# isys2001-assignment

For publicly available bike share data, you can access comprehensive datasets from several major cities' bike share programs. These datasets typically include detailed trip records with information such as start and end times, start and end station names, and ride durations. Some sources to consider include:

1. **Citi Bike NYC** - Offers detailed historical trip data, including ride IDs, types of rides, start and end times, station names, and geographic coordinates of the stations. Data is available for public use and can be downloaded in CSV format. You can access Citi Bike's data [here](https://citibikenyc.com/system-data).

2. **Bluebikes Boston** - Provides trip data that includes trip duration, station names, and the demographics of riders such as birth year and gender. Bluebikes also offers real-time data in the General Bikeshare Feed Specification (GBFS) format. You can access Bluebikes' data [here](https://bluebikes.com/system-data).

3. **Bay Wheels by Lyft** - Publishes anonymized trip data which includes details like trip duration, station names, coordinates, and ride IDs. Real-time data is also available in GBFS format. You can access Bay Wheels' data [here](https://www.lyft.com/bikes/bay-wheels/system-data).

For house prices data, it depends on the geographical area of interest. A commonly used source for U.S. housing data is the **Zillow Research Data** page. Zillow provides data on home values, rents, and other real estate metrics across various U.S. regions. You can explore Zillow's data offerings [here](https://www.zillow.com/research/data/). Another option is the **U.S. Census Bureau**, which offers extensive data on housing through its American Community Survey and other programs, accessible [here](https://www.census.gov/programs-surveys/acs).

These datasets are highly useful for analysis in urban planning, transportation, real estate, and economics research, providing a robust foundation for academic or professional projects.

---
title: Programming Assessment Choose Your Own Python Notebook Scenario
subtitle: ISYS2001 Introduction to Business Programming
format:
    pdf:
      toc: true
      colorlinks: true
    docx:
      toc: true
      highlight-style: github
    html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

#### **Due, Friday May 24, 2024, 2024 by 11:59pm**

## Objective:

For this assessment, you will create an interactive Jupyter Notebook project that demonstrates your programming skills and understanding of core concepts. You may choose from one of the following four scenarios:

1. **Analysing Bike Sharing Data**
2. **Simulating a Simple Game**
3. **Predicting Housing Prices**
4. **Teaching Python Concepts in Jupyter Notebooks**

Regardless of the scenario you choose, your Jupyter Notebook project should include the following elements:

- Narrative explanations of your code, programming concepts, and insights
- Unit tests to ensure the robustness of your code
- Integration with GitHub for version control and collaboration

While you may use existing Jupyter Notebook examples and templates as a starting point, it is important that you make the project your own by adding unique features, insights, and implementations.

The assessment will be evaluated based on the following criteria:

- Demonstration of programming concepts and skills
- Quality and clarity of your explanations and narrative
- Effective use of Jupyter Notebook features
- Proper integration with GitHub

## Ethical Use of AI and Large Language Models

While you are encouraged to leverage AI and large language models (LLMs) in your Jupyter Notebook project, it is crucial that you do so in a responsible and ethical manner. When using these powerful tools, consider the following guidelines:

1. **Transparency and Acknowledgement**: Clearly indicate in your Jupyter Notebook where you have used AI or LLMs, and provide appropriate citations and references to the models and tools you have employed. This ensures transparency and allows your instructor to properly evaluate your work.

2. **Avoid Misrepresentation**: Do not present the output of AI or LLMs as your own original work. Clearly distinguish between your own contributions and the generated content from the models.

By adhering to these guidelines, you can ensure that your use of AI and large language models in this assignment is both effective and responsible. If you have any questions or concerns regarding the ethical use of these technologies, please don't hesitate to reach out to your instructor.


## Submission Instructions

* Create your Jupyter Notebook project and store it in a GitHub repository.
* Ensure that your GitHub repository includes all the necessary files, including the Jupyter Notebook, any supporting files, and a README file.
* Compress your entire GitHub repository into a zip file.
* Submit the zip file of your GitHub repository via the link on the LMS Blackboard by the due date.


## Academic Integrity

Curtin's Academic Integrity policy must be followed in all submissions. For more
details, please consult the unit outline. All submissions must adhere to the
Copyright Act of 1968 as well as the 'Digital Agenda' revisions to the Copyright
Act.


## Grading Rubrics

## Rubric: Analysing Bike Sharing Data

Criteria | Distinction | Credit | Pass
--- | --- | --- | ---
Data Exploration | Comprehensive exploration of the dataset, uncovering multiple key insights | Thorough exploration of the dataset, identifying several meaningful insights | Basic exploration of the dataset, identifying a few relevant insights
Visualisations | Highly effective, polished visualisations that clearly communicate insights | Well-designed visualisations that support the data analysis | Appropriate visualisations that help illustrate the data
Coding Quality | Efficient, well-structured code with clear documentation and comments | Clean, readable code with appropriate documentation | Functional code that accomplishes the required tasks
Narrative Explanations | Exceptionally clear, concise, and engaging explanations of the analysis and findings | Clear and coherent explanations of the analysis and findings | Adequate explanations of the analysis and findings
GitHub Integration | Effective use of GitHub features, including a detailed README and evidence of collaboration | Proper use of GitHub for version control and sharing the project | Basic GitHub integration, including a README file

## Rubric: Simulating a Simple Game

Criteria | Distinction | Credit | Pass
--- | --- | --- | ---
Game Logic | Robust, well-designed game logic that handles all possible scenarios | Solid game logic that covers the core gameplay | Functional game logic that implements the basic game rules
User Interface | Highly interactive and intuitive user interface within the Jupyter Notebook | Well-designed user interface that allows for smooth gameplay | Basic user interface that enables players to interact with the game
Visualisations | Visually appealing and informative visualisations that enhance the gaming experience | Effective visualisations that help players understand the game state | Appropriate visualisations to display the game board and progress
Narrative Explanations | Exceptional explanations of the programming concepts and design decisions behind the game | Clear explanations of the programming concepts and design choices | Adequate explanations of the game implementation and key programming concepts
Unit Testing | Comprehensive unit tests that ensure the robustness and reliability of the game code | Thorough unit tests that cover the main game functionality | Basic unit tests to verify the core game logic
GitHub Integration | Effective use of GitHub features, including a detailed README and evidence of collaboration | Proper use of GitHub for version control and sharing the project | Basic GitHub integration, including a README file

## Rubric: Predicting Housing Prices

Criteria | Distinction | Credit | Pass
--- | --- | --- | ---
Data Preprocessing | Comprehensive data preprocessing, including handling missing values, outliers, and feature engineering | Effective data preprocessing, addressing the key data quality issues | Basic data preprocessing, covering the essential data cleaning and preparation tasks
Model Implementation | Sophisticated model implementation, including hyperparameter tuning and evaluation of multiple algorithms | Solid model implementation, including appropriate algorithm selection and parameter tuning | Functional model implementation, using a suitable algorithm and default parameters
Model Performance | Exceptional model performance, with high accuracy and clear justification of the chosen metrics | Good model performance, with appropriate evaluation metrics and interpretation of results | Acceptable model performance, with basic evaluation and interpretation of the results
Narrative Explanations | Exceptional explanations of the modeling approach, insights, and limitations | Clear explanations of the modeling approach, insights, and limitations | Adequate explanations of the modeling approach and key findings
Visualisations | Highly effective visualisations that provide deep insights into the data and model performance | Well-designed visualisations that support the analysis and interpretation of results | Appropriate visualisations to explore the data and present the model performance
GitHub Integration | Effective use of GitHub features, including a detailed README and evidence of collaboration | Proper use of GitHub for version control and sharing the project | Basic GitHub integration, including a README file

## Rubric: Teaching Python Concepts in Jupyter Notebooks

Criteria | Distinction | Credit | Pass
--- | --- | --- | ---
Concept Coverage | Comprehensive coverage of at least 7 key Python programming concepts | Thorough coverage of at least 5 Python programming concepts | Adequate coverage of at least 3 Python programming concepts
Explanatory Quality | Exceptionally clear, concise, and engaging explanations that demonstrate deep understanding | Clear and coherent explanations that effectively communicate the concepts | Adequate explanations that convey the basic understanding of the concepts
Code Examples | Highly effective, well-commented code examples that clearly illustrate the concepts | Relevant code examples that support the explanations of the concepts | Basic code examples that demonstrate the core programming concepts
Visualisations | Visually appealing and informative visualisations that enhance the learning experience | Effective visualisations that help explain the programming concepts | Appropriate visualisations to support the concept explanations
Interactive Elements | Seamless integration of interactive elements (e.g., Jupyter Widgets) that foster active learning | Meaningful interactive elements that allow the reader to engage with the concepts | Basic interactive elements that supplement the concept explanations
Assessment Questions | Comprehensive self-assessment questions that thoroughly test the reader's understanding | Relevant self-assessment questions that evaluate the reader's grasp of the concepts | Adequate self-assessment questions to gauge the reader's comprehension
GitHub Integration | Effective use of GitHub features, including a detailed README and evidence of collaboration | Proper use of GitHub for version control and sharing the project | Basic GitHub integration, including a README file


Please note that the assessment will be graded based on the criteria outlined in the respective rubric for the scenario you choose.

If you have any questions or need clarification, please don't hesitate to ask.

Good luck with your project!

# weather-dashboard-source

[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/michael-borck/the_calculator_walkthrough.git/HEAD?labpath=calculator_best.ipynb)

# The Calculator Walkthrough
An exercise in programming to help hone your skills through practice and repetition.
This notebook is a complete walkthrough with notes and explanations. It can be used as a reference, a study guide and provide one possible answer that you can use to compare with your attempt. This notebook is too long to be a [CodeKatas](http://codekata.com/) but aspires to similar principles. 

## CodeKata Principles

With CodeKatas, you are trying to solve a problem and follow the best practices of the programming language.   There are no right or wrong answers. The benefit comes from the process, not from the result. See [Awesome Katas] for a curated list of CodeKatas see [Awesome Katas](https://github.com/gamontal/awesome-katas). For Python CodeKatas see [here](https://github.com/clair3st/code-katas).

## What are *our* Best Practices

Here are the best practices we have been applying throughout the course.

1. Use a code repository (*GitHub, small frequent commits*)
2. Follow style guidelines (*PEP8*)
3. Correct broken code immediately (*exception handling, input validation, testing*)
4. Use the PyPI instead of doing it yourself (*import module*)
5. Use the Right Data Types and Structures (*int, float, list, etc. *)
6. Write Readable Code (*meaningful names and comments*)
7. Create readable documentation (*Docstrings*)
8. Use Virtual Environments (*Google VM instance, Binder*)
9. Avoid anti-patterns (*be specific imports, exceptions etc. *)
10. Follow *Zen of Python* (try *import this*)

## How to use this notebook

You should copy the notebook, delete all the cells except for *The Challenge - Simple Calculator* and then attempt to solve the problem by applying the best practices above.


# Turtle Racing

This is a Google Colab notebookfor drawing classic Turtle figures. It's also compatible with Jupyter Lab notebooks.  These notebooks have been adapted from [The Beginner's Guide to Python Turtle](https://realpython.com/beginners-guide-python-turtle/) to use [ColabTurtlePlus](https://pypi.org/project/ColabTurtlePlus/).



Certainly! Let’s break down the pseudo code for each task in the analysis, followed by the adjusted guidance on how to conduct visual analysis using the `StockMarketSimulation` class. This approach provides structured yet open-ended guidance to encourage student experimentation and learning.

### Pseudo Code for Analysis Tasks

1. **Investigate the Impact of Volatility**
   - Objective: Explore how different levels of volatility affect stock price fluctuations and the potential for investment gains or losses.
```python
# Pseudo code for analyzing the impact of different volatility levels on stock price stability

volatility_levels = [0.01, 0.02, 0.05]  # Different levels of volatility to test
for volatility in volatility_levels:
    sim = StockMarketSimulation(start_price=100, days=365, volatility=volatility, drift=0.001)
    prices = sim.run_simulation()
    plot_prices(prices)  # Visualize stock price fluctuations for each volatility level
    print_statistics(prices)  # Function to print or calculate statistical metrics (mean, std, max drawdown)
```

2. **Simulate a Major Market Event**
   - Objective: Analyze the immediate and long-term effects of a major market event on stock prices.
```python
# Pseudo code for simulating and analyzing a major market event

event_days = [50, 150, 250]  # Days to simulate a market event
event_impacts = [0.1, -0.1]  # Positive for beneficial, negative for detrimental impacts
for day in event_days:
    for impact in event_impacts:
        sim = StockMarketSimulation(start_price=100, days=365, volatility=0.02, 
                                    drift=0.001, event_day=day, event_impact=impact)
        prices = sim.run_simulation()
        plot_prices(prices, event_day=day)  # Visualize with the event day marked
        analyze_event_impact(prices, day)  # Analyze and compare before and after event prices
```

3. **Develop and Test Trading Strategies**
   - Objective: Develop simple trading strategies and test their effectiveness over the simulation period.
```python
# Pseudo code for developing and testing trading strategies based on stock price trends

strategies = ['moving_average_crossover', 'buy_and_hold', 'contrarian']
for strategy in strategies:
    sim = StockMarketSimulation(start_price=100, days=365, volatility=0.02, drift=0.001)
    prices = sim.run_simulation()
    strategy_results = apply_strategy(prices, strategy)  # Apply and analyze strategy
    plot_strategy_results(strategy_results)  # Visualize effectiveness of strategies
```

### Adjusted Guidance for Visual Analysis

**Guidance on Conducting Visual Analysis Using the Simulation:**

- **Baseline Scenario Without Events**: Start by running simulations without any major market events to understand the natural fluctuation and drift of stock prices. This will provide a baseline for comparing other scenarios.
  
- **Labeling and Annotations**: Ensure your plots are clearly labeled with appropriate legends and annotations. For example, mark significant days such as the occurrence of market events or when a specific strategy decision was made.

- **Comparison and Metrics**: Use visual tools to compare different scenarios side-by-side. Consider using metrics like Sharpe ratio, maximum drawdown, or cumulative returns to quantify investment performance and risk under different settings.

- **Interactive Exploration**: Encourage students to interact with the simulation parameters dynamically. This could be facilitated through tools that allow parameter adjustment and immediate replotting to see results.

**Experimentation Reminder**: 
- Encourage students to experiment with different scenarios by adjusting the parameters and observing the effects. Each experiment should aim to provide insights into how different market conditions or decisions can affect investment outcomes.
- Promote the development of hypotheses before running simulations and discuss whether the outcomes support or refute these hypotheses.

This guidance and pseudo code approach aims to balance structured learning objectives with open-ended exploration, helping students to engage deeply with the material and develop a practical understanding of stock market dynamics.

Thanks for pointing that out! I'll include the revised rubric in the assignment specification now and adjust the simulation options accordingly.

---

### **Title: Business Simulations with Simulacra**

### **Overview**

In this assignment, you will utilize the Simulacra Python package to conduct simulations across various business scenarios. You will select a simulation type, set parameters to model realistic situations, visualize outcomes, analyze the effects of parameter changes, and extract insights to support decision-making processes. Your work will be compiled in a Google Colab Notebook and saved to a dedicated GitHub repository.

### **Objectives**

- Understand and apply simulation techniques in business contexts.
- Analyze the impact of different variables in simulation models.
- Develop skills in data visualization and interpretation.

### **Assignment Tasks**

#### 1. **Setup:**
   - Create a new GitHub repository specifically for this assignment.
   - Clone the repository in your Google Colab environment to ensure all changes are version-controlled.
   - Install the Simulacra package from our class GitHub repository. Follow the provided setup instructions to prepare your environment for running simulations.

#### 2. **Choose Your Simulation:**
   - Decide which simulation you want to explore:
     - Stock Market Simulation
     - Resource Fluctuations Simulation
     - Product Popularity Simulation

#### 3. **Familiarize Yourself with the Simulation:**
   - Read the detailed documentation for your selected simulation type within the Simulacra package. Understand the role and typical range of each parameter.

#### 4. **Execute the Simulation:**
   - Instantiate your chosen simulation class with initial parameters reflecting a realistic scenario.
   - Execute the simulation by calling the `run_simulation()` method and collect the output data.

#### 5. **Visualize the Simulation Data:**
   - Use various plotting techniques (e.g., line plots, bar charts) to visualize key trends and dynamics within the data.
   - Highlight any significant effects due to specific events or interventions, if relevant.

#### 6. **Analytical Experimentation:**
   - Modify parameters to explore how changes influence simulation outcomes.
   - Analyze key metrics derived from the data (like peak values, averages, variability).
   - Model potential strategies or interventions and assess their impact.

#### 7. **Compile and Report Your Findings:**
   - Assemble your work into a Jupyter Notebook that includes:
     - Code implementations along with detailed comments.
     - Visualizations with captions explaining each figure.
     - A comprehensive analysis section discussing parameter choices, observed results, and their implications.
     - A reflection on the simulation's limitations and suggestions for improvement.
   - Commit regularly to your GitHub repository to maintain a log of your progress.
   - Submit a zip of your GitHub repository to capture all logs for analysis of your commit frequency and development progress.

### **Evaluation Criteria**

- **Functionality and Code Clarity:** Clear, efficient, and well-documented code.
- **Visualization Quality:** Accurate and insightful visual representations of the data.
- **Depth of Analysis:** Thorough exploration and nuanced understanding of how parameter variations affect outcomes.
- **Reflective Discussion:** Insightful discussion on the real-world applicability and limitations of the models.
- **Overall Presentation:** Coherence, logical structure, and professionalism in the presentation of the report.

### **Additional Guidelines**

- **Collaboration Policy:** Collaboration among students is encouraged to foster peer learning, however, all submitted work must be independently created.
- **Exploratory Approach:** You are encouraged to delve deeper into any specific aspects of the simulations that pique your interest. Investigate additional questions or scenarios beyond the basic assignment requirements.

### **Rubric for Business Simulations with Simulacra**


| Criteria                            | Fail (Unsatisfactory)                                                                                      | Pass (Satisfactory)                                                                                       | Credit (Good)                                                                                                        | Distinction (Very Good)                                                                                                               | High Distinction (Excellent)                                                                                                                      |
|-------------------------------------|------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------|
| **Functionality and Code Clarity**  | Code does not execute, contains multiple errors, and lacks comments.                                        | Code executes with minor issues, meets basic requirements, and has minimal comments.                      | Code is mostly correct, with some advanced elements; well-commented to explain the functionality.                    | Code runs perfectly, includes advanced features, and is clearly commented to explain complex logic.                                   | Code not only runs flawlessly but also displays innovative approaches, exceptional efficiency, and is exemplary in clarity and structure. |
| **Visualization Quality**            | Visualizations are incorrect or missing.                                                                   | Visualizations are correct but basic and lack clarity or detail.                                          | Visualizations are correct, clear, and provide useful insights into the data.                                        | Visualizations are detailed, very clear, and enhance understanding of the simulation outcomes with thoughtful layouts.                 | Visualizations are outstanding, providing deep insights and are professionally presented with exceptional attention to detail.               |
| **Depth of Analysis**                | Analysis is missing or incorrect. Demonstrates a lack of understanding.                                    | Analysis is correct but superficial. Shows basic understanding without significant insight.                | Good analysis that correctly interprets data and explores effects of parameter changes with some depth.               | Very thorough analysis, showing a deep understanding of simulation dynamics and thoughtful exploration of parameter impacts.           | Exceptional analysis that offers profound insights, linking simulation results to real-world implications and theoretical concepts.       |
| **Reflective Discussion**            | Lacks reflection; no consideration of the limitations or applicability of the simulations.                  | Limited reflection on the limitations and real-world applicability of the simulations.                     | Reflects on limitations and applicability, making reasonable suggestions for improvement.                            | In-depth reflection on limitations and applicability; offers well-considered improvements and shows understanding of broader context. | Extensive and insightful reflection, critically assessing all aspects of the simulations and suggesting innovative improvements.         |
| **Overall Presentation and Engagement** | Work is disorganized, poorly presented, and lacks evidence of version control engagement.                    | Work is organized with minor errors in presentation and basic use of GitHub with infrequent commits.        | Work is well-organized, clear, presented in a logically structured manner with regular commits and clear GitHub usage. | Work is very well-organized, presented with high professionalism, excellent use of GitHub including branch management.                  | Work is exceptionally presented, showcasing outstanding professionalism, narrative, and exemplary GitHub practices including regular commits and branches. |


**Disease Spread Simulation**

**Purpose**

This simulation models the spread of an infectious disease within a population, helping students explore epidemiological concepts and the effectiveness of public health interventions.

**Parameters**

- `start_population`: The initial number of people in the population.
- `days`: The duration of the simulation.
- `infection_rate`: The probability that an individual will contract the disease each day.
- `recovery_rate`: The probability of an infected individual recovering each day.
- `outbreak_day`: Specifies the day on which a major outbreak event occurs (optional).
- `severity`: The magnitude of the outbreak's impact on infection rates, positive for an increase.

**Tasks**

- **Visualization:**
  - Plot the number of susceptible, infected, and recovered individuals over time.
  - Highlight any major outbreak events on the plot if included.

- **Analysis:**
  - Investigate how changes in the infection and recovery rates affect the disease dynamics.
  - Simulate a major outbreak event and analyze its effect on the epidemic curve.
  - (Optional) Model potential public health interventions, such as vaccination or quarantine, and evaluate their impact on the disease spread.

**Example Code**

```python
from simulacra import DiseaseSimulation
import matplotlib.pyplot as plt

# Example setup: High infection rate with a significant recovery rate,
# and a major outbreak event.
sim = DiseaseSimulation(start_population=1000, days=200, infection_rate=0.1, 
                        recovery_rate=0.05, outbreak_day=50, severity=0.25)

susceptible, infected, recovered = sim.run_simulation()

# Visualizing the disease spread
plt.figure(figsize=(10, 6))
plt.plot(susceptible, label='Susceptible')
plt.plot(infected, label='Infected', color='red')
plt.plot(recovered, label='Recovered', color='green')
plt.axvline(x=sim.outbreak_day, color='purple', linestyle='--', label='Major Outbreak')
plt.xlabel('Days')
plt.ylabel('Number of Individuals')
plt.title('Disease Spread Simulation')
plt.legend()
plt.show()
```

**Hints**

- Begin your analysis with baseline parameters before introducing an outbreak to understand the natural progression of the disease.
- Use clear labels and annotations on your plots to indicate significant simulation events, such as the introduction of an outbreak or intervention.
- Consider calculating metrics like peak infection rates, time until peak, and total recovered as part of your analysis to measure the impact of different scenarios.

**Experimentation Reminder:** Use the simulation to test hypotheses about disease spread and control measures. Adjust parameters, introduce interventions, and explore the resulting dynamics to gain insights into effective disease management strategies.


**Resource Fluctuations Simulation**

**Purpose**

This simulation models the price fluctuations of a critical resource for a business. It is applicable to commodities, raw materials, or any essential business input, helping students understand market dynamics and pricing strategies.

**Parameters**

- `start_price`: The initial price of the resource.
- `days`: The duration of the simulation.
- `volatility`: Controls the severity of day-to-day price fluctuations.
- `drift`: Indicates the general upward or downward trend in price over time.
- `supply_disruption_day`: Specifies the day on which a supply disruption event occurs (optional).
- `disruption_severity`: The magnitude of the supply disruption's impact on the price, positive indicating a shortage and negative indicating a surplus.

**Tasks**

- **Visualization:**
  - Plot the price data series over time.
  - Mark any supply disruption events on the plot if included.

- **Analysis:**
  - Assess the impact of volatility on the stability of resource prices by experimenting with different volatility values.
  - Model a supply disruption event and analyze how it affects the price trend and the impact of the disruption's severity.
  - (Optional) Explore simple strategies a business might use to hedge against price fluctuations.

**Example Code**

```python
from simulacra import ResourceSimulation
import matplotlib.pyplot as plt

# Setting up a moderate volatility and upward drift scenario with a supply disruption.
sim = ResourceSimulation(start_price=100, days=250, volatility=0.015, 
                         drift=0.0003, supply_disruption_day=100, disruption_severity=0.3) 

prices = sim.run_simulation()

# Visualizing the price simulation
plt.figure(figsize=(10, 6))
plt.plot(prices, label='Resource Price')
plt.axvline(x=sim.supply_disruption_day, color='r', linestyle='--', label='Supply Disruption')
plt.xlabel('Days')
plt.ylabel('Price')
plt.title('Resource Price Simulation')
plt.legend()
plt.show()
```

**Hints**

- Start with a basic simulation setup without a supply disruption to understand the baseline dynamics.
- Ensure your plots are well-labeled and include annotations to clarify significant events like disruptions.
- Consider calculating and comparing statistics such as the average price before and after a disruption event to quantify its impact.

**Experimentation Reminder:** Use the simulation to explore and test various scenarios. Adjust parameters, try different strategies, and analyze the outcomes to gain deeper insights into resource management under fluctuating conditions.

### Task-Specific Guidance for Resource Simulation

**1. Assess the Impact of Volatility on Price Stability**
- **Guidance**: Start by exploring how different levels of volatility affect day-to-day price fluctuations. This will help you understand the sensitivity of resource prices to changes in market conditions.
- **Questions to Consider**:
  - What trends do you notice as volatility increases? How does it affect the predictability of price movements?
  - How do different volatility levels impact the overall risk profile of investing in this resource?

**2. Model a Supply Disruption Event and Analyze Its Impact**
- **Guidance**: Set up scenarios where a supply disruption occurs at a predetermined day. Change the severity of these disruptions to see how they influence resource prices.
- **Questions to Consider**:
  - How does the timing of a supply disruption affect its impact on resource prices?
  - Compare the prices before and after the disruption. What can you infer about the resilience of the market to sudden changes?

**3. Explore Hedging Strategies**
- **Guidance**: Implement simple hedging strategies to see how they could mitigate the risks associated with price volatility and supply disruptions. Consider strategies like futures contracts or options.
- **Questions to Consider**:
  - Which hedging strategy appears most effective in stabilizing price fluctuations?
  - How do the costs of these strategies compare to their benefits in terms of reduced price volatility?

### Example Adjusted Guidance for Visual Analysis

**Guidance on Conducting Visual Analysis Using the Simulation:**
- **Baseline Scenario Without Disruptions**: Begin by simulating the price path without any disruptions to establish a baseline for comparison with more complex scenarios.
  
- **Labeling and Annotations**: Ensure that your plots clearly show the days on the x-axis and price on the y-axis. Use lines or markers to indicate the day of a supply disruption or the implementation of a hedging strategy.

- **Interactive Exploration**: If tools are available, adjust parameters such as volatility and drift dynamically to observe how these changes affect the price simulation. This can help in understanding the immediate effects of each parameter.

- **Comparative Analysis**: Conduct side-by-side comparisons of scenarios with different levels of volatility or different strategies to visually assess their impact. This can make it easier to understand which conditions or strategies lead to the most favorable outcomes.

**Experimentation Reminder**:
- Encourage students to experiment with a wide range of scenarios, including extreme cases, to fully explore the dynamics of resource pricing under various conditions.
- Recommend that students keep a detailed log of their simulation settings and outcomes, facilitating a deeper analysis and discussion of their results.

This adjusted guidance helps ensure that students not only follow clear steps in their simulation analysis but also think critically about the implications of their findings, fostering a deeper understanding of economic principles and risk management strategies in resource markets.

### Introduction to the Notebook

Welcome to this interactive Google Colab notebook designed to assist you with your assignment on analysing and visualising resource fluctuations in a simulated environment. This notebook is intended to serve as both an educational tool and a practical starting point for examining how various factors influence resource availability and management over time.

In this assignment, you will:

1. **Run a Resource Fluctuations Simulation**: Utilise the `ResourceFluctuationsSimulation` class provided within this notebook to generate simulated data on resource levels across different scenarios. This class allows you to manipulate parameters such as initial resource levels, consumption rates, replenishment rates, and external impacts, enabling you to observe how these variables affect overall resource sustainability.

2. **Visualise the Results**: Employ the `plot_resources` function to graph the changes in resource levels over time. This function includes capabilities to annotate significant events or interventions, visually demonstrating their impact on resource trends.

**Objectives**:
- Analyse the effects of consumption patterns, replenishment strategies, and external events on resource levels.
- Develop skills in creating and interpreting dynamic visualisations that reflect changes in real-world scenarios.
- Enhance your Python programming proficiency, with a particular focus on utilising libraries for effective data visualisation.

**Using Google Colab**:
- Google Colab provides a powerful, cloud-based platform to execute Python code, which means you can work on this notebook without requiring any specific setups on your local machine.
- Remember to save a copy of this notebook in your Google Drive to ensure that all your modifications and data are preserved.

**Preparation**:
- Take a moment to get acquainted with Google Colab’s user interface and features if this is your first time using it.
- Carefully review the code snippets and the accompanying explanatory texts in this notebook to fully understand how the simulation and plotting functions are structured and operated.

This notebook is crafted to be interactive and instructional, aimed at deepening your understanding of resource management simulation and the analytical tools used in such assessments. By the end of this activity, you will have gained valuable insights into the complexities of resource dynamics and how they can be modeled and visualised effectively. Let’s start this explorative journey into resource fluctuations simulation.

Here's the pseudo code for each of the tasks in the analysis section of your product popularity simulation assignment. This will help students structure their experiments and analyses effectively.

### 1. Examine How Changes in Growth Rate and Marketing Impact Affect Demand

**Objective**: Investigate how different settings for natural growth rate and ongoing marketing efforts influence the overall demand for a product.

```python
# Pseudo code for analyzing changes in growth rate and marketing impact

growth_rates = [0.01, 0.02, 0.03]  # Different growth rates to test
marketing_impacts = [0.05, 0.1, 0.15]  # Different marketing impacts to test

for growth_rate in growth_rates:
    for marketing_impact in marketing_impacts:
        sim = ProductPopularitySimulation(start_demand=500, days=180, growth_rate=growth_rate,
                                          marketing_impact=marketing_impact)
        demand = sim.run_simulation()
        plot_demand(demand)  # Visualize the demand curve for each combination
        print_demand_statistics(demand)  # Function to print or calculate demand statistics
```

### 2. Simulate a Major Marketing Campaign and Analyze Its Effect on Demand Growth

**Objective**: Analyze how a significant promotional campaign affects the demand for a product both immediately and over time.

```python
# Pseudo code for simulating and analyzing a major marketing campaign

promotion_days = [30, 60, 90]  # Days to start the promotion campaign
promotion_effects = [0.2, 0.5, 0.7]  # Different levels of campaign effectiveness

for day in promotion_days:
    for effect in promotion_effects:
        sim = ProductPopularitySimulation(start_demand=500, days=180, growth_rate=0.02,
                                          marketing_impact=0.1, promotion_day=day, promotion_effectiveness=effect)
        demand = sim.run_simulation()
        plot_demand(demand, promotion_day=day)  # Visualize with the campaign day marked
        analyze_campaign_effect(demand, day)  # Analyze and compare before and after campaign demand
```

### 3. Explore Different Marketing Strategies and Their Cost-Effectiveness

**Objective**: Explore various marketing strategies and evaluate their return on investment (ROI) based on the increase in demand relative to the costs.

```python
# Pseudo code for exploring and comparing different marketing strategies

strategies = ['social_media_boost', 'discount_offers', 'influencer_partnerships']
costs = {'social_media_boost': 1000, 'discount_offers': 500, 'influencer_partnerships': 1500}

for strategy in strategies:
    # Assume different effectiveness and costs for each strategy
    sim = ProductPopularitySimulation(start_demand=500, days=180, growth_rate=0.02,
                                      marketing_impact=0.1, promotion_day=30, promotion_effectiveness=strategy_effectiveness(strategy))
    demand = sim.run_simulation()
    plot_demand(demand)  # Visualize effectiveness of strategies
    total_cost = costs[strategy]
    evaluate_roi(demand, total_cost)  # Calculate and display the ROI of each strategy
```

### Auxiliary Functions to Implement
- **print_demand_statistics(demand)**: Calculates and prints statistics like mean demand, peak demand, etc.
- **analyze_campaign_effect(demand, promotion_day)**: Compares demand levels before and after the promotional campaign to assess its impact.
- **strategy_effectiveness(strategy)**: Returns a hypothetical effectiveness value based on the strategy type.
- **evaluate_roi(demand, cost)**: Calculates return on investment by comparing the increase in demand against the strategy cost.

This pseudo code provides a structured approach for students to conduct their analyses, enabling them to understand the dynamics of product popularity and the effectiveness of marketing strategies in a simulated environment.

# Business Report Project - Example

Welcome to our GitHub repository! This repository demonstrates how to use a Python notebook (Jupyter Notebook) to create a comprehensive and interactive business report. We guide you through the step-by-step process of creating such a report, which includes data analysis, data visualization, report writing, and presenting results in a readable and professional format.

## Table of Contents

- [Installation](#installation)
- [Usage](#usage)
- [Contributing](#contributing)
- [License](#license)

## Installation

To get started, you'll need to install Jupyter Notebook. If you haven't installed it yet, we recommend installing it via Anaconda, which includes Python, Jupyter Notebook, and other commonly used packages for scientific computing and data science.

You can download Anaconda [here](https://www.anaconda.com/distribution/). For more detailed installation instructions, visit the [official Jupyter installation guide](https://jupyter.org/install).

### Alternative: Google Colab

If you prefer not to install anything, Google Colaboratory (also known as Colab) is a great alternative. It's a free Jupyter notebook environment that runs entirely in the cloud. It includes many of the most popular Python libraries, so it's perfect for this project.

To get started with Google Colab:

1. Go to [Google Colab](https://colab.research.google.com/)
2. Click on `File` > `Open notebook`
3. Click on the `GitHub` tab
4. Enter the URL of this repository

Next, clone this repository to your local machine using:

```
git clone https://github.com/YourUsername/YourRepoName.git
```

Or in Google Colab:

```python
!pip install -q import-ipynb
import import_ipynb
from getpass import getpass
import os

# This will prompt for the GitHub personal access token
token = getpass('Enter your personal access token for GitHub')

os.environ['GITHUB_AUTH'] = token

!git clone https://$GITHUB_AUTH@github.com/YourUsername/YourRepoName.git
```

## Usage

Open the `business_report.ipynb` file in Jupyter Notebook:

```
jupyter notebook business_report.ipynb
```

You can execute each cell in the notebook by selecting it and pressing `Shift+Enter`. This will run the contents of the current cell and move to the next one.

The notebook contains detailed comments explaining what each cell does, and markdown cells providing a narrative to the report.

## Contributing

Contributions are always welcome! Please read the [contribution guidelines](CONTRIBUTING.md) first.

## License

This project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details.


# ISYS2001 Extended Learning Portfolio


---
title: "Reflective Journal Compilation Assignment"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Due Date:** 23:59 Sunday, 15 September 2024  
**Submission:** Turnitin link on the Blackboard course website

**Assignment Overview:**

Throughout the first six weeks of this course, you have been completing weekly reflective journals. It is now time to compiling your reflective journals into a single document and submitting it for assessment. This component focuses on the **completeness** requirement of the first assessment.  The compiling and organising the final submission as outlined below.

**Submission Instructions:**

1. **Compile Your Journal Entries:**
   - Copy the body of each weekly journal entry into a single Word document.
   - Ensure that all entries are in chronological order.

2. **Add Required Sections:**
   - **Cover Page:** Create a cover page that includes your name, student ID, course title, assignment title ("Reflective Journal Compilation"), and the submission date.
   - **Table of Contents:** Include a table of contents after the cover page, listing each journal entry with appropriate titles and page numbers.

3. **Organise Your Document:**
   - **Title Each Journal Entry:** Clearly label each journal entry with a title that reflects the content or week (e.g., "Week 1: Introduction and Expectations").
   - Ensure that each entry starts on a new page to maintain clarity and organisation.

4. **Review and Format:**
   - Check for consistency in formatting (e.g., font type, size, spacing).
   - Proofread your document for grammar, spelling, and clarity.

5. **Submit Your Document:**
   - Save your Word document as a PDF to ensure formatting is preserved.
   - Submit the PDF file to the Turnitin link provided on the Blackboard course website by the due date.


If you have any questions or need assistance with the assignment, please reach out before the due date.

---
title: "Instructor Guidance Notes for Marking the Reflective Journal Assessment"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Purpose:**  

These guidance notes provide instructions for marking the Reflective Journal
Assessment using the simplified rubric. Please ensure you only assess
submissions from students specific tutorial groups assigned to you.

**General Instructions:**

- Each week’s journal is worth 1 mark:  
- Reflective writing is available in Turnitin, while notebooks are in the submitted journals.
- Turnitin is mainly for plagarism and high AI.
- For the notebooks, sample three entries (one every two weeks) to assess
  completion. If a student has not completed the bulk of the notebook tasks,
  give **0 marks** for that element.
- Be firm on notebook completion: incomplete or poorly attempted notebooks
  should receive **0 marks** for the coding element.
- Each week’s journal is worth **1 mark** in total, based on both the reflective
  writing and the coding notebooks.
- Use the **Levels of Achievement** rubric to assess the overall quality of the
  journal entry, which includes both reflective writing and the notebooks.
  - Zero: Incomplete or inaccurate work.
  - 0.5: Basic or limited work with issues such as poor formatting, indentation, or lack of comments in the code.
  - 1: Thoughtful work with functional code but some minor issues, and good reflection.
  
### **Notebook Sampling**:

- Sample three student notebooks (one every two weeks) to evaluate both the
  quality and completeness of their coding work.
- Use the rubric to assess the overall quality, combining both the reflective
  writing and the coding elements into one unified evaluation.

---

This simplified approach allows you to evaluate the journal entry holistically
without splitting marks between reflection and code, while still maintaining a
clear grading structure based on the quality of both components.

---

### **Week 1** (1 mark)
- **Reflective Writing**  
  - Check that students reflect on their learning experience and engagement with
    the material in the journal body. Award 0.5 marks for a reasonable level of
    reflection.
- **Notebooks**  
  - Verify that students have:
    - Completed `hello_world.ipynb`
    - Provided evidence for the **Code Magnets** exercise
    - Completed the **Sharpen My Pencil** task  
  - Award 0.5 marks only if the bulk of these tasks are complete.

---

### **Week 2** (1 mark)
- **Reflective Writing**  
  - As in Week 1, evaluate whether students provide thoughtful reflections on their learning progress.
- **Notebooks**  
  - Check for completion of:
    - An updated `sundae_winner.ipynb`
    - Completion of `a_taste_of_python.ipynb`  
  - Award 0.5 marks for substantial completion of the notebooks.

---

### **Week 3** (1 mark)
- **Reflective Writing**  
  - Continue assessing reflective quality on learning experiences.
- **Notebooks**  
  - Confirm completion of:
    - **Weather Adventures Pseudocode Worksheet**
    - **Weather Adventures Notebook**  
  - Full 0.5 marks if both are completed satisfactorily.

---

### **Week 4** (1 mark)
- **Reflective Writing**  
  - As with previous weeks, evaluate the reflective writing for depth of thought.
- **Notebooks**  
  - Check for:
    - Completion of the **Data Structures Worksheet**
    - The **Business Buzzword Notebook**  
  - Award 0.5 marks if both tasks are completed adequately.

---

### **Week 5** (1 mark)
- **Reflective Writing**  
  - Evaluate reflections on Week 5's content and engagement.
- **Notebooks**  
  - Ensure the **Functions Worksheet** is completed.  
  - Full marks if the worksheet is substantially finished.

---

### **Week 6** (1 mark)
- **Reflective Writing**  
  - Continue to assess the depth and thoughtfulness of student reflections.
- **Notebooks**  
  - Check for completion of the **Input Validation** task.  
  - Award full marks for substantial completion.

---

**Note to Tutors:**

Roughly 0.5 for journal entry, 0.5 for the code/notebooks.  Sample student
notebooks once every two weeks (3 in total). If a student has completed most of
the tasks in the notebook, award 0.5 marks. If the bulk is not completed, award
0 marks for the coding element.

---
title: "Weather Wizards: Crafting Interactive Dashboards"
subtitle: "Transform real-time weather data into captivating visuals with your programming magic"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

#### **Assignment Overview**

In this assignment, you will create a Python-based weather dashboard using
Google Colab, integrating data from the OpenWeatherMap API. The dashboard will
feature weather data visualisations and will be developed using a
procedural/function-based approach. This project allows you to demonstrate the
skills and concepts covered in the unit, including data handling, API usage,
data visualisation, basic programming constructs, and good coding practices.

#### **Assignment Objectives**

- Apply Python programming concepts to create a functional weather dashboard.
- Utilise the OpenWeatherMap API to retrieve and display weather data.
- Develop visualisations using matplotlib or seaborn.
- Demonstrate effective use of AI tools (e.g., GitHub Copilot, ChatGPT) to aid
  coding, and document your interactions with these tools.
- Use version control effectively, making regular commits to a private GitHub
  repository, demonstrating a structured and iterative development process.
- Present your final work in a professional, well-documented Jupyter Notebook,
  including reflections on AI tool usage.

#### **Task Requirements**

1. **Data Collection and API Usage**:
   - Use the OpenWeatherMap API to fetch weather data for a location of your
     choice.
   - Implement basic error handling for API calls, such as handling invalid
     responses.
   - Securely manage your API key (instructions for obtaining an API key will be
     provided separately).

2. **Data Processing**:
   - Extract and process at least 2 weather parameters (e.g., temperature,
     humidity).
   - Use pandas for data manipulation if necessary.

3. **Dashboard Development**:
   - Create a weather dashboard using Google Colab.
   - Implement at least 1 type of visualisation using matplotlib or seaborn.
   - Include an interactive element (e.g., input field for city selection).

4. **Code Organisation and Documentation**:
   - Organise code into functions for data fetching, processing, and visualisation.
   - Provide comments and docstrings for your functions to explain their purpose
     and usage.
   - Use comments to explain complex logic and AI-assisted code sections.
   - Follow best coding practices for readability.

5. **AI Tools Usage**:
   - Use AI coding tools like GitHub Copilot or ChatGPT to assist in your
     development.
   - Briefly document your use of these tools in code comments and in a
     reflection section.

6. **Version Control and Development Process**:
   - Use version control by making regular commits to your GitHub repository
     after significant changes.
   - **Create a private GitHub repository** for your project.
   - **Invite your tutor to your private repository** to grant access for
     assessment. Failure to send an invite will result in a significant loss of
     marks because we cannot see the change and commit history.
   - Make at least **5 meaningful commits**, demonstrating the evolution of your
     project.
   - Use clear and descriptive commit messages that reflect the specific changes
     made.

7. **Professional Report**:
   - Structure your final notebook as a professional report, including:
     - **Introduction**: Project purpose and scope.
     - **Methods**: Description of data collection and processing steps.
     - **Results**: Visualisations and their interpretations.
     - **Discussion**: Reflection on the use of AI tools and any challenges faced.
     - **Conclusion**: Summary of what was achieved.
   - Include a brief discussion on data ethics and privacy considerations
     related to weather data usage.

#### **Required Libraries**

- `requests` (for API calls)
- `pandas` (for data manipulation)
- `matplotlib` or `seaborn` (for visualisation)

#### **Assessment Criteria**

Your project will be assessed based on:

- **Correct Application of Techniques (40%)**: Proper use of Python constructs,
  data handling, basic error checking, and visualisation techniques.
- **Code Quality and Documentation (15%)**: Good code quality, including
  comments, docstrings, adherence to coding standards, and code organisation.
- **Quality of Visualisations (15%)**: Clarity, relevance, and correctness of
  the visual representations.
- **Effective Use of AI (10%)**: Documented and ethical use of AI tools to
  enhance your coding process.
- **Effective Use of Version Control (10%)**: Demonstrated use of version
  control with regular commits and clear commit messages.
- **Overall Presentation (10%)**: Professionalism, clarity, and completeness of
  the final notebook report.

#### **Grading Rubric**

| Grade Level          | Functionality                                                                                                                                               |
|----------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Pass (50-64%)        | Basic text output of weather data; Minimal error handling; Basic API integration; Basic comments.                                                           |
| Credit (65-74%)      | One type of visualisation; Proper data processing; Clear code organisation; Some error handling; Comments and docstrings; Basic use of version control.     |
| Distinction (75-84%) | Interactive element (e.g., input field for city selection); Multiple visualisations; Good error handling; Detailed comments and docstrings; Regular commits. |
| High Distinction (85-100%) | Advanced features (e.g., additional data parameters); Exceptional code quality and documentation; Comprehensive error checking; Creative use of libraries; Regular, detailed commits with descriptive messages. |

#### **Suggested Timeline**

- **Week 1**:
  - Set up the OpenWeatherMap API and securely manage your API key.
  - Begin data retrieval for a chosen location.
  - Initialise your private GitHub repository and invite your tutor.
  - Make initial commits with setup code.

- **Week 2**:
  - Implement data processing to extract required weather parameters.
  - Start developing visualisations.
  - Continue making regular commits with descriptive messages.

- **Week 3**:
  - Add an interactive element to your dashboard.
  - Refine visualisations and ensure they are informative.
  - Document your use of AI tools.
  - Enhance code with comments and docstrings.

- **Week 4**:
  - Finalise your code and ensure it runs without errors.
  - Complete your professional report within the notebook.
  - Make final commits and review your GitHub repository for completeness.

#### **Submission Details**

- **Due Date**: Friday, 18th October 2024, 23:59.
- **Submission Format**:
  - Submit your final Google Colab notebook as a `.ipynb` file.
  - Provide a **link to your private GitHub repository** containing your
    commits.
  - **Ensure you have invited your tutor to your private repository** to grant
    access for assessment. Failure to send an invite will result in a
    significant loss of marks because we cannot see the change and commit
    history.

- **Late Submission**: Penalties apply as outlined in the unit handbook.

#### **Additional Notes**

- **API Key Security**: Ensure your API key is not shared publicly in your code
  or repository. Use secure methods to handle the API key, such as environment
  variables or input prompts.

- **Data Ethics**: Consider the ethical implications of data usage and discuss
  this in your report. Even though weather data is public, responsible use and
  acknowledgment of data sources are important.

- **Version Control Best Practices**:
  - **Private Repository**: Create a private repository to protect your work.
  - **Inviting Your Tutor**: Invite your tutor to your private repository for
    assessment purposes.
  - **Regular Commits**: Commit after significant changes or feature additions.
    This helps in tracking changes, debugging, and collaborating.

- **Commenting and Documentation**: Write clear and concise docstrings for your
  functions. Follow standard documentation conventions to explain the purpose,
  parameters, return values, and any side effects.

- **Error Handling**: Implement basic error handling to manage issues such as
  invalid API responses.

- **Professionalism**: Ensure your final notebook is well-organised, free of
  errors, and professionally presented.


---
title: "Control Structures"
subtitle: "Weather Adventures in Python Land"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Copyright Information

![](../../_assets/curtin-copy-right.png)

# Acknowledge of Country
I acknowledge the traditional custodians of the land on which I work and live,
and recognise their continuing connection to land, water and community. I pay
respect to elders past, present and emerging.

![](../../_assets/ack_country.png)

# Today

- Learn about branching (if-then-else)
- Explore repetition (for and while loops)
- Combined these concepts in weather-related examples
- Touch (discussed next lecture) on functions, error handling, and data structures

::: {.notes}
**Aim**
The aim of this slide is to provide an overview of the key topics that will be covered in today's lecture on branching, repetition, and their applications in weather-related examples.

**Context**
This slide follows on from the "Recall - Six Things" slide, which likely reviewed previous concepts. The topics introduced in "Today" will be expanded upon in subsequent slides, such as "What's Branching?", "If-Then in Python", "What's Repetition?", and "For Loops in Python". The weather-related examples mentioned will be demonstrated in slides like "Weather Condition Checker" and "Weekly Forecast".

**Learn about branching (if-then-else)**
Branching, also known as conditional statements, allows a program to make decisions based on certain conditions. In this lecture, we will explore the if-then-else structure, which executes a block of code if a specified condition is true and another block of code if the condition is false. Understanding branching is crucial for creating programs that can adapt to different scenarios and inputs.

**Explore repetition (for and while loops)**
Repetition, or looping, is a fundamental concept in programming that allows a block of code to be executed multiple times. We will discuss two types of loops: for loops, which iterate over a sequence of elements, and while loops, which continue to execute as long as a given condition is true. Mastering loops enables you to automate repetitive tasks and process large amounts of data efficiently.

**Combined these concepts in weather-related examples**
To demonstrate the practical applications of branching and repetition, we will work through several weather-related examples. These examples will showcase how conditional statements and loops can be used to create programs that analyse and respond to different weather conditions. By combining these concepts, you will gain a deeper understanding of how to build more complex and interactive weather applications.

**Touch (discussed next lecture) on functions, error handling, and data structures**
In the next lecture, we will introduce the concepts of functions, error handling, and data structures. Functions allow you to organise and reuse code, making your programs more modular and easier to maintain. Error handling helps you anticipate and manage potential issues in your code, improving its reliability. Data structures, such as lists and dictionaries, provide efficient ways to store and manipulate data. These topics will be discussed in more detail in the upcoming lecture.
:::

# Recall - Six Things

| **Six Things** | **Python Language Feature**                                 |
|------------------------|--------------------------------------------------------------|
| Input                  | `input()`             |
| Output                 | `print()` function, writing to files, sending data over network|
| Calculate              | Operators (`+`, `-`, `*`, `/`, `%`, `**`) (`<`, `>`, `==`, `<=`, `>=`)         |
| Store                  | Variables  |
| **Decision**           | `if` statements, `else`, `elif`                              |
| **Repetition**         | `for` loops, `while` loops, list comprehensions              |

::: {.notes}
**Aim**
The purpose of this slide is to briefly review six key concepts covered earlier in the presentation.

**Context**
This slide follows the "Today" slide, which likely outlines the topics to be covered in the presentation. The "Recall - Six Things" slide serves as a quick review before diving into the main content, starting with the next slide on "What's Branching?". The six recalled items are likely foundational concepts for understanding the upcoming topics on branching, repetition, and their applications in Python programming.
:::

# What's Branching?

- Making decisions in code
- Uses conditional statements (if-else)
- Like checking weather forecasts
- Determines program flow
- Enables responsive program behavior

::: {.notes}
**Aim**
The aim of this slide is to introduce the concept of branching in programming and explain how it allows programs to make decisions based on certain conditions.

**Context**
This slide follows on from the "Recall - Six Things" slide and precedes slides on Boolean expressions, operators, and specific examples of branching in Python. It provides a foundation for understanding how programs can respond differently based on input or calculated values.

**Making decisions in code**
Branching is a fundamental concept in programming that allows code to make decisions. Just as we make decisions in our daily lives based on certain conditions, programs can also evaluate conditions and execute different blocks of code depending on whether those conditions are met. This enables programs to respond intelligently and perform different actions in different situations.

**Uses conditional statements (if-else)**
The most common way to implement branching in code is through the use of conditional statements, particularly the if-else statement. An if statement checks whether a condition is true, and if so, executes a certain block of code. If the condition is false, an else block can be used to specify an alternative action. This allows the program to choose between two different paths based on the outcome of the condition.

**Like checking weather forecasts**
Branching can be thought of as similar to checking a weather forecast before deciding what to wear or whether to bring an umbrella. The program checks certain conditions, such as the current temperature or chance of rain, and then chooses an appropriate course of action based on those conditions. This analogy helps to illustrate the decision-making process that branching enables in programs.

**Determines program flow**
Branching is a key factor in determining the flow of a program. When a program reaches a branching point, such as an if statement, it will follow a different path depending on the outcome of the condition. This means that the program's execution can vary based on the input it receives or the values it calculates, leading to different outcomes or outputs.

**Enables responsive program behaviour**
By using branching, programs can be designed to respond intelligently to different situations. For example, a program could use branching to provide personalised recommendations based on user input, or to handle errors gracefully by executing different code when something goes wrong. This flexibility and responsiveness is a crucial aspect of creating programs that are useful and engaging for users.
:::

# Boolean Expressions

- Evaluate to True or False
- Compare values (==, !=, <, >)
- Combine with and, or, not
- Essential for decision making
- Examples: is_raining, temp > 30

::: {.notes}
**Aim**
This slide aims to introduce boolean expressions and their role in decision making within Python programs.

**Context**
Following an introduction to branching, this slide delves into boolean expressions as the foundation for conditional statements. It prepares the audience for upcoming slides that demonstrate the use of if-then, else, and elif statements in Python.

**Evaluate to True or False** Boolean expressions are fundamental constructs in programming that evaluate to either True or False. They form the basis for decision making in code, allowing programs to execute different blocks of code depending on whether a condition is met or not. Boolean expressions are essential for creating logical flow and controlling program behaviour based on specific criteria.

**Compare values (==, !=, <, >)** Boolean expressions often involve comparing values using operators such as equal to (==), not equal to (!=), less than (<), and greater than (>). These operators allow programmers to check if two values are equal, unequal, or if one value is greater or less than another. By comparing values, boolean expressions can determine the relationship between variables or constants and make decisions accordingly.

**Combine with and, or, not** Boolean expressions can be combined using logical operators like and, or, and not. The 'and' operator returns True if both expressions are True, while the 'or' operator returns True if at least one expression is True. The 'not' operator negates a boolean expression, returning the opposite value. These operators enable the creation of more complex conditions by combining multiple boolean expressions.

**Essential for decision making** Boolean expressions are crucial for decision making in programming. They allow programs to evaluate conditions and execute different code blocks based on the results. Decision making is a fundamental aspect of programming, enabling programs to respond to different scenarios, handle user input, and control the flow of execution. Without boolean expressions, programs would be limited to linear execution and lack the ability to adapt to varying conditions.

**Examples: is_raining, temp > 30** The slide provides two examples of boolean expressions: 'is_raining' and 'temp > 30'. 'is_raining' is a boolean variable that could represent whether it is currently raining or not. 'temp > 30' is a boolean expression that compares the value of the 'temp' variable to the constant value 30, evaluating to True if the temperature is greater than 30 and False otherwise. These examples demonstrate how boolean expressions can represent real-world conditions and make decisions based on them.
:::

# Common Boolean Operators

```python
# Comparison operators
== (equal to)
!= (not equal to)
< (less than)
> (greater than)
<= (less than or equal to)
>= (greater than or equal to)
```

::: {.notes}
**Aim**
This slide aims to introduce the common Boolean operators used in Python programming to create logical expressions for conditional statements and loops.

**Context**
Boolean operators are a fundamental concept in programming, and understanding them is essential for implementing branching and repetition in Python. This slide follows the introduction to Boolean expressions and precedes the slides on logical operators and their practical applications in if-then statements, loops, and the weather condition checker example.

**AND** The AND operator returns True if both operands are True, and False otherwise. It is denoted by the keyword "and" in Python. For example, the expression "x > 0 and x < 10" will evaluate to True only if the value of x is between 0 and 10 (excluding 0 and 10).

**OR** The OR operator returns True if at least one of the operands is True, and False if both operands are False. It is denoted by the keyword "or" in Python. For example, the expression "x < 0 or x > 10" will evaluate to True if the value of x is less than 0 or greater than 10.

**NOT** The NOT operator returns the opposite Boolean value of its operand. It is denoted by the keyword "not" in Python. For example, if x is True, then "not x" will evaluate to False, and if x is False, then "not x" will evaluate to True.
:::

# Logical Operators

```python
# Combine boolean expressions
and (both conditions true)
or (at least one condition true)
not (negates the condition)

# Example
is_raining and temperature < 10
```

::: {.notes}
**Aim**
This slide aims to introduce logical operators and their role in creating more complex conditions in branching and repetition structures.

**Context**
Following the discussion of boolean expressions and common boolean operators, this slide delves into logical operators. It sets the stage for the subsequent slides that demonstrate how these operators are used in Python's if-then-else and loop constructs.

**Logical Operators** 
Logical operators allow programmers to combine multiple boolean expressions to create more sophisticated conditions. The three main logical operators are AND, OR, and NOT. The AND operator returns True only if both operands are True. The OR operator returns True if at least one of the operands is True. The NOT operator negates the value of a single operand, returning the opposite boolean value.
:::

# If-Then in Python

```python
if temperature > 30:
    print('It's hot!')
    suggest_cold_drink()
```

- Checks a condition
- Executes if condition is True
- Can include multiple statements
- Indentation is important
- Use for simple decisions

::: {.notes}
**Aim**
To introduce the if-then statement in Python and explain its purpose and syntax.

**Context**
Following an introduction to branching and boolean expressions, this slide focuses on the if-then statement in Python. The next slides will cover else and elif statements, allowing for more complex decision-making in Python programs.

**Checks a condition** The if-then statement in Python is used to check a specific condition. It evaluates a boolean expression, which can be either True or False. This allows the program to make decisions based on the state of variables or the result of comparisons.

**Executes if condition is True** If the condition in the if statement evaluates to True, the code block following the if statement is executed. This code block can contain one or more statements that are run only when the condition is met. If the condition is False, the code block is skipped.

**Can include multiple statements** The code block following an if statement can include multiple lines of code. All of these statements will be executed if the condition is True. It's important to note that all statements in the block must be indented to the same level.

**Indentation is important** In Python, indentation is used to define code blocks. After an if statement, the code block must be indented (usually by 4 spaces). This indentation tells Python which lines of code belong to the if statement. Incorrect indentation can lead to syntax errors.

**Use for simple decisions** If-then statements are best used for simple decision-making in a program. When there are only two possible outcomes based on a condition (i.e., the condition is either True or False), an if-then statement is a clear and concise way to control the flow of the program.
:::

# Else in Python

```python
if temperature > 30:
    print('It's hot!')
else:
    print('It's not too hot.')
```

- Provides alternative action
- Executes when if is False
- Completes the decision structure
- Ensures code for all cases
- Use for binary decisions

::: {.notes}
**Aim**
This slide aims to explain the purpose and usage of the else statement in Python conditional logic.

**Context**
After introducing the concept of branching and if statements, this slide covers the else statement as the next component in decision structures. It is followed by elif for more complex conditionals and practical examples applying these concepts.

**Provides alternative action** The else statement provides an alternative action to be executed when the condition in the preceding if statement evaluates to False. It allows you to specify a block of code that should run if none of the previous conditions were met.

**Executes when if is False** The code block under the else statement will only execute if the condition in the if statement is False. This ensures that either the if block or the else block will run, but never both for the same condition.

**Completes the decision structure** By including an else statement, you create a complete decision structure that covers all possible cases. This is useful when you need to ensure that some action is always taken, regardless of whether the if condition is True or False.

**Ensures code for all cases** Using an else statement guarantees that you have provided code to handle all possible cases in your conditional logic. This helps prevent gaps in your decision-making process and makes your code more robust.

**Use for binary decisions** The if-else structure is most commonly used for binary decisions, where there are only two possible outcomes. If you need to check for multiple conditions, you can use elif statements in between the if and else to handle additional cases.
:::

# Elif in Python

```python
if temperature > 30:
    print('It's hot!')
elif temperature < 10:
    print('It's cold!')
else:
    print('It's pleasant.')
```

::: {.notes}
**Aim**
This slide aims to introduce the elif statement in Python and explain its role in creating more complex branching structures.

**Context**
The elif statement builds upon the concepts of boolean expressions, if-then statements, and else statements covered in previous slides. It allows for more sophisticated decision-making in Python programs and sets the stage for the weather condition checker example in the following slide.

**[Bullet Point 1]** The elif keyword in Python is short for "else if" and is used in conjunction with if and else statements to create more complex branching structures. It allows you to specify additional conditions to check if the preceding if statement's condition is false. You can include multiple elif statements to handle different cases or scenarios.

**[Bullet Point 2]** The syntax for using elif is similar to if statements. After an initial if statement, you can add one or more elif statements, each followed by a condition and a colon. The code block under each elif statement is executed if its condition evaluates to True. You can optionally include an else statement at the end to handle the case when none of the conditions are met.

**[Bullet Point 3]** When Python encounters an if-elif-else structure, it evaluates the conditions in order from top to bottom. If the if statement's condition is True, its code block is executed, and the rest of the elif and else blocks are skipped. If the if condition is False, Python moves on to the first elif condition. If that condition is True, its code block is executed, and the remaining elif and else blocks are skipped. This process continues until a condition is met or until the else block is reached.

**[Bullet Point 4]** Elif statements are useful when you need to check multiple conditions and execute different code blocks based on those conditions. They provide a way to handle various scenarios or cases in your program logic. By using elif, you can create more precise control flow and make your code more readable and manageable.
:::

# Weather Condition Checker

```python
if is_raining:
    bring_umbrella()
if is_snowing:
    wear_boots()
if is_sunny:
    apply_sunscreen()
```

- Multiple independent checks
- Each condition evaluated separately
- Actions not mutually exclusive
- Flexible decision structure
- Useful for complex scenarios

::: {.notes}
**Aim**
The slide aims to explain how a weather condition checker works, highlighting its ability to handle complex scenarios through independent checks and flexible decision structures.

**Context**
The "Weather Condition Checker" slide follows the introduction to branching and Boolean expressions. It serves as a practical example of applying these concepts before moving on to repetition and more advanced weather-related programs.

**Multiple independent checks** The weather condition checker performs multiple checks on different weather conditions, such as temperature, humidity, wind speed, and precipitation. Each of these checks is independent of the others, allowing the program to evaluate each condition separately. This modular approach makes the code more readable and easier to maintain.

**Each condition evaluated separately** The program evaluates each weather condition individually using separate Boolean expressions. For example, it might check if the temperature is above a certain threshold, if the humidity is within a specific range, or if the wind speed exceeds a given value. By evaluating each condition separately, the program can make more precise decisions based on the specific criteria for each weather aspect.

**Actions not mutually exclusive** The actions taken by the weather condition checker based on the results of the condition checks are not mutually exclusive. This means that multiple actions can be triggered simultaneously if the corresponding conditions are met. For instance, the program might suggest wearing a coat if the temperature is low, while also recommending an umbrella if it's raining. This allows for more comprehensive and tailored recommendations.

**Flexible decision structure** The weather condition checker employs a flexible decision structure, such as if-elif-else statements or nested conditionals, to handle various combinations of weather conditions. This flexibility enables the program to account for a wide range of scenarios and provide appropriate outputs based on the specific conditions encountered. By using a flexible decision structure, the program can adapt to different weather situations and offer relevant advice or actions.

**Useful for complex scenarios** The independent checks, separate condition evaluations, non-mutually exclusive actions, and flexible decision structure make the weather condition checker particularly useful for handling complex weather scenarios. It can take into account multiple factors and their interactions to provide accurate and helpful information to users. This approach allows the program to deal with the intricacies of real-world weather patterns and offer more nuanced and relevant outputs.
:::

# What's Repetition?

- Executing code multiple times
- Uses loops (for, while)
- Like daily weather checks
- Automates repetitive tasks
- Efficient for data processing

::: {.notes}
**Aim**
The aim of this slide is to introduce the concept of repetition in programming and explain its role in automating tasks.

**Context**
Having covered branching and conditionals in previous slides, this slide introduces repetition as another fundamental programming concept. It sets the stage for the following slides which will delve into specific loop constructs in Python, such as for loops and while loops.

**Executing code multiple times**
Repetition in programming refers to the ability to execute a block of code multiple times. This is a powerful feature that allows programmers to automate repetitive tasks and process large amounts of data efficiently. Instead of manually writing the same code over and over, repetition constructs enable the code to be executed as many times as needed.

**Uses loops (for, while)**
In Python, repetition is achieved through the use of loops. The two main types of loops are for loops and while loops. For loops are used when the number of iterations is known in advance, such as iterating over a sequence of elements. While loops, on the other hand, are used when the number of iterations is not known and depends on a certain condition being met.

**Like daily weather checks**
A real-world analogy for repetition is performing daily weather checks. Just as we might check the weather forecast every morning to plan our day, a program can use repetition to perform a task or check a condition repeatedly. This could involve retrieving data from a weather API, processing it, and updating a display or sending notifications based on the current weather conditions.

**Automates repetitive tasks**
One of the key benefits of repetition in programming is its ability to automate repetitive tasks. Instead of manually performing the same action over and over, loops allow us to write code once and have it execute multiple times. This saves time, reduces the risk of errors, and makes our code more concise and maintainable.

**Efficient for data processing**
Repetition is particularly useful when it comes to processing large amounts of data. Whether it's iterating over a list of items, reading data from a file, or querying a database, loops enable us to efficiently process and manipulate data. By using repetition constructs, we can perform operations on each element of a dataset without having to write separate code for each individual item.
:::

# For Loops in Python

```python
for day in range(7):
    check_forecast(day)
```

- Iterate over a sequence
- Repeat a specific number times
- Useful for known iterations
- Concise and readable
- Example: weekly weather forecast

::: {.notes}
**Aim**
The aim of this slide is to introduce for loops in Python and explain their purpose and usage.

**Context**
This slide follows on from discussing the concept of repetition in programming. It precedes a slide on while loops, another type of repetition structure in Python.

**Iterate over a sequence** For loops in Python allow you to iterate over a sequence of items, such as a list, tuple, or string. This means the loop will execute once for each item in the sequence, with a loop variable taking on the value of the current item in each iteration. This is useful when you need to process each item in a collection individually.

**Repeat a specific number times** For loops can also be used to repeat a block of code a specific number of times. This is achieved using the range() function, which generates a sequence of numbers. By specifying the range, you can control exactly how many times the loop will execute.

**Useful for known iterations** For loops are particularly useful when you know in advance how many times you need to repeat a block of code. This could be based on the length of a sequence you're iterating over, or a fixed number of repetitions required for a specific task.

**Concise and readable** One advantage of for loops is their concise and readable syntax. The structure of a for loop clearly shows what sequence is being iterated over and what variable is being used for each item. This makes for loops easy to understand and maintain.

**Example: weekly weather forecast** To illustrate the usage of for loops, consider generating a weekly weather forecast. You could use a for loop to iterate over a list of the seven days of the week, executing the code to fetch and display the weather data for each day. This is a clear and efficient way to process the data for a known number of iterations.
:::

# While Loops in Python

```python
days_of_rain = 0
while days_of_rain < 3:
    if is_raining():
        days_of_rain += 1
    check_next_day()
```

- Repeat while condition is True
- Useful for unknown iterations
- Requires careful condition management
- Can create infinite loops
- Example: continuous weather monitoring

::: {.notes}
**Aim**
This slide aims to introduce while loops in Python and explain their key characteristics and use cases.

**Context**
Having discussed for loops in the previous slide, this slide expands on another type of repetition structure in Python: while loops. It is followed by slides that demonstrate practical applications of while loops, such as in a weekly forecast program and a weather station simulator.

**Repeat while condition is True** While loops in Python continue to execute a block of code as long as a specified condition evaluates to True. The loop body is repeated until the condition becomes False. This allows for dynamic control flow based on changing conditions.

**Useful for unknown iterations** While loops are particularly handy when the number of required iterations is not known in advance. They can keep running until a certain condition is met, making them flexible for scenarios where the loop's end point is determined by external factors or computed values.

**Requires careful condition management** To prevent while loops from running indefinitely, it's crucial to manage the loop condition carefully. The condition should eventually become False, either through changes made within the loop body or by external events. Forgetting to update the condition can lead to infinite loops.

**Can create infinite loops** If the condition in a while loop always remains True, the loop will continue to execute indefinitely, resulting in an infinite loop. This can cause the program to hang or crash. It's important to include appropriate termination conditions and test the loop to ensure it ends as expected.

**Example: continuous weather monitoring** A practical example of using a while loop is in a weather monitoring system. The loop can continuously check the current weather conditions and perform actions based on the readings. It can keep running until a specific condition is met, such as a certain temperature threshold or a user-initiated termination signal.
:::

# Weekly Forecast

```python
for week in range(4):
    for day in range(7):
        forecast = get_forecast(week, day)
        print(f'Week {week+1}, Day {day+1}: {forecast}')
```

::: {.notes}
**Aim**
The aim of this slide is to introduce the concept of generating weekly weather forecasts using Python programming.

**Context**
This slide follows on from the introduction of branching, boolean expressions, and conditional statements in Python. It precedes a deeper exploration of combining branching and repetition to create more complex weather forecasting programs.

**Bullet Point 1**

**Bullet Point 2**

**Bullet Point 3**
:::

# Combining Branching and Repetition

```python
for day in range(7):
    temp = get_temperature(day)
    if temp > 30:
        print(f'Day {day + 1}: Hot!')
    elif temp < 10:
        print(f'Day {day + 1}: Cold!')
    else:
        print(f'Day {day + 1}: Nice!')
```

::: {.notes}
**Aim**
This slide aims to show how branching and repetition can be combined in Python programs to create more powerful and flexible logic.

**Context**
Having covered branching with if-elif-else statements and repetition with for and while loops separately, this slide demonstrates how these concepts can be used together. It leads into a practical example in the next slide, "Weather Station Simulator".
:::

# Weather Station Simulator

```python
while True:
    temp = measure_temperature()
    if temp > 35:
        sound_heat_alarm()
    elif temp < -10:
        sound_freeze_alarm()
    update_display(temp)
    time.sleep(60)  # Wait for 1 minute
```

::: {.notes}
**Aim**
The aim of this slide is to introduce students to a Weather Station Simulator program that combines branching and repetition concepts.

**Context**
This slide builds upon the previous lessons on branching and repetition in Python. It demonstrates how these concepts can be combined to create a more complex program that simulates a weather station. The slide sets the stage for the following slides, which delve into additional features and enhancements to the Weather Station Simulator.

**Bullet Point 1**

**Bullet Point 2**

**Bullet Point 3**
:::

# Breaking the Loop

```python
days_monitored = 0
while True:
    if is_severe_storm():
        print('Severe storm detected!')
        break
    days_monitored += 1
    if days_monitored >= 30:
        print('30 days complete.')
        break
```

::: {.notes}
**Aim**
The aim of this slide is to introduce the concept of breaking out of loops in Python using the `break` statement.

**Context**
This slide follows on from the previous slides covering for loops and while loops in Python. It introduces a new concept that allows for more control over loop execution. The following slides will apply this concept in practical examples like a quick weather forecast program.

**Breaking the Loop** 
In Python, the `break` statement provides a way to exit a loop prematurely. When `break` is encountered inside a loop, the program immediately exits the loop, regardless of the loop condition. This is useful in situations where you want to stop the loop based on a certain condition without waiting for the loop to complete all its iterations.

To use `break`, simply include the `break` statement at the point where you want the loop to exit. Any code after the `break` statement inside the loop will not be executed. Execution will continue with the first statement after the loop.

The `break` statement works with both for loops and while loops in Python. It provides an important control mechanism to prevent unnecessary iterations and to handle special conditions that require loop termination.

In the context of the weather station simulator example, `break` could be used to exit the loop if the user enters a specific input to quit the program. This allows for a graceful exit from the loop and the program.
:::

# List Comprehensions

```python
temps = [get_temp(day) for day in range(7)]
forecasts = ['Hot' if t > 30 else 'Cold' if t < 10 else 'Nice' for t in temps]
```

- Concise way to create lists
- Combines loop and conditional logic
- Readable for simple operations
- Powerful for data transformations
- Example: weekly temperature categorisation

::: {.notes}
**Aim**
This slide introduces list comprehensions as a concise and efficient way to create lists in Python, combining looping and conditional logic.

**Context**
After covering branching (if-elif-else) and repetition (for and while loops) in Python, this slide shows how these concepts can be combined using list comprehensions. It leads into the next slides on reusable weather logic and applying functions with loops.

**Concise way to create lists** List comprehensions provide a compact syntax for creating lists based on existing lists or other iterable objects. They allow you to generate new lists in a single line of code, making your code more concise and readable.

**Combines loop and conditional logic** List comprehensions integrate the functionality of loops and conditional statements into a single expression. You can iterate over elements, apply transformations, and filter items based on specific conditions, all within the list comprehension itself.

**Readable for simple operations** For straightforward list creation tasks, list comprehensions offer a clear and intuitive way to express the desired operation. They eliminate the need for explicit loop and conditional constructs, making the code more readable and maintainable.

**Powerful for data transformations** List comprehensions shine when it comes to performing data transformations on lists. You can easily apply functions, mathematical operations, or string manipulations to each element of a list, creating a new list with the transformed values.

**Example: weekly temperature categorization** To illustrate the usage of list comprehensions, the slide presents an example of categorizing weekly temperatures. By applying a list comprehension to a list of temperature values, you can create a new list that categorizes each temperature as "hot", "warm", or "cold" based on specific thresholds.
:::


# Robust Weather App

```python
try:
    temperature = get_temperature()
    print(f'Temperature: {temperature}°C')
except SensorError:
    print('Error reading sensor')
```

- Anticipate and handle errors
- Prevents crashes due to exceptions
- Improves user experience
- Enables graceful error recovery
- Essential for reliable applications

::: {.notes}
**Aim**
This slide aims to highlight the importance of error handling and robustness in weather applications to ensure a smooth user experience and prevent application crashes.

**Context**
In the context of the presentation, this slide follows the discussion on reusable weather logic and applying functions with loops. It precedes the slides on storing weather data and looping through dictionaries, suggesting a focus on building reliable and user-friendly weather applications.

**Anticipate and handle errors** Error handling is a crucial aspect of building robust weather applications. By anticipating potential errors, such as network connectivity issues, invalid user inputs, or unexpected API responses, developers can implement appropriate error handling mechanisms. This involves using try-except blocks to catch exceptions, providing informative error messages to users, and gracefully recovering from errors whenever possible.

**Prevents crashes due to exceptions** Unhandled exceptions can lead to application crashes, resulting in a poor user experience and potentially causing data loss. By implementing proper error handling, developers can prevent crashes caused by exceptions. When an exception occurs, the application can catch it, log the error for later analysis, and display a user-friendly error message instead of abruptly terminating.

**Improves user experience** Robust error handling significantly enhances the user experience of weather applications. Instead of encountering cryptic error messages or sudden crashes, users receive clear and informative feedback when something goes wrong. This helps users understand the issue and provides guidance on how to proceed, such as checking their network connection or entering valid input. A smooth and uninterrupted user experience builds trust and encourages continued use of the application.

**Enables graceful error recovery** Graceful error recovery is an essential aspect of robust weather applications. When an error occurs, the application should attempt to recover from it whenever possible. For example, if a network request fails, the application can retry the request after a certain interval or fall back to cached data. Graceful error recovery minimises disruptions to the user experience and ensures that the application remains functional even in the face of errors.

**Essential for reliable applications** Robustness and error handling are essential for building reliable weather applications. Users rely on these applications for accurate and timely weather information, and any failures or crashes can erode user trust and satisfaction. By prioritising robustness and implementing comprehensive error handling, developers can create weather applications that are dependable, stable, and able to handle various exceptional scenarios gracefully.
:::

# Storing Weather Data

```python
weather_data = {
    'temperature': 22,
    'humidity': 65,
    'wind_speed': 10,
    'conditions': 'Partly cloudy'
}
```

::: {.notes}
**Aim**
The aim of this slide is to introduce the concept of storing weather data and explore different data structures for organising weather information.

**Context**
After covering branching, repetition, and functions to create a robust weather application, the next step is to discuss data storage. This slide leads into the following slide on looping through dictionaries to access and manipulate stored weather data.

**Bullet Point 1** In Python, weather data can be stored using various data structures such as lists, tuples, and dictionaries. Lists are ordered collections of items that can be modified, while tuples are immutable ordered sequences. Dictionaries, on the other hand, store key-value pairs and provide efficient lookup and retrieval of data based on unique keys.

**Bullet Point 2** When choosing a data structure for weather data, consider the nature of the data and the operations you need to perform. Lists and tuples are suitable for storing ordered sequences of weather measurements, such as temperature readings over time. Dictionaries are ideal when you need to associate specific weather attributes with unique identifiers, such as city names or dates.

**Bullet Point 3** To store weather data efficiently, consider the following best practices:
1. Use meaningful variable and key names to enhance code readability.
2. Ensure data consistency by validating and cleaning input data before storing it.
3. Organize data in a structured format, such as grouping related measurements together.
4. Choose appropriate data types for each weather attribute to optimize memory usage and performance.

**Bullet Point 4** When working with stored weather data, you can perform various operations, such as:
1. Accessing specific weather measurements by index or key.
2. Modifying or updating existing weather data.
3. Filtering and searching for specific weather conditions or patterns.
4. Performing calculations and analysis on the stored data, such as calculating averages or extremes.

**Bullet Point 5** Real-world weather applications often require persistent storage solutions beyond in-memory data structures. You can store weather data in files, databases, or cloud storage services for long-term persistence and scalability. Popular options include CSV files, SQLite databases, or cloud platforms like AWS S3 or Google Cloud Storage.
:::

# Looping Through Dictionaries

```python
for key, value in weather_data.items():
    print(f'{key.capitalize()}: {value}')
```

- Access key-value pairs
- Iterate through dictionary entries
- Useful for structured data
- Flexible data representation
- Example: detailed weather report

::: {.notes}
**Aim**
This slide aims to cover how to work with dictionaries in Python, focusing on accessing and iterating through key-value pairs.

**Context**
After learning about branching, repetition, and functions in previous slides, we now explore dictionaries as a flexible way to store and work with structured data. The next slides discuss using GenAI to learn Python effectively and apply these concepts in a weather analysis project.

**Access key-value pairs** In Python dictionaries, data is stored as key-value pairs. To access a value, you use its corresponding key inside square brackets. For example, if `weather` is a dictionary, you can access the temperature with `weather["temperature"]`. This allows for quick and direct access to specific data points.

**Iterate through dictionary entries** You can loop through a dictionary using a `for` loop. By default, iterating over a dictionary gives you its keys. To access both keys and values, use the `.items()` method, like `for key, value in weather.items():`. This lets you process all the data in a dictionary efficiently.

**Useful for structured data** Dictionaries are ideal for representing structured data where each piece of information has a unique label or key. For instance, a weather report could have keys like "temperature", "humidity", "wind_speed", etc. This key-value structure keeps the data organised and easy to understand.

**Flexible data representation** Unlike lists which are ordered sequences, dictionaries are unordered and can hold various types of data as values. The values can be of any data type, like numbers, strings, booleans, or even lists and other dictionaries. This flexibility makes dictionaries suitable for complex, hierarchical data structures.

**Example: detailed weather report** A practical example is a detailed weather report stored in a dictionary. It could have keys for different aspects of the weather, like:
```python
weather = {
    "temperature": 25.3,
    "humidity": 0.6,
    "wind_speed": 10,
    "wind_direction": "NE",
    "forecast": ["sunny", "cloudy", "rainy"]
}
```
You can then access and work with this data easily using the keys.
:::

# Using GenAI as Your Python Tutor

- Ask for concept explanations
- Request code examples
- Get personalized practice questions
- Debug your code together
- Explore real-world weather applications

::: {.notes}
**Aim**
This slide aims to highlight how GenAI can be used as a personalised Python tutor to help learners grasp concepts, get code examples, practise, debug, and explore real-world applications.

**Context**
Following the presentation's sections on Python branching, repetition, and functions in weather applications, this slide introduces GenAI as a learning tool to support Python skill development. It precedes slides on effective GenAI learning strategies and the course project of building a weather analysis tool.

**Ask for concept explanations**
When learning Python, you can ask GenAI to explain programming concepts in detail. For example, you could ask it to clarify the difference between for and while loops, or how if-elif-else statements work. GenAI will provide clear explanations to help you understand the concepts better.

**Request code examples** 
GenAI can generate Python code examples on demand. If you're unsure how to write a for loop to iterate through a list, just ask GenAI. It will provide a relevant code snippet with explanations, helping you learn by example.

**Get personalised practice questions**
GenAI can create practice Python questions tailored to your learning needs. Request questions on specific topics like dictionaries or functions, and GenAI will generate unique problems for you to solve. This personalised practice helps reinforce your understanding.

**Debug your code together**
When you encounter bugs in your Python code, GenAI can help you debug. Paste your code and error message, and ask GenAI to identify the issue. It will explain the problem and suggest fixes, helping you learn debugging skills experientially.

**Explore real-world weather applications**
GenAI can help you explore real-world applications of Python in weather data analysis. Ask for examples of how to use Python libraries like Matplotlib to visualise weather patterns or how to fetch weather data from APIs. GenAI will provide code snippets and explanations, bridging the gap between theory and practical application.
:::

# GenAI Learning Strategies

1. Concept Clarification
   - "Explain boolean expressions simply"
   - "How does 'elif' differ from 'else'?"
   - "Show weather-related 'while' loop example"

2. Code Practice
   - "Generate a weather-themed 'if-else' exercise"
   - "Create a loop to process weekly temperatures"
   - "Help debug this weather station code"

3. Real-world Application
   - "How to use Python for weather forecasting?"
   - "Suggest a weather data analysis project"
   - "Explain APIs for retrieving weather data"

4. Personalized Learning Path
   - "What should I learn after mastering loops?"
   - "Suggest advanced weather-related Python projects"
   - "Create a study plan for Python in meteorology"

5. Interactive Problem-Solving
   - "Let's build a simple weather app together"
   - "Help me optimize this weather data processing code"
   - "Guide me through creating a temperature converter"

::: {.notes}
**Aim**
This slide aims to showcase how learners can effectively leverage GenAI as a personalised Python tutor to reinforce key programming concepts and tackle weather-related coding challenges.

**Context**
Following the introduction of branching, repetition, and their applications in weather-related programming tasks, this slide focuses on strategies for utilising GenAI to deepen understanding and acquire practical skills. The subsequent slides provide tips for effective GenAI use and introduce the course project, tying together the concepts covered throughout the presentation.

**"Explain boolean expressions simply"** Request GenAI to provide a concise, beginner-friendly explanation of boolean expressions, their role in decision-making, and how they are used in if-else statements. This will help solidify your understanding of the fundamental concept that underpins branching in Python.

**"How does 'elif' differ from 'else'?"** Ask GenAI to clarify the difference between 'elif' and 'else' in Python, including when to use each one and how they contribute to creating more complex decision-making structures. This will help you grasp the nuances of branching and write more efficient code.

**"Show weather-related 'while' loop example"** Prompt GenAI to provide a practical example of using a 'while' loop in a weather-related context, such as continuously monitoring temperature until a certain condition is met. This will demonstrate how repetition can be applied to real-world scenarios and help you visualise the concept more clearly.

**"Generate a weather-themed 'if-else' exercise"** Request GenAI to create a practice exercise that combines weather-related conditions with if-else statements, allowing you to apply your knowledge of branching in a relevant context. Engaging in targeted practice will reinforce your understanding and improve your problem-solving skills.

**"Create a loop to process weekly temperatures"** Ask GenAI to guide you through creating a loop that processes a list of weekly temperatures, showcasing how repetition can be used to automate tasks and handle multiple data points efficiently. This will help you gain practical experience in applying loops to real-world weather data.

**"Help debug this weather station code"** Present a snippet of your weather station code that isn't working as expected and ask GenAI to identify the issues and provide suggestions for fixing them. This will help you develop debugging skills and learn how to troubleshoot common problems in your code.

**"How to use Python for weather forecasting?"** Inquire about the essential concepts, libraries, and APIs that are commonly used in Python for weather forecasting. GenAI can provide an overview of the key components and steps involved, helping you understand how to approach weather forecasting projects using Python.

**"Suggest a weather data analysis project"** Request GenAI to propose a small-scale weather data analysis project that allows you to apply the concepts of branching, repetition, and data manipulation using Python. Having a concrete project idea will give you a clear goal to work towards and provide an opportunity to practice your skills in a meaningful context.

**"Explain APIs for retrieving weather data"** Ask GenAI to explain how APIs can be used to retrieve weather data in Python, including popular weather APIs, their usage, and any necessary authentication steps. Understanding how to work with APIs will enable you to access real-time weather data for your projects and analyses.

**"What should I learn after mastering loops?"** Seek guidance on what topics or concepts you should focus on next after gaining proficiency in using loops in Python. GenAI can suggest areas such as functions, data structures, or file handling, depending on your interests and goals related to weather data processing and analysis.

**"Suggest advanced weather-related Python projects"** Request ideas for more complex weather-related projects that incorporate advanced Python concepts, such as data visualisation, machine learning, or building web applications. Having a roadmap of potential projects will keep you motivated and provide opportunities to apply your growing skill set.

**"Create a study plan for Python in meteorology"** Ask GenAI to help you develop a personalised study plan that covers the key Python concepts and skills needed for working with weather data and pursuing meteorology-related projects. A structured learning path will help you stay organised and progress efficiently towards your goals.

**"Let's build a simple weather app together"** Engage GenAI in a step-by-step collaborative process of building a basic weather application that demonstrates the practical application of branching, repetition, and API integration. This hands-on experience will solidify your understanding of the concepts and boost your confidence in developing weather-related tools
:::

# Asking for Practice Questions

- "Generate 5 weather-themed 'if-else' questions"
- "Create loop exercises using temperature data"
- "Provide boolean expression practice with forecasts"
- "Design a mini-project: 7-day forecast analyzer"
- "Craft debugging challenges for weather scripts"

::: {.notes}
**Aim**
This slide aims to demonstrate how AI tutoring tools can generate customised practice questions and projects to reinforce learning of programming concepts like branching and repetition.

**Context**
Following the introduction of branching, loops, and their application in weather-related examples, this slide shows how AI can be leveraged to create targeted practice material. It leads into tips for effective AI use and a course project that ties together the concepts covered.

**"Generate 5 weather-themed 'if-else' questions"**
Ask the AI tutor to create a set of questions that test understanding of if-else statements in a weather context. For example: "Write an if-else statement that prints 'Bring an umbrella' if the weather is 'rainy', otherwise prints 'Leave the umbrella at home'."

**"Create loop exercises using temperature data"**
Request practice problems that involve iterating over temperature data using for or while loops. This could include calculating averages, finding min/max values, or counting days above/below a certain threshold.

**"Provide boolean expression practice with forecasts"**
Seek questions that combine weather forecasts with boolean operators and logical reasoning. For instance: "Write a boolean expression that evaluates to True if the forecast is 'sunny' and the temperature is above 20°C."

**"Design a mini-project: 7-day forecast analyzer"**
Challenge the AI to outline a small project that integrates branching and looping concepts. A 7-day forecast analyzer could involve storing daily weather data in a list or dictionary, then using loops and conditional statements to generate summary statistics or recommendations.

**"Craft debugging challenges for weather scripts"**
Ask for weather-related code snippets that contain intentional bugs or logical errors. Practising debugging reinforces understanding of how branching and repetition structures should work. The AI tutor can provide the broken code and challenge you to identify and fix the issues.
:::

# Tips for Effective GenAI Use

- Be specific in your requests
- Start simple, then increase complexity
- Ask for explanations of generated code
- Use GenAI to review your solutions
- Combine concepts in your practice requests

::: {.notes}
**Aim**
The aim of this slide is to provide practical advice to learners on how to effectively utilise generative AI tools to support their Python learning and problem-solving.

**Context**
This slide builds upon the previous discussion of using generative AI as a Python tutor and learning strategies. It offers concrete tips to help learners maximise the benefits of generative AI in their Python learning journey before introducing the course project.

**Be specific in your requests**
When seeking assistance from a generative AI tool, it's crucial to provide clear and precise instructions. Instead of asking broad, open-ended questions, break down your problem into smaller, well-defined components. Specify the desired output format, any constraints or requirements, and relevant context. This enables the AI to generate more accurate and relevant responses tailored to your needs.

**Start simple, then increase complexity**
When learning a new concept or working on a problem, begin with simple, straightforward requests to the AI. Once you have a solid grasp of the basics, gradually increase the complexity of your queries. This incremental approach allows you to build a strong foundation and prevents overwhelming you with intricate solutions right from the start. As you progress, challenge yourself with more advanced problems and leverage the AI's capabilities to explore different approaches and techniques.

**Ask for explanations of generated code**
When the AI generates code snippets or solutions, don't hesitate to ask for clarifications and explanations. Request the AI to provide comments or a step-by-step breakdown of how the code works. This helps you understand the logic behind the generated code and enhances your learning. By actively engaging with the AI's explanations, you can deepen your comprehension of Python concepts and programming patterns.

**Use GenAI to review your solutions**
After solving a problem or writing code on your own, utilise generative AI to review and provide feedback on your solution. Share your code with the AI and ask for suggestions on how to improve its efficiency, readability, or adherence to best practices. The AI can offer alternative approaches, point out potential issues, and suggest optimisations. This iterative process of coding and seeking feedback strengthens your problem-solving skills and helps you write cleaner, more robust code.

**Combine concepts in your practice requests**
As you progress in your Python learning, challenge yourself by combining multiple concepts in your practice requests to the AI. For example, ask the AI to create a program that involves both branching and repetition, or to design a function that incorporates data structures like dictionaries. By integrating various concepts, you can develop a more comprehensive understanding of how different Python elements work together. This holistic approach prepares you for tackling real-world problems that often require a combination of programming techniques.
:::

# Course Project:  Weather Analysis Tool

- Combine all learned concepts
- Process historical weather data
- Generate weather reports
- Predict future weather patterns
- Create a user-friendly interface

::: {.notes}
**Aim**
The purpose of this slide is to provide an overview of the course project, which is a weather analysis tool that brings together all the concepts learned throughout the course.

**Context**
This slide comes near the end of the presentation, after covering various programming concepts such as branching, loops, functions, and data structures. It ties these concepts together into a practical, real-world application.

**Combine all learned concepts** The weather analysis tool project will integrate all the key programming concepts covered in the course, including branching with if-else statements and Boolean expressions, repetition using for and while loops, reusable code through functions, and data storage and manipulation using dictionaries. By combining these concepts, students will demonstrate their understanding and ability to apply them in a cohesive manner.

**Process historical weather data** One of the main tasks of the weather analysis tool will be to process and analyse historical weather data. Students will learn how to read weather data from files or databases, clean and preprocess the data as needed, and perform statistical analyses to extract meaningful insights about past weather patterns.

**Generate weather reports** Using the processed historical data, the weather analysis tool will generate informative weather reports. These reports may include summary statistics, visualisations such as graphs and charts, and textual descriptions of notable weather events or trends. Students will learn how to present weather data in a clear and concise manner.

**Predict future weather patterns** Building upon the analysis of historical data, students will explore basic machine learning techniques to predict future weather patterns. This may involve training simple models on past data to forecast temperature, precipitation, or other weather variables. Through this component, students will gain an introduction to the fundamental concepts of machine learning and its applications in weather prediction.

**Create a user-friendly interface** To make the weather analysis tool accessible and easy to use, students will design and implement a user-friendly interface. This may involve creating a command-line interface that accepts user input, displays menu options, and presents weather information in a clear and organised fashion. Students will learn how to design intuitive user interactions and handle user input effectively.
:::

# Today

- Mastered branching with if-else
- Explored loops for repetition
- Combined concepts in weather examples
- GenAI: Your 24/7 Python tutor
- Enhance learning with personalised practice
- Progress at your own pace

::: {.notes}
**Aim**
This slide aims to recap the key concepts covered in today's session and highlight the benefits of using GenAI as a personalised Python tutor.

**Context**
The "Today" slide serves as a midpoint review, following the introduction of branching with if-else statements and loops for repetition. It also sets the stage for the upcoming sections on combining these concepts in weather examples and showcasing how GenAI can support learners throughout their Python learning journey.

**Mastered branching with if-else**
In today's session, we explored the concept of branching using if-else statements in Python. Learners discovered how to create conditional logic that allows their programs to make decisions based on specific criteria, enabling them to build more dynamic and responsive applications.

**Explored loops for repetition**
We also delved into the world of loops, which allow learners to automate repetitive tasks in their Python programs. By understanding how to use for and while loops, learners can now create more efficient and concise code, reducing the need for manual repetition.

**Combined concepts in weather examples**
To reinforce the understanding of branching and loops, we applied these concepts to real-world weather examples. Learners had the opportunity to practice using if-else statements and loops in the context of weather condition checkers, weekly forecasts, and weather station simulators, solidifying their knowledge through practical application.

**GenAI: Your 24/7 Python tutor**
GenAI was introduced as a powerful tool that learners can leverage as their personal Python tutor. Available 24/7, GenAI provides instant support and guidance whenever learners need assistance with their Python projects or have questions about specific concepts.

**Enhance learning with personalised practice**
With GenAI, learners can access personalised practice exercises and explanations tailored to their individual needs. By engaging with GenAI, learners can receive targeted feedback and support, helping them to reinforce their understanding of Python concepts and overcome any challenges they may face.

**Progress at your own pace**
One of the key benefits of using GenAI as a Python tutor is the ability to progress at your own pace. Learners can interact with GenAI whenever they have time, allowing them to fit their Python learning journey around their schedules and ensuring a flexible, self-directed learning experience.
:::



---
title: "Asking for Practice Questions"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Demonstrate the use of AI tutoring tools to generate customized practice questions and projects focused on branching and repetition concepts.
- Apply knowledge of if-else statements, loops, and boolean expressions to solve weather-themed coding exercises.
- Identify and correct common errors in code snippets involving branching and looping structures.

**Introduction**

Following the introduction of branching, loops, and their application in weather-related examples, this lesson shows how AI can be leveraged to create targeted practice material. It leads into tips for effective AI use and a course project that ties together the concepts covered.

**"Generate 5 weather-themed 'if-else' questions"**
Ask the AI tutor to create a set of questions that test understanding of if-else statements in a weather context. For example: "Write an if-else statement that prints 'Bring an umbrella' if the weather is 'rainy', otherwise prints 'Leave the umbrella at home'."

**"Create loop exercises using temperature data"**
Request practice problems that involve iterating over temperature data using for or while loops. This could include calculating averages, finding min/max values, or counting days above/below a certain threshold.

**"Provide boolean expression practice with forecasts"**
Seek questions that combine weather forecasts with boolean operators and logical reasoning. For instance: "Write a boolean expression that evaluates to True if the forecast is 'sunny' and the temperature is above 20°C."

**"Design a mini-project: 7-day forecast analyzer"**
Challenge the AI to outline a small project that integrates branching and looping concepts. A 7-day forecast analyzer could involve storing daily weather data in a list or dictionary, then using loops and conditional statements to generate summary statistics or recommendations.

**"Craft debugging challenges for weather scripts"**
Ask for weather-related code snippets that contain intentional bugs or logical errors. Practising debugging reinforces understanding of how branching and repetition structures should work. The AI tutor can provide the broken code and challenge you to identify and fix the issues.

**Key Takeaways**

- AI tutoring tools can create targeted practice questions and projects to reinforce understanding of programming concepts like branching and repetition.
- Weather-related examples provide a relatable context for applying if-else statements, loops, and boolean expressions.
- Practicing with AI-generated exercises, including debugging challenges, helps solidify understanding of how branching and looping structures work.
- Integrating multiple programming concepts into mini-projects, such as a 7-day forecast analyzer, promotes deeper learning and problem-solving skills.

**Quick Quiz**

1. What is the primary benefit of using AI tutoring tools to generate practice questions?
   Answer: AI tutoring tools can create customized practice questions tailored to specific programming concepts and contexts.

2. How can weather-related examples help in learning branching and repetition concepts?
   Answer: Weather-related examples provide a relatable and practical context for applying if-else statements, loops, and boolean expressions.

3. Why is debugging practice important when learning branching and looping structures?
   Answer: Debugging practice reinforces understanding of how branching and looping structures should work and helps identify common errors and logical issues.

**Additional Resources**

- Python If-Else Statements: https://www.w3schools.com/python/python_conditions.asp
- Python For Loops: https://www.w3schools.com/python/python_for_loops.asp
- Python While Loops: https://www.w3schools.com/python/python_while_loops.asp

*Created on: 2024-08-05*


---
title: "Overview"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the concept of branching and how to use if-then-else statements to make decisions in a program.
- Learn about repetition using for and while loops to automate repetitive tasks and process data efficiently.
- Apply branching and repetition concepts to create weather-related examples and gain practical experience.

**Introduction**

This lesson follows on from the "Recall - Six Things" lesson, which likely reviewed previous concepts. The topics introduced in "Overview" will be expanded upon in subsequent lessons, such as "What's Branching?", "If-Then in Python", "What's Repetition?", and "For Loops in Python". The weather-related examples mentioned will be demonstrated in lessons like "Weather Condition Checker" and "Weekly Forecast".

**Learn about branching (if-then-else)**
Branching, also known as conditional statements, allows a program to make decisions based on certain conditions. In this lecture, we will explore the if-then-else structure, which executes a block of code if a specified condition is true and another block of code if the condition is false. Understanding branching is crucial for creating programs that can adapt to different scenarios and inputs.

**Explore repetition (for and while loops)**
Repetition, or looping, is a fundamental concept in programming that allows a block of code to be executed multiple times. We will discuss two types of loops: for loops, which iterate over a sequence of elements, and while loops, which continue to execute as long as a given condition is true. Mastering loops enables you to automate repetitive tasks and process large amounts of data efficiently.

**Combined these concepts in weather-related examples**
To demonstrate the practical applications of branching and repetition, we will work through several weather-related examples. These examples will showcase how conditional statements and loops can be used to create programs that analyse and respond to different weather conditions. By combining these concepts, you will gain a deeper understanding of how to build more complex and interactive weather applications.

**Touch (discussed next lecture) on functions, error handling, and data structures**
In the next lecture, we will introduce the concepts of functions, error handling, and data structures. Functions allow you to organise and reuse code, making your programs more modular and easier to maintain. Error handling helps you anticipate and manage potential issues in your code, improving its reliability. Data structures, such as lists and dictionaries, provide efficient ways to store and manipulate data. These topics will be discussed in more detail in the upcoming lecture.

**Key Takeaways**

- Branching allows programs to make decisions based on certain conditions using if-then-else statements.
- Repetition, or looping, enables the execution of a block of code multiple times using for and while loops.
- Combining branching and repetition can create more complex and interactive weather applications.
- Functions, error handling, and data structures will be introduced in the next lecture to further enhance programming skills.

**Quick Quiz**

1. What is the purpose of branching in programming?
   Answer: Branching allows a program to make decisions based on certain conditions.

2. What are the two types of loops discussed in this lecture?
   Answer: The two types of loops discussed are for loops and while loops.

3. How can branching and repetition be combined in weather-related examples?
   Answer: Branching and repetition can be used together to create programs that analyze and respond to different weather conditions.

**Additional Resources**

- Python If-Else Statement Tutorial: https://www.datacamp.com/tutorial/python-if-else-statement
- Python For Loops Tutorial: https://www.datacamp.com/tutorial/python-for-loop
- Python While Loops Tutorial: https://www.datacamp.com/tutorial/python-while-loop

*Created on: 2024-08-05*


---
title: "Recall - Six Things"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Recall and briefly explain six key concepts from the previous lessons.
- Connect the reviewed concepts to the upcoming topics on branching and repetition in Python programming.

**Introduction**



**Aim**
The purpose of this lesson is to briefly review six key concepts covered earlier in the presentation.

**Context**
This lesson follows the "Overview" lesson, which likely outlines the topics to be covered in the presentation. The "Recall - Six Things" lesson serves as a quick review before diving into the main content, starting with the next lesson on "What's Branching?". The six recalled items are likely foundational concepts for understanding the upcoming topics on branching, repetition, and their applications in Python programming.

**Key Takeaways**

- The lesson serves as a quick review of six foundational concepts before moving on to new topics.
- Understanding these six concepts is crucial for grasping the upcoming lessons on branching and repetition in Python.
- Regularly reviewing and connecting previously learned concepts helps reinforce learning and build a strong foundation.

**Quick Quiz**

1. Why is it important to review key concepts before moving on to new topics?
   Answer: Reviewing key concepts helps reinforce learning, build connections, and create a solid foundation for understanding new material.

2. How does this lesson relate to the upcoming topics on branching and repetition in Python?
   Answer: The six recalled concepts are likely foundational for understanding how branching and repetition work in Python programming.

**Additional Resources**

- The Importance of Review in Learning: https://www.example.com/review-importance
- Building Strong Foundations in Python Programming: https://www.example.com/python-foundations

*Created on: 2024-08-05*


---
title: "Looping Through Dictionaries"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Access values in a dictionary using their corresponding keys
- Iterate through a dictionary's keys and values using a for loop
- Understand the advantages of using dictionaries for structured data

**Introduction**

After learning about branching, repetition, and functions in previous lessons, we now explore dictionaries as a flexible way to store and work with structured data. The next lessons discuss using GenAI to learn Python effectively and apply these concepts in a weather analysis project.

**Access key-value pairs** In Python dictionaries, data is stored as key-value pairs. To access a value, you use its corresponding key inside square brackets. For example, if `weather` is a dictionary, you can access the temperature with `weather["temperature"]`. This allows for quick and direct access to specific data points.

**Iterate through dictionary entries** You can loop through a dictionary using a `for` loop. By default, iterating over a dictionary gives you its keys. To access both keys and values, use the `.items()` method, like `for key, value in weather.items():`. This lets you process all the data in a dictionary efficiently.

**Useful for structured data** Dictionaries are ideal for representing structured data where each piece of information has a unique label or key. For instance, a weather report could have keys like "temperature", "humidity", "wind_speed", etc. This key-value structure keeps the data organised and easy to understand.

**Flexible data representation** Unlike lists which are ordered sequences, dictionaries are unordered and can hold various types of data as values. The values can be of any data type, like numbers, strings, booleans, or even lists and other dictionaries. This flexibility makes dictionaries suitable for complex, hierarchical data structures.

**Example: detailed weather report** A practical example is a detailed weather report stored in a dictionary. It could have keys for different aspects of the weather, like:
```python
weather = {
    "temperature": 25.3,
    "humidity": 0.6,
    "wind_speed": 10,
    "wind_direction": "NE",
    "forecast": ["sunny", "cloudy", "rainy"]
}
```
You can then access and work with this data easily using the keys.

**Key Takeaways**

- Dictionaries store data as key-value pairs, allowing quick access to specific data points
- Iterating over a dictionary by default gives you its keys, but you can use .items() to access both keys and values
- Dictionaries are ideal for representing structured data where each piece of information has a unique label or key
- Unlike lists, dictionaries are unordered and can hold various types of data as values, making them flexible for complex data structures

**Quick Quiz**

1. How do you access a value in a dictionary?
   Answer: By using its corresponding key inside square brackets, e.g., dict['key']

2. What method is used to iterate through both keys and values of a dictionary?
   Answer: The .items() method, used in a for loop like: for key, value in dict.items():

3. True or False: Dictionaries are ordered and can only hold one data type.
   Answer: False. Dictionaries are unordered and can hold various data types as values.

**Additional Resources**

- Python Dictionaries: https://docs.python.org/3/tutorial/datastructures.html#dictionaries
- Dictionaries in Python: https://realpython.com/python-dicts/
- Python Dictionary Methods: https://www.w3schools.com/python/python_dictionaries_methods.asp

*Created on: 2024-08-05*


---
title: "Using GenAI as Your Python Tutor"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand how to leverage GenAI as a personalized Python tutor to enhance learning and problem-solving skills.
- Apply GenAI's capabilities to get explanations, examples, practice questions, debugging assistance, and explore real-world weather applications using Python.

**Introduction**

Following the presentation's sections on Python branching, repetition, and functions in weather applications, this lesson introduces GenAI as a learning tool to support Python skill development. It precedes lessons on effective GenAI learning strategies and the course project of building a weather analysis tool.

**Ask for concept explanations**
When learning Python, you can ask GenAI to explain programming concepts in detail. For example, you could ask it to clarify the difference between for and while loops, or how if-elif-else statements work. GenAI will provide clear explanations to help you understand the concepts better.

**Request code examples** 
GenAI can generate Python code examples on demand. If you're unsure how to write a for loop to iterate through a list, just ask GenAI. It will provide a relevant code snippet with explanations, helping you learn by example.

**Get personalised practice questions**
GenAI can create practice Python questions tailored to your learning needs. Request questions on specific topics like dictionaries or functions, and GenAI will generate unique problems for you to solve. This personalised practice helps reinforce your understanding.

**Debug your code together**
When you encounter bugs in your Python code, GenAI can help you debug. Paste your code and error message, and ask GenAI to identify the issue. It will explain the problem and suggest fixes, helping you learn debugging skills experientially.

**Explore real-world weather applications**
GenAI can help you explore real-world applications of Python in weather data analysis. Ask for examples of how to use Python libraries like Matplotlib to visualise weather patterns or how to fetch weather data from APIs. GenAI will provide code snippets and explanations, bridging the gap between theory and practical application.

**Key Takeaways**

- GenAI can provide detailed explanations of Python programming concepts to clarify understanding.
- Learners can request Python code examples from GenAI to learn by example and understand how to implement specific functionalities.
- GenAI can generate personalized practice questions tailored to the learner's needs, reinforcing their understanding of Python concepts.
- When facing bugs in Python code, GenAI can assist in identifying issues and suggesting fixes, helping learners develop debugging skills.
- GenAI can help explore real-world applications of Python in weather data analysis, bridging the gap between theory and practical application.

**Quick Quiz**

1. What is one way GenAI can help you understand Python programming concepts better?
   Answer: GenAI can provide clear explanations of programming concepts when asked to clarify topics like the difference between for and while loops or how if-elif-else statements work.

2. How can GenAI assist you in debugging your Python code?
   Answer: You can paste your code and error message and ask GenAI to identify the issue. It will explain the problem and suggest fixes, helping you learn debugging skills experientially.

**Additional Resources**

- [Python Documentation](https://docs.python.org/) - Official Python documentation for in-depth understanding of the language.
- [Real Python](https://realpython.com/) - Online platform with tutorials, articles, and guides on various Python topics and real-world applications.
- [Matplotlib Documentation](https://matplotlib.org/stable/contents.html) - Official documentation for Matplotlib, a popular Python library for data visualization.

*Created on: 2024-08-05*


---
title: "Weekly Forecast"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand how to use Python to retrieve weekly weather forecast data from an API
- Learn to process and analyze the retrieved forecast data using Python libraries
- Create a simple Python script to display the weekly weather forecast

**Introduction**

This lesson follows on from the introduction of branching, boolean expressions, and conditional statements in Python. It precedes a deeper exploration of combining branching and repetition to create more complex weather forecasting programs.

**Bullet Point 1**

**Bullet Point 2**

**Bullet Point 3**

**Key Takeaways**

- Python can be used to fetch weather forecast data from various weather APIs
- Libraries such as requests and json are useful for retrieving and processing JSON data from APIs
- Conditional statements and loops can be used to analyze and display the forecast data based on specific criteria
- Presenting the weather forecast data in a clear and concise manner is important for user readability

**Quick Quiz**

1. Which Python library is commonly used to send HTTP requests to APIs?
   Answer: requests

2. What is the purpose of using conditional statements in a weather forecast program?
   Answer: To analyze and display forecast data based on specific criteria

**Additional Resources**

- Python Requests Library Guide: https://realpython.com/python-requests/
- OpenWeatherMap API Documentation: https://openweathermap.org/api
- Python JSON Module: https://docs.python.org/3/library/json.html

*Created on: 2024-08-05*


---
title: "Overview"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the key concepts of branching with if-else statements and loops for repetition in Python.
- Apply the learned concepts to real-world weather examples, demonstrating practical application.
- Recognize the benefits of using GenAI as a personalized Python tutor for enhanced learning and support.

**Introduction**

The "Overview" lesson serves as a midpoint review, following the introduction of branching with if-else statements and loops for repetition. It also sets the stage for the upcoming sections on combining these concepts in weather examples and showcasing how GenAI can support learners throughout their Python learning journey.

**Mastered branching with if-else**
In Overview's session, we explored the concept of branching using if-else statements in Python. Learners discovered how to create conditional logic that allows their programs to make decisions based on specific criteria, enabling them to build more dynamic and responsive applications.

**Explored loops for repetition**
We also delved into the world of loops, which allow learners to automate repetitive tasks in their Python programs. By understanding how to use for and while loops, learners can now create more efficient and concise code, reducing the need for manual repetition.

**Combined concepts in weather examples**
To reinforce the understanding of branching and loops, we applied these concepts to real-world weather examples. Learners had the opportunity to practice using if-else statements and loops in the context of weather condition checkers, weekly forecasts, and weather station simulators, solidifying their knowledge through practical application.

**GenAI: Your 24/7 Python tutor**
GenAI was introduced as a powerful tool that learners can leverage as their personal Python tutor. Available 24/7, GenAI provides instant support and guidance whenever learners need assistance with their Python projects or have questions about specific concepts.

**Enhance learning with personalised practice**
With GenAI, learners can access personalised practice exercises and explanations tailored to their individual needs. By engaging with GenAI, learners can receive targeted feedback and support, helping them to reinforce their understanding of Python concepts and overcome any challenges they may face.

**Progress at your own pace**
One of the key benefits of using GenAI as a Python tutor is the ability to progress at your own pace. Learners can interact with GenAI whenever they have time, allowing them to fit their Python learning journey around their schedules and ensuring a flexible, self-directed learning experience.

**Key Takeaways**

- If-else statements enable conditional logic and decision-making in Python programs.
- Loops (for and while) allow for automation of repetitive tasks, leading to more efficient code.
- Combining branching and loops in weather examples reinforces understanding through practical application.
- GenAI serves as a 24/7 Python tutor, providing instant support and guidance.
- Personalized practice and self-paced learning with GenAI enhance the Python learning journey.

**Quick Quiz**

1. What is the primary purpose of using if-else statements in Python?
   Answer: To create conditional logic that allows programs to make decisions based on specific criteria.

2. How can loops help in writing Python programs?
   Answer: Loops automate repetitive tasks, reducing the need for manual repetition and making code more efficient.

3. What is one key benefit of using GenAI as a Python tutor?
   Answer: GenAI allows learners to progress at their own pace, fitting their Python learning journey around their schedules.

**Additional Resources**

- Python If-Else Statement Tutorial: https://www.geeksforgeeks.org/python-if-else/
- Python Loops Tutorial: https://www.w3schools.com/python/python_for_loops.asp
- Real-world Python Projects for Beginners: https://realpython.com/tutorials/projects/

*Created on: 2024-08-05*


---
title: "GenAI Learning Strategies"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- By the end of this lesson, learners will be able to effectively use GenAI to deepen their understanding of branching and repetition in Python.
- Learners will be able to apply their knowledge of if-else statements and loops to solve weather-related programming challenges with the help of GenAI.
- Learners will understand how to leverage GenAI for debugging, project ideas, and learning guidance related to Python programming in the context of weather data processing and analysis.

**Introduction**

Following the introduction of branching, repetition, and their applications in weather-related programming tasks, this lesson focuses on strategies for utilising GenAI to deepen understanding and acquire practical skills. The subsequent lessons provide tips for effective GenAI use and introduce the course project, tying together the concepts covered throughout the presentation.

**"Explain boolean expressions simply"** Request GenAI to provide a concise, beginner-friendly explanation of boolean expressions, their role in decision-making, and how they are used in if-else statements. This will help solidify your understanding of the fundamental concept that underpins branching in Python.

**"How does 'elif' differ from 'else'?"** Ask GenAI to clarify the difference between 'elif' and 'else' in Python, including when to use each one and how they contribute to creating more complex decision-making structures. This will help you grasp the nuances of branching and write more efficient code.

**"Show weather-related 'while' loop example"** Prompt GenAI to provide a practical example of using a 'while' loop in a weather-related context, such as continuously monitoring temperature until a certain condition is met. This will demonstrate how repetition can be applied to real-world scenarios and help you visualise the concept more clearly.

**"Generate a weather-themed 'if-else' exercise"** Request GenAI to create a practice exercise that combines weather-related conditions with if-else statements, allowing you to apply your knowledge of branching in a relevant context. Engaging in targeted practice will reinforce your understanding and improve your problem-solving skills.

**"Create a loop to process weekly temperatures"** Ask GenAI to guide you through creating a loop that processes a list of weekly temperatures, showcasing how repetition can be used to automate tasks and handle multiple data points efficiently. This will help you gain practical experience in applying loops to real-world weather data.

**"Help debug this weather station code"** Present a snippet of your weather station code that isn't working as expected and ask GenAI to identify the issues and provide suggestions for fixing them. This will help you develop debugging skills and learn how to troubleshoot common problems in your code.

**"How to use Python for weather forecasting?"** Inquire about the essential concepts, libraries, and APIs that are commonly used in Python for weather forecasting. GenAI can provide an overview of the key components and steps involved, helping you understand how to approach weather forecasting projects using Python.

**"Suggest a weather data analysis project"** Request GenAI to propose a small-scale weather data analysis project that allows you to apply the concepts of branching, repetition, and data manipulation using Python. Having a concrete project idea will give you a clear goal to work towards and provide an opportunity to practice your skills in a meaningful context.

**"Explain APIs for retrieving weather data"** Ask GenAI to explain how APIs can be used to retrieve weather data in Python, including popular weather APIs, their usage, and any necessary authentication steps. Understanding how to work with APIs will enable you to access real-time weather data for your projects and analyses.

**"What should I learn after mastering loops?"** Seek guidance on what topics or concepts you should focus on next after gaining proficiency in using loops in Python. GenAI can suggest areas such as functions, data structures, or file handling, depending on your interests and goals related to weather data processing and analysis.

**"Suggest advanced weather-related Python projects"** Request ideas for more complex weather-related projects that incorporate advanced Python concepts, such as data visualisation, machine learning, or building web applications. Having a roadmap of potential projects will keep you motivated and provide opportunities to apply your growing skill set.

**"Create a study plan for Python in meteorology"** Ask GenAI to help you develop a personalised study plan that covers the key Python concepts and skills needed for working with weather data and pursuing meteorology-related projects. A structured learning path will help you stay organised and progress efficiently towards your goals.

**"Let's build a simple weather app together"** Engage GenAI in a step-by-step collaborative process of building a basic weather application that demonstrates the practical application of branching, repetition, and API integration. This hands-on experience will solidify your understanding of the concepts and boost your confidence in developing weather-related tools

**Key Takeaways**

- GenAI can provide beginner-friendly explanations of key concepts like boolean expressions and the differences between 'elif' and 'else'.
- Learners can request practical examples and exercises from GenAI to reinforce their understanding of branching and repetition in weather-related contexts.
- GenAI can assist with debugging code snippets, suggesting weather data analysis projects, and providing guidance on advanced topics and learning paths.
- Collaborating with GenAI to build a simple weather app can help solidify understanding and boost confidence in developing weather-related tools using Python.
- Engaging with GenAI as a personalised tutor can help learners effectively apply Python concepts to real-world weather data processing and analysis tasks.

**Quick Quiz**

1. What is the primary benefit of using GenAI to learn about boolean expressions in Python?
   Answer: GenAI can provide concise, beginner-friendly explanations that help solidify understanding of this fundamental concept.

2. How can GenAI assist learners in applying their knowledge of branching and repetition to weather-related programming tasks?
   Answer: GenAI can generate targeted practice exercises and guide learners through creating loops to process weather data efficiently.

3. In what ways can GenAI support learners in their journey to mastering Python for weather data analysis and forecasting?
   Answer: GenAI can suggest project ideas, provide guidance on advanced topics, and help develop personalised study plans aligned with the learner's goals.

**Additional Resources**

- Python Documentation - Control Flow Tools: https://docs.python.org/3/tutorial/controlflow.html
- Real Python - Python 'while' Loops: https://realpython.com/python-while-loop/
- OpenWeatherMap API Documentation: https://openweathermap.org/api

*Created on: 2024-08-05*


---
title: "Course Project:  Weather Analysis Tool"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Develop a weather analysis tool that integrates key programming concepts such as branching, loops, functions, and data structures.
- Process and analyze historical weather data to generate informative reports and predict future weather patterns.
- Design and implement a user-friendly interface for the weather analysis tool, allowing users to interact with the program easily.

**Introduction**

This lesson comes near the end of the presentation, after covering various programming concepts such as branching, loops, functions, and data structures. It ties these concepts together into a practical, real-world application.

**Combine all learned concepts** The weather analysis tool project will integrate all the key programming concepts covered in the course, including branching with if-else statements and Boolean expressions, repetition using for and while loops, reusable code through functions, and data storage and manipulation using dictionaries. By combining these concepts, students will demonstrate their understanding and ability to apply them in a cohesive manner.

**Process historical weather data** One of the main tasks of the weather analysis tool will be to process and analyse historical weather data. Students will learn how to read weather data from files or databases, clean and preprocess the data as needed, and perform statistical analyses to extract meaningful insights about past weather patterns.

**Generate weather reports** Using the processed historical data, the weather analysis tool will generate informative weather reports. These reports may include summary statistics, visualisations such as graphs and charts, and textual descriptions of notable weather events or trends. Students will learn how to present weather data in a clear and concise manner.

**Predict future weather patterns** Building upon the analysis of historical data, students will explore basic machine learning techniques to predict future weather patterns. This may involve training simple models on past data to forecast temperature, precipitation, or other weather variables. Through this component, students will gain an introduction to the fundamental concepts of machine learning and its applications in weather prediction.

**Create a user-friendly interface** To make the weather analysis tool accessible and easy to use, students will design and implement a user-friendly interface. This may involve creating a command-line interface that accepts user input, displays menu options, and presents weather information in a clear and organised fashion. Students will learn how to design intuitive user interactions and handle user input effectively.

**Key Takeaways**

- The weather analysis tool project combines all the fundamental programming concepts learned throughout the course.
- Processing historical weather data involves reading data from files or databases, cleaning and preprocessing the data, and performing statistical analyses.
- Generating weather reports includes presenting summary statistics, visualizations, and textual descriptions of weather events or trends.
- Basic machine learning techniques can be applied to predict future weather patterns based on historical data.
- Creating a user-friendly interface is crucial for making the weather analysis tool accessible and easy to use.

**Quick Quiz**

1. What are the key programming concepts integrated into the weather analysis tool project?
   Answer: The key programming concepts integrated into the weather analysis tool project are branching with if-else statements and Boolean expressions, repetition using for and while loops, reusable code through functions, and data storage and manipulation using dictionaries.

2. What are the main steps involved in processing historical weather data?
   Answer: The main steps involved in processing historical weather data are reading data from files or databases, cleaning and preprocessing the data as needed, and performing statistical analyses to extract meaningful insights.

3. Why is creating a user-friendly interface important for the weather analysis tool?
   Answer: Creating a user-friendly interface is important for the weather analysis tool because it makes the program accessible and easy to use for users, allowing them to interact with the tool effectively and obtain the desired weather information.

**Additional Resources**

- Python Documentation - Reading and Writing Files: https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files
- Pandas Documentation - Data Structures: https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html
- Scikit-learn Documentation - Machine Learning Basics: https://scikit-learn.org/stable/tutorial/basic/tutorial.html

*Created on: 2024-08-05*


---
title: "Weather Station Simulator"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand how branching and repetition concepts can be combined in a Python program
- Develop a basic Weather Station Simulator program that accepts user input and provides weather information
- Analyze the code structure and logic of the Weather Station Simulator program

**Introduction**

This lesson builds upon the previous lessons on branching and repetition in Python. It demonstrates how these concepts can be combined to create a more complex program that simulates a weather station. The lesson sets the stage for the following lessons, which delve into additional features and enhancements to the Weather Station Simulator.

**Bullet Point 1**

**Bullet Point 2**

**Bullet Point 3**

**Key Takeaways**

- The Weather Station Simulator program demonstrates the practical application of branching and repetition concepts in Python
- User input is utilized to create an interactive experience, allowing users to request weather information for specific locations
- The program structure involves a combination of conditional statements (branching) and loops (repetition) to control the flow of execution
- The Weather Station Simulator serves as a foundation for further enhancements and additions in subsequent lessons

**Quick Quiz**

1. What are the two main programming concepts combined in the Weather Station Simulator?
   Answer: Branching and repetition

2. How does the Weather Station Simulator program handle user input?
   Answer: It prompts the user to enter a location and uses that input to provide weather information

3. What is the purpose of combining branching and repetition in the Weather Station Simulator?
   Answer: To create a more complex and interactive program that can respond to user input and provide relevant information

**Additional Resources**

- Python Documentation - Control Flow Tools: https://docs.python.org/3/tutorial/controlflow.html
- Real Python - Python Conditional Statements: https://realpython.com/python-conditional-statements/
- Python For Beginners - Loops in Python: https://www.pythonforbeginners.com/loops/loops-in-python

*Created on: 2024-08-05*


---
title: "Reusable Weather Logic"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Identify common code patterns in weather data processing
- Extract reusable logic into well-defined functions
- Improve code modularity and maintainability through function usage

**Introduction**



**Aim**
Teach students how to create reusable weather logic by extracting common code into functions, making their programs more modular and maintainable.

**Context**
This lesson follows the "Quick Forecasts" lesson, which introduced the concept of using functions to simplify code. It precedes the "Applying Functions with Loops" lesson, which will demonstrate how to combine functions with loops for more efficient weather data processing.

**Key Takeaways**

- Functions allow you to encapsulate reusable logic and avoid code duplication
- By extracting common weather data processing tasks into functions, your code becomes more modular and easier to maintain
- Well-defined functions with clear inputs and outputs make your code more readable and understandable
- Reusable functions can be shared across multiple weather-related projects, saving time and effort

**Quick Quiz**

1. What is the main benefit of extracting reusable weather logic into functions?
   Answer: It makes the code more modular and maintainable by avoiding code duplication.

2. How can well-defined functions make your code more readable?
   Answer: By providing clear inputs and outputs, making the purpose of the function easier to understand.

**Additional Resources**

- Python Functions: https://www.w3schools.com/python/python_functions.asp
- Best Practices for Writing Reusable Code: https://dev.to/alexomeyer/best-practices-for-writing-reusable-code-2fhh
- Modular Programming in Python: https://realpython.com/modular-programming-python/

*Created on: 2024-08-05*


---
title: "Comparison operators"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the functionality and syntax of the AND, OR, and NOT Boolean operators in Python
- Apply Boolean operators to create logical expressions for conditional statements and loops
- Evaluate the outcome of logical expressions involving multiple Boolean operators

**Introduction**

Boolean operators are a fundamental concept in programming, and understanding them is essential for implementing branching and repetition in Python. This lesson follows the introduction to Boolean expressions and precedes the lessons on logical operators and their practical applications in if-then statements, loops, and the weather condition checker example.

**AND** The AND operator returns True if both operands are True, and False otherwise. It is denoted by the keyword "and" in Python. For example, the expression "x > 0 and x < 10" will evaluate to True only if the value of x is between 0 and 10 (excluding 0 and 10).

**OR** The OR operator returns True if at least one of the operands is True, and False if both operands are False. It is denoted by the keyword "or" in Python. For example, the expression "x < 0 or x > 10" will evaluate to True if the value of x is less than 0 or greater than 10.

**NOT** The NOT operator returns the opposite Boolean value of its operand. It is denoted by the keyword "not" in Python. For example, if x is True, then "not x" will evaluate to False, and if x is False, then "not x" will evaluate to True.

**Key Takeaways**

- The AND operator returns True only if both operands are True, and False otherwise
- The OR operator returns True if at least one of the operands is True, and False if both operands are False
- The NOT operator returns the opposite Boolean value of its operand
- Boolean operators are essential for implementing branching and repetition in Python programs
- Logical expressions involving multiple Boolean operators can be used to create complex conditions

**Quick Quiz**

1. What is the result of the expression 'True and False'?
   Answer: False

2. What is the result of the expression 'not (x < 5 or x > 10)' if x is 7?
   Answer: False

3. Which Boolean operator returns True if at least one of the operands is True?
   Answer: OR

**Additional Resources**

- Python Documentation - Boolean Operations: https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not
- Real Python - Python Boolean Operators: https://realpython.com/python-boolean-operators/
- W3Schools - Python Booleans: https://www.w3schools.com/python/python_booleans.asp

*Created on: 2024-08-05*


---
title: "Tips for Effective GenAI Use"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Learners will be able to construct clear and specific requests to generative AI tools to obtain accurate and relevant assistance for their Python problems.
- Learners will be able to leverage generative AI tools to review and improve their own Python code solutions, focusing on efficiency, readability, and adherence to best practices.

**Introduction**

This lesson builds upon the previous discussion of using generative AI as a Python tutor and learning strategies. It offers concrete tips to help learners maximise the benefits of generative AI in their Python learning journey before introducing the course project.

**Be specific in your requests**
When seeking assistance from a generative AI tool, it's crucial to provide clear and precise instructions. Instead of asking broad, open-ended questions, break down your problem into smaller, well-defined components. Specify the desired output format, any constraints or requirements, and relevant context. This enables the AI to generate more accurate and relevant responses tailored to your needs.

**Start simple, then increase complexity**
When learning a new concept or working on a problem, begin with simple, straightforward requests to the AI. Once you have a solid grasp of the basics, gradually increase the complexity of your queries. This incremental approach allows you to build a strong foundation and prevents overwhelming you with intricate solutions right from the start. As you progress, challenge yourself with more advanced problems and leverage the AI's capabilities to explore different approaches and techniques.

**Ask for explanations of generated code**
When the AI generates code snippets or solutions, don't hesitate to ask for clarifications and explanations. Request the AI to provide comments or a step-by-step breakdown of how the code works. This helps you understand the logic behind the generated code and enhances your learning. By actively engaging with the AI's explanations, you can deepen your comprehension of Python concepts and programming patterns.

**Use GenAI to review your solutions**
After solving a problem or writing code on your own, utilise generative AI to review and provide feedback on your solution. Share your code with the AI and ask for suggestions on how to improve its efficiency, readability, or adherence to best practices. The AI can offer alternative approaches, point out potential issues, and suggest optimisations. This iterative process of coding and seeking feedback strengthens your problem-solving skills and helps you write cleaner, more robust code.

**Combine concepts in your practice requests**
As you progress in your Python learning, challenge yourself by combining multiple concepts in your practice requests to the AI. For example, ask the AI to create a program that involves both branching and repetition, or to design a function that incorporates data structures like dictionaries. By integrating various concepts, you can develop a more comprehensive understanding of how different Python elements work together. This holistic approach prepares you for tackling real-world problems that often require a combination of programming techniques.

**Key Takeaways**

- Provide clear and precise instructions to generative AI tools, breaking down problems into well-defined components for better results.
- Start with simple requests and gradually increase complexity to build a strong foundation and avoid overwhelming yourself.
- Ask the AI for explanations and step-by-step breakdowns of generated code to deepen your understanding of Python concepts.
- Use generative AI to review and provide feedback on your own code solutions, iteratively improving your problem-solving skills.
- Combine multiple Python concepts in your practice requests to develop a comprehensive understanding of how different elements work together.

**Quick Quiz**

1. What is the benefit of providing clear and precise instructions to generative AI tools when seeking assistance for Python problems?
   Answer: Providing clear and precise instructions enables the AI to generate more accurate and relevant responses tailored to your specific needs.

2. How can you use generative AI to improve your own Python code solutions?
   Answer: You can share your code with the AI and ask for suggestions on how to improve its efficiency, readability, or adherence to best practices. The AI can offer alternative approaches, point out potential issues, and suggest optimizations.

**Additional Resources**

- Best Practices for Prompt Engineering with OpenAI API: https://help.openai.com/en/articles/6654000-best-practices-for-prompt-engineering-with-openai-api
- GitHub Copilot - Your AI pair programmer: https://github.com/features/copilot

*Created on: 2024-08-05*


---
title: "If-Then in Python"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the purpose and syntax of the if-then statement in Python
- Be able to write simple if-then statements to make decisions in a Python program
- Recognize the importance of proper indentation in Python code blocks

**Introduction**

Following an introduction to branching and boolean expressions, this lesson focuses on the if-then statement in Python. The next lessons will cover else and elif statements, allowing for more complex decision-making in Python programs.

**Checks a condition** The if-then statement in Python is used to check a specific condition. It evaluates a boolean expression, which can be either True or False. This allows the program to make decisions based on the state of variables or the result of comparisons.

**Executes if condition is True** If the condition in the if statement evaluates to True, the code block following the if statement is executed. This code block can contain one or more statements that are run only when the condition is met. If the condition is False, the code block is skipped.

**Can include multiple statements** The code block following an if statement can include multiple lines of code. All of these statements will be executed if the condition is True. It's important to note that all statements in the block must be indented to the same level.

**Indentation is important** In Python, indentation is used to define code blocks. After an if statement, the code block must be indented (usually by 4 spaces). This indentation tells Python which lines of code belong to the if statement. Incorrect indentation can lead to syntax errors.

**Use for simple decisions** If-then statements are best used for simple decision-making in a program. When there are only two possible outcomes based on a condition (i.e., the condition is either True or False), an if-then statement is a clear and concise way to control the flow of the program.

**Key Takeaways**

- The if-then statement checks a condition and executes a code block if the condition is True
- If the condition is False, the code block following the if statement is skipped
- Code blocks after an if statement can include multiple statements, all indented to the same level
- Proper indentation is crucial in Python to define code blocks
- If-then statements are best used for simple decision-making with two possible outcomes

**Quick Quiz**

1. What happens when the condition in an if statement evaluates to False?
   Answer: The code block following the if statement is skipped

2. How does Python determine which lines of code belong to an if statement?
   Answer: By the indentation of the code block following the if statement

**Additional Resources**

- Python If-Then-Else: https://www.w3schools.com/python/python_conditions.asp
- Python If Statements: https://realpython.com/python-conditional-statements/
- Python Decision Making: https://www.programiz.com/python-programming/if-elif-else

*Created on: 2024-08-05*


---
title: "What's Branching?"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the concept of branching and how it enables decision-making in programs.
- Recognize the if-else statement as the primary means of implementing branching in code.
- Explain how branching determines program flow and allows for responsive program behavior.

**Introduction**

This lesson follows on from the "Recall - Six Things" lesson and precedes lessons on Boolean expressions, operators, and specific examples of branching in Python. It provides a foundation for understanding how programs can respond differently based on input or calculated values.

**Making decisions in code**
Branching is a fundamental concept in programming that allows code to make decisions. Just as we make decisions in our daily lives based on certain conditions, programs can also evaluate conditions and execute different blocks of code depending on whether those conditions are met. This enables programs to respond intelligently and perform different actions in different situations.

**Uses conditional statements (if-else)**
The most common way to implement branching in code is through the use of conditional statements, particularly the if-else statement. An if statement checks whether a condition is true, and if so, executes a certain block of code. If the condition is false, an else block can be used to specify an alternative action. This allows the program to choose between two different paths based on the outcome of the condition.

**Like checking weather forecasts**
Branching can be thought of as similar to checking a weather forecast before deciding what to wear or whether to bring an umbrella. The program checks certain conditions, such as the current temperature or chance of rain, and then chooses an appropriate course of action based on those conditions. This analogy helps to illustrate the decision-making process that branching enables in programs.

**Determines program flow**
Branching is a key factor in determining the flow of a program. When a program reaches a branching point, such as an if statement, it will follow a different path depending on the outcome of the condition. This means that the program's execution can vary based on the input it receives or the values it calculates, leading to different outcomes or outputs.

**Enables responsive program behaviour**
By using branching, programs can be designed to respond intelligently to different situations. For example, a program could use branching to provide personalised recommendations based on user input, or to handle errors gracefully by executing different code when something goes wrong. This flexibility and responsiveness is a crucial aspect of creating programs that are useful and engaging for users.

**Key Takeaways**

- Branching allows programs to make decisions based on certain conditions.
- If-else statements are commonly used to implement branching in code.
- Branching is similar to making decisions in daily life, such as checking weather forecasts.
- Program flow is determined by the outcomes of branching conditions.
- Branching enables programs to respond intelligently to different situations.

**Quick Quiz**

1. What is the primary purpose of branching in programming?
   Answer: To allow programs to make decisions based on certain conditions.

2. Which statement is commonly used to implement branching in code?
   Answer: The if-else statement.

**Additional Resources**

- Branching and Conditional Statements in Python: https://realpython.com/python-conditional-statements/
- Branching and Decision Making in Programming: https://www.geeksforgeeks.org/decision-making-in-c-c-else-nested-else-if/
- Understanding Branching and Conditional Logic in Programming: https://medium.com/@Rahul_Prog/understanding-branching-and-conditional-logic-in-programming-846fbc7b1a3e

*Created on: 2024-08-05*


---
title: "Example"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the functionality of the three main logical operators: AND, OR, and NOT
- Apply logical operators to create complex conditions in branching and repetition structures
- Evaluate the outcome of boolean expressions that include logical operators

**Introduction**

Following the discussion of boolean expressions and common boolean operators, this lesson delves into logical operators. It sets the stage for the subsequent lessons that demonstrate how these operators are used in Python's if-then-else and loop constructs.

**Logical Operators** 
Logical operators allow programmers to combine multiple boolean expressions to create more sophisticated conditions. The three main logical operators are AND, OR, and NOT. The AND operator returns True only if both operands are True. The OR operator returns True if at least one of the operands is True. The NOT operator negates the value of a single operand, returning the opposite boolean value.

**Key Takeaways**

- Logical operators combine multiple boolean expressions to create more sophisticated conditions
- The AND operator returns True only if both operands are True
- The OR operator returns True if at least one of the operands is True
- The NOT operator negates the value of a single operand, returning the opposite boolean value
- Logical operators are essential for creating complex conditions in if-then-else statements and loops

**Quick Quiz**

1. What is the result of the expression 'True AND False'?
   Answer: False

2. What is the result of the expression 'NOT (True OR False)'?
   Answer: False

3. Which logical operator returns True if at least one of the operands is True?
   Answer: OR

**Additional Resources**

- Python Logical Operators: https://www.w3schools.com/python/python_operators.asp
- Logical Operators in Python: https://realpython.com/python-operators-expressions/#logical-operators
- Python Operators: https://www.programiz.com/python-programming/operators

*Created on: 2024-08-05*


---
title: "Breaking the Loop"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the purpose and usage of the `break` statement in Python loops.
- Be able to apply the `break` statement to exit loops prematurely based on specific conditions.
- Recognize situations where using `break` can improve the efficiency and readability of loop-based code.

**Introduction**

This lesson follows on from the previous lessons covering for loops and while loops in Python. It introduces a new concept that allows for more control over loop execution. The following lessons will apply this concept in practical examples like a quick weather forecast program.

**Breaking the Loop** 
In Python, the `break` statement provides a way to exit a loop prematurely. When `break` is encountered inside a loop, the program immediately exits the loop, regardless of the loop condition. This is useful in situations where you want to stop the loop based on a certain condition without waiting for the loop to complete all its iterations.

To use `break`, simply include the `break` statement at the point where you want the loop to exit. Any code after the `break` statement inside the loop will not be executed. Execution will continue with the first statement after the loop.

The `break` statement works with both for loops and while loops in Python. It provides an important control mechanism to prevent unnecessary iterations and to handle special conditions that require loop termination.

In the context of the weather station simulator example, `break` could be used to exit the loop if the user enters a specific input to quit the program. This allows for a graceful exit from the loop and the program.

**Key Takeaways**

- The `break` statement allows for immediate termination of a loop when encountered, regardless of the loop condition.
- Using `break` can prevent unnecessary iterations and improve code efficiency.
- The `break` statement works with both for loops and while loops in Python.
- Code after the `break` statement inside the loop will not be executed, and execution continues with the first statement after the loop.
- Effective use of `break` can enhance code readability and handle special conditions that require loop termination.

**Quick Quiz**

1. What is the purpose of the `break` statement in Python loops?
   Answer: The `break` statement is used to exit a loop prematurely, regardless of the loop condition.

2. True or False: The `break` statement only works with for loops in Python.
   Answer: False. The `break` statement works with both for loops and while loops in Python.

3. What happens to the code after the `break` statement inside a loop?
   Answer: The code after the `break` statement inside the loop will not be executed, and execution continues with the first statement after the loop.

**Additional Resources**

- Python Documentation - The `break` statement: https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops
- Real Python - Python 'while' Loops (Indefinite Iteration): https://realpython.com/python-while-loop/#the-break-and-continue-statements
- GeeksforGeeks - Python break statement: https://www.geeksforgeeks.org/python-break-statement/

*Created on: 2024-08-05*


---
title: "Weather Condition Checker"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand how a weather condition checker performs independent checks on different weather conditions to make precise decisions.
- Learn how to use flexible decision structures, such as if-elif-else statements or nested conditionals, to handle complex weather scenarios.
- Recognize the benefits of modular code design and separate condition evaluations in creating maintainable and adaptable programs.

**Introduction**

The "Weather Condition Checker" lesson follows the introduction to branching and Boolean expressions. It serves as a practical example of applying these concepts before moving on to repetition and more advanced weather-related programs.

**Multiple independent checks** The weather condition checker performs multiple checks on different weather conditions, such as temperature, humidity, wind speed, and precipitation. Each of these checks is independent of the others, allowing the program to evaluate each condition separately. This modular approach makes the code more readable and easier to maintain.

**Each condition evaluated separately** The program evaluates each weather condition individually using separate Boolean expressions. For example, it might check if the temperature is above a certain threshold, if the humidity is within a specific range, or if the wind speed exceeds a given value. By evaluating each condition separately, the program can make more precise decisions based on the specific criteria for each weather aspect.

**Actions not mutually exclusive** The actions taken by the weather condition checker based on the results of the condition checks are not mutually exclusive. This means that multiple actions can be triggered simultaneously if the corresponding conditions are met. For instance, the program might suggest wearing a coat if the temperature is low, while also recommending an umbrella if it's raining. This allows for more comprehensive and tailored recommendations.

**Flexible decision structure** The weather condition checker employs a flexible decision structure, such as if-elif-else statements or nested conditionals, to handle various combinations of weather conditions. This flexibility enables the program to account for a wide range of scenarios and provide appropriate outputs based on the specific conditions encountered. By using a flexible decision structure, the program can adapt to different weather situations and offer relevant advice or actions.

**Useful for complex scenarios** The independent checks, separate condition evaluations, non-mutually exclusive actions, and flexible decision structure make the weather condition checker particularly useful for handling complex weather scenarios. It can take into account multiple factors and their interactions to provide accurate and helpful information to users. This approach allows the program to deal with the intricacies of real-world weather patterns and offer more nuanced and relevant outputs.

**Key Takeaways**

- A weather condition checker performs multiple independent checks on different weather conditions, allowing for modular and maintainable code.
- Each weather condition is evaluated separately using Boolean expressions, enabling precise decision-making based on specific criteria.
- Actions taken by the weather condition checker are not mutually exclusive, allowing for comprehensive and tailored recommendations.
- Flexible decision structures, such as if-elif-else statements or nested conditionals, enable the program to handle various combinations of weather conditions.
- The independent checks, separate condition evaluations, non-mutually exclusive actions, and flexible decision structure make the weather condition checker useful for handling complex weather scenarios.

**Quick Quiz**

1. What is the benefit of performing independent checks on different weather conditions in a weather condition checker?
   Answer: Independent checks allow for modular and maintainable code, making it easier to evaluate each condition separately and provide precise decisions.

2. How do flexible decision structures, such as if-elif-else statements or nested conditionals, help in handling complex weather scenarios?
   Answer: Flexible decision structures enable the program to account for various combinations of weather conditions and provide appropriate outputs based on the specific conditions encountered.

**Additional Resources**

- Python Conditions and If statements: https://www.w3schools.com/python/python_conditions.asp
- Nested if statements in Python: https://www.programiz.com/python-programming/nested-if-statements
- Real Python - Conditional Statements in Python: https://realpython.com/python-conditional-statements/

*Created on: 2024-08-05*


---
title: "Else in Python"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the purpose and functionality of the else statement in Python conditional logic.
- Apply the else statement to provide an alternative action when the if condition is False.
- Create complete decision structures using if-else statements for binary decisions.

**Introduction**

After introducing the concept of branching and if statements, this lesson covers the else statement as the next component in decision structures. It is followed by elif for more complex conditionals and practical examples applying these concepts.

**Provides alternative action** The else statement provides an alternative action to be executed when the condition in the preceding if statement evaluates to False. It allows you to specify a block of code that should run if none of the previous conditions were met.

**Executes when if is False** The code block under the else statement will only execute if the condition in the if statement is False. This ensures that either the if block or the else block will run, but never both for the same condition.

**Completes the decision structure** By including an else statement, you create a complete decision structure that covers all possible cases. This is useful when you need to ensure that some action is always taken, regardless of whether the if condition is True or False.

**Ensures code for all cases** Using an else statement guarantees that you have provided code to handle all possible cases in your conditional logic. This helps prevent gaps in your decision-making process and makes your code more robust.

**Use for binary decisions** The if-else structure is most commonly used for binary decisions, where there are only two possible outcomes. If you need to check for multiple conditions, you can use elif statements in between the if and else to handle additional cases.

**Key Takeaways**

- The else statement provides an alternative action to be executed when the if condition is False.
- The code block under the else statement only runs if the if condition evaluates to False.
- Using an else statement ensures that your decision structure covers all possible cases.
- The if-else structure is most suitable for binary decisions with only two possible outcomes.
- For multiple conditions, use elif statements between the if and else to handle additional cases.

**Quick Quiz**

1. What is the purpose of the else statement in Python?
   Answer: To provide an alternative action when the if condition evaluates to False.

2. When does the code block under the else statement execute?
   Answer: Only when the if condition is False.

3. True or False: The if-else structure is suitable for handling multiple conditions.
   Answer: False. For multiple conditions, you should use elif statements between the if and else.

**Additional Resources**

- Python if...else Statement: https://www.w3schools.com/python/python_conditions.asp
- Conditional Execution in Python: https://realpython.com/python-conditional-statements/
- Python Decision Making: if, else, and elif Statements: https://www.programiz.com/python-programming/if-elif-else

*Created on: 2024-08-05*


---
title: "While Loops in Python"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the basic structure and functionality of while loops in Python
- Learn how to control the flow of while loops using appropriate conditions
- Recognize the potential for infinite loops and how to avoid them

**Introduction**

Having discussed for loops in the previous lesson, this lesson expands on another type of repetition structure in Python: while loops. It is followed by lessons that demonstrate practical applications of while loops, such as in a weekly forecast program and a weather station simulator.

**Repeat while condition is True** While loops in Python continue to execute a block of code as long as a specified condition evaluates to True. The loop body is repeated until the condition becomes False. This allows for dynamic control flow based on changing conditions.

**Useful for unknown iterations** While loops are particularly handy when the number of required iterations is not known in advance. They can keep running until a certain condition is met, making them flexible for scenarios where the loop's end point is determined by external factors or computed values.

**Requires careful condition management** To prevent while loops from running indefinitely, it's crucial to manage the loop condition carefully. The condition should eventually become False, either through changes made within the loop body or by external events. Forgetting to update the condition can lead to infinite loops.

**Can create infinite loops** If the condition in a while loop always remains True, the loop will continue to execute indefinitely, resulting in an infinite loop. This can cause the program to hang or crash. It's important to include appropriate termination conditions and test the loop to ensure it ends as expected.

**Example: continuous weather monitoring** A practical example of using a while loop is in a weather monitoring system. The loop can continuously check the current weather conditions and perform actions based on the readings. It can keep running until a specific condition is met, such as a certain temperature threshold or a user-initiated termination signal.

**Key Takeaways**

- While loops execute a block of code repeatedly as long as a specified condition evaluates to True
- While loops are useful when the number of required iterations is not known in advance
- Careful management of the loop condition is crucial to prevent infinite loops
- While loops can be used in scenarios where continuous monitoring or dynamic control flow is needed

**Quick Quiz**

1. What is the main difference between a while loop and a for loop in Python?
   Answer: While loops execute based on a condition, whereas for loops iterate over a sequence.

2. True or False: A while loop will always execute at least once.
   Answer: False. If the condition is initially False, the loop body will not execute.

3. What can happen if the condition in a while loop always remains True?
   Answer: The loop will run indefinitely, resulting in an infinite loop.

**Additional Resources**

- Python While Loops: https://www.w3schools.com/python/python_while_loops.asp
- Python While Loop: https://www.programiz.com/python-programming/while-loop
- while Loop Examples: https://www.geeksforgeeks.org/python-while-loop/

*Created on: 2024-08-05*


---
title: "Storing Weather Data"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand different data structures in Python suitable for storing weather data, such as lists, tuples, and dictionaries.
- Apply best practices for storing weather data efficiently, including choosing appropriate data types and organizing data in a structured format.
- Perform basic operations on stored weather data, such as accessing, modifying, and analyzing measurements.

**Introduction**

After covering branching, repetition, and functions to create a robust weather application, the next step is to discuss data storage. This lesson leads into the following lesson on looping through dictionaries to access and manipulate stored weather data.

**Bullet Point 1** In Python, weather data can be stored using various data structures such as lists, tuples, and dictionaries. Lists are ordered collections of items that can be modified, while tuples are immutable ordered sequences. Dictionaries, on the other hand, store key-value pairs and provide efficient lookup and retrieval of data based on unique keys.

**Bullet Point 2** When choosing a data structure for weather data, consider the nature of the data and the operations you need to perform. Lists and tuples are suitable for storing ordered sequences of weather measurements, such as temperature readings over time. Dictionaries are ideal when you need to associate specific weather attributes with unique identifiers, such as city names or dates.

**Bullet Point 3** To store weather data efficiently, consider the following best practices:
1. Use meaningful variable and key names to enhance code readability.
2. Ensure data consistency by validating and cleaning input data before storing it.
3. Organize data in a structured format, such as grouping related measurements together.
4. Choose appropriate data types for each weather attribute to optimize memory usage and performance.

**Bullet Point 4** When working with stored weather data, you can perform various operations, such as:
1. Accessing specific weather measurements by index or key.
2. Modifying or updating existing weather data.
3. Filtering and searching for specific weather conditions or patterns.
4. Performing calculations and analysis on the stored data, such as calculating averages or extremes.

**Bullet Point 5** Real-world weather applications often require persistent storage solutions beyond in-memory data structures. You can store weather data in files, databases, or cloud storage services for long-term persistence and scalability. Popular options include CSV files, SQLite databases, or cloud platforms like AWS S3 or Google Cloud Storage.

**Key Takeaways**

- Lists, tuples, and dictionaries are commonly used data structures for storing weather data in Python.
- Choose the appropriate data structure based on the nature of the data and the required operations.
- Follow best practices for storing weather data, such as using meaningful names, ensuring data consistency, and optimizing memory usage.
- Perform operations on stored weather data, including accessing, modifying, filtering, and analyzing measurements.
- Consider persistent storage solutions like files, databases, or cloud storage for long-term data retention and scalability.

**Quick Quiz**

1. Which data structure in Python is most suitable for storing key-value pairs of weather data?
   Answer: 2

2. When storing weather data, which of the following is NOT a best practice?
   Answer: 2

**Additional Resources**

- Python Data Structures: https://docs.python.org/3/tutorial/datastructures.html
- Pandas: Powerful Data Analysis Library: https://pandas.pydata.org/
- SQLite: Lightweight Relational Database: https://www.sqlite.org/

*Created on: 2024-08-05*


---
title: "What's Repetition?"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the concept of repetition in programming and its role in automating tasks
- Identify the two main types of loops in Python: for loops and while loops
- Recognize the benefits of using repetition for processing large amounts of data efficiently

**Introduction**

Having covered branching and conditionals in previous lessons, this lesson introduces repetition as another fundamental programming concept. It sets the stage for the following lessons which will delve into specific loop constructs in Python, such as for loops and while loops.

**Executing code multiple times**
Repetition in programming refers to the ability to execute a block of code multiple times. This is a powerful feature that allows programmers to automate repetitive tasks and process large amounts of data efficiently. Instead of manually writing the same code over and over, repetition constructs enable the code to be executed as many times as needed.

**Uses loops (for, while)**
In Python, repetition is achieved through the use of loops. The two main types of loops are for loops and while loops. For loops are used when the number of iterations is known in advance, such as iterating over a sequence of elements. While loops, on the other hand, are used when the number of iterations is not known and depends on a certain condition being met.

**Like daily weather checks**
A real-world analogy for repetition is performing daily weather checks. Just as we might check the weather forecast every morning to plan our day, a program can use repetition to perform a task or check a condition repeatedly. This could involve retrieving data from a weather API, processing it, and updating a display or sending notifications based on the current weather conditions.

**Automates repetitive tasks**
One of the key benefits of repetition in programming is its ability to automate repetitive tasks. Instead of manually performing the same action over and over, loops allow us to write code once and have it execute multiple times. This saves time, reduces the risk of errors, and makes our code more concise and maintainable.

**Efficient for data processing**
Repetition is particularly useful when it comes to processing large amounts of data. Whether it's iterating over a list of items, reading data from a file, or querying a database, loops enable us to efficiently process and manipulate data. By using repetition constructs, we can perform operations on each element of a dataset without having to write separate code for each individual item.

**Key Takeaways**

- Repetition in programming allows executing a block of code multiple times
- Loops (for and while) are used to achieve repetition in Python
- Repetition automates repetitive tasks, saving time and reducing errors
- Loops are efficient for processing and manipulating large datasets
- Repetition is a fundamental programming concept that enables powerful automation

**Quick Quiz**

1. What is the main benefit of using repetition in programming?
   Answer: b

2. Which type of loop is used when the number of iterations is known in advance?
   Answer: a

**Additional Resources**

- Python Loops Tutorial: https://www.tutorialspoint.com/python/python_loops.htm
- Real Python - For Loops in Python: https://realpython.com/python-for-loop/
- Python While Loops Tutorial with Examples: https://www.programiz.com/python-programming/while-loop

*Created on: 2024-08-05*


---
title: "For Loops in Python"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the purpose and usage of for loops in Python for iterating over sequences and repeating code blocks.
- Utilize the range() function to control the number of loop iterations.
- Recognize situations where for loops are appropriate, such as processing items in a collection or repeating a task a known number of times.

**Introduction**

This lesson follows on from discussing the concept of repetition in programming. It precedes a lesson on while loops, another type of repetition structure in Python.

**Iterate over a sequence** For loops in Python allow you to iterate over a sequence of items, such as a list, tuple, or string. This means the loop will execute once for each item in the sequence, with a loop variable taking on the value of the current item in each iteration. This is useful when you need to process each item in a collection individually.

**Repeat a specific number times** For loops can also be used to repeat a block of code a specific number of times. This is achieved using the range() function, which generates a sequence of numbers. By specifying the range, you can control exactly how many times the loop will execute.

**Useful for known iterations** For loops are particularly useful when you know in advance how many times you need to repeat a block of code. This could be based on the length of a sequence you're iterating over, or a fixed number of repetitions required for a specific task.

**Concise and readable** One advantage of for loops is their concise and readable syntax. The structure of a for loop clearly shows what sequence is being iterated over and what variable is being used for each item. This makes for loops easy to understand and maintain.

**Example: weekly weather forecast** To illustrate the usage of for loops, consider generating a weekly weather forecast. You could use a for loop to iterate over a list of the seven days of the week, executing the code to fetch and display the weather data for each day. This is a clear and efficient way to process the data for a known number of iterations.

**Key Takeaways**

- For loops allow iteration over sequences like lists, tuples, and strings.
- The range() function generates a sequence of numbers to control loop iterations.
- For loops are useful when the number of required iterations is known in advance.
- The concise and readable syntax of for loops makes them easy to understand and maintain.
- For loops are efficient for processing data in scenarios with a known number of iterations.

**Quick Quiz**

1. What is the primary purpose of for loops in Python?
   Answer: To iterate over a sequence of items or repeat a block of code a specific number of times.

2. How can you control the number of times a for loop executes?
   Answer: By using the range() function to generate a sequence of numbers specifying the desired number of iterations.

3. When are for loops particularly useful in Python?
   Answer: When you know in advance how many times you need to repeat a block of code, such as when processing items in a collection or repeating a task a fixed number of times.

**Additional Resources**

- Python For Loops Tutorial: https://www.w3schools.com/python/python_for_loops.asp
- Python range() Function: https://www.programiz.com/python-programming/methods/built-in/range
- Python For Loops Examples and Explanations: https://realpython.com/python-for-loop/

*Created on: 2024-08-05*


---
title: "Robust Weather App"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the importance of error handling in building robust weather applications
- Learn how to anticipate and handle common errors, such as network connectivity issues and invalid user inputs
- Implement graceful error recovery mechanisms to minimize disruptions to the user experience

**Introduction**

In the context of the presentation, this lesson follows the discussion on reusable weather logic and applying functions with loops. It precedes the lessons on storing weather data and looping through dictionaries, suggesting a focus on building reliable and user-friendly weather applications.

**Anticipate and handle errors** Error handling is a crucial aspect of building robust weather applications. By anticipating potential errors, such as network connectivity issues, invalid user inputs, or unexpected API responses, developers can implement appropriate error handling mechanisms. This involves using try-except blocks to catch exceptions, providing informative error messages to users, and gracefully recovering from errors whenever possible.

**Prevents crashes due to exceptions** Unhandled exceptions can lead to application crashes, resulting in a poor user experience and potentially causing data loss. By implementing proper error handling, developers can prevent crashes caused by exceptions. When an exception occurs, the application can catch it, log the error for later analysis, and display a user-friendly error message instead of abruptly terminating.

**Improves user experience** Robust error handling significantly enhances the user experience of weather applications. Instead of encountering cryptic error messages or sudden crashes, users receive clear and informative feedback when something goes wrong. This helps users understand the issue and provides guidance on how to proceed, such as checking their network connection or entering valid input. A smooth and uninterrupted user experience builds trust and encourages continued use of the application.

**Enables graceful error recovery** Graceful error recovery is an essential aspect of robust weather applications. When an error occurs, the application should attempt to recover from it whenever possible. For example, if a network request fails, the application can retry the request after a certain interval or fall back to cached data. Graceful error recovery minimises disruptions to the user experience and ensures that the application remains functional even in the face of errors.

**Essential for reliable applications** Robustness and error handling are essential for building reliable weather applications. Users rely on these applications for accurate and timely weather information, and any failures or crashes can erode user trust and satisfaction. By prioritising robustness and implementing comprehensive error handling, developers can create weather applications that are dependable, stable, and able to handle various exceptional scenarios gracefully.

**Key Takeaways**

- Error handling is crucial for building robust weather applications that provide a smooth user experience
- Unhandled exceptions can lead to application crashes and data loss, emphasizing the need for proper error handling
- Robust error handling improves user experience by providing clear and informative feedback when errors occur
- Graceful error recovery ensures that the application remains functional and minimizes disruptions
- Prioritizing robustness and error handling is essential for building reliable and trustworthy weather applications

**Quick Quiz**

1. Why is error handling important in weather applications?
   Answer: Error handling is important in weather applications to prevent crashes, improve user experience, and ensure reliability

2. What are some common errors that weather applications should anticipate and handle?
   Answer: Common errors include network connectivity issues, invalid user inputs, and unexpected API responses

3. How does graceful error recovery contribute to a better user experience?
   Answer: Graceful error recovery minimizes disruptions to the user experience by attempting to recover from errors whenever possible, such as retrying failed network requests or falling back to cached data

**Additional Resources**

- Python Documentation - Errors and Exceptions: https://docs.python.org/3/tutorial/errors.html
- Real Python - Python Exceptions: An Introduction: https://realpython.com/python-exceptions/
- Medium - Best Practices for Error Handling in Python: https://medium.com/swlh/best-practices-for-error-handling-in-python-b80b50cee8de

*Created on: 2024-08-05*


---
title: "Boolean Expressions"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the concept of boolean expressions and their role in decision making within Python programs.
- Learn how to compare values using operators like ==, !=, <, and > to create boolean expressions.
- Gain knowledge of logical operators (and, or, not) and how they can be used to combine boolean expressions.

**Introduction**

Following an introduction to branching, this lesson delves into boolean expressions as the foundation for conditional statements. It prepares the audience for upcoming lessons that demonstrate the use of if-then, else, and elif statements in Python.

**Evaluate to True or False** Boolean expressions are fundamental constructs in programming that evaluate to either True or False. They form the basis for decision making in code, allowing programs to execute different blocks of code depending on whether a condition is met or not. Boolean expressions are essential for creating logical flow and controlling program behaviour based on specific criteria.

**Compare values (==, !=, <, >)** Boolean expressions often involve comparing values using operators such as equal to (==), not equal to (!=), less than (<), and greater than (>). These operators allow programmers to check if two values are equal, unequal, or if one value is greater or less than another. By comparing values, boolean expressions can determine the relationship between variables or constants and make decisions accordingly.

**Combine with and, or, not** Boolean expressions can be combined using logical operators like and, or, and not. The 'and' operator returns True if both expressions are True, while the 'or' operator returns True if at least one expression is True. The 'not' operator negates a boolean expression, returning the opposite value. These operators enable the creation of more complex conditions by combining multiple boolean expressions.

**Essential for decision making** Boolean expressions are crucial for decision making in programming. They allow programs to evaluate conditions and execute different code blocks based on the results. Decision making is a fundamental aspect of programming, enabling programs to respond to different scenarios, handle user input, and control the flow of execution. Without boolean expressions, programs would be limited to linear execution and lack the ability to adapt to varying conditions.

**Examples: is_raining, temp > 30** The lesson provides two examples of boolean expressions: 'is_raining' and 'temp > 30'. 'is_raining' is a boolean variable that could represent whether it is currently raining or not. 'temp > 30' is a boolean expression that compares the value of the 'temp' variable to the constant value 30, evaluating to True if the temperature is greater than 30 and False otherwise. These examples demonstrate how boolean expressions can represent real-world conditions and make decisions based on them.

**Key Takeaways**

- Boolean expressions evaluate to either True or False and form the basis for decision making in code.
- Comparison operators (==, !=, <, >) allow programmers to check the relationship between values.
- Logical operators (and, or, not) enable the creation of more complex conditions by combining boolean expressions.
- Boolean expressions are essential for controlling program flow and executing different code blocks based on specific criteria.

**Quick Quiz**

1. What are the two possible values that a boolean expression can evaluate to?
   Answer: True or False

2. Which logical operator returns True if both expressions are True?
   Answer: and

3. Given the expression: x > 10 and x < 20, what can you conclude about the value of x when the expression evaluates to True?
   Answer: x is greater than 10 and less than 20

**Additional Resources**

- Python Boolean Expressions: https://realpython.com/python-boolean/
- Logical Operators in Python: https://www.w3schools.com/python/python_operators.asp
- Python Decision Making: https://www.geeksforgeeks.org/decision-making-in-python/

*Created on: 2024-08-05*


---
title: "Quick Forecasts"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the syntax and purpose of list comprehensions in Python
- Apply list comprehensions to create new lists based on existing lists or iterable objects
- Combine looping and conditional logic within list comprehensions to transform and filter data

**Introduction**

After covering branching (if-elif-else) and repetition (for and while loops) in Python, this lesson shows how these concepts can be combined using list comprehensions. It leads into the next lessons on reusable weather logic and applying functions with loops.

**Concise way to create lists** List comprehensions provide a compact syntax for creating lists based on existing lists or other iterable objects. They allow you to generate new lists in a single line of code, making your code more concise and readable.

**Combines loop and conditional logic** List comprehensions integrate the functionality of loops and conditional statements into a single expression. You can iterate over elements, apply transformations, and filter items based on specific conditions, all within the list comprehension itself.

**Readable for simple operations** For straightforward list creation tasks, list comprehensions offer a clear and intuitive way to express the desired operation. They eliminate the need for explicit loop and conditional constructs, making the code more readable and maintainable.

**Powerful for data transformations** List comprehensions shine when it comes to performing data transformations on lists. You can easily apply functions, mathematical operations, or string manipulations to each element of a list, creating a new list with the transformed values.

**Example: weekly temperature categorization** To illustrate the usage of list comprehensions, the lesson presents an example of categorizing weekly temperatures. By applying a list comprehension to a list of temperature values, you can create a new list that categorizes each temperature as "hot", "warm", or "cold" based on specific thresholds.

**Key Takeaways**

- List comprehensions provide a concise and readable way to create lists in a single line of code
- They combine the functionality of loops and conditional statements into a single expression
- List comprehensions are particularly useful for performing data transformations on lists
- They can make your code more readable and maintainable for simple list creation tasks

**Quick Quiz**

1. What is the main advantage of using list comprehensions in Python?
   Answer: List comprehensions allow you to create lists in a concise and readable way, combining loops and conditional logic in a single expression.

2. True or False: List comprehensions can only be used to create lists based on existing lists.
   Answer: False. List comprehensions can create lists based on any iterable object, not just existing lists.

**Additional Resources**

- Python documentation on list comprehensions: https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
- Real Python article on list comprehensions: https://realpython.com/list-comprehension-python/
- GeeksforGeeks tutorial on list comprehensions: https://www.geeksforgeeks.org/python-list-comprehension/

*Created on: 2024-08-05*


---
title: "Applying Functions with Loops"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand how to use functions within loops to modularize code
- Apply the concept of combining functions and loops to solve specific problems
- Recognize situations where using functions in loops can make code more efficient and maintainable

**Introduction**

This lesson builds upon the previous topics of loops and functions, showing how they can be combined effectively. It sets the stage for the next lesson on creating a robust weather app by applying these concepts.

**Detailed Presenter Notes**

**Key Takeaways**

- Functions can be called within loops to execute repetitive tasks with different parameters
- Combining functions and loops allows for more modular, reusable, and maintainable code
- By encapsulating specific functionality within functions, the main loop becomes more readable and easier to understand
- Using functions in loops can help avoid code duplication and make the program more efficient

**Quick Quiz**

1. What is the main benefit of using functions within loops?
   Answer: It allows for more modular, reusable, and maintainable code

2. How can using functions in loops make the main program more readable?
   Answer: By encapsulating specific functionality within functions, the main loop becomes more concise and easier to understand

**Additional Resources**

- Python Functions: https://www.w3schools.com/python/python_functions.asp
- Python Loops: https://www.learnpython.org/en/Loops
- Modular Programming in Python: https://realpython.com/modular-programming-python/

*Created on: 2024-08-05*


---
title: "Combining Branching and Repetition"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand how to combine if-elif-else statements with for and while loops
- Recognize situations where combining branching and repetition is useful
- Be able to write Python programs that use both branching and repetition together

**Introduction**



**Aim**
This lesson aims to show how branching and repetition can be combined in Python programs to create more powerful and flexible logic.

**Context**
Having covered branching with if-elif-else statements and repetition with for and while loops separately, this lesson demonstrates how these concepts can be used together. It leads into a practical example in the next lesson, "Weather Station Simulator".

**Key Takeaways**

- Branching and repetition can be nested inside each other to create more complex logic
- Loops can contain conditional statements to control the flow of the loop
- Conditional statements can contain loops to repeat code based on certain conditions
- Combining branching and repetition allows for more powerful and flexible programming
- Real-world applications often require a combination of branching and repetition

**Quick Quiz**

1. What is the main benefit of combining branching and repetition in a program?
   Answer: It allows for more powerful and flexible programming logic

2. Can loops contain conditional statements?
   Answer: Yes, loops can contain if-elif-else statements to control the flow of the loop

3. Can conditional statements contain loops?
   Answer: Yes, conditional statements can contain loops to repeat code based on certain conditions

**Additional Resources**

- Python Conditions and If statements: https://www.w3schools.com/python/python_conditions.asp
- Python For Loops: https://www.w3schools.com/python/python_for_loops.asp
- Python While Loops: https://www.w3schools.com/python/python_while_loops.asp

*Created on: 2024-08-05*


---
title: "Elif in Python"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the purpose and syntax of the elif statement in Python
- Learn how to create complex branching structures using if, elif, and else statements
- Recognize when to use elif statements to handle multiple conditions

**Introduction**

The elif statement builds upon the concepts of boolean expressions, if-then statements, and else statements covered in previous lessons. It allows for more sophisticated decision-making in Python programs and sets the stage for the weather condition checker example in the following lesson.

**[Bullet Point 1]** The elif keyword in Python is short for "else if" and is used in conjunction with if and else statements to create more complex branching structures. It allows you to specify additional conditions to check if the preceding if statement's condition is false. You can include multiple elif statements to handle different cases or scenarios.

**[Bullet Point 2]** The syntax for using elif is similar to if statements. After an initial if statement, you can add one or more elif statements, each followed by a condition and a colon. The code block under each elif statement is executed if its condition evaluates to True. You can optionally include an else statement at the end to handle the case when none of the conditions are met.

**[Bullet Point 3]** When Python encounters an if-elif-else structure, it evaluates the conditions in order from top to bottom. If the if statement's condition is True, its code block is executed, and the rest of the elif and else blocks are skipped. If the if condition is False, Python moves on to the first elif condition. If that condition is True, its code block is executed, and the remaining elif and else blocks are skipped. This process continues until a condition is met or until the else block is reached.

**[Bullet Point 4]** Elif statements are useful when you need to check multiple conditions and execute different code blocks based on those conditions. They provide a way to handle various scenarios or cases in your program logic. By using elif, you can create more precise control flow and make your code more readable and manageable.

**Key Takeaways**

- The elif keyword is used in combination with if and else to create complex branching structures
- Elif allows you to specify additional conditions to check if the preceding if statement's condition is false
- Python evaluates the conditions in an if-elif-else structure from top to bottom, executing the first code block whose condition is True
- Elif statements make code more readable and manageable when handling multiple conditions and scenarios

**Quick Quiz**

1. What is the purpose of the elif statement in Python?
   Answer: To specify additional conditions to check if the preceding if statement's condition is false

2. How does Python evaluate the conditions in an if-elif-else structure?
   Answer: Python evaluates the conditions from top to bottom, executing the first code block whose condition is True

**Additional Resources**

- Python if, elif, else Statements: https://www.programiz.com/python-programming/if-elif-else
- Python if...elif...else Statement: https://www.tutorialspoint.com/python/python_if_else.htm
- Python if, else, and elif Statements: https://realpython.com/python-conditional-statements/

*Created on: 2024-08-05*


---
title: "Weather Adventures in Python Land: Staff Answers"
subtitle: "Python Essentials"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


## Part 1: Basic Concepts in Pseudocode

1. Suggest clothing based on temperature:
```
Input temperature
If temperature > 25°C then
    Suggest light clothing
Else if temperature >= 15°C and temperature <= 25°C then
    Suggest a light jacket
Else
    Suggest warm clothing
```

2. Check if it's a good day for a picnic:
```
Input temperature
Input is_raining
If not is_raining AND temperature >= 20°C AND temperature <= 30°C then
    Print "It's a good day for a picnic!"
Else
    Print "Not an ideal day for a picnic."
```

3. Count rainy days in a week:
```
Set rainy_days = 0
For each day in week (7 times):
    Input weather_condition
    If weather_condition is "rainy" then
        Increment rainy_days by 1
Print rainy_days
```

4. Calculate average temperature for 5 days:
```
Set total_temperature = 0
For i = 1 to 5:
    Input daily_temperature
    Add daily_temperature to total_temperature
Set average_temperature = total_temperature / 5
Print average_temperature
```

5. Issue heat wave warning:
```
Set consecutive_hot_days = 0
For each day in forecast:
    Input temperature
    If temperature > 35°C then
        Increment consecutive_hot_days by 1
        If consecutive_hot_days >= 3 then
            Issue heat wave warning
            Exit loop
    Else
        Set consecutive_hot_days = 0
```

## Part 2: Structuring English Descriptions into Pseudocode

6. Air Quality Monitoring:
```
Set readings_count = 0
Set alert_triggered = False

While readings_count < 24 AND not alert_triggered:
    Measure AQI
    Increment readings_count by 1
    If AQI > 150 then
        Trigger alert
        Set alert_triggered = True
    Wait for 1 hour
```

7. Weather Forecasting Process:
```
For day = 1 to 7:
    Input today's temperature, humidity, wind_speed
    Input yesterday's temperature, humidity

    If today's temperature > yesterday's temperature AND today's humidity > yesterday's humidity then
        If wind_speed is increasing then
            Predict stormy weather
        Else
            Predict higher chance of rain
    Else if today's temperature ≈ yesterday's temperature AND today's humidity ≈ yesterday's humidity then
        Predict similar weather to today
    Else
        Predict based on other factors (not specified in the given process)

    Set yesterday's temperature = today's temperature
    Set yesterday's humidity = today's humidity
```

8. Severe Weather Alert System:
```
While True:
    Input temperature, wind_speed, precipitation
    
    Set alert_level = "None"
    
    If temperature > 40°C OR wind_speed > 100 km/h OR precipitation > 50 mm/hour then
        Set alert_level = "Red Alert"
    Else if temperature > 35°C AND wind_speed > 60 km/h AND precipitation > 30 mm/hour then
        Set alert_level = "Orange Alert"
    Else if (temperature > 35°C AND wind_speed > 60 km/h) OR
            (temperature > 35°C AND precipitation > 30 mm/hour) OR
            (wind_speed > 60 km/h AND precipitation > 30 mm/hour) then
        Set alert_level = "Yellow Alert"
    
    If alert_level != "None" then
        Issue alert_level
    
    Wait for 30 minutes
```

## Part 3: Reflection and Analysis

9. Challenging aspects of structuring pseudocode:
   - The weather forecasting process (Question 7) was challenging due to the need to compare current and previous day's data, requiring careful consideration of variable updates and logical flow.
   - The severe weather alert system (Question 8) was complex due to multiple nested conditions and the need to check for different combinations of factors.

10. Three questions for a GenAI tutor to refine the severe weather alert system pseudocode:
   a. How can I optimize the condition checks to make the code more efficient?
   b. What's the best way to implement the "maintains the highest level alert until conditions improve" requirement?
   c. How can I modify the pseudocode to allow for easy addition of new alert conditions in the future?

11. Extending the air quality monitoring pseudocode:
   To extend the air quality monitoring system, we could:
   - Add multiple pollutant measurements (e.g., PM2.5, ozone, nitrogen dioxide)
   - Implement different alert levels based on AQI ranges
   - Include a rolling average calculation for more stable readings
   - Add wind direction and speed to predict pollution spread
   - Implement a data logging system for historical analysis

This extended version might look like:

```
Initialize pollutants_list = [PM2.5, ozone, nitrogen_dioxide]
Initialize readings = empty dictionary
Initialize alert_levels = {
    "Green": 0-50,
    "Yellow": 51-100,
    "Orange": 101-150,
    "Red": 151-200,
    "Purple": 201+
}

While True:
    For each pollutant in pollutants_list:
        Measure pollutant level
        Add to readings[pollutant]
        If readings[pollutant] has 24 entries:
            Calculate 24-hour average
            Remove oldest reading
    
    Calculate overall AQI based on pollutant readings
    
    Determine alert_level based on AQI and alert_levels
    
    If alert_level changed:
        Issue new alert
    
    Measure wind_direction and wind_speed
    Predict pollution spread based on wind data
    
    Log all data to database
    
    Wait for 1 hour
```

This extended version provides a more comprehensive air quality monitoring system with multiple pollutants, rolling averages, multi-level alerts, and additional features like wind-based predictions and data logging.


---
title: "Overview"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to provide an overview of the key topics that will be covered in Overview's lecture on branching, repetition, and their applications in weather-related examples.

**Context**
This lesson follows on from the "Recall - Six Things" lesson, which likely reviewed previous concepts. The topics introduced in "Overview" will be expanded upon in subsequent lessons, such as "What's Branching?", "If-Then in Python", "What's Repetition?", and "For Loops in Python". The weather-related examples mentioned will be demonstrated in lessons like "Weather Condition Checker" and "Weekly Forecast".

**Learn about branching (if-then-else)**
Branching, also known as conditional statements, allows a program to make decisions based on certain conditions. In this lecture, we will explore the if-then-else structure, which executes a block of code if a specified condition is true and another block of code if the condition is false. Understanding branching is crucial for creating programs that can adapt to different scenarios and inputs.

**Explore repetition (for and while loops)**
Repetition, or looping, is a fundamental concept in programming that allows a block of code to be executed multiple times. We will discuss two types of loops: for loops, which iterate over a sequence of elements, and while loops, which continue to execute as long as a given condition is true. Mastering loops enables you to automate repetitive tasks and process large amounts of data efficiently.

**Combined these concepts in weather-related examples**
To demonstrate the practical applications of branching and repetition, we will work through several weather-related examples. These examples will showcase how conditional statements and loops can be used to create programs that analyse and respond to different weather conditions. By combining these concepts, you will gain a deeper understanding of how to build more complex and interactive weather applications.

**Touch (discussed next lecture) on functions, error handling, and data structures**
In the next lecture, we will introduce the concepts of functions, error handling, and data structures. Functions allow you to organise and reuse code, making your programs more modular and easier to maintain. Error handling helps you anticipate and manage potential issues in your code, improving its reliability. Data structures, such as lists and dictionaries, provide efficient ways to store and manipulate data. These topics will be discussed in more detail in the upcoming lecture.

---
title: "Combining Branching and Repetition"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to show how branching and repetition can be combined in Python programs to create more powerful and flexible logic.

**Context**
Having covered branching with if-elif-else statements and repetition with for and while loops separately, this lesson demonstrates how these concepts can be used together. It leads into a practical example in the next lesson, "Weather Station Simulator".

---
title: "Quick Forecasts"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson introduces list comprehensions as a concise and efficient way to create lists in Python, combining looping and conditional logic.

**Context**
After covering branching (if-elif-else) and repetition (for and while loops) in Python, this lesson shows how these concepts can be combined using list comprehensions. It leads into the next lessons on reusable weather logic and applying functions with loops.

**Concise way to create lists** List comprehensions provide a compact syntax for creating lists based on existing lists or other iterable objects. They allow you to generate new lists in a single line of code, making your code more concise and readable.

**Combines loop and conditional logic** List comprehensions integrate the functionality of loops and conditional statements into a single expression. You can iterate over elements, apply transformations, and filter items based on specific conditions, all within the list comprehension itself.

**Readable for simple operations** For straightforward list creation tasks, list comprehensions offer a clear and intuitive way to express the desired operation. They eliminate the need for explicit loop and conditional constructs, making the code more readable and maintainable.

**Powerful for data transformations** List comprehensions shine when it comes to performing data transformations on lists. You can easily apply functions, mathematical operations, or string manipulations to each element of a list, creating a new list with the transformed values.

**Example: weekly temperature categorization** To illustrate the usage of list comprehensions, the lesson presents an example of categorizing weekly temperatures. By applying a list comprehension to a list of temperature values, you can create a new list that categorizes each temperature as "hot", "warm", or "cold" based on specific thresholds.

---
title: "Weather Station Simulator"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to introduce students to a Weather Station Simulator program that combines branching and repetition concepts.

**Context**
This lesson builds upon the previous lessons on branching and repetition in Python. It demonstrates how these concepts can be combined to create a more complex program that simulates a weather station. The lesson sets the stage for the following lessons, which delve into additional features and enhancements to the Weather Station Simulator.

**Bullet Point 1**

**Bullet Point 2**

**Bullet Point 3**

---
title: "If-Then in Python"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
To introduce the if-then statement in Python and explain its purpose and syntax.

**Context**
Following an introduction to branching and boolean expressions, this lesson focuses on the if-then statement in Python. The next lessons will cover else and elif statements, allowing for more complex decision-making in Python programs.

**Checks a condition** The if-then statement in Python is used to check a specific condition. It evaluates a boolean expression, which can be either True or False. This allows the program to make decisions based on the state of variables or the result of comparisons.

**Executes if condition is True** If the condition in the if statement evaluates to True, the code block following the if statement is executed. This code block can contain one or more statements that are run only when the condition is met. If the condition is False, the code block is skipped.

**Can include multiple statements** The code block following an if statement can include multiple lines of code. All of these statements will be executed if the condition is True. It's important to note that all statements in the block must be indented to the same level.

**Indentation is important** In Python, indentation is used to define code blocks. After an if statement, the code block must be indented (usually by 4 spaces). This indentation tells Python which lines of code belong to the if statement. Incorrect indentation can lead to syntax errors.

**Use for simple decisions** If-then statements are best used for simple decision-making in a program. When there are only two possible outcomes based on a condition (i.e., the condition is either True or False), an if-then statement is a clear and concise way to control the flow of the program.

---
title: "Storing Weather Data"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to introduce the concept of storing weather data and explore different data structures for organising weather information.

**Context**
After covering branching, repetition, and functions to create a robust weather application, the next step is to discuss data storage. This lesson leads into the following lesson on looping through dictionaries to access and manipulate stored weather data.

**Bullet Point 1** In Python, weather data can be stored using various data structures such as lists, tuples, and dictionaries. Lists are ordered collections of items that can be modified, while tuples are immutable ordered sequences. Dictionaries, on the other hand, store key-value pairs and provide efficient lookup and retrieval of data based on unique keys.

**Bullet Point 2** When choosing a data structure for weather data, consider the nature of the data and the operations you need to perform. Lists and tuples are suitable for storing ordered sequences of weather measurements, such as temperature readings over time. Dictionaries are ideal when you need to associate specific weather attributes with unique identifiers, such as city names or dates.

**Bullet Point 3** To store weather data efficiently, consider the following best practices:
1. Use meaningful variable and key names to enhance code readability.
2. Ensure data consistency by validating and cleaning input data before storing it.
3. Organize data in a structured format, such as grouping related measurements together.
4. Choose appropriate data types for each weather attribute to optimize memory usage and performance.

**Bullet Point 4** When working with stored weather data, you can perform various operations, such as:
1. Accessing specific weather measurements by index or key.
2. Modifying or updating existing weather data.
3. Filtering and searching for specific weather conditions or patterns.
4. Performing calculations and analysis on the stored data, such as calculating averages or extremes.

**Bullet Point 5** Real-world weather applications often require persistent storage solutions beyond in-memory data structures. You can store weather data in files, databases, or cloud storage services for long-term persistence and scalability. Popular options include CSV files, SQLite databases, or cloud platforms like AWS S3 or Google Cloud Storage.

---
title: "GenAI Learning Strategies"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to showcase how learners can effectively leverage GenAI as a personalised Python tutor to reinforce key programming concepts and tackle weather-related coding challenges.

**Context**
Following the introduction of branching, repetition, and their applications in weather-related programming tasks, this lesson focuses on strategies for utilising GenAI to deepen understanding and acquire practical skills. The subsequent lessons provide tips for effective GenAI use and introduce the course project, tying together the concepts covered throughout the presentation.

**"Explain boolean expressions simply"** Request GenAI to provide a concise, beginner-friendly explanation of boolean expressions, their role in decision-making, and how they are used in if-else statements. This will help solidify your understanding of the fundamental concept that underpins branching in Python.

**"How does 'elif' differ from 'else'?"** Ask GenAI to clarify the difference between 'elif' and 'else' in Python, including when to use each one and how they contribute to creating more complex decision-making structures. This will help you grasp the nuances of branching and write more efficient code.

**"Show weather-related 'while' loop example"** Prompt GenAI to provide a practical example of using a 'while' loop in a weather-related context, such as continuously monitoring temperature until a certain condition is met. This will demonstrate how repetition can be applied to real-world scenarios and help you visualise the concept more clearly.

**"Generate a weather-themed 'if-else' exercise"** Request GenAI to create a practice exercise that combines weather-related conditions with if-else statements, allowing you to apply your knowledge of branching in a relevant context. Engaging in targeted practice will reinforce your understanding and improve your problem-solving skills.

**"Create a loop to process weekly temperatures"** Ask GenAI to guide you through creating a loop that processes a list of weekly temperatures, showcasing how repetition can be used to automate tasks and handle multiple data points efficiently. This will help you gain practical experience in applying loops to real-world weather data.

**"Help debug this weather station code"** Present a snippet of your weather station code that isn't working as expected and ask GenAI to identify the issues and provide suggestions for fixing them. This will help you develop debugging skills and learn how to troubleshoot common problems in your code.

**"How to use Python for weather forecasting?"** Inquire about the essential concepts, libraries, and APIs that are commonly used in Python for weather forecasting. GenAI can provide an overview of the key components and steps involved, helping you understand how to approach weather forecasting projects using Python.

**"Suggest a weather data analysis project"** Request GenAI to propose a small-scale weather data analysis project that allows you to apply the concepts of branching, repetition, and data manipulation using Python. Having a concrete project idea will give you a clear goal to work towards and provide an opportunity to practice your skills in a meaningful context.

**"Explain APIs for retrieving weather data"** Ask GenAI to explain how APIs can be used to retrieve weather data in Python, including popular weather APIs, their usage, and any necessary authentication steps. Understanding how to work with APIs will enable you to access real-time weather data for your projects and analyses.

**"What should I learn after mastering loops?"** Seek guidance on what topics or concepts you should focus on next after gaining proficiency in using loops in Python. GenAI can suggest areas such as functions, data structures, or file handling, depending on your interests and goals related to weather data processing and analysis.

**"Suggest advanced weather-related Python projects"** Request ideas for more complex weather-related projects that incorporate advanced Python concepts, such as data visualisation, machine learning, or building web applications. Having a roadmap of potential projects will keep you motivated and provide opportunities to apply your growing skill set.

**"Create a study plan for Python in meteorology"** Ask GenAI to help you develop a personalised study plan that covers the key Python concepts and skills needed for working with weather data and pursuing meteorology-related projects. A structured learning path will help you stay organised and progress efficiently towards your goals.

**"Let's build a simple weather app together"** Engage GenAI in a step-by-step collaborative process of building a basic weather application that demonstrates the practical application of branching, repetition, and API integration. This hands-on experience will solidify your understanding of the concepts and boost your confidence in developing weather-related tools

---
title: "Course Project:  Weather Analysis Tool"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The purpose of this lesson is to provide an overview of the course project, which is a weather analysis tool that brings together all the concepts learned throughout the course.

**Context**
This lesson comes near the end of the presentation, after covering various programming concepts such as branching, loops, functions, and data structures. It ties these concepts together into a practical, real-world application.

**Combine all learned concepts** The weather analysis tool project will integrate all the key programming concepts covered in the course, including branching with if-else statements and Boolean expressions, repetition using for and while loops, reusable code through functions, and data storage and manipulation using dictionaries. By combining these concepts, students will demonstrate their understanding and ability to apply them in a cohesive manner.

**Process historical weather data** One of the main tasks of the weather analysis tool will be to process and analyse historical weather data. Students will learn how to read weather data from files or databases, clean and preprocess the data as needed, and perform statistical analyses to extract meaningful insights about past weather patterns.

**Generate weather reports** Using the processed historical data, the weather analysis tool will generate informative weather reports. These reports may include summary statistics, visualisations such as graphs and charts, and textual descriptions of notable weather events or trends. Students will learn how to present weather data in a clear and concise manner.

**Predict future weather patterns** Building upon the analysis of historical data, students will explore basic machine learning techniques to predict future weather patterns. This may involve training simple models on past data to forecast temperature, precipitation, or other weather variables. Through this component, students will gain an introduction to the fundamental concepts of machine learning and its applications in weather prediction.

**Create a user-friendly interface** To make the weather analysis tool accessible and easy to use, students will design and implement a user-friendly interface. This may involve creating a command-line interface that accepts user input, displays menu options, and presents weather information in a clear and organised fashion. Students will learn how to design intuitive user interactions and handle user input effectively.

---
title: "Boolean Expressions"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to introduce boolean expressions and their role in decision making within Python programs.

**Context**
Following an introduction to branching, this lesson delves into boolean expressions as the foundation for conditional statements. It prepares the audience for upcoming lessons that demonstrate the use of if-then, else, and elif statements in Python.

**Evaluate to True or False** Boolean expressions are fundamental constructs in programming that evaluate to either True or False. They form the basis for decision making in code, allowing programs to execute different blocks of code depending on whether a condition is met or not. Boolean expressions are essential for creating logical flow and controlling program behaviour based on specific criteria.

**Compare values (==, !=, <, >)** Boolean expressions often involve comparing values using operators such as equal to (==), not equal to (!=), less than (<), and greater than (>). These operators allow programmers to check if two values are equal, unequal, or if one value is greater or less than another. By comparing values, boolean expressions can determine the relationship between variables or constants and make decisions accordingly.

**Combine with and, or, not** Boolean expressions can be combined using logical operators like and, or, and not. The 'and' operator returns True if both expressions are True, while the 'or' operator returns True if at least one expression is True. The 'not' operator negates a boolean expression, returning the opposite value. These operators enable the creation of more complex conditions by combining multiple boolean expressions.

**Essential for decision making** Boolean expressions are crucial for decision making in programming. They allow programs to evaluate conditions and execute different code blocks based on the results. Decision making is a fundamental aspect of programming, enabling programs to respond to different scenarios, handle user input, and control the flow of execution. Without boolean expressions, programs would be limited to linear execution and lack the ability to adapt to varying conditions.

**Examples: is_raining, temp > 30** The lesson provides two examples of boolean expressions: 'is_raining' and 'temp > 30'. 'is_raining' is a boolean variable that could represent whether it is currently raining or not. 'temp > 30' is a boolean expression that compares the value of the 'temp' variable to the constant value 30, evaluating to True if the temperature is greater than 30 and False otherwise. These examples demonstrate how boolean expressions can represent real-world conditions and make decisions based on them.

---
title: "Reusable Weather Logic"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
Teach students how to create reusable weather logic by extracting common code into functions, making their programs more modular and maintainable.

**Context**
This lesson follows the "Quick Forecasts" lesson, which introduced the concept of using functions to simplify code. It precedes the "Applying Functions with Loops" lesson, which will demonstrate how to combine functions with loops for more efficient weather data processing.

---
title: "Applying Functions with Loops"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The purpose of this lesson is to demonstrate how functions can be used in combination with loops to create more modular and reusable code.

**Context**
This lesson builds upon the previous topics of loops and functions, showing how they can be combined effectively. It sets the stage for the next lesson on creating a robust weather app by applying these concepts.

**Detailed Presenter Notes**

---
title: "Robust Weather App"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to highlight the importance of error handling and robustness in weather applications to ensure a smooth user experience and prevent application crashes.

**Context**
In the context of the presentation, this lesson follows the discussion on reusable weather logic and applying functions with loops. It precedes the lessons on storing weather data and looping through dictionaries, suggesting a focus on building reliable and user-friendly weather applications.

**Anticipate and handle errors** Error handling is a crucial aspect of building robust weather applications. By anticipating potential errors, such as network connectivity issues, invalid user inputs, or unexpected API responses, developers can implement appropriate error handling mechanisms. This involves using try-except blocks to catch exceptions, providing informative error messages to users, and gracefully recovering from errors whenever possible.

**Prevents crashes due to exceptions** Unhandled exceptions can lead to application crashes, resulting in a poor user experience and potentially causing data loss. By implementing proper error handling, developers can prevent crashes caused by exceptions. When an exception occurs, the application can catch it, log the error for later analysis, and display a user-friendly error message instead of abruptly terminating.

**Improves user experience** Robust error handling significantly enhances the user experience of weather applications. Instead of encountering cryptic error messages or sudden crashes, users receive clear and informative feedback when something goes wrong. This helps users understand the issue and provides guidance on how to proceed, such as checking their network connection or entering valid input. A smooth and uninterrupted user experience builds trust and encourages continued use of the application.

**Enables graceful error recovery** Graceful error recovery is an essential aspect of robust weather applications. When an error occurs, the application should attempt to recover from it whenever possible. For example, if a network request fails, the application can retry the request after a certain interval or fall back to cached data. Graceful error recovery minimises disruptions to the user experience and ensures that the application remains functional even in the face of errors.

**Essential for reliable applications** Robustness and error handling are essential for building reliable weather applications. Users rely on these applications for accurate and timely weather information, and any failures or crashes can erode user trust and satisfaction. By prioritising robustness and implementing comprehensive error handling, developers can create weather applications that are dependable, stable, and able to handle various exceptional scenarios gracefully.

---
title: "Using GenAI as Your Python Tutor"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to highlight how GenAI can be used as a personalised Python tutor to help learners grasp concepts, get code examples, practise, debug, and explore real-world applications.

**Context**
Following the presentation's sections on Python branching, repetition, and functions in weather applications, this lesson introduces GenAI as a learning tool to support Python skill development. It precedes lessons on effective GenAI learning strategies and the course project of building a weather analysis tool.

**Ask for concept explanations**
When learning Python, you can ask GenAI to explain programming concepts in detail. For example, you could ask it to clarify the difference between for and while loops, or how if-elif-else statements work. GenAI will provide clear explanations to help you understand the concepts better.

**Request code examples** 
GenAI can generate Python code examples on demand. If you're unsure how to write a for loop to iterate through a list, just ask GenAI. It will provide a relevant code snippet with explanations, helping you learn by example.

**Get personalised practice questions**
GenAI can create practice Python questions tailored to your learning needs. Request questions on specific topics like dictionaries or functions, and GenAI will generate unique problems for you to solve. This personalised practice helps reinforce your understanding.

**Debug your code together**
When you encounter bugs in your Python code, GenAI can help you debug. Paste your code and error message, and ask GenAI to identify the issue. It will explain the problem and suggest fixes, helping you learn debugging skills experientially.

**Explore real-world weather applications**
GenAI can help you explore real-world applications of Python in weather data analysis. Ask for examples of how to use Python libraries like Matplotlib to visualise weather patterns or how to fetch weather data from APIs. GenAI will provide code snippets and explanations, bridging the gap between theory and practical application.

---
title: "Looping Through Dictionaries"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to cover how to work with dictionaries in Python, focusing on accessing and iterating through key-value pairs.

**Context**
After learning about branching, repetition, and functions in previous lessons, we now explore dictionaries as a flexible way to store and work with structured data. The next lessons discuss using GenAI to learn Python effectively and apply these concepts in a weather analysis project.

**Access key-value pairs** In Python dictionaries, data is stored as key-value pairs. To access a value, you use its corresponding key inside square brackets. For example, if `weather` is a dictionary, you can access the temperature with `weather["temperature"]`. This allows for quick and direct access to specific data points.

**Iterate through dictionary entries** You can loop through a dictionary using a `for` loop. By default, iterating over a dictionary gives you its keys. To access both keys and values, use the `.items()` method, like `for key, value in weather.items():`. This lets you process all the data in a dictionary efficiently.

**Useful for structured data** Dictionaries are ideal for representing structured data where each piece of information has a unique label or key. For instance, a weather report could have keys like "temperature", "humidity", "wind_speed", etc. This key-value structure keeps the data organised and easy to understand.

**Flexible data representation** Unlike lists which are ordered sequences, dictionaries are unordered and can hold various types of data as values. The values can be of any data type, like numbers, strings, booleans, or even lists and other dictionaries. This flexibility makes dictionaries suitable for complex, hierarchical data structures.

**Example: detailed weather report** A practical example is a detailed weather report stored in a dictionary. It could have keys for different aspects of the weather, like:
```python
weather = {
    "temperature": 25.3,
    "humidity": 0.6,
    "wind_speed": 10,
    "wind_direction": "NE",
    "forecast": ["sunny", "cloudy", "rainy"]
}
```
You can then access and work with this data easily using the keys.

---
title: "Else in Python"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to explain the purpose and usage of the else statement in Python conditional logic.

**Context**
After introducing the concept of branching and if statements, this lesson covers the else statement as the next component in decision structures. It is followed by elif for more complex conditionals and practical examples applying these concepts.

**Provides alternative action** The else statement provides an alternative action to be executed when the condition in the preceding if statement evaluates to False. It allows you to specify a block of code that should run if none of the previous conditions were met.

**Executes when if is False** The code block under the else statement will only execute if the condition in the if statement is False. This ensures that either the if block or the else block will run, but never both for the same condition.

**Completes the decision structure** By including an else statement, you create a complete decision structure that covers all possible cases. This is useful when you need to ensure that some action is always taken, regardless of whether the if condition is True or False.

**Ensures code for all cases** Using an else statement guarantees that you have provided code to handle all possible cases in your conditional logic. This helps prevent gaps in your decision-making process and makes your code more robust.

**Use for binary decisions** The if-else structure is most commonly used for binary decisions, where there are only two possible outcomes. If you need to check for multiple conditions, you can use elif statements in between the if and else to handle additional cases.

---
title: "Weekly Forecast"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to introduce the concept of generating weekly weather forecasts using Python programming.

**Context**
This lesson follows on from the introduction of branching, boolean expressions, and conditional statements in Python. It precedes a deeper exploration of combining branching and repetition to create more complex weather forecasting programs.

**Bullet Point 1**

**Bullet Point 2**

**Bullet Point 3**

---
title: "Recall - Six Things"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The purpose of this lesson is to briefly review six key concepts covered earlier in the presentation.

**Context**
This lesson follows the "Overview" lesson, which likely outlines the topics to be covered in the presentation. The "Recall - Six Things" lesson serves as a quick review before diving into the main content, starting with the next lesson on "What's Branching?". The six recalled items are likely foundational concepts for understanding the upcoming topics on branching, repetition, and their applications in Python programming.

---
title: "Tips for Effective GenAI Use"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to provide practical advice to learners on how to effectively utilise generative AI tools to support their Python learning and problem-solving.

**Context**
This lesson builds upon the previous discussion of using generative AI as a Python tutor and learning strategies. It offers concrete tips to help learners maximise the benefits of generative AI in their Python learning journey before introducing the course project.

**Be specific in your requests**
When seeking assistance from a generative AI tool, it's crucial to provide clear and precise instructions. Instead of asking broad, open-ended questions, break down your problem into smaller, well-defined components. Specify the desired output format, any constraints or requirements, and relevant context. This enables the AI to generate more accurate and relevant responses tailored to your needs.

**Start simple, then increase complexity**
When learning a new concept or working on a problem, begin with simple, straightforward requests to the AI. Once you have a solid grasp of the basics, gradually increase the complexity of your queries. This incremental approach allows you to build a strong foundation and prevents overwhelming you with intricate solutions right from the start. As you progress, challenge yourself with more advanced problems and leverage the AI's capabilities to explore different approaches and techniques.

**Ask for explanations of generated code**
When the AI generates code snippets or solutions, don't hesitate to ask for clarifications and explanations. Request the AI to provide comments or a step-by-step breakdown of how the code works. This helps you understand the logic behind the generated code and enhances your learning. By actively engaging with the AI's explanations, you can deepen your comprehension of Python concepts and programming patterns.

**Use GenAI to review your solutions**
After solving a problem or writing code on your own, utilise generative AI to review and provide feedback on your solution. Share your code with the AI and ask for suggestions on how to improve its efficiency, readability, or adherence to best practices. The AI can offer alternative approaches, point out potential issues, and suggest optimisations. This iterative process of coding and seeking feedback strengthens your problem-solving skills and helps you write cleaner, more robust code.

**Combine concepts in your practice requests**
As you progress in your Python learning, challenge yourself by combining multiple concepts in your practice requests to the AI. For example, ask the AI to create a program that involves both branching and repetition, or to design a function that incorporates data structures like dictionaries. By integrating various concepts, you can develop a more comprehensive understanding of how different Python elements work together. This holistic approach prepares you for tackling real-world problems that often require a combination of programming techniques.

---
title: "Breaking the Loop"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to introduce the concept of breaking out of loops in Python using the `break` statement.

**Context**
This lesson follows on from the previous lessons covering for loops and while loops in Python. It introduces a new concept that allows for more control over loop execution. The following lessons will apply this concept in practical examples like a quick weather forecast program.

**Breaking the Loop** 
In Python, the `break` statement provides a way to exit a loop prematurely. When `break` is encountered inside a loop, the program immediately exits the loop, regardless of the loop condition. This is useful in situations where you want to stop the loop based on a certain condition without waiting for the loop to complete all its iterations.

To use `break`, simply include the `break` statement at the point where you want the loop to exit. Any code after the `break` statement inside the loop will not be executed. Execution will continue with the first statement after the loop.

The `break` statement works with both for loops and while loops in Python. It provides an important control mechanism to prevent unnecessary iterations and to handle special conditions that require loop termination.

In the context of the weather station simulator example, `break` could be used to exit the loop if the user enters a specific input to quit the program. This allows for a graceful exit from the loop and the program.

---
title: "Comparison operators"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to introduce the common Boolean operators used in Python programming to create logical expressions for conditional statements and loops.

**Context**
Boolean operators are a fundamental concept in programming, and understanding them is essential for implementing branching and repetition in Python. This lesson follows the introduction to Boolean expressions and precedes the lessons on logical operators and their practical applications in if-then statements, loops, and the weather condition checker example.

**AND** The AND operator returns True if both operands are True, and False otherwise. It is denoted by the keyword "and" in Python. For example, the expression "x > 0 and x < 10" will evaluate to True only if the value of x is between 0 and 10 (excluding 0 and 10).

**OR** The OR operator returns True if at least one of the operands is True, and False if both operands are False. It is denoted by the keyword "or" in Python. For example, the expression "x < 0 or x > 10" will evaluate to True if the value of x is less than 0 or greater than 10.

**NOT** The NOT operator returns the opposite Boolean value of its operand. It is denoted by the keyword "not" in Python. For example, if x is True, then "not x" will evaluate to False, and if x is False, then "not x" will evaluate to True.

---
title: "Asking for Practice Questions"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to demonstrate how AI tutoring tools can generate customised practice questions and projects to reinforce learning of programming concepts like branching and repetition.

**Context**
Following the introduction of branching, loops, and their application in weather-related examples, this lesson shows how AI can be leveraged to create targeted practice material. It leads into tips for effective AI use and a course project that ties together the concepts covered.

**"Generate 5 weather-themed 'if-else' questions"**
Ask the AI tutor to create a set of questions that test understanding of if-else statements in a weather context. For example: "Write an if-else statement that prints 'Bring an umbrella' if the weather is 'rainy', otherwise prints 'Leave the umbrella at home'."

**"Create loop exercises using temperature data"**
Request practice problems that involve iterating over temperature data using for or while loops. This could include calculating averages, finding min/max values, or counting days above/below a certain threshold.

**"Provide boolean expression practice with forecasts"**
Seek questions that combine weather forecasts with boolean operators and logical reasoning. For instance: "Write a boolean expression that evaluates to True if the forecast is 'sunny' and the temperature is above 20°C."

**"Design a mini-project: 7-day forecast analyzer"**
Challenge the AI to outline a small project that integrates branching and looping concepts. A 7-day forecast analyzer could involve storing daily weather data in a list or dictionary, then using loops and conditional statements to generate summary statistics or recommendations.

**"Craft debugging challenges for weather scripts"**
Ask for weather-related code snippets that contain intentional bugs or logical errors. Practising debugging reinforces understanding of how branching and repetition structures should work. The AI tutor can provide the broken code and challenge you to identify and fix the issues.

---
title: "For Loops in Python"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to introduce for loops in Python and explain their purpose and usage.

**Context**
This lesson follows on from discussing the concept of repetition in programming. It precedes a lesson on while loops, another type of repetition structure in Python.

**Iterate over a sequence** For loops in Python allow you to iterate over a sequence of items, such as a list, tuple, or string. This means the loop will execute once for each item in the sequence, with a loop variable taking on the value of the current item in each iteration. This is useful when you need to process each item in a collection individually.

**Repeat a specific number times** For loops can also be used to repeat a block of code a specific number of times. This is achieved using the range() function, which generates a sequence of numbers. By specifying the range, you can control exactly how many times the loop will execute.

**Useful for known iterations** For loops are particularly useful when you know in advance how many times you need to repeat a block of code. This could be based on the length of a sequence you're iterating over, or a fixed number of repetitions required for a specific task.

**Concise and readable** One advantage of for loops is their concise and readable syntax. The structure of a for loop clearly shows what sequence is being iterated over and what variable is being used for each item. This makes for loops easy to understand and maintain.

**Example: weekly weather forecast** To illustrate the usage of for loops, consider generating a weekly weather forecast. You could use a for loop to iterate over a list of the seven days of the week, executing the code to fetch and display the weather data for each day. This is a clear and efficient way to process the data for a known number of iterations.

---
title: "Weather Condition Checker"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The lesson aims to explain how a weather condition checker works, highlighting its ability to handle complex scenarios through independent checks and flexible decision structures.

**Context**
The "Weather Condition Checker" lesson follows the introduction to branching and Boolean expressions. It serves as a practical example of applying these concepts before moving on to repetition and more advanced weather-related programs.

**Multiple independent checks** The weather condition checker performs multiple checks on different weather conditions, such as temperature, humidity, wind speed, and precipitation. Each of these checks is independent of the others, allowing the program to evaluate each condition separately. This modular approach makes the code more readable and easier to maintain.

**Each condition evaluated separately** The program evaluates each weather condition individually using separate Boolean expressions. For example, it might check if the temperature is above a certain threshold, if the humidity is within a specific range, or if the wind speed exceeds a given value. By evaluating each condition separately, the program can make more precise decisions based on the specific criteria for each weather aspect.

**Actions not mutually exclusive** The actions taken by the weather condition checker based on the results of the condition checks are not mutually exclusive. This means that multiple actions can be triggered simultaneously if the corresponding conditions are met. For instance, the program might suggest wearing a coat if the temperature is low, while also recommending an umbrella if it's raining. This allows for more comprehensive and tailored recommendations.

**Flexible decision structure** The weather condition checker employs a flexible decision structure, such as if-elif-else statements or nested conditionals, to handle various combinations of weather conditions. This flexibility enables the program to account for a wide range of scenarios and provide appropriate outputs based on the specific conditions encountered. By using a flexible decision structure, the program can adapt to different weather situations and offer relevant advice or actions.

**Useful for complex scenarios** The independent checks, separate condition evaluations, non-mutually exclusive actions, and flexible decision structure make the weather condition checker particularly useful for handling complex weather scenarios. It can take into account multiple factors and their interactions to provide accurate and helpful information to users. This approach allows the program to deal with the intricacies of real-world weather patterns and offer more nuanced and relevant outputs.

---
title: "What's Repetition?"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to introduce the concept of repetition in programming and explain its role in automating tasks.

**Context**
Having covered branching and conditionals in previous lessons, this lesson introduces repetition as another fundamental programming concept. It sets the stage for the following lessons which will delve into specific loop constructs in Python, such as for loops and while loops.

**Executing code multiple times**
Repetition in programming refers to the ability to execute a block of code multiple times. This is a powerful feature that allows programmers to automate repetitive tasks and process large amounts of data efficiently. Instead of manually writing the same code over and over, repetition constructs enable the code to be executed as many times as needed.

**Uses loops (for, while)**
In Python, repetition is achieved through the use of loops. The two main types of loops are for loops and while loops. For loops are used when the number of iterations is known in advance, such as iterating over a sequence of elements. While loops, on the other hand, are used when the number of iterations is not known and depends on a certain condition being met.

**Like daily weather checks**
A real-world analogy for repetition is performing daily weather checks. Just as we might check the weather forecast every morning to plan our day, a program can use repetition to perform a task or check a condition repeatedly. This could involve retrieving data from a weather API, processing it, and updating a display or sending notifications based on the current weather conditions.

**Automates repetitive tasks**
One of the key benefits of repetition in programming is its ability to automate repetitive tasks. Instead of manually performing the same action over and over, loops allow us to write code once and have it execute multiple times. This saves time, reduces the risk of errors, and makes our code more concise and maintainable.

**Efficient for data processing**
Repetition is particularly useful when it comes to processing large amounts of data. Whether it's iterating over a list of items, reading data from a file, or querying a database, loops enable us to efficiently process and manipulate data. By using repetition constructs, we can perform operations on each element of a dataset without having to write separate code for each individual item.

---
title: "While Loops in Python"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to introduce while loops in Python and explain their key characteristics and use cases.

**Context**
Having discussed for loops in the previous lesson, this lesson expands on another type of repetition structure in Python: while loops. It is followed by lessons that demonstrate practical applications of while loops, such as in a weekly forecast program and a weather station simulator.

**Repeat while condition is True** While loops in Python continue to execute a block of code as long as a specified condition evaluates to True. The loop body is repeated until the condition becomes False. This allows for dynamic control flow based on changing conditions.

**Useful for unknown iterations** While loops are particularly handy when the number of required iterations is not known in advance. They can keep running until a certain condition is met, making them flexible for scenarios where the loop's end point is determined by external factors or computed values.

**Requires careful condition management** To prevent while loops from running indefinitely, it's crucial to manage the loop condition carefully. The condition should eventually become False, either through changes made within the loop body or by external events. Forgetting to update the condition can lead to infinite loops.

**Can create infinite loops** If the condition in a while loop always remains True, the loop will continue to execute indefinitely, resulting in an infinite loop. This can cause the program to hang or crash. It's important to include appropriate termination conditions and test the loop to ensure it ends as expected.

**Example: continuous weather monitoring** A practical example of using a while loop is in a weather monitoring system. The loop can continuously check the current weather conditions and perform actions based on the readings. It can keep running until a specific condition is met, such as a certain temperature threshold or a user-initiated termination signal.

---
title: "Elif in Python"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to introduce the elif statement in Python and explain its role in creating more complex branching structures.

**Context**
The elif statement builds upon the concepts of boolean expressions, if-then statements, and else statements covered in previous lessons. It allows for more sophisticated decision-making in Python programs and sets the stage for the weather condition checker example in the following lesson.

**[Bullet Point 1]** The elif keyword in Python is short for "else if" and is used in conjunction with if and else statements to create more complex branching structures. It allows you to specify additional conditions to check if the preceding if statement's condition is false. You can include multiple elif statements to handle different cases or scenarios.

**[Bullet Point 2]** The syntax for using elif is similar to if statements. After an initial if statement, you can add one or more elif statements, each followed by a condition and a colon. The code block under each elif statement is executed if its condition evaluates to True. You can optionally include an else statement at the end to handle the case when none of the conditions are met.

**[Bullet Point 3]** When Python encounters an if-elif-else structure, it evaluates the conditions in order from top to bottom. If the if statement's condition is True, its code block is executed, and the rest of the elif and else blocks are skipped. If the if condition is False, Python moves on to the first elif condition. If that condition is True, its code block is executed, and the remaining elif and else blocks are skipped. This process continues until a condition is met or until the else block is reached.

**[Bullet Point 4]** Elif statements are useful when you need to check multiple conditions and execute different code blocks based on those conditions. They provide a way to handle various scenarios or cases in your program logic. By using elif, you can create more precise control flow and make your code more readable and manageable.

---
title: "Overview"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to recap the key concepts covered in Overview's session and highlight the benefits of using GenAI as a personalised Python tutor.

**Context**
The "Overview" lesson serves as a midpoint review, following the introduction of branching with if-else statements and loops for repetition. It also sets the stage for the upcoming sections on combining these concepts in weather examples and showcasing how GenAI can support learners throughout their Python learning journey.

**Mastered branching with if-else**
In Overview's session, we explored the concept of branching using if-else statements in Python. Learners discovered how to create conditional logic that allows their programs to make decisions based on specific criteria, enabling them to build more dynamic and responsive applications.

**Explored loops for repetition**
We also delved into the world of loops, which allow learners to automate repetitive tasks in their Python programs. By understanding how to use for and while loops, learners can now create more efficient and concise code, reducing the need for manual repetition.

**Combined concepts in weather examples**
To reinforce the understanding of branching and loops, we applied these concepts to real-world weather examples. Learners had the opportunity to practice using if-else statements and loops in the context of weather condition checkers, weekly forecasts, and weather station simulators, solidifying their knowledge through practical application.

**GenAI: Your 24/7 Python tutor**
GenAI was introduced as a powerful tool that learners can leverage as their personal Python tutor. Available 24/7, GenAI provides instant support and guidance whenever learners need assistance with their Python projects or have questions about specific concepts.

**Enhance learning with personalised practice**
With GenAI, learners can access personalised practice exercises and explanations tailored to their individual needs. By engaging with GenAI, learners can receive targeted feedback and support, helping them to reinforce their understanding of Python concepts and overcome any challenges they may face.

**Progress at your own pace**
One of the key benefits of using GenAI as a Python tutor is the ability to progress at your own pace. Learners can interact with GenAI whenever they have time, allowing them to fit their Python learning journey around their schedules and ensuring a flexible, self-directed learning experience.

---
title: "Example"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to introduce logical operators and their role in creating more complex conditions in branching and repetition structures.

**Context**
Following the discussion of boolean expressions and common boolean operators, this lesson delves into logical operators. It sets the stage for the subsequent lessons that demonstrate how these operators are used in Python's if-then-else and loop constructs.

**Logical Operators** 
Logical operators allow programmers to combine multiple boolean expressions to create more sophisticated conditions. The three main logical operators are AND, OR, and NOT. The AND operator returns True only if both operands are True. The OR operator returns True if at least one of the operands is True. The NOT operator negates the value of a single operand, returning the opposite boolean value.

---
title: "What's Branching?"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to introduce the concept of branching in programming and explain how it allows programs to make decisions based on certain conditions.

**Context**
This lesson follows on from the "Recall - Six Things" lesson and precedes lessons on Boolean expressions, operators, and specific examples of branching in Python. It provides a foundation for understanding how programs can respond differently based on input or calculated values.

**Making decisions in code**
Branching is a fundamental concept in programming that allows code to make decisions. Just as we make decisions in our daily lives based on certain conditions, programs can also evaluate conditions and execute different blocks of code depending on whether those conditions are met. This enables programs to respond intelligently and perform different actions in different situations.

**Uses conditional statements (if-else)**
The most common way to implement branching in code is through the use of conditional statements, particularly the if-else statement. An if statement checks whether a condition is true, and if so, executes a certain block of code. If the condition is false, an else block can be used to specify an alternative action. This allows the program to choose between two different paths based on the outcome of the condition.

**Like checking weather forecasts**
Branching can be thought of as similar to checking a weather forecast before deciding what to wear or whether to bring an umbrella. The program checks certain conditions, such as the current temperature or chance of rain, and then chooses an appropriate course of action based on those conditions. This analogy helps to illustrate the decision-making process that branching enables in programs.

**Determines program flow**
Branching is a key factor in determining the flow of a program. When a program reaches a branching point, such as an if statement, it will follow a different path depending on the outcome of the condition. This means that the program's execution can vary based on the input it receives or the values it calculates, leading to different outcomes or outputs.

**Enables responsive program behaviour**
By using branching, programs can be designed to respond intelligently to different situations. For example, a program could use branching to provide personalised recommendations based on user input, or to handle errors gracefully by executing different code when something goes wrong. This flexibility and responsiveness is a crucial aspect of creating programs that are useful and engaging for users.

---
title: "Python Basics"
subtitle: "Problem Solving"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Copyright Information

![](../../_assets/curtin-copy-right.png)

# Acknowledge of Country
I acknowledge the traditional custodians of the land on which I work and live,
and recognise their continuing connection to land, water and community. I pay
respect to elders past, present and emerging.

![](../../_assets/ack_country.png)

# Today

* Break a problems down into simple actions
* Actions carry out simple tasks
* A set of actions is called an algorithm
* Algorithms expressed as Pseudocode
* Coding is translating an algorithm to a program
* Six operations a computer can do

::: {.notes}
**Aim**
This slide introduces the agenda and key topics for the presentation on AI and machine learning.

**Context**
Following the opening slides on copyright and acknowledgement of country, this slide provides an overview of the presentation's contents. The subsequent slides delve into problem-solving methodologies and introduce fundamental programming concepts.
:::

# Problem Solving

“The biggest mistake I see new programmers make is focusing on learning syntax instead of learning how to solve problems\.”

— V\. Anton Spraul\, Think Like a Programmer: An Introduction to Creative Problem solving

::: {.notes}
**Aim**
The aim of this slide is to introduce the concept of problem solving in the context of AI and machine learning.

**Context**
This slide comes early in the presentation, following the introductory slides on copyright information and acknowledgement of country. It sets the stage for discussing problem solving methodologies and techniques in subsequent slides.

**Presenter Notes**
This slide is intentionally left blank to allow the presenter to engage the audience and invite their thoughts on problem solving. The presenter may ask the audience to share examples of problems they have faced in their work or studies related to AI and machine learning. This interaction helps to make the topic more relevant and relatable for the audience.

The lack of bullet points also serves as a visual cue for the presenter to pause and reflect on the importance of problem solving as a fundamental skill in AI and machine learning. It provides an opportunity to emphasise that the ability to break down complex problems, identify key components, and develop systematic approaches is essential for success in this field.

The presenter can use this slide to highlight that the upcoming slides will delve into specific problem solving methodologies and techniques that are commonly used in AI and machine learning. This sets the expectation for the audience and helps to create a logical flow for the presentation.
:::

# Problem Solving Methodology

- State the problem clearly
- Describe the input and output
- Work a simple example by hand
- Develop and algorithm
- Convert to Python (or some other languagE)
- Test solution with a variety of data

::: {.notes}
**Aim**
This slide aims to introduce a structured approach to problem-solving in the context of AI and machine learning.

**Context**
Having discussed the importance of problem-solving skills, this slide breaks down a step-by-step methodology that can be applied to tackle challenges in AI and machine learning. The subsequent slides will elaborate on some of these steps, such as stating the problem clearly and using pseudocode.

**State the problem clearly** Before attempting to solve a problem, it is crucial to have a clear understanding of what the problem is. This involves identifying the key issues, constraints, and desired outcomes. By stating the problem clearly, you can focus your efforts on finding the most appropriate solution.

**Describe the input and output** To develop an effective algorithm, you need to define the expected inputs and outputs. This includes specifying the data types, formats, and any constraints or assumptions. By clearly describing the input and output, you can ensure that your solution is compatible with the problem requirements.

**Work a simple example by hand** Before diving into complex algorithms, it is helpful to work through a simple example by hand. This allows you to break down the problem into smaller steps and gain a better understanding of the logic required. By manually solving a simple case, you can identify patterns and develop insights that will inform your algorithm design.

**Develop an algorithm** With a clear problem statement and an understanding of the inputs and outputs, you can now develop an algorithm to solve the problem. This involves outlining the step-by-step process for transforming the input into the desired output. The algorithm should be designed to handle various scenarios and edge cases efficiently.

**Convert to Python (or some other language)** Once you have developed an algorithm, the next step is to implement it in a programming language such as Python. This involves translating the algorithmic steps into code, taking into account the specific syntax and libraries of the chosen language. It is important to write clean, well-documented code that accurately reflects the algorithm.

**Test solution with a variety of data** After implementing the solution, it is crucial to test it with a diverse range of input data. This includes both typical cases and edge cases to ensure that the algorithm performs as expected. Testing helps identify any bugs, limitations, or areas for optimization. By thoroughly testing the solution, you can have confidence in its robustness and reliability.
:::

# State the Problem Clearly

“If you can’t explain something in simple terms\, you don’t understand it\.”

— Richard Feynman

![](img/02_Python_Objects1.png)

::: {.notes}
**Aim**
The aim of this slide is to emphasise the importance of clearly defining the problem when problem solving.

**Context**
This slide follows on from an introduction to problem solving and the problem solving methodology. It precedes slides that discuss specific problem solving techniques like rubber duck debugging and pseudocode.
:::

# Rubber Duck

![](img/02_Python_Objects2.png)

::: {.notes}
**Aim**
Introduce the concept of "rubber duck debugging" as a problem-solving technique in programming.

**Context**
This slide follows the "Problem Solving Methodology" and "State the Problem Clearly" slides, providing a specific technique for addressing programming issues. It precedes the "Psuedocode" and "Psuedocode Example" slides, which present another approach to problem-solving in programming.

**Bullet Point 1**
Rubber duck debugging is a technique where programmers explain their code, line by line, to an inanimate object, such as a rubber duck. This process helps them identify errors, inconsistencies, or areas for improvement in their code. By articulating the purpose and functionality of each line, programmers can often spot issues they might have overlooked during the coding process.

**Bullet Point 2**
The concept of rubber duck debugging is derived from a story in the book "The Pragmatic Programmer" by Andrew Hunt and David Thomas. In the book, a programmer carries around a rubber duck and explains his code to it, helping him solve problems more effectively. This anecdote has become a well-known reference in the programming community.

**Bullet Point 3**
Rubber duck debugging is a simple yet powerful technique that can be used by programmers of all skill levels. It encourages a systematic and thoughtful approach to problem-solving, as the act of explaining code step-by-step can help reveal gaps in logic or understanding. This technique can be particularly useful when dealing with complex or stubborn bugs.

**Bullet Point 4**
While the term "rubber duck debugging" specifically refers to the use of a rubber duck, the concept can be applied using any inanimate object or even a willing colleague. The key is to verbally explain the code in detail, as if teaching it to someone else. This process of externalization can help programmers better understand their own code and identify areas for improvement.
:::

# Psuedocode

- List the steps
- Use short phrases \(make it easier to convert\)
- No Syntax or rules
- Not a language  \(not compiled or executed\)
- Communication tool
- Logic of the solution
- Translate into a programming language

::: {.notes}
**Aim**
The purpose of this slide is to introduce pseudocode as a tool for outlining the logic and steps of a solution to a problem, without being tied to specific programming language syntax.

**Context**
This slide follows on from discussing problem-solving methodologies and precedes an example of pseudocode in action. It sits within the broader context of the presentation covering fundamental concepts in AI and machine learning, such as values, variables and operators.

**List the steps** Pseudocode involves listing out the sequential steps needed to solve a problem or implement an algorithm. By breaking down the solution into clear, ordered steps, it helps to clarify the logic and flow of the approach.

**Use short phrases (make it easier to convert)** When writing pseudocode, use concise, simple language rather than complete sentences. Short phrases make the pseudocode more readable and easier to convert into actual programming language code later on.

**No Syntax or rules** Pseudocode does not adhere to the strict syntax rules of programming languages. This allows the focus to remain on expressing the logic and sequence of the solution without getting bogged down in language specifics.

**Not a language (not compiled or executed)** Pseudocode is not an actual programming language that can be compiled or run. Its purpose is to communicate and plan the logic of a program in a human-readable way, not to be machine executable.

**Communication tool** One of the key roles of pseudocode is as a tool for communicating ideas between developers, team members and stakeholders. It provides a common language to discuss the logic and approach of a solution without requiring technical programming knowledge.

**Logic of the solution** Pseudocode captures the algorithmic thinking behind a solution - the logical steps, decisions, iterations, etc. It describes what needs to be done to solve the problem, rather than how to do it in a specific language.

**Translate into a programming language** Once the logic of a solution has been planned out in pseudocode, the next step is converting it into a chosen programming language. The pseudocode acts as a blueprint to guide the actual coding process.
:::

# Psuedocode Example

```text
Pick up dictionary
Open to middle of dictionary
Look at page
If word is on page
   Read definition
Else if word is earlier in book
   Open to middle of left half of book
   Go back to line 3
Else if word is later in book
   Open to middle of right half of book
   Go back to line 3
Else
   Quit
```

::: {.notes}
**Aim**
This slide aims to provide a concrete example of pseudocode to illustrate the concepts discussed in the previous slide.

**Context**
Following the introduction to pseudocode, this slide offers a practical demonstration of how pseudocode can be used to outline the logic and structure of a program. The example will help learners understand the application of the six basic operations and the use of variables, which will be covered in subsequent slides.
:::

# Only Six  Operations

- Receive Information
- Output Information
- Perform Arithmetic
- Assign a value to a variable
- Compare to variables
- Repeat a group of actions.

::: {.notes}
**Aim**
Introduce the six fundamental operations that computers can perform, which form the basis for all computational tasks.

**Context**
Having discussed problem-solving methodologies and pseudocode, this slide focuses on the core capabilities of computers. It sets the stage for the following slides, which delve into values, variables, and operators.

**Receive Information**
Computers can accept input from various sources, such as keyboards, mice, touchscreens, or sensors. This allows them to gather data and instructions necessary for processing. Input can be in the form of text, numbers, or even binary data.

**Output Information**
After processing data, computers can display results or send information to external devices. Common output methods include displaying text or graphics on a screen, printing documents, playing audio, or transmitting data over networks.

**Perform Arithmetic**
Computers excel at mathematical calculations. They can perform basic arithmetic operations like addition, subtraction, multiplication, and division with incredible speed and accuracy. These operations are fundamental to many computational tasks.

**Assign a value to a variable**
Variables are used to store and reference data in a program. Computers can assign specific values to variables, allowing for efficient data management and manipulation. This enables programs to keep track of changing data throughout execution.

**Compare to variables**
Computers can compare the values of two or more variables using relational operators. This allows for decision-making in programs, such as determining equality, greater than, or less than relationships between variables. Comparisons are crucial for controlling program flow and implementing conditional logic.

**Repeat a group of actions.**
Computers can execute a set of instructions repeatedly using loops. This allows for efficient processing of large amounts of data or performing iterative tasks. Loops enable computers to automate repetitive operations, saving time and effort compared to manual execution.
:::

# Computer can…

- Store Values
- Perform Operations

::: {.notes}
**Aim**
The aim of this slide is to introduce the fundamental capabilities of computers in storing data and executing instructions.

**Context**
Having discussed problem-solving methodologies and pseudocode, this slide transitions to the basic building blocks of computer programming. It lays the foundation for subsequent slides on values, variables, and operators.

**Store Values**
Computers have the ability to store and retrieve data in their memory. This data can be in various forms such as numbers, text, or images. The computer allocates a specific location in its memory to hold each piece of data, allowing it to be accessed and manipulated as needed. Storing values is a crucial aspect of computer programming, as it enables the preservation and utilisation of data throughout the execution of a program.

**Perform Operations**
In addition to storing data, computers can execute a set of instructions, known as operations or computations, on that data. These operations can be arithmetic (such as addition, subtraction, multiplication, or division), logical (comparisons and conditional statements), or manipulations of the stored values (like combining or splitting text). By performing these operations, computers can process and transform data, solve complex problems, and generate meaningful outputs based on the provided instructions and data.
:::

# What are values?

- Single Value
  - Integer (count)
  - Float (measurE)
  - Character
  - Boolean

![](img/02_Python_Objects3.png)

::: {.notes}
**Aim**
The aim of this slide is to introduce the different types of values that can be used in programming.

**Context**
This slide follows on from the discussion of problem-solving methodology and pseudocode. It provides a foundation for understanding variables and operators, which will be covered in the subsequent slides.

**Single Value** A single value is the simplest type of data that can be stored in a program. It represents a single piece of information, such as a number or a character. Single values are the building blocks of more complex data structures.

**Integer (count)** An integer is a whole number that can be positive, negative, or zero. Integers are commonly used for counting and indexing. They are represented by a fixed number of bits, which determines the range of values they can store.

**Float (measure)** A float, short for floating-point number, is used to represent decimal numbers. Floats are useful for measuring and calculating values that require precision, such as distances or weights. They are stored using a mantissa and an exponent, allowing for a wide range of values.

**Character** A character is a single letter, digit, punctuation mark, or symbol. Characters are typically represented by a single byte of memory and are used for storing and manipulating text data. They can be combined to form strings, which are sequences of characters.

**Boolean** A boolean is a data type that can have only two possible values: true or false. Booleans are used for logical operations and decision-making in programs. They are essential for controlling the flow of execution based on certain conditions.
:::

# Variables

A  _variable_  is the name given to a part of the computers memory\, designed to store a particular data item\.

![](img/02_Python_Objects4.png)

::: {.notes}
**Aim**
The aim of this slide is to introduce the concept of variables and their role in programming.

**Context**
This slide follows on from the discussion of values and precedes the explanation of variable names and operators. It forms part of the broader introduction to fundamental programming concepts.
:::

# Variable Names

* Rules
  * Only letters\, numbers\, and the underscore character \(\_\)
  * No spaces
  * No quotes
  * Can’t start with a number
  * Can't be a keyword import
* Conventions
  * variable names should be meaningful
  * separate words with underscores  \(snake\_case\)

::: {.notes}
**Aim**
This slide aims to provide guidelines for choosing appropriate variable names in programming.

**Context**
Having introduced the concept of variables in the previous slide, this slide delves into the specifics of naming variables effectively. The next slides will cover operators and relational operators, building on the foundation of variables and their names.

**Descriptive Names** 
Variable names should be descriptive and meaningful, clearly indicating the purpose or content of the variable. For example, instead of using a generic name like "x", choose a name like "age" or "student_count" that conveys the variable's role in the program. Descriptive names enhance code readability and make it easier for other developers (or yourself in the future) to understand the code's intent.

**Consistent Naming Conventions**
Adopt a consistent naming convention throughout your codebase. Common conventions include camelCase (e.g., firstName), PascalCase (e.g., ClassName), or snake_case (e.g., student_id). Stick to the chosen convention to maintain uniformity and improve code clarity. Consistency in naming helps avoid confusion and makes the code more predictable and easier to follow.

**Avoid Reserved Keywords**
When choosing variable names, avoid using reserved keywords specific to the programming language you are using. Reserved keywords have predefined meanings and cannot be used as variable names. Examples of reserved keywords in various languages include "if", "while", "for", "class", etc. Familiarize yourself with the reserved keywords of the language you are working with to prevent naming conflicts and syntax errors.

**Keep Names Concise**
While variable names should be descriptive, they should also be concise. Aim for a balance between clarity and brevity. Avoid excessively long names that can make the code harder to read and maintain. Use abbreviations or acronyms judiciously and only when they are widely understood within the context of your project or domain. Striking the right balance ensures that variable names are informative without being cumbersome.
:::

# Operators

![](img/02_Python_Objects5.png)

::: {.notes}
**Aim**
Introduce various operators used in programming and explain their purpose.

**Context**
After discussing variables and values, the next logical step is to introduce operators. These allow us to perform calculations and comparisons using the variables and values. The following slide will go into more detail about relational operators specifically.
:::

# Relational Operators
![](img/02_Python_Objects6.png)

::: {.notes}
**Aim**
The aim of this slide is to introduce relational operators and their role in programming.

**Context**
This slide follows on from the discussion of operators in general. It leads into the next slide which tests the audience's understanding of the concepts covered.
:::

# Can you

- Break a problems down into simple actions
- Actions carry out simple tasks
- A set of actions is called an algorithm
- Algorithms expressed as Pseudocode
- Coding is translating an algorithm to a program
- Six operations a computer can do

::: {.notes}
**Aim**
The aim of this slide is to introduce the concept of algorithms and how they are expressed in programming.

**Context**
Following on from discussing problem-solving methodologies and pseudocode, this slide explores the fundamental building blocks of algorithms and how they are translated into computer programs. It leads into the next topic of values, variables and operators.

**Break a problems down into simple actions**
To create an algorithm, you first need to break down a problem into a series of simple, clearly defined actions or steps. Each action should be a single, straightforward task that can be carried out without requiring further breakdown. This process of decomposition is crucial in designing effective algorithms.

**Actions carry out simple tasks**
Each action within an algorithm is responsible for carrying out a specific, simple task. These tasks are the basic building blocks of the algorithm and are typically very limited in scope. For example, an action might be to add two numbers together, compare two values, or store a piece of data.

**A set of actions is called an algorithm**
When you combine a series of actions together in a specific order to solve a problem or accomplish a task, you create an algorithm. An algorithm is essentially a step-by-step procedure or set of instructions that can be followed to achieve a desired outcome. Algorithms are used to solve a wide variety of problems in computer science and programming.

**Algorithms expressed as Pseudocode**
Pseudocode is a way of expressing algorithms using a simplified, informal language that is easy for humans to read and understand. It uses a combination of natural language and programming-like syntax to describe the steps of an algorithm. Pseudocode is not tied to any specific programming language and serves as a blueprint for the actual code.

**Coding is translating an algorithm to a program**
Once an algorithm has been designed and expressed in pseudocode, the next step is to translate it into an actual computer program using a programming language. This process, known as coding, involves writing instructions that the computer can execute using the specific syntax and rules of the chosen language. The programmer's goal is to accurately translate the algorithm into code that runs correctly and efficiently.

**Six operations a computer can do**
At their core, computers can only perform six fundamental operations: input, output, processing, branching, looping, and storing data. Every program, no matter how complex, is ultimately built upon these six basic operations. Understanding these operations and how they are combined to create algorithms is essential for effective programming.
:::

# Next time

- Making decisions
- Controlling the flow of a program

::: {.notes}
**Aim**
This slide aims to preview the key programming concepts that will be covered in the next lesson.

**Context**
After introducing fundamental concepts like problem-solving, pseudocode, variables, and operators, this slide serves as a glimpse into the upcoming topics. It bridges the gap between the basic building blocks and the more advanced programming concepts that enable students to create functional programs.

**Making decisions**
In the next lesson, we will explore how computers make decisions based on certain conditions using control structures such as if-else statements and switch-case statements. These concepts allow programmers to create programs that can respond differently based on user input or other variables, enabling more dynamic and interactive software.

**Controlling the flow of a program** 
We will also discuss how to control the flow of a program using loops, such as for loops and while loops. These structures allow programmers to repeat a block of code multiple times, either for a specified number of iterations or until a certain condition is met. By mastering these concepts, students will be able to create more efficient and powerful programs.
:::



---
title: "Overview"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the scope and structure of the presentation on AI and machine learning
- Identify the key topics that will be covered in the subsequent lessons

**Introduction**



**Aim**
This lesson introduces the agenda and key topics for the presentation on AI and machine learning.

**Context**
Following the opening lessons on copyright and acknowledgement of country, this lesson provides an overview of the presentation's contents. The subsequent lessons delve into problem-solving methodologies and introduce fundamental programming concepts.

**Key Takeaways**

- This lesson serves as an introduction to the presentation on AI and machine learning
- The presentation will cover problem-solving methodologies and fundamental programming concepts
- Subsequent lessons will delve deeper into the key topics introduced in this overview

**Quick Quiz**

1. What is the main focus of this presentation?
   Answer: The main focus of this presentation is AI and machine learning

2. What topics will be covered in the lessons following this overview?
   Answer: The subsequent lessons will cover problem-solving methodologies and fundamental programming concepts

**Additional Resources**

- Introduction to Machine Learning: https://www.coursera.org/learn/machine-learning
- Problem-Solving Techniques in Computer Science: https://www.geeksforgeeks.org/problem-solving-techniques-in-computer-science/

*Created on: 2024-07-29*


---
title: "Psuedocode Example"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand how pseudocode is used to outline the logic and structure of a program
- Recognize the application of the six basic operations in a pseudocode example
- Identify the use of variables in a pseudocode example

**Introduction**



**Aim**
This lesson aims to provide a concrete example of pseudocode to illustrate the concepts discussed in the previous lesson.

**Context**
Following the introduction to pseudocode, this lesson offers a practical demonstration of how pseudocode can be used to outline the logic and structure of a program. The example will help learners understand the application of the six basic operations and the use of variables, which will be covered in subsequent lessons.

**Key Takeaways**

- Pseudocode is a useful tool for planning and communicating the logic of a program
- The six basic operations (input, output, processing, decision, repetition, and storage) are essential components of pseudocode
- Variables are used in pseudocode to store and manipulate data
- Pseudocode examples help bridge the gap between concept and implementation

**Quick Quiz**

1. What is the primary purpose of using pseudocode?
   Answer: To outline the logic and structure of a program

2. Which of the following is not one of the six basic operations in pseudocode?
   Answer: Debugging

**Additional Resources**

- Pseudocode Examples: https://www.example.com/pseudocode-examples
- Introduction to Variables in Programming: https://www.example.com/variables-intro

*Created on: 2024-07-29*


---
title: "Next time"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand how to use control structures such as if-else statements and switch-case statements to make decisions in a program.
- Learn how to use loops, including for loops and while loops, to control the flow of a program and repeat code blocks.
- Apply decision-making and looping concepts to create more dynamic, interactive, and efficient programs.

**Introduction**

After introducing fundamental concepts like problem-solving, pseudocode, variables, and operators, this lesson serves as a glimpse into the upcoming topics. It bridges the gap between the basic building blocks and the more advanced programming concepts that enable students to create functional programs.

**Making decisions**
In the next lesson, we will explore how computers make decisions based on certain conditions using control structures such as if-else statements and switch-case statements. These concepts allow programmers to create programs that can respond differently based on user input or other variables, enabling more dynamic and interactive software.

**Controlling the flow of a program** 
We will also discuss how to control the flow of a program using loops, such as for loops and while loops. These structures allow programmers to repeat a block of code multiple times, either for a specified number of iterations or until a certain condition is met. By mastering these concepts, students will be able to create more efficient and powerful programs.

**Key Takeaways**

- Control structures allow computers to make decisions based on certain conditions.
- If-else statements and switch-case statements enable programs to respond differently based on user input or other variables.
- Loops, such as for loops and while loops, allow programmers to repeat a block of code multiple times.
- Mastering decision-making and looping concepts is essential for creating more efficient and powerful programs.

**Quick Quiz**

1. Which control structure is used to make decisions based on certain conditions?
   Answer: If-else statements and switch-case statements

2. What is the purpose of loops in programming?
   Answer: To repeat a block of code multiple times, either for a specified number of iterations or until a certain condition is met

**Additional Resources**

- Control Flow - Python Documentation: https://docs.python.org/3/tutorial/controlflow.html
- C++ Decision Making and Loops - Programiz: https://www.programiz.com/cpp-programming/decision-making-loops
- JavaScript Conditional Statements and Loops - W3Schools: https://www.w3schools.com/js/js_if_else.asp

*Created on: 2024-07-29*


---
title: "Psuedocode"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the purpose and benefits of using pseudocode in problem-solving and algorithm design.
- Be able to write pseudocode that effectively communicates the logic and steps of a solution.
- Recognize the role of pseudocode as a stepping stone to writing actual code in a programming language.

**Introduction**

This lesson follows on from discussing problem-solving methodologies and precedes an example of pseudocode in action. It sits within the broader context of the presentation covering fundamental concepts in AI and machine learning, such as values, variables and operators.

**List the steps** Pseudocode involves listing out the sequential steps needed to solve a problem or implement an algorithm. By breaking down the solution into clear, ordered steps, it helps to clarify the logic and flow of the approach.

**Use short phrases (make it easier to convert)** When writing pseudocode, use concise, simple language rather than complete sentences. Short phrases make the pseudocode more readable and easier to convert into actual programming language code later on.

**No Syntax or rules** Pseudocode does not adhere to the strict syntax rules of programming languages. This allows the focus to remain on expressing the logic and sequence of the solution without getting bogged down in language specifics.

**Not a language (not compiled or executed)** Pseudocode is not an actual programming language that can be compiled or run. Its purpose is to communicate and plan the logic of a program in a human-readable way, not to be machine executable.

**Communication tool** One of the key roles of pseudocode is as a tool for communicating ideas between developers, team members and stakeholders. It provides a common language to discuss the logic and approach of a solution without requiring technical programming knowledge.

**Logic of the solution** Pseudocode captures the algorithmic thinking behind a solution - the logical steps, decisions, iterations, etc. It describes what needs to be done to solve the problem, rather than how to do it in a specific language.

**Translate into a programming language** Once the logic of a solution has been planned out in pseudocode, the next step is converting it into a chosen programming language. The pseudocode acts as a blueprint to guide the actual coding process.

**Key Takeaways**

- Pseudocode is a tool for outlining the logic and steps of a solution without being tied to specific programming language syntax.
- It involves using short phrases and simple language to list out the sequential steps needed to solve a problem or implement an algorithm.
- Pseudocode serves as a communication tool for discussing ideas between developers, team members, and stakeholders.
- The focus of pseudocode is on capturing the algorithmic thinking and logic behind a solution.
- Once the logic is planned out in pseudocode, the next step is converting it into a chosen programming language.

**Quick Quiz**

1. What is the main purpose of using pseudocode?
   Answer: To outline the logic and steps of a solution without being tied to specific programming language syntax.

2. Is pseudocode an actual programming language that can be compiled and executed?
   Answer: No, pseudocode is not an actual programming language. It is a tool for communicating and planning the logic of a program in a human-readable way.

3. What is the next step after planning out the logic of a solution in pseudocode?
   Answer: Converting the pseudocode into a chosen programming language.

**Additional Resources**

- How to Write Pseudocode: A Beginner's Guide: https://www.geeksforgeeks.org/how-to-write-a-pseudo-code/
- Pseudocode Examples and Guidelines: https://www.unf.edu/~broggio/cop2221/2221pseu.htm
- Pseudocode - Wikipedia: https://en.wikipedia.org/wiki/Pseudocode

*Created on: 2024-07-29*


---
title: "What are values?"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Identify and differentiate between the four main types of values: integers, floats, characters, and booleans.
- Understand the purpose and uses of each value type in programming.
- Recognize the importance of selecting the appropriate value type for a given task.

**Introduction**

This lesson follows on from the discussion of problem-solving methodology and pseudocode. It provides a foundation for understanding variables and operators, which will be covered in the subsequent lessons.

**Single Value** A single value is the simplest type of data that can be stored in a program. It represents a single piece of information, such as a number or a character. Single values are the building blocks of more complex data structures.

**Integer (count)** An integer is a whole number that can be positive, negative, or zero. Integers are commonly used for counting and indexing. They are represented by a fixed number of bits, which determines the range of values they can store.

**Float (measure)** A float, short for floating-point number, is used to represent decimal numbers. Floats are useful for measuring and calculating values that require precision, such as distances or weights. They are stored using a mantissa and an exponent, allowing for a wide range of values.

**Character** A character is a single letter, digit, punctuation mark, or symbol. Characters are typically represented by a single byte of memory and are used for storing and manipulating text data. They can be combined to form strings, which are sequences of characters.

**Boolean** A boolean is a data type that can have only two possible values: true or false. Booleans are used for logical operations and decision-making in programs. They are essential for controlling the flow of execution based on certain conditions.

**Key Takeaways**

- Single values are the simplest type of data that can be stored in a program.
- Integers are used for counting and indexing, while floats are used for measuring and calculating values that require precision.
- Characters represent single letters, digits, punctuation marks, or symbols and can be combined to form strings.
- Booleans are used for logical operations and decision-making, with only two possible values: true or false.

**Quick Quiz**

1. Which value type is most suitable for storing a person's age?
   Answer: Integer

2. True or False: Characters can be combined to form strings.
   Answer: True

3. What are the only two possible values for a boolean?
   Answer: True and False

**Additional Resources**

- Data Types in Programming: https://www.geeksforgeeks.org/data-types-in-programming/
- Understanding Data Types: https://www.programiz.com/article/data-types-programming
- Primitive Data Types in Java: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html

*Created on: 2024-07-29*


---
title: "Can you"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the process of breaking down problems into simple actions to create algorithms.
- Learn how to express algorithms using pseudocode and translate them into computer programs.
- Identify the six fundamental operations that computers can perform.

**Introduction**

Following on from discussing problem-solving methodologies and pseudocode, this lesson explores the fundamental building blocks of algorithms and how they are translated into computer programs. It leads into the next topic of values, variables and operators.

**Break a problems down into simple actions**
To create an algorithm, you first need to break down a problem into a series of simple, clearly defined actions or steps. Each action should be a single, straightforward task that can be carried out without requiring further breakdown. This process of decomposition is crucial in designing effective algorithms.

**Actions carry out simple tasks**
Each action within an algorithm is responsible for carrying out a specific, simple task. These tasks are the basic building blocks of the algorithm and are typically very limited in scope. For example, an action might be to add two numbers together, compare two values, or store a piece of data.

**A set of actions is called an algorithm**
When you combine a series of actions together in a specific order to solve a problem or accomplish a task, you create an algorithm. An algorithm is essentially a step-by-step procedure or set of instructions that can be followed to achieve a desired outcome. Algorithms are used to solve a wide variety of problems in computer science and programming.

**Algorithms expressed as Pseudocode**
Pseudocode is a way of expressing algorithms using a simplified, informal language that is easy for humans to read and understand. It uses a combination of natural language and programming-like syntax to describe the steps of an algorithm. Pseudocode is not tied to any specific programming language and serves as a blueprint for the actual code.

**Coding is translating an algorithm to a program**
Once an algorithm has been designed and expressed in pseudocode, the next step is to translate it into an actual computer program using a programming language. This process, known as coding, involves writing instructions that the computer can execute using the specific syntax and rules of the chosen language. The programmer's goal is to accurately translate the algorithm into code that runs correctly and efficiently.

**Six operations a computer can do**
At their core, computers can only perform six fundamental operations: input, output, processing, branching, looping, and storing data. Every program, no matter how complex, is ultimately built upon these six basic operations. Understanding these operations and how they are combined to create algorithms is essential for effective programming.

**Key Takeaways**

- Algorithms are created by breaking down problems into a series of simple, clearly defined actions.
- Each action within an algorithm carries out a specific, simple task.
- Pseudocode is a simplified, informal language used to express algorithms.
- Coding is the process of translating an algorithm into a computer program.
- Computers can perform six fundamental operations: input, output, processing, branching, looping, and storing data.

**Quick Quiz**

1. What is the process of breaking down a problem into simple actions called?
   Answer: Decomposition

2. What is the purpose of pseudocode?
   Answer: To express algorithms using a simplified, informal language that is easy for humans to read and understand.

3. How many fundamental operations can a computer perform?
   Answer: Six

**Additional Resources**

- Introduction to Algorithms: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/
- Pseudocode Tutorial: https://www.geeksforgeeks.org/how-to-write-a-pseudo-code/
- Fundamentals of Computer Programming: https://www.coursera.org/learn/computer-programming

*Created on: 2024-07-29*


---
title: "Problem Solving"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Recognize the importance of problem solving skills in AI and machine learning
- Understand that problem solving involves breaking down complex issues into manageable components
- Anticipate learning about specific problem solving methodologies and techniques in subsequent lessons

**Introduction**

This lesson comes early in the presentation, following the introductory lessons on copyright information and acknowledgement of country. It sets the stage for discussing problem solving methodologies and techniques in subsequent lessons.

**Presenter Notes**
This lesson is intentionally left blank to allow the presenter to engage the audience and invite their thoughts on problem solving. The presenter may ask the audience to share examples of problems they have faced in their work or studies related to AI and machine learning. This interaction helps to make the topic more relevant and relatable for the audience.

The lack of bullet points also serves as a visual cue for the presenter to pause and reflect on the importance of problem solving as a fundamental skill in AI and machine learning. It provides an opportunity to emphasise that the ability to break down complex problems, identify key components, and develop systematic approaches is essential for success in this field.

The presenter can use this lesson to highlight that the upcoming lessons will delve into specific problem solving methodologies and techniques that are commonly used in AI and machine learning. This sets the expectation for the audience and helps to create a logical flow for the presentation.

**Key Takeaways**

- Problem solving is a fundamental skill in AI and machine learning
- Breaking down complex problems into key components is essential for success
- Systematic approaches to problem solving will be covered in upcoming lessons
- Sharing real-world examples helps make the topic more relevant and relatable
- Pausing to reflect on the importance of problem solving sets the stage for further learning

**Quick Quiz**

1. Why is problem solving an essential skill in AI and machine learning?
   Answer: It allows professionals to break down complex issues and develop systematic approaches to solve them

2. What can you expect to learn in the upcoming lessons?
   Answer: Specific problem solving methodologies and techniques commonly used in AI and machine learning

**Additional Resources**

- The Importance of Problem Solving Skills in AI and Machine Learning: https://example.com/problem-solving-ai-ml
- Top 5 Problem Solving Techniques for AI and Machine Learning Professionals: https://example.com/top-5-problem-solving-techniques
- Case Studies: Real-World Problem Solving in AI and Machine Learning: https://example.com/case-studies-problem-solving

*Created on: 2024-07-29*


---
title: "Problem Solving Methodology"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand and apply a structured problem-solving methodology in the context of AI and machine learning.
- Develop the ability to state problems clearly, describe inputs and outputs, and design effective algorithms.
- Gain proficiency in translating algorithms into code and testing solutions with diverse data sets.

**Introduction**

Having discussed the importance of problem-solving skills, this lesson breaks down a step-by-step methodology that can be applied to tackle challenges in AI and machine learning. The subsequent lessons will elaborate on some of these steps, such as stating the problem clearly and using pseudocode.

**State the problem clearly** Before attempting to solve a problem, it is crucial to have a clear understanding of what the problem is. This involves identifying the key issues, constraints, and desired outcomes. By stating the problem clearly, you can focus your efforts on finding the most appropriate solution.

**Describe the input and output** To develop an effective algorithm, you need to define the expected inputs and outputs. This includes specifying the data types, formats, and any constraints or assumptions. By clearly describing the input and output, you can ensure that your solution is compatible with the problem requirements.

**Work a simple example by hand** Before diving into complex algorithms, it is helpful to work through a simple example by hand. This allows you to break down the problem into smaller steps and gain a better understanding of the logic required. By manually solving a simple case, you can identify patterns and develop insights that will inform your algorithm design.

**Develop an algorithm** With a clear problem statement and an understanding of the inputs and outputs, you can now develop an algorithm to solve the problem. This involves outlining the step-by-step process for transforming the input into the desired output. The algorithm should be designed to handle various scenarios and edge cases efficiently.

**Convert to Python (or some other language)** Once you have developed an algorithm, the next step is to implement it in a programming language such as Python. This involves translating the algorithmic steps into code, taking into account the specific syntax and libraries of the chosen language. It is important to write clean, well-documented code that accurately reflects the algorithm.

**Test solution with a variety of data** After implementing the solution, it is crucial to test it with a diverse range of input data. This includes both typical cases and edge cases to ensure that the algorithm performs as expected. Testing helps identify any bugs, limitations, or areas for optimization. By thoroughly testing the solution, you can have confidence in its robustness and reliability.

**Key Takeaways**

- Stating the problem clearly is essential for focusing efforts on finding the most appropriate solution.
- Defining expected inputs and outputs ensures compatibility between the solution and problem requirements.
- Working through a simple example by hand helps break down the problem and develop insights for algorithm design.
- Developing an algorithm involves outlining a step-by-step process for transforming input into the desired output.
- Testing the implemented solution with a variety of data, including edge cases, ensures robustness and reliability.

**Quick Quiz**

1. What is the importance of stating the problem clearly in problem-solving?
   Answer: Stating the problem clearly helps focus efforts on finding the most appropriate solution by identifying key issues, constraints, and desired outcomes.

2. Why is it helpful to work through a simple example by hand before developing an algorithm?
   Answer: Working through a simple example by hand allows you to break down the problem into smaller steps, gain a better understanding of the required logic, and identify patterns that inform algorithm design.

3. What is the purpose of testing the implemented solution with a variety of data?
   Answer: Testing the solution with diverse input data, including typical cases and edge cases, helps identify bugs, limitations, or areas for optimization, ensuring the algorithm's robustness and reliability.

**Additional Resources**

- Problem-Solving Techniques for Coding Interviews: https://www.geeksforgeeks.org/problem-solving-techniques-for-coding-interviews/
- The Art of Problem Solving in Data Science and Machine Learning: https://towardsdatascience.com/the-art-of-problem-solving-in-data-science-and-machine-learning-487c5d5b5f14
- A Step-by-Step Guide to Problem Solving in Python: https://realpython.com/python-thinking-recursively/

*Created on: 2024-07-29*


---
title: "Variable Names"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the importance of using descriptive and meaningful variable names to enhance code readability and maintainability.
- Learn and apply consistent naming conventions (e.g., camelCase, PascalCase, snake_case) throughout the codebase.
- Identify and avoid using reserved keywords specific to the programming language when naming variables.

**Introduction**

Having introduced the concept of variables in the previous lesson, this lesson delves into the specifics of naming variables effectively. The next lessons will cover operators and relational operators, building on the foundation of variables and their names.

**Descriptive Names** 
Variable names should be descriptive and meaningful, clearly indicating the purpose or content of the variable. For example, instead of using a generic name like "x", choose a name like "age" or "student_count" that conveys the variable's role in the program. Descriptive names enhance code readability and make it easier for other developers (or yourself in the future) to understand the code's intent.

**Consistent Naming Conventions**
Adopt a consistent naming convention throughout your codebase. Common conventions include camelCase (e.g., firstName), PascalCase (e.g., ClassName), or snake_case (e.g., student_id). Stick to the chosen convention to maintain uniformity and improve code clarity. Consistency in naming helps avoid confusion and makes the code more predictable and easier to follow.

**Avoid Reserved Keywords**
When choosing variable names, avoid using reserved keywords specific to the programming language you are using. Reserved keywords have predefined meanings and cannot be used as variable names. Examples of reserved keywords in various languages include "if", "while", "for", "class", etc. Familiarize yourself with the reserved keywords of the language you are working with to prevent naming conflicts and syntax errors.

**Keep Names Concise**
While variable names should be descriptive, they should also be concise. Aim for a balance between clarity and brevity. Avoid excessively long names that can make the code harder to read and maintain. Use abbreviations or acronyms judiciously and only when they are widely understood within the context of your project or domain. Striking the right balance ensures that variable names are informative without being cumbersome.

**Key Takeaways**

- Choose variable names that clearly indicate the purpose or content of the variable.
- Maintain consistency in naming conventions to improve code clarity and predictability.
- Avoid using reserved keywords as variable names to prevent naming conflicts and syntax errors.
- Strike a balance between descriptive and concise variable names for optimal readability.
- Proper variable naming enhances code maintainability and collaboration with other developers.

**Quick Quiz**

1. Which of the following is an example of a descriptive variable name?
   Answer: student_count

2. True or False: It is acceptable to use reserved keywords as variable names.
   Answer: False

**Additional Resources**

- Naming Conventions in Programming: https://en.wikipedia.org/wiki/Naming_convention_(programming)
- Clean Code: A Handbook of Agile Software Craftsmanship by Robert C. Martin (ISBN: 978-0132350884)
- Programming Best Practices: Naming Conventions: https://stackoverflow.com/questions/159720/what-are-the-best-practices-for-naming-variables-and-methods-in-python

*Created on: 2024-07-29*


---
title: "Computer can…"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand how computers store data in memory and retrieve it when needed
- Recognize the types of operations computers can perform on stored data, including arithmetic, logical, and value manipulations

**Introduction**

Having discussed problem-solving methodologies and pseudocode, this lesson transitions to the basic building blocks of computer programming. It lays the foundation for subsequent lessons on values, variables, and operators.

**Store Values**
Computers have the ability to store and retrieve data in their memory. This data can be in various forms such as numbers, text, or images. The computer allocates a specific location in its memory to hold each piece of data, allowing it to be accessed and manipulated as needed. Storing values is a crucial aspect of computer programming, as it enables the preservation and utilisation of data throughout the execution of a program.

**Perform Operations**
In addition to storing data, computers can execute a set of instructions, known as operations or computations, on that data. These operations can be arithmetic (such as addition, subtraction, multiplication, or division), logical (comparisons and conditional statements), or manipulations of the stored values (like combining or splitting text). By performing these operations, computers can process and transform data, solve complex problems, and generate meaningful outputs based on the provided instructions and data.

**Key Takeaways**

- Computers can store various types of data, such as numbers, text, and images, in their memory
- Each piece of data is allocated a specific memory location for storage and retrieval
- Computers can execute a set of instructions (operations) on the stored data
- Operations include arithmetic calculations, logical comparisons, and data manipulations
- By performing operations on data, computers can process information, solve problems, and generate outputs

**Quick Quiz**

1. What types of data can computers store in their memory?
   Answer: Computers can store various types of data, including numbers, text, and images

2. What are the three main categories of operations computers can perform on data?
   Answer: The three main categories of operations are arithmetic, logical, and value manipulations

**Additional Resources**

- Introduction to Computer Memory: https://www.geeksforgeeks.org/introduction-to-computer-memory/
- Computer Basics: Understanding Computer Operations: https://edu.gcfglobal.org/en/computerbasics/understanding-computer-operations/1/

*Created on: 2024-07-29*


---
title: "Relational Operators"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand what relational operators are and their purpose in programming
- Learn the different types of relational operators and their syntax
- Be able to use relational operators in conditional statements and loops

**Introduction**



**Aim**
The aim of this lesson is to introduce relational operators and their role in programming.

**Context**
This lesson follows on from the discussion of operators in general. It leads into the next lesson which tests the audience's understanding of the concepts covered.

**Key Takeaways**

- Relational operators compare two values and return a boolean result (true or false)
- The main relational operators are: equality (==), inequality (!=), greater than (>), less than (<), greater than or equal to (>=), and less than or equal to (<=)
- Relational operators are essential for controlling the flow of a program through conditional statements and loops
- The result of a relational operation can be assigned to a variable or used directly in an if statement or loop condition

**Quick Quiz**

1. What is the result of the following expression: 5 > 3?
   Answer: true

2. Which relational operator checks if two values are not equal?
   Answer: !=

3. Is the following statement true or false: 7 <= 7?
   Answer: true

**Additional Resources**

- Mozilla Developer Network: Comparison operators (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)
- W3Schools: Java Comparison Operators (https://www.w3schools.com/java/java_operators.asp)
- Python.org: Comparisons (https://docs.python.org/3/library/stdtypes.html#comparisons)

*Created on: 2024-07-29*


---
title: "State the Problem Clearly"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the importance of clearly defining a problem before attempting to solve it
- Identify the key components of a well-defined problem statement
- Practice writing clear and concise problem statements for given scenarios

**Introduction**



**Aim**
The aim of this lesson is to emphasise the importance of clearly defining the problem when problem solving.

**Context**
This lesson follows on from an introduction to problem solving and the problem solving methodology. It precedes lessons that discuss specific problem solving techniques like rubber duck debugging and pseudocode.

**Key Takeaways**

- A clearly defined problem is essential for effective problem solving
- A well-defined problem statement includes the current state, desired state, and obstacles
- Avoid ambiguity and assumptions when stating the problem
- Investing time in properly defining the problem can save time and resources in the long run

**Quick Quiz**

1. Why is it important to clearly define a problem before attempting to solve it?
   Answer: A clear problem definition helps focus efforts, avoid wasted time, and find the most appropriate solution.

2. What are the three key components of a well-defined problem statement?
   Answer: Current state, desired state, and obstacles.

**Additional Resources**

- The Importance of Defining the Problem: https://www.mindtools.com/pages/article/newTMC_85.htm
- How to Define a Problem Statement: A Guide: https://www.indeed.com/career-advice/career-development/how-to-define-a-problem-statement

*Created on: 2024-07-29*


---
title: "Operators"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the purpose and types of operators used in programming.
- Learn how to use arithmetic, assignment, comparison, and logical operators.
- Recognize operator precedence and how it affects the order of operations.

**Introduction**



**Aim**
Introduce various operators used in programming and explain their purpose.

**Context**
After discussing variables and values, the next logical step is to introduce operators. These allow us to perform calculations and comparisons using the variables and values. The following lesson will go into more detail about relational operators specifically.

**Key Takeaways**

- Operators are symbols that perform operations on one or more operands (values or variables).
- Arithmetic operators (+, -, *, /, %, etc.) perform mathematical calculations.
- Assignment operators (=, +=, -=, etc.) assign values to variables.
- Comparison operators (==, !=, >, <, etc.) compare values and return a boolean result.
- Logical operators (&&, ||, !) combine or negate boolean expressions.

**Quick Quiz**

1. What is the result of the following expression: 5 + 3 * 2 - 1?
   Answer: 10

2. What does the '!=' operator do?
   Answer: It checks if two values are not equal.

3. What is the purpose of the '&&' operator?
   Answer: It returns true if both operands are true; otherwise, it returns false.

**Additional Resources**

- Operator precedence in programming: https://en.wikipedia.org/wiki/Order_of_operations#Programming_languages
- JavaScript Operators: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators
- Python Operators: https://www.w3schools.com/python/python_operators.asp

*Created on: 2024-07-29*


---
title: "Only Six  Operations"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the six fundamental operations that computers can perform.
- Recognize how these operations form the basis for all computational tasks.
- Identify examples of each operation in real-world scenarios.

**Introduction**

Having discussed problem-solving methodologies and pseudocode, this lesson focuses on the core capabilities of computers. It sets the stage for the following lessons, which delve into values, variables, and operators.

**Receive Information**
Computers can accept input from various sources, such as keyboards, mice, touchscreens, or sensors. This allows them to gather data and instructions necessary for processing. Input can be in the form of text, numbers, or even binary data.

**Output Information**
After processing data, computers can display results or send information to external devices. Common output methods include displaying text or graphics on a screen, printing documents, playing audio, or transmitting data over networks.

**Perform Arithmetic**
Computers excel at mathematical calculations. They can perform basic arithmetic operations like addition, subtraction, multiplication, and division with incredible speed and accuracy. These operations are fundamental to many computational tasks.

**Assign a value to a variable**
Variables are used to store and reference data in a program. Computers can assign specific values to variables, allowing for efficient data management and manipulation. This enables programs to keep track of changing data throughout execution.

**Compare to variables**
Computers can compare the values of two or more variables using relational operators. This allows for decision-making in programs, such as determining equality, greater than, or less than relationships between variables. Comparisons are crucial for controlling program flow and implementing conditional logic.

**Repeat a group of actions.**
Computers can execute a set of instructions repeatedly using loops. This allows for efficient processing of large amounts of data or performing iterative tasks. Loops enable computers to automate repetitive operations, saving time and effort compared to manual execution.

**Key Takeaways**

- Computers can receive information from various input sources.
- Output information is displayed or sent to external devices after processing.
- Arithmetic operations are performed with speed and accuracy.
- Variables store and reference data, enabling efficient manipulation.
- Comparing variables allows for decision-making and conditional logic.
- Repetition of actions is achieved through loops, automating tasks.

**Quick Quiz**

1. Which operation allows computers to gather data and instructions?
   Answer: Receive information

2. What is the purpose of assigning values to variables in a program?
   Answer: To store and reference data for efficient manipulation

3. How do loops contribute to efficient processing in computers?
   Answer: By executing a set of instructions repeatedly, automating repetitive tasks

**Additional Resources**

- Introduction to Computer Science: https://www.khanacademy.org/computing/computer-science/algorithms
- Computer Science Fundamentals: https://www.coursera.org/learn/computer-science-fundamentals
- Computer Science Basics: https://www.edx.org/course/computer-science-basics

*Created on: 2024-07-29*


---
title: "Variables"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand what variables are and why they are used in programming.
- Learn how to declare and assign values to variables.
- Recognize different data types that can be stored in variables.

**Introduction**



**Aim**
The aim of this lesson is to introduce the concept of variables and their role in programming.

**Context**
This lesson follows on from the discussion of values and precedes the explanation of variable names and operators. It forms part of the broader introduction to fundamental programming concepts.

**Key Takeaways**

- Variables are containers for storing data values.
- Variables must be declared with a specific data type and assigned a value before they can be used.
- Variables can store different data types, such as integers, floats, booleans, and strings.
- The value of a variable can be changed throughout the program.
- Meaningful variable names should be used to improve code readability.

**Quick Quiz**

1. What is a variable in programming?
   Answer: A variable is a container for storing a data value.

2. True or False: Variables must be declared before they can be used.
   Answer: True

3. Which of the following is NOT a common data type for variables?
A) Integer
B) Float
C) Boolean
D) Date
   Answer: D) Date

**Additional Resources**

- Variables in Python: https://www.w3schools.com/python/python_variables.asp
- JavaScript Variables: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Variables
- C++ Variables: https://www.tutorialspoint.com/cplusplus/cpp_variables.htm

*Created on: 2024-07-29*


---
title: "Rubber Duck"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---


**Learning Objectives**

- Understand the concept of rubber duck debugging and its role in problem-solving for programmers.
- Apply the rubber duck debugging technique to identify and resolve issues in code.
- Recognize the benefits of articulating code step-by-step in the debugging process.

**Introduction**

This lesson follows the "Problem Solving Methodology" and "State the Problem Clearly" lessons, providing a specific technique for addressing programming issues. It precedes the "Psuedocode" and "Psuedocode Example" lessons, which present another approach to problem-solving in programming.

**Bullet Point 1**
Rubber duck debugging is a technique where programmers explain their code, line by line, to an inanimate object, such as a rubber duck. This process helps them identify errors, inconsistencies, or areas for improvement in their code. By articulating the purpose and functionality of each line, programmers can often spot issues they might have overlooked during the coding process.

**Bullet Point 2**
The concept of rubber duck debugging is derived from a story in the book "The Pragmatic Programmer" by Andrew Hunt and David Thomas. In the book, a programmer carries around a rubber duck and explains his code to it, helping him solve problems more effectively. This anecdote has become a well-known reference in the programming community.

**Bullet Point 3**
Rubber duck debugging is a simple yet powerful technique that can be used by programmers of all skill levels. It encourages a systematic and thoughtful approach to problem-solving, as the act of explaining code step-by-step can help reveal gaps in logic or understanding. This technique can be particularly useful when dealing with complex or stubborn bugs.

**Bullet Point 4**
While the term "rubber duck debugging" specifically refers to the use of a rubber duck, the concept can be applied using any inanimate object or even a willing colleague. The key is to verbally explain the code in detail, as if teaching it to someone else. This process of externalization can help programmers better understand their own code and identify areas for improvement.

**Key Takeaways**

- Rubber duck debugging involves explaining code line by line to an inanimate object, such as a rubber duck.
- This technique helps programmers identify errors, inconsistencies, or areas for improvement in their code.
- Rubber duck debugging encourages a systematic and thoughtful approach to problem-solving.
- The process of externalization can help programmers better understand their own code.
- While a rubber duck is commonly referenced, any inanimate object or willing colleague can be used for this technique.

**Quick Quiz**

1. What is the primary goal of rubber duck debugging?
   Answer: To help programmers identify and resolve issues in their code by explaining it step-by-step.

2. True or False: Rubber duck debugging can only be done with an actual rubber duck.
   Answer: False. Any inanimate object or willing colleague can be used for this technique.

3. How does explaining code line by line help in the debugging process?
   Answer: It encourages a systematic and thoughtful approach, revealing gaps in logic or understanding.

**Additional Resources**

- The Pragmatic Programmer: From Journeyman to Master: https://www.goodreads.com/book/show/4099.The_Pragmatic_Programmer
- Rubber Duck Debugging: The Psychology of How It Works: https://www.thoughtfulcode.com/rubber-duck-debugging-psychology/
- Rubber Duck Problem Solving: https://rubberduckdebugging.com/

*Created on: 2024-07-29*


---
title: "Problem Solving Methodology"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to introduce a structured approach to problem-solving in the context of AI and machine learning.

**Context**
Having discussed the importance of problem-solving skills, this lesson breaks down a step-by-step methodology that can be applied to tackle challenges in AI and machine learning. The subsequent lessons will elaborate on some of these steps, such as stating the problem clearly and using pseudocode.

**State the problem clearly** Before attempting to solve a problem, it is crucial to have a clear understanding of what the problem is. This involves identifying the key issues, constraints, and desired outcomes. By stating the problem clearly, you can focus your efforts on finding the most appropriate solution.

**Describe the input and output** To develop an effective algorithm, you need to define the expected inputs and outputs. This includes specifying the data types, formats, and any constraints or assumptions. By clearly describing the input and output, you can ensure that your solution is compatible with the problem requirements.

**Work a simple example by hand** Before diving into complex algorithms, it is helpful to work through a simple example by hand. This allows you to break down the problem into smaller steps and gain a better understanding of the logic required. By manually solving a simple case, you can identify patterns and develop insights that will inform your algorithm design.

**Develop an algorithm** With a clear problem statement and an understanding of the inputs and outputs, you can now develop an algorithm to solve the problem. This involves outlining the step-by-step process for transforming the input into the desired output. The algorithm should be designed to handle various scenarios and edge cases efficiently.

**Convert to Python (or some other language)** Once you have developed an algorithm, the next step is to implement it in a programming language such as Python. This involves translating the algorithmic steps into code, taking into account the specific syntax and libraries of the chosen language. It is important to write clean, well-documented code that accurately reflects the algorithm.

**Test solution with a variety of data** After implementing the solution, it is crucial to test it with a diverse range of input data. This includes both typical cases and edge cases to ensure that the algorithm performs as expected. Testing helps identify any bugs, limitations, or areas for optimization. By thoroughly testing the solution, you can have confidence in its robustness and reliability.

---
title: "Variables"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to introduce the concept of variables and their role in programming.

**Context**
This lesson follows on from the discussion of values and precedes the explanation of variable names and operators. It forms part of the broader introduction to fundamental programming concepts.

---
title: "Can you"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to introduce the concept of algorithms and how they are expressed in programming.

**Context**
Following on from discussing problem-solving methodologies and pseudocode, this lesson explores the fundamental building blocks of algorithms and how they are translated into computer programs. It leads into the next topic of values, variables and operators.

**Break a problems down into simple actions**
To create an algorithm, you first need to break down a problem into a series of simple, clearly defined actions or steps. Each action should be a single, straightforward task that can be carried out without requiring further breakdown. This process of decomposition is crucial in designing effective algorithms.

**Actions carry out simple tasks**
Each action within an algorithm is responsible for carrying out a specific, simple task. These tasks are the basic building blocks of the algorithm and are typically very limited in scope. For example, an action might be to add two numbers together, compare two values, or store a piece of data.

**A set of actions is called an algorithm**
When you combine a series of actions together in a specific order to solve a problem or accomplish a task, you create an algorithm. An algorithm is essentially a step-by-step procedure or set of instructions that can be followed to achieve a desired outcome. Algorithms are used to solve a wide variety of problems in computer science and programming.

**Algorithms expressed as Pseudocode**
Pseudocode is a way of expressing algorithms using a simplified, informal language that is easy for humans to read and understand. It uses a combination of natural language and programming-like syntax to describe the steps of an algorithm. Pseudocode is not tied to any specific programming language and serves as a blueprint for the actual code.

**Coding is translating an algorithm to a program**
Once an algorithm has been designed and expressed in pseudocode, the next step is to translate it into an actual computer program using a programming language. This process, known as coding, involves writing instructions that the computer can execute using the specific syntax and rules of the chosen language. The programmer's goal is to accurately translate the algorithm into code that runs correctly and efficiently.

**Six operations a computer can do**
At their core, computers can only perform six fundamental operations: input, output, processing, branching, looping, and storing data. Every program, no matter how complex, is ultimately built upon these six basic operations. Understanding these operations and how they are combined to create algorithms is essential for effective programming.

---
title: "Relational Operators"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to introduce relational operators and their role in programming.

**Context**
This lesson follows on from the discussion of operators in general. It leads into the next lesson which tests the audience's understanding of the concepts covered.

---
title: "Operators"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
Introduce various operators used in programming and explain their purpose.

**Context**
After discussing variables and values, the next logical step is to introduce operators. These allow us to perform calculations and comparisons using the variables and values. The following lesson will go into more detail about relational operators specifically.

---
title: "Overview"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson introduces the agenda and key topics for the presentation on AI and machine learning.

**Context**
Following the opening lessons on copyright and acknowledgement of country, this lesson provides an overview of the presentation's contents. The subsequent lessons delve into problem-solving methodologies and introduce fundamental programming concepts.

---
title: "Next time"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to preview the key programming concepts that will be covered in the next lesson.

**Context**
After introducing fundamental concepts like problem-solving, pseudocode, variables, and operators, this lesson serves as a glimpse into the upcoming topics. It bridges the gap between the basic building blocks and the more advanced programming concepts that enable students to create functional programs.

**Making decisions**
In the next lesson, we will explore how computers make decisions based on certain conditions using control structures such as if-else statements and switch-case statements. These concepts allow programmers to create programs that can respond differently based on user input or other variables, enabling more dynamic and interactive software.

**Controlling the flow of a program** 
We will also discuss how to control the flow of a program using loops, such as for loops and while loops. These structures allow programmers to repeat a block of code multiple times, either for a specified number of iterations or until a certain condition is met. By mastering these concepts, students will be able to create more efficient and powerful programs.

---
title: "Computer can…"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to introduce the fundamental capabilities of computers in storing data and executing instructions.

**Context**
Having discussed problem-solving methodologies and pseudocode, this lesson transitions to the basic building blocks of computer programming. It lays the foundation for subsequent lessons on values, variables, and operators.

**Store Values**
Computers have the ability to store and retrieve data in their memory. This data can be in various forms such as numbers, text, or images. The computer allocates a specific location in its memory to hold each piece of data, allowing it to be accessed and manipulated as needed. Storing values is a crucial aspect of computer programming, as it enables the preservation and utilisation of data throughout the execution of a program.

**Perform Operations**
In addition to storing data, computers can execute a set of instructions, known as operations or computations, on that data. These operations can be arithmetic (such as addition, subtraction, multiplication, or division), logical (comparisons and conditional statements), or manipulations of the stored values (like combining or splitting text). By performing these operations, computers can process and transform data, solve complex problems, and generate meaningful outputs based on the provided instructions and data.

---
title: "Rubber Duck"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
Introduce the concept of "rubber duck debugging" as a problem-solving technique in programming.

**Context**
This lesson follows the "Problem Solving Methodology" and "State the Problem Clearly" lessons, providing a specific technique for addressing programming issues. It precedes the "Psuedocode" and "Psuedocode Example" lessons, which present another approach to problem-solving in programming.

**Bullet Point 1**
Rubber duck debugging is a technique where programmers explain their code, line by line, to an inanimate object, such as a rubber duck. This process helps them identify errors, inconsistencies, or areas for improvement in their code. By articulating the purpose and functionality of each line, programmers can often spot issues they might have overlooked during the coding process.

**Bullet Point 2**
The concept of rubber duck debugging is derived from a story in the book "The Pragmatic Programmer" by Andrew Hunt and David Thomas. In the book, a programmer carries around a rubber duck and explains his code to it, helping him solve problems more effectively. This anecdote has become a well-known reference in the programming community.

**Bullet Point 3**
Rubber duck debugging is a simple yet powerful technique that can be used by programmers of all skill levels. It encourages a systematic and thoughtful approach to problem-solving, as the act of explaining code step-by-step can help reveal gaps in logic or understanding. This technique can be particularly useful when dealing with complex or stubborn bugs.

**Bullet Point 4**
While the term "rubber duck debugging" specifically refers to the use of a rubber duck, the concept can be applied using any inanimate object or even a willing colleague. The key is to verbally explain the code in detail, as if teaching it to someone else. This process of externalization can help programmers better understand their own code and identify areas for improvement.

---
title: "Psuedocode Example"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to provide a concrete example of pseudocode to illustrate the concepts discussed in the previous lesson.

**Context**
Following the introduction to pseudocode, this lesson offers a practical demonstration of how pseudocode can be used to outline the logic and structure of a program. The example will help learners understand the application of the six basic operations and the use of variables, which will be covered in subsequent lessons.

---
title: "Only Six  Operations"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
Introduce the six fundamental operations that computers can perform, which form the basis for all computational tasks.

**Context**
Having discussed problem-solving methodologies and pseudocode, this lesson focuses on the core capabilities of computers. It sets the stage for the following lessons, which delve into values, variables, and operators.

**Receive Information**
Computers can accept input from various sources, such as keyboards, mice, touchscreens, or sensors. This allows them to gather data and instructions necessary for processing. Input can be in the form of text, numbers, or even binary data.

**Output Information**
After processing data, computers can display results or send information to external devices. Common output methods include displaying text or graphics on a screen, printing documents, playing audio, or transmitting data over networks.

**Perform Arithmetic**
Computers excel at mathematical calculations. They can perform basic arithmetic operations like addition, subtraction, multiplication, and division with incredible speed and accuracy. These operations are fundamental to many computational tasks.

**Assign a value to a variable**
Variables are used to store and reference data in a program. Computers can assign specific values to variables, allowing for efficient data management and manipulation. This enables programs to keep track of changing data throughout execution.

**Compare to variables**
Computers can compare the values of two or more variables using relational operators. This allows for decision-making in programs, such as determining equality, greater than, or less than relationships between variables. Comparisons are crucial for controlling program flow and implementing conditional logic.

**Repeat a group of actions.**
Computers can execute a set of instructions repeatedly using loops. This allows for efficient processing of large amounts of data or performing iterative tasks. Loops enable computers to automate repetitive operations, saving time and effort compared to manual execution.

---
title: "Psuedocode"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The purpose of this lesson is to introduce pseudocode as a tool for outlining the logic and steps of a solution to a problem, without being tied to specific programming language syntax.

**Context**
This lesson follows on from discussing problem-solving methodologies and precedes an example of pseudocode in action. It sits within the broader context of the presentation covering fundamental concepts in AI and machine learning, such as values, variables and operators.

**List the steps** Pseudocode involves listing out the sequential steps needed to solve a problem or implement an algorithm. By breaking down the solution into clear, ordered steps, it helps to clarify the logic and flow of the approach.

**Use short phrases (make it easier to convert)** When writing pseudocode, use concise, simple language rather than complete sentences. Short phrases make the pseudocode more readable and easier to convert into actual programming language code later on.

**No Syntax or rules** Pseudocode does not adhere to the strict syntax rules of programming languages. This allows the focus to remain on expressing the logic and sequence of the solution without getting bogged down in language specifics.

**Not a language (not compiled or executed)** Pseudocode is not an actual programming language that can be compiled or run. Its purpose is to communicate and plan the logic of a program in a human-readable way, not to be machine executable.

**Communication tool** One of the key roles of pseudocode is as a tool for communicating ideas between developers, team members and stakeholders. It provides a common language to discuss the logic and approach of a solution without requiring technical programming knowledge.

**Logic of the solution** Pseudocode captures the algorithmic thinking behind a solution - the logical steps, decisions, iterations, etc. It describes what needs to be done to solve the problem, rather than how to do it in a specific language.

**Translate into a programming language** Once the logic of a solution has been planned out in pseudocode, the next step is converting it into a chosen programming language. The pseudocode acts as a blueprint to guide the actual coding process.

---
title: "Problem Solving"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to introduce the concept of problem solving in the context of AI and machine learning.

**Context**
This lesson comes early in the presentation, following the introductory lessons on copyright information and acknowledgement of country. It sets the stage for discussing problem solving methodologies and techniques in subsequent lessons.

**Presenter Notes**
This lesson is intentionally left blank to allow the presenter to engage the audience and invite their thoughts on problem solving. The presenter may ask the audience to share examples of problems they have faced in their work or studies related to AI and machine learning. This interaction helps to make the topic more relevant and relatable for the audience.

The lack of bullet points also serves as a visual cue for the presenter to pause and reflect on the importance of problem solving as a fundamental skill in AI and machine learning. It provides an opportunity to emphasise that the ability to break down complex problems, identify key components, and develop systematic approaches is essential for success in this field.

The presenter can use this lesson to highlight that the upcoming lessons will delve into specific problem solving methodologies and techniques that are commonly used in AI and machine learning. This sets the expectation for the audience and helps to create a logical flow for the presentation.

---
title: "Variable Names"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
This lesson aims to provide guidelines for choosing appropriate variable names in programming.

**Context**
Having introduced the concept of variables in the previous lesson, this lesson delves into the specifics of naming variables effectively. The next lessons will cover operators and relational operators, building on the foundation of variables and their names.

**Descriptive Names** 
Variable names should be descriptive and meaningful, clearly indicating the purpose or content of the variable. For example, instead of using a generic name like "x", choose a name like "age" or "student_count" that conveys the variable's role in the program. Descriptive names enhance code readability and make it easier for other developers (or yourself in the future) to understand the code's intent.

**Consistent Naming Conventions**
Adopt a consistent naming convention throughout your codebase. Common conventions include camelCase (e.g., firstName), PascalCase (e.g., ClassName), or snake_case (e.g., student_id). Stick to the chosen convention to maintain uniformity and improve code clarity. Consistency in naming helps avoid confusion and makes the code more predictable and easier to follow.

**Avoid Reserved Keywords**
When choosing variable names, avoid using reserved keywords specific to the programming language you are using. Reserved keywords have predefined meanings and cannot be used as variable names. Examples of reserved keywords in various languages include "if", "while", "for", "class", etc. Familiarize yourself with the reserved keywords of the language you are working with to prevent naming conflicts and syntax errors.

**Keep Names Concise**
While variable names should be descriptive, they should also be concise. Aim for a balance between clarity and brevity. Avoid excessively long names that can make the code harder to read and maintain. Use abbreviations or acronyms judiciously and only when they are widely understood within the context of your project or domain. Striking the right balance ensures that variable names are informative without being cumbersome.

---
title: "State the Problem Clearly"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to emphasise the importance of clearly defining the problem when problem solving.

**Context**
This lesson follows on from an introduction to problem solving and the problem solving methodology. It precedes lessons that discuss specific problem solving techniques like rubber duck debugging and pseudocode.

---
title: "What are values?"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

**Aim**
The aim of this lesson is to introduce the different types of values that can be used in programming.

**Context**
This lesson follows on from the discussion of problem-solving methodology and pseudocode. It provides a foundation for understanding variables and operators, which will be covered in the subsequent lessons.

**Single Value** A single value is the simplest type of data that can be stored in a program. It represents a single piece of information, such as a number or a character. Single values are the building blocks of more complex data structures.

**Integer (count)** An integer is a whole number that can be positive, negative, or zero. Integers are commonly used for counting and indexing. They are represented by a fixed number of bits, which determines the range of values they can store.

**Float (measure)** A float, short for floating-point number, is used to represent decimal numbers. Floats are useful for measuring and calculating values that require precision, such as distances or weights. They are stored using a mantissa and an exponent, allowing for a wide range of values.

**Character** A character is a single letter, digit, punctuation mark, or symbol. Characters are typically represented by a single byte of memory and are used for storing and manipulating text data. They can be combined to form strings, which are sequences of characters.

**Boolean** A boolean is a data type that can have only two possible values: true or false. Booleans are used for logical operations and decision-making in programs. They are essential for controlling the flow of execution based on certain conditions.

---
title: "Forecasting Functions: Python's Weather Wizardry"
subtitle: "Coding up a storm with Python's powerful function features"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Copyright Information

![](../../../_assets/curtin-copy-right.png)

# Acknowledge of Country
I acknowledge the traditional custodians of the land on which I work and live,
and recognise their continuing connection to land, water and community. I pay
respect to elders past, present and emerging.

![](../../../_assets/ack_country.png)

# Today's Learning Outcomes
- Why we need functions
- Function syntax in Python
- Defining and calling functions
- Parameters and return values
- Creating functions
- What are modules and why use them?
- The import statement and its variations

::: {.notes}
**Aim**
The aim of this slide is to clearly outline the key learning objectives for the session, providing students with a roadmap of what they will learn about functions and modules in Python.

**Context**
This slide follows the Acknowledgement of Country and sets the stage for the rest of the presentation. The topics covered in the learning outcomes will be expanded upon in subsequent slides, such as "Why Functions?", "Function Syntax", and "What are modules and why use them?".

**Why we need functions**
Functions are a fundamental concept in programming that allow us to break down complex problems into smaller, more manageable tasks. They help us avoid repetition, make our code more readable and maintainable, and enable us to reuse code across different parts of a program or even across different projects.

**Function syntax in Python**
To define a function in Python, we use the `def` keyword followed by the function name, parentheses containing any parameters the function accepts, and a colon. The body of the function is indented below the definition line. To call a function, we simply write its name followed by parentheses containing any required arguments.

**Defining and calling functions**
When defining a function, we specify its name, parameters (if any), and the code that should be executed when the function is called. To call a function, we use its name followed by parentheses and provide any necessary arguments. This invokes the function and executes the code within its body.

**Parameters and return values**
Functions can accept parameters, which are values passed into the function when it is called. These parameters allow us to provide different data to the function each time it is called, making it more flexible and reusable. Functions can also return values using the `return` keyword, allowing them to pass data back to the caller.

**Creating functions**
To create a function, we start with the `def` keyword, followed by the function name and parentheses containing any parameters. We then write the code that the function should execute when called, indenting it below the definition line. It's important to choose descriptive names for functions and parameters to make the code more readable and self-explanatory.

**What are modules and why use them?**
Modules are files containing Python code that define functions, classes, and variables. They allow us to organize our code into logical, reusable units and help keep our main program files clean and concise. By using modules, we can break down complex programs into smaller, more manageable parts and easily import and reuse code across different projects.

**The import statement and its variations**
To use functions, classes, or variables defined in a module, we need to import the module into our main program. We do this using the `import` statement followed by the name of the module. There are several variations of the `import` statement, such as importing specific items from a module or renaming a module with an alias, which can help make our code more concise and avoid naming conflicts.
:::

# Why Functions?
- Reusability: Write once, reuse everywhere.
- Modularity: Break tasks into smaller parts.
- Abstraction: Simplify complex tasks easily.
- Organisation: Keep code clean and structured.
- Scalability: Grow programs with ease.
- Testing: Easier to test and fix..

#
![](images/Slide1.jpeg)

#
![](images/Slide2.jpeg)

#
![](images/Slide3.jpeg)

#
![](images/Slide4.jpeg)

#
![](images/Slide5.jpeg)

::: {.notes}
**Aim**
This slide aims to introduce the key benefits of using functions in programming, highlighting their importance in writing efficient, maintainable, and scalable code.

**Context**
After presenting the learning outcomes, this slide delves into the first major topic: functions. It sets the foundation for understanding functions before discussing their syntax and common built-in functions in Python. The slide also relates to the upcoming topic of modules, as functions are essential building blocks for creating and using modules effectively.

**Reusability: Write once, reuse everywhere.**
Functions allow you to write a block of code once and reuse it multiple times throughout your program. By encapsulating a specific task or operation into a function, you can call it whenever needed, saving time and effort in writing repetitive code. This reusability promotes code efficiency and maintainability, as you can make changes to the function in one place and have those changes propagate to all instances where the function is used.

**Modularity: Break tasks into smaller parts.**
Functions enable you to break down complex tasks into smaller, more manageable parts. By dividing a program into logical functions, each responsible for a specific subtask, you can improve the overall structure and readability of your code. Modular code is easier to understand, debug, and maintain, as you can focus on one function at a time without being overwhelmed by the entire program's complexity.

**Abstraction: Simplify complex tasks easily.**
Functions provide a level of abstraction by hiding the internal details of how a task is accomplished. When you use a function, you only need to know its purpose, input parameters, and expected output, without worrying about the underlying implementation. This abstraction simplifies the usage of complex operations, making your code more readable and allowing you to focus on the higher-level logic of your program.

**Organisation: Keep code clean and structured.**
Functions contribute to better code organisation by grouping related code together. By encapsulating specific tasks into functions, you can keep your main program clean and structured, with a clear flow of execution. Well-organised code is easier to navigate, understand, and maintain, especially as your programs grow in size and complexity.

**Scalability: Grow programs with ease.**
As your programs expand and evolve, functions facilitate scalability. You can easily add new features or modify existing functionality by creating new functions or updating existing ones, without disrupting the overall structure of your code. Functions allow you to build upon existing code, promoting code reuse and reducing duplication, making your programs more scalable and adaptable to changing requirements.

**Testing: Easier to test and fix.**
Functions make testing and debugging more manageable. By isolating specific tasks into functions, you can test each function independently, ensuring that it produces the expected output for various inputs. If a bug is identified, you can focus on fixing the specific function rather than searching through the entire codebase. This targeted testing and debugging approach saves time and effort in maintaining and improving the quality of your code.
:::

# Common Builtin Functions

| **Function** | **Purpose**                                              | **Example**                  |
|--------------|----------------------------------------------------------|------------------------------|
| `print()`    | Outputs data to the console                              | `print("Hello, World!")`     |
| `len()`      | Returns the length of an object                          | `len([1, 2, 3])`             |
| `int()`      | Converts a value to an integer                           | `int("42")`                  |
| `str()`      | Converts a value to a string                             | `str(42)`                    |
| `sum()`      | Returns the sum of all items               | `sum([1, 2, 3])`             |
| `range()`    | Generates a sequence of numbers                          | `range(5)`                   |
| `max()`      | Returns the largest item                  | `max(1, 2, 3)`               |
| `min()`      | Returns the smallest item                 | `min(1, 2, 3)`               |
| `input()`    | Reads a string from user input                           | `name = input("Enter your name: ")` |

::: {.notes}
**Aim**
The aim of this slide is to introduce students to some commonly used built-in functions in Python.

**Context**
After discussing the importance and benefits of functions, this slide highlights specific built-in functions that are readily available in Python. The following slides will cover function syntax and how to create reusable logic with functions.
:::

# Function Syntax
```python
def function_name(parameters):
    # Function body
    return value
```

::: {.notes}
**Aim**
Introduce the syntax for defining functions in Python.

**Context**
This slide follows the "Why Functions?" slide, which explains the benefits of using functions. It precedes the "Consider" slide, which likely provides examples or considerations for writing functions. The slide is part of a larger presentation on AI and machine learning that also covers topics like built-in functions and Python modules.

**Bullet Point 1**
The `def` keyword is used to define a function in Python. It is followed by the function name and parentheses `()`, which may contain parameters if the function accepts input values. After the parentheses, a colon `:` is used to indicate the start of the function block. The function body, which contains the code to be executed when the function is called, is indented below the function definition line.

**Bullet Point 2**
Function parameters are optional input values that can be passed to a function when it is called. They are defined within the parentheses `()` in the function definition. When a function is called with arguments, the values of the arguments are assigned to the corresponding parameters in the function definition. This allows functions to perform operations on different input values each time they are called.

**Bullet Point 3**
The `return` statement is used to specify the value that a function should output or "return" when it is finished executing. When a `return` statement is encountered in a function, the function execution stops, and the specified value is sent back to the point where the function was called. If no `return` statement is used, the function will return `None` by default. A function can have multiple `return` statements, but only one will be executed, depending on the conditions met within the function.
:::

# Consider
```python
temp = 25
humidity = 80

if temp > 30 and humidity > 70:
    print('Hot and humid')
elif temp < 0:
    print('Freezing')
else:
    print('Moderate')
```

::: {.notes}
**Aim**
To prompt the audience to consider the importance of refactoring repetitive code into reusable functions.

**Context**
This slide follows the introduction of functions and common built-in functions in Python. It sets the stage for discussing a specific example of refactoring weather-related logic into a reusable function, which leads into the topic of modules and their benefits.
:::

# Reusable Weather Logic

```python
def categorise_weather(temp, humidity):
    if temp > 30 and humidity > 70:
        return 'Hot and humid'
    elif temp < 0:
        return 'Freezing'
    else:
        return 'Moderate'
```
#
![](images/Slide18.jpeg)

#
![](images/Slide19.jpeg)

#
![](images/Slide20.jpeg)

#
![](images/Slide21.jpeg)

#
![](images/Slide22.jpeg)

#
![](images/Slide23.jpeg)

#
![](images/Slide24.jpeg)

#
![](images/Slide25.jpeg)

::: {.notes}
**Aim**
Explain the concept of reusable weather logic and how it can be implemented in Python code.

**Context**
Having covered the basics of functions and modules, this slide builds on that knowledge to show how those concepts can be applied to create reusable logic for a specific task, in this example, weather-related functionality. The next slides will cover common Python modules and how to import them using aliases.
:::

# What are modules and why use them?
- Modules are just Python files
- Modules help organize code
- Modules let you use code that others have written
- Python comes with useful modules
- You can also import specific functions or classes from a module using the `from` statement.
- Aliases can be used to refer to modules with a shorter name.
- Modules can be installed using package managers like `pip`.

::: {.notes}
**Aim**
The aim of this slide is to introduce the concept of modules in Python and explain their benefits for code organisation and reuse.

**Context**
This slide follows on from the discussion of functions in Python, building on the idea of code reuse and organisation. It leads into the next slide which covers some commonly used Python modules.

**Modules are just Python files** Modules in Python are simply regular Python files containing Python code. Any Python file can be treated as a module and imported into another Python program or script. This allows you to break up your code into smaller, more manageable pieces.

**Modules help organize code** As your Python projects grow larger, it becomes increasingly important to keep your code organised and maintainable. By splitting your code into separate modules based on functionality or purpose, you can make your codebase easier to navigate and understand. Each module can encapsulate related functions, classes, and variables.

**Modules let you use code that others have written** One of the great advantages of modules is the ability to leverage code written by other developers. You can import modules created by the Python community or your colleagues, saving time and effort by not having to write everything from scratch. This promotes code reuse and allows you to benefit from the expertise of others.

**Python comes with useful modules** Python comes with a rich standard library that includes a wide range of built-in modules. These modules provide functionality for common tasks such as file I/O, networking, string manipulation, and more. By using these built-in modules, you can quickly add powerful capabilities to your Python programs without the need for external dependencies.

**You can also import specific functions or classes from a module using the `from` statement.** In addition to importing an entire module, you can also import specific functions, classes, or variables from a module using the `from` keyword. This allows you to selectively import only the parts of a module that you need, which can help avoid naming conflicts and make your code more concise.

**Aliases can be used to refer to modules with a shorter name.** When importing modules, you can assign an alias to the module name using the `as` keyword. This is useful when dealing with modules that have long or cumbersome names. By assigning a shorter alias, you can refer to the module more conveniently throughout your code.

**Modules can be installed using package managers like `pip`.** While Python comes with a standard library, there are countless third-party modules available that extend Python's functionality. These modules can be easily installed using package managers like `pip`. With `pip`, you can quickly install, upgrade, and manage external modules, making it simple to expand your Python capabilities as needed.
:::

# Common Python Modules

| **Module**     | **Purpose**                                                                 | **Example**                              |
|----------------|-----------------------------------------------------------------------------|------------------------------------------|
| `os`           | Interacts with the operating system, file and directory operations          | `os.listdir()` lists files in a directory |
| `sys`          | Interacting with the Python runtime        | `sys.argv` retrieves command-line arguments |
| `math`         | Provides mathematical functions like trigonometry and logarithms            | `math.sqrt(16)` calculates square root    |
| `random`       | Implements pseudo-random number generators                                  | `random.randint(1, 10)` generates random integer |
| `pandas`       | Data manipulation and analysis      | `pandas.DataFrame()` creates a data table |
| `matplotlib`   | Generates plots and graphs for data visualisation                           | `matplotlib.pyplot.plot()` creates a line plot |
| `numpy`        | Large, multi-dimensional arrays and matrices, and mathematical functions | `numpy.array()` creates an array |

#
![](images/Slide8.jpeg)

#
![](images/Slide9.jpeg)

#
![](images/Slide10.jpeg)

#
![](images/Slide11.jpeg)

# What is an Alias?

An alias in Python is like a nickname for a module or library. It allows you to
use a shorter, more convenient name when referring to that module in your code.

Some of the most frequently used aliases in Python are:

- `import pandas as pd`
- `import numpy as np`
- `import matplotlib.pyplot as plt`

::: {.notes}
**Aim**
The aim of this slide is to introduce the concept of aliases in Python and demonstrate their usage with common module imports.

**Context**
This slide follows on from an introduction to Python modules and the `import` statement. It provides concrete examples of using aliases with popular Python modules before moving on to the learning outcomes for the session.

**`import pandas as pd`**
When importing the `pandas` module, it is common convention to alias it as `pd`. This allows you to reference the module using the shorter alias throughout your code. For example, instead of writing `pandas.DataFrame()`, you can simply use `pd.DataFrame()`. Using the `pd` alias for `pandas` is a widely adopted practice in the Python data science community.

**`import numpy as np`**
Similar to `pandas`, the `numpy` module is frequently aliased as `np`. This abbreviation makes it more convenient to work with `numpy` functionalities in your Python scripts. By importing `numpy` as `np`, you can access its functions and classes using the concise `np.` prefix. For instance, `np.array()` creates a new `numpy` array object.

**`import matplotlib.pyplot as plt`**
When working with the `matplotlib` library for data visualization, it is customary to import the `pyplot` module as `plt`. This alias allows you to easily create and customize plots using functions like `plt.plot()`, `plt.xlabel()`, and `plt.title()`. The `plt` alias is a well-established convention within the Python data visualization community.
:::

# Recall `import` Statement
![](images/Slide13.jpeg)

#
![](images/Slide14.jpeg)

#
![](images/Slide15.jpeg)

#
![](images/Slide16.jpeg)

::: {.notes}
**Aim**
Refresh understanding of the `import` statement and its role in accessing modules and functions.

**Context**
This slide follows the introduction to modules and common Python modules. It provides a quick review of the `import` statement syntax before moving on to learning outcomes and the next lecture.
:::

# Today's Learning Outcomes
- Why we need functions
- Function syntax in Python
- Defining and calling functions
- Parameters and return values
- Creating functions
- What are modules and why use them?
- The import statement and its variations

::: {.notes}
**Aim**
The aim of this slide is to outline the key learning objectives for the session, focusing on functions and modules in Python.

**Context**
This slide comes early in the presentation, following the "Acknowledgement of Country" and copyright information. It sets the stage for the subsequent slides that delve into the specifics of functions and modules, providing examples and demonstrations.

**Why we need functions** Functions allow us to break down complex tasks into smaller, more manageable pieces of code. By encapsulating a specific set of instructions within a function, we can reuse that code throughout our program without having to rewrite it each time. This promotes code reusability, modularity, and maintainability, making our programs more efficient and easier to understand.

**Function syntax in Python** In Python, a function is defined using the `def` keyword, followed by the function name and a set of parentheses containing any parameters the function may take. The function body is indented and contains the code that will be executed when the function is called. Functions can optionally return a value using the `return` statement.

**Defining and calling functions** To define a function, we use the `def` keyword, specify the function name, and include any necessary parameters. Once defined, we can call the function by its name followed by parentheses, passing in any required arguments. This allows us to execute the code within the function whenever needed.

**Parameters and return values** Functions can accept input values, known as parameters, which allow us to pass data into the function for processing. These parameters are specified within the parentheses in the function definition. Functions can also return values using the `return` statement, allowing us to pass data back to the calling code. This enables functions to perform calculations or operations and provide the results to other parts of the program.

**Creating functions** When creating functions, it's important to choose descriptive names that clearly indicate the purpose of the function. Functions should typically perform a single, well-defined task, following the principle of "separation of concerns." By keeping functions focused and modular, we can improve code readability, maintainability, and reusability.

**What are modules and why use them?** Modules in Python are files containing Python code that can be imported and used in other Python programs. They provide a way to organize related functions, classes, and variables into separate namespaces, promoting code modularity and reusability. By using modules, we can break down large programs into smaller, more manageable files, making the codebase easier to navigate and maintain.

**The import statement and its variations** To use functions or classes from a module, we need to import the module into our Python script. The `import` statement allows us to bring the contents of a module into our current namespace. We can import the entire module, specific functions or classes from the module, or use an alias to provide a different name for the imported module. This flexibility enables us to access the desired functionality from modules while avoiding naming conflicts.
:::

# Next time
- Input validation
- Exception handling

::: {.notes}
**Aim**
To preview upcoming topics in this AI and machine learning course, specifically input validation and exception handling.

**Context**
After covering many core concepts such as functions, modules, and aliasing, this final slide looks ahead to the next session. It introduces two important programming practices to make code more robust and reliable.

**Input Validation** Input validation involves checking data from external sources to ensure it is of the expected type and format before using it. This prevents errors caused by invalid or malicious inputs. Validation can check data type, length, range, format, or presence of required values. Proper validation makes programs more secure and less prone to crashing or misbehaving due to bad data.

**Exception Handling** Exceptions are errors that occur during program execution. Exception handling uses try/except blocks to gracefully manage these runtime errors without abruptly terminating the program. The code to handle expected exceptions is placed in the try block. If an exception occurs, control transfers to the except block to run appropriate error-handling code. This allows logging errors, alerting the user, retrying operations or safely shutting down instead of crashing.
:::



---
title: "API Basics for Python Programmers"
subtitle: "Understanding APIs with Weather Examples"
author: "Michael Borck"
execute:
  echo: false
jupyter: python3
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Copyright Information

![](../../../_assets/curtin-copy-right.png)

# Acknowledge of Country
I acknowledge the traditional custodians of the land on which I work and live,
and recognise their continuing connection to land, water and community. I pay
respect to elders past, present and emerging.

![](../../../_assets/ack_country.png)

# Today's Overview
- Introduction to APIs
- Understanding the Web
- URLs and Endpoints
- HTTP Methods
- Working with JSON Data
- Python's `requests` Library
- Building a Simple Weather App

::: {.notes}
**Aim**
The aim of this slide is to provide an overview of the key topics that will be covered in today's presentation on APIs and machine learning.

**Context**
This slide follows the "Acknowledgement of Country" and "Copyright Information" slides, setting the stage for the main content of the presentation. The topics listed on this slide will be expanded upon in the subsequent slides, providing a more in-depth understanding of APIs and their role in machine learning.

**Introduction to APIs**
APIs, or Application Programming Interfaces, are a fundamental concept in modern software development. They allow different software systems to communicate and exchange data with each other, enabling developers to build more complex and feature-rich applications by leveraging existing services and functionality.

**Understanding the Web**
To fully grasp the concept of APIs, it's essential to have a basic understanding of how the web works. This includes familiarity with the client-server model, the role of web browsers and servers, and the various protocols used for communication, such as HTTP and HTTPS.

**URLs and Endpoints**
URLs (Uniform Resource Locators) are a crucial component of APIs, as they specify the location of the resources being accessed. Endpoints are the specific URLs that an API exposes for different functionalities, allowing developers to interact with the API by making requests to these endpoints.

**HTTP Methods**
HTTP (Hypertext Transfer Protocol) is the foundation of data communication on the web. Understanding the different HTTP methods, such as GET, POST, PUT, and DELETE, is essential for working with APIs effectively, as these methods determine the type of operation being performed on the server.

**Working with JSON Data**
JSON (JavaScript Object Notation) is a lightweight data interchange format that is widely used in APIs. It provides a structured way to represent data in a human-readable and machine-parsable format, making it easy to transmit data between different systems and languages.

**Python's `requests` Library**
Python's `requests` library is a powerful tool for making HTTP requests and interacting with APIs. It simplifies the process of sending requests, handling responses, and working with JSON data, making it an essential library for any Python developer working with APIs.

**Building a Simple Weather App**
To demonstrate the practical application of APIs, the presentation will guide attendees through the process of building a simple weather app using a weather API. This hands-on example will showcase how to make API requests, handle responses, parse JSON data, and display the retrieved information in a user-friendly manner.
:::

# What is an API?
- **API** stands for **Application Programming Interface**
- It allows different software applications to communicate
- Think of it as a **bridge** between your code and external services

::: {.notes}
**Aim**
This slide aims to introduce the concept of an API, explaining what it is and how it facilitates communication between different software applications.

**Context**
After providing an overview of the presentation, this slide serves as the starting point for diving into the world of APIs. It lays the foundation for subsequent slides that will explore key concepts related to APIs, such as URLs, endpoints, HTTP methods, and RESTful architecture.

**API stands for Application Programming Interface**
An Application Programming Interface, or API, is a set of rules, protocols, and tools that define how different software components should interact with each other. It acts as a contract between the provider of a service and the developer who wants to use that service, specifying the types of requests that can be made, the data formats that should be used, and the conventions to follow.

**It allows different software applications to communicate**
The primary purpose of an API is to enable communication between different software applications. It provides a way for applications to share data and functionality, even if they are built using different programming languages or running on different platforms. By exposing a well-defined interface, an API allows developers to integrate external services into their own applications without needing to understand the internal workings of those services.

**Think of it as a bridge between your code and external services**
A helpful analogy for understanding APIs is to think of them as bridges connecting your code to external services. Just as a physical bridge allows people and vehicles to cross from one side to the other, an API acts as a bridge that enables your application to send requests to external services and receive responses back. It provides a structured way for your code to interact with and leverage the functionality provided by those services, making it easier to build powerful and feature-rich applications.
:::

# Understanding the Web
- The **Web** is a network of interconnected documents and resources
- **Clients** (like your Python script) request resources from **servers**
- Communication happens over the **Internet**

::: {.notes}
**Aim**
This slide aims to provide a high-level overview of how the Web works, introducing key concepts such as clients, servers, and the Internet.

**Context**
Before diving into the specifics of APIs, it's important to establish a foundational understanding of the Web. This slide sets the stage for subsequent slides that cover topics like URLs, endpoints, and HTTP methods, which are essential for working with APIs effectively.

**The Web is a network of interconnected documents and resources**
The Web, short for World Wide Web, is a vast network of linked documents and resources, such as web pages, images, videos, and more. These resources are connected through hyperlinks, allowing users to navigate from one resource to another seamlessly. The Web has revolutionised the way we access and share information, making it possible to retrieve data from servers located anywhere in the world.

**Clients (like your Python script) request resources from servers**
In the context of the Web, clients are the devices or software applications that request resources from servers. A common example of a client is a web browser, but in the case of this presentation, we'll be focusing on using Python scripts as clients. When a client sends a request to a server, it specifies the resource it wants to access using a URL (Uniform Resource Locator). The server then processes the request and sends back the requested resource or an appropriate response.

**Communication happens over the Internet**
The Internet is the global network infrastructure that enables communication between clients and servers. When a client sends a request to a server, the request travels through a series of interconnected networks, known as the Internet, to reach the server. The server then sends its response back to the client using the same network infrastructure. This communication is made possible by a set of standardised protocols, such as HTTP (Hypertext Transfer Protocol), which define the rules for data exchange between clients and servers.
:::

# Key Concept: URLs
- **URL** stands for **Uniform Resource Locator**
- It's the address used to access resources on the Web
- Example: `https://api.openweathermap.org/data/2.5/weather`

::: {.notes}
**Aim**
The aim of this slide is to introduce the concept of URLs and explain their role in accessing resources on the Web.

**Context**
After discussing the fundamentals of APIs and the Web, this slide focuses on URLs as a key concept. It sets the stage for the following slides that delve into the anatomy of URLs and how they relate to endpoints in RESTful APIs.

**URL stands for Uniform Resource Locator**
A URL is a standardised naming convention used to identify and locate resources on the internet. It provides a consistent and uniform way to reference web pages, images, videos, and other types of content accessible via the internet.

**It's the address used to access resources on the Web**
Just like a physical address helps you locate a specific building or residence, a URL acts as the address for a resource on the Web. By entering a URL into a web browser, you can navigate to and access the corresponding resource, such as a web page, image, or API endpoint.

**Example: `https://api.openweathermap.org/data/2.5/weather`**
This example URL demonstrates a typical structure. It starts with the protocol (`https://`), followed by the domain name (`api.openweathermap.org`), and then the path to the specific resource (`/data/2.5/weather`). In this case, the URL points to the weather endpoint of the OpenWeatherMap API, which can be used to retrieve current weather data for a specified location.
:::

# Anatomy of a URL
- **Scheme:** `https://`
- **Domain:** `api.openweathermap.org`
- **Path:** `/data/2.5/weather`
- **Query Parameters:** `?q=London&units=metric&appid=YOUR_API_KEY`

::: {.notes}
**Aim**
To break down the structure of a URL and explain the purpose of each component, using a real-world API example.

**Context**
This slide follows the "Key Concept: URLs" slide, which introduced the importance of URLs in web communication. It precedes the "Understanding Endpoints" slide, which will build upon the knowledge of URL components to explain how APIs use specific endpoints for different functionality.

**Scheme: `https://`**
The scheme specifies the protocol used to access the resource on the web. In this example, `https://` indicates that the Hypertext Transfer Protocol Secure (HTTPS) is being used, which provides an encrypted and secure connection between the client and the server.

**Domain: `api.openweathermap.org`**
The domain represents the unique address of the website or API provider on the internet. It consists of the subdomain (`api`), the second-level domain (`openweathermap`), and the top-level domain (`.org`). In this case, `api.openweathermap.org` points to the API server of the OpenWeatherMap service.

**Path: `/data/2.5/weather`**
The path specifies the location of the resource within the website or API. It can include multiple segments separated by forward slashes. In the given example, `/data/2.5/weather` indicates that we are accessing the current weather data endpoint of the OpenWeatherMap API, with version 2.5.

**Query Parameters: `?q=London&units=metric&appid=YOUR_API_KEY`**
Query parameters are used to pass additional information to the API server. They are appended to the URL after a question mark (`?`) and consist of key-value pairs separated by ampersands (`&`). In this example:
- `q=London` specifies the location for which we want to retrieve weather data.
- `units=metric` sets the units of measurement to metric.
- `appid=YOUR_API_KEY` is used for authentication, where `YOUR_API_KEY` should be replaced with the actual API key provided by OpenWeatherMap.
:::

# Understanding Endpoints
- An **Endpoint** is a specific URL where APIs can be accessed
- Each endpoint corresponds to a specific function
- Example: `/weather` for current weather data

::: {.notes}
**Aim**
The aim of this slide is to introduce the concept of endpoints in the context of APIs and explain their role in accessing specific functions.

**Context**
Having covered the fundamentals of APIs and the web, including URLs, this slide dives deeper into the structure of APIs by examining endpoints. This lays the groundwork for understanding how to interact with APIs using different HTTP methods, which will be covered in the next slide.

**An Endpoint is a specific URL where APIs can be accessed**
An API endpoint is a unique URL that serves as the entry point for accessing a particular API. When you make a request to an API, you send that request to a specific endpoint. The endpoint URL contains the base URL of the API, followed by the path to the specific resource or functionality you want to access. For example, if the base URL of an API is `https://api.example.com`, an endpoint for retrieving weather data might be `https://api.example.com/weather`.

**Each endpoint corresponds to a specific function**
Each endpoint within an API is designed to perform a specific function or provide access to a particular resource. APIs often have multiple endpoints, each serving a different purpose. For instance, an API for a weather service might have separate endpoints for retrieving current weather data, fetching a five-day forecast, or accessing historical weather information. By making requests to these specific endpoints, you can retrieve the desired data or perform the corresponding actions.

**Example: `/weather` for current weather data**
To illustrate the concept of endpoints, let's consider an example. In a weather API, there might be an endpoint specifically for retrieving the current weather data. This endpoint could be represented by the path `/weather`. To access the current weather information, you would make a request to the complete URL, such as `https://api.example.com/weather`. This endpoint would respond with the relevant data, such as temperature, humidity, wind speed, and other current weather conditions for a specified location.
:::

# HTTP Methods
- **GET:** Retrieve data
- **POST:** Send data
- **PUT:** Update data
- **DELETE:** Remove data
- **Example:** Using GET to fetch weather information

::: {.notes}
**Aim**
This slide aims to introduce the core HTTP methods used in interacting with APIs, focusing on their primary functions.

**Context**
Having covered the basics of APIs, URLs, and endpoints, this slide delves into the specific HTTP methods employed when making API requests. It lays the foundation for understanding RESTful APIs and sets the stage for practical examples using Python's `requests` library in subsequent slides.

**GET: Retrieve data**
The GET method is used to retrieve data from an API. When a GET request is sent to a specific endpoint, the API returns the requested information without modifying any data on the server. GET requests are the most common type of API request and are used when you need to fetch data, such as retrieving weather information or user profiles.

**POST: Send data**
The POST method is used to send data to an API for creating new resources. When you want to submit data to an API, such as creating a new user account or posting a comment, you would send a POST request to the appropriate endpoint. The data being sent is typically included in the request body and processed by the API to create a new resource on the server.

**PUT: Update data**
The PUT method is used to update existing data through an API. When you need to modify a specific resource, you send a PUT request to the corresponding endpoint, along with the updated data in the request body. The API then processes the request and updates the resource on the server accordingly. PUT requests are idempotent, meaning that multiple identical requests will have the same effect as a single request.

**DELETE: Remove data**
The DELETE method is used to remove or delete a resource via an API. When you send a DELETE request to a specific endpoint, the API processes the request and deletes the corresponding resource from the server. DELETE requests are typically used when you want to remove data permanently, such as deleting a user account or removing a blog post.

**Example: Using GET to fetch weather information**
To illustrate the usage of the GET method, consider an example where you want to fetch weather information from an API. You would send a GET request to the API's weather endpoint, specifying the necessary parameters such as location or date. The API would then process the request and return the requested weather data in the response, which you can parse and use in your application.
:::

# RESTful APIs
- **REST** stands for **Representational State Transfer**
- A common architectural style for APIs
- Uses standard HTTP methods and status codes

::: {.notes}
**Aim**
The aim of this slide is to introduce RESTful APIs and explain their key characteristics.

**Context**
Having covered the basics of APIs, HTTP methods, and URLs in the previous slides, this slide focuses on RESTful APIs specifically. It serves as a foundation for understanding how to interact with APIs using Python's `requests` library in the upcoming slides.

**REST stands for Representational State Transfer**
REST is an architectural style that defines a set of constraints for designing networked applications. It relies on a stateless, client-server communication protocol, typically HTTP. RESTful APIs expose a set of resources that can be accessed and manipulated using standard HTTP methods.

**A common architectural style for APIs**
RESTful APIs have become the most popular and widely adopted style for building web APIs. They provide a simple, scalable, and uniform interface for interacting with web services. Many popular web services, such as Twitter, GitHub, and Google Maps, provide RESTful APIs for developers to access their functionality and data.

**Uses standard HTTP methods and status codes**
RESTful APIs leverage the existing HTTP methods (GET, POST, PUT, DELETE) to perform operations on resources. Each method has a specific purpose: GET for retrieving data, POST for creating new resources, PUT for updating existing resources, and DELETE for removing resources. Additionally, RESTful APIs use standard HTTP status codes to indicate the success or failure of a request, such as 200 (OK), 201 (Created), 400 (Bad Request), and 404 (Not Found).
:::

# Data Formats: JSON
- **JSON** stands for **JavaScript Object Notation**
- A lightweight data-interchange format
- Easy to read and write for humans and machines
- Example:
  ```json
  {
    "temp": 20,
    "unit": "Celsius",
    "condition": "Sunny"
  }
  ```

::: {.notes}
**Aim**
The purpose of this slide is to introduce JSON as a lightweight data format and explain its key characteristics and readability for both humans and machines.

**Context**
Following the discussion of RESTful APIs and data formats in the previous slides, this slide focuses specifically on JSON. It will be followed by slides demonstrating how to use Python's `requests` library to make API requests and parse JSON responses.

**JSON stands for JavaScript Object Notation**
JSON, which is short for JavaScript Object Notation, is a popular data format used for exchanging data between web services and applications. Despite its name, JSON is language-independent and can be used with various programming languages, not just JavaScript.

**A lightweight data-interchange format**
JSON is designed to be a lightweight and efficient format for transmitting structured data over a network. Its simplicity and small file size make it ideal for web applications and APIs where fast data transfer is crucial. JSON files are plain text, which contributes to their lightweight nature.

**Easy to read and write for humans and machines**
One of the key advantages of JSON is its readability. JSON uses a simple and intuitive syntax that closely resembles JavaScript object notation. This makes it easy for developers to read, write, and understand JSON data. At the same time, JSON's structured format allows machines to parse and generate JSON data effortlessly.

**Example:**
To illustrate the structure and readability of JSON, an example is provided on the slide. The example demonstrates how data can be represented as key-value pairs and arrays in JSON format. This helps the audience visualise what JSON data looks like and understand its hierarchical nature.
:::

# Introduction to Python's `requests` Library
- `requests` is a powerful HTTP library in Python
- Simplifies making API calls
- Installation:
  ```bash
  pip install requests
  ```

::: {.notes}
**Aim**
The aim of this slide is to introduce the `requests` library in Python and highlight its key features for making HTTP requests.

**Context**
Having covered the fundamentals of APIs, HTTP methods, and data formats like JSON, this slide focuses on the practical aspect of interacting with APIs using Python. It sets the stage for the upcoming slides that demonstrate how to use `requests` for making API calls and handling responses.

**`requests` is a powerful HTTP library in Python**
The `requests` library is a widely-used and feature-rich library in Python for making HTTP requests. It provides a simple and intuitive interface for sending GET, POST, PUT, DELETE, and other types of requests to web servers. With `requests`, developers can easily interact with APIs, fetch data from websites, and send data to remote servers.

**Simplifies making API calls**
One of the key advantages of using `requests` is that it abstracts away the complexities of making HTTP requests. It handles low-level details such as establishing connections, encoding request data, and handling cookies and authentication. This allows developers to focus on the high-level logic of their application without worrying about the intricacies of the HTTP protocol.

**Installation:**
To start using the `requests` library, you need to install it in your Python environment. The easiest way to install `requests` is by using `pip`, the package installer for Python. You can install `requests` by running the following command in your terminal or command prompt:

```
pip install requests
```

Once installed, you can import the `requests` library in your Python scripts and start making HTTP requests.
:::

# Making Your First API Request
```python
import requests

response = requests.get("https://api.openweathermap.org/data/2.5/weather", params={
    "q": "London",
    "units": "metric",
    "appid": "YOUR_API_KEY"
})
print(response.status_code)
```

- **Status Code 200:** Success

::: {.notes}
**Aim**
The aim of this slide is to introduce the concept of a successful API request and the meaning of the HTTP status code 200.

**Context**
After covering the basics of APIs, HTTP methods, and RESTful APIs, this slide focuses on making the first API request using Python's `requests` library. It leads into subsequent slides that cover handling API responses, parsing JSON data, and practical examples using a weather API.

**Status Code 200: Success**
When making an API request, the server will respond with an HTTP status code indicating the outcome of the request. A status code of 200 means that the request was successful, and the server has returned the requested data. This is the ideal response you want to see when interacting with an API, as it confirms that your request was properly formatted and the API was able to process it without any issues. In the upcoming examples, we'll demonstrate how to check the status code of an API response using Python's `requests` library and handle different status codes gracefully.
:::

# Making Data More Readable with `pprint`

- **`pprint`** stands for **Pretty Print**
- Part of Python's built-in `pprint` module
- Enhances the readability of complex data structures
- Especially useful for:
  - **JSON responses** from APIs
  - **Nested dictionaries** and **lists**

::: {.notes}
**Aim**
The aim of this slide is to introduce the `pprint` module in Python and explain how it can be used to improve the readability of complex data structures.

**Context**
This slide follows on from the discussion of data formats like JSON and how to make API requests using Python's `requests` library. It provides a useful tool for handling the often complex and nested data returned by APIs, before moving on to parsing JSON responses and practical examples using a weather API.

**`pprint` stands for Pretty Print**
The `pprint` module in Python is short for "pretty print". Its purpose is to format and display complex data structures in a more readable and visually appealing way. By using `pprint`, you can make your code output easier to understand and debug, especially when working with large or deeply nested data.

**Part of Python's built-in `pprint` module**
`pprint` is a built-in module in Python, which means you don't need to install any additional libraries to use it. To start using `pprint` in your Python code, you simply need to import it at the beginning of your script with `import pprint`. This makes it a convenient tool that's always available in your Python environment.

**Enhances the readability of complex data structures**
The main benefit of using `pprint` is that it enhances the readability of complex data structures. When you print a dictionary or a list using the standard `print()` function, the output can be difficult to read, especially if the data is nested or contains long strings. `pprint` formats the data with indentation and line breaks, making it much easier to see the structure and content of the data.

**Especially useful for JSON responses from APIs**
`pprint` is particularly handy when working with JSON data returned by APIs. API responses often contain deeply nested dictionaries and lists, which can be challenging to read and understand using the standard `print()` function. By using `pprint` to display the JSON data, you can quickly get a clear picture of the structure and content of the response, making it easier to extract the information you need.

**Especially useful for nested dictionaries and lists**
In addition to JSON data, `pprint` is useful for displaying any complex data structure in Python, such as nested dictionaries and lists. When you have data with multiple levels of nesting, `pprint` can help you visualise the hierarchy and relationships between the different elements. This is especially valuable when debugging or trying to understand the structure of your data.
:::

# Handling API Responses
- **Response Object** contains data from the server
- Access response content:
  ```python
  from pprint import pprint
  data = response.json()
  print(data)
  ```
- Handle errors gracefully

::: {.notes}
**Aim**
The aim of this slide is to explain how to handle the response received from an API and access the data it contains.

**Context**
After learning how to make API requests using Python's `requests` library and format the response data with `pprint`, the next step is to understand how to handle the response object and extract the relevant data. This slide builds on the previous concepts and sets the stage for parsing JSON data in the following slide.

**Response Object contains data from the server**
When you make an API request, the server sends back a response object that contains the data you requested. This response object is a crucial part of working with APIs, as it holds the information you need to process and use in your application. The response object includes not only the data itself but also metadata such as the status code, headers, and more.

**Access response content:**
To access the actual data within the response object, you need to know how to retrieve it properly. Depending on the format of the data (e.g., JSON, XML), you'll use different methods to extract the content. For example, if the API returns JSON data, you can use the `response.json()` method to parse the JSON and convert it into a Python dictionary or list. This allows you to easily access and manipulate the data in your Python code.

**Handle errors gracefully**
When working with APIs, it's important to handle errors gracefully. API requests can fail for various reasons, such as invalid requests, authentication issues, or server-side problems. By implementing proper error handling, you can catch and manage these errors to prevent your application from crashing or behaving unexpectedly. This involves checking the response status code and using try-except blocks to handle exceptions that may occur during the API request or data parsing process.
:::

# Parsing JSON in Python

```python
data = response.json()
temperature = data['main']['temp']
condition = data['weather'][0]['description']
print(f"Temperature: {temperature}°C, Condition: {condition}")
```

- Extract specific information from the response

::: {.notes}
**Aim**
This slide aims to explain how to extract specific information from a JSON response using Python.

**Context**
After learning about JSON data format and making API requests using Python's `requests` library, this slide focuses on parsing the JSON response to extract the desired information. The following slides will demonstrate this concept with a practical example using a weather API.

**Extract specific information from the response**
Once you have made an API request and received a JSON response, you often need to extract specific pieces of information from the structured data. Python's built-in `json` module allows you to parse the JSON response and access the data using dot notation or square bracket notation, depending on whether you're working with an object or an array. By carefully examining the structure of the JSON response, you can navigate through the hierarchy of data and retrieve the values you need for your application.
:::

# Weather API Example: Current Weather

```python
import requests

location='New York'
api_key = "YOUR_API_KEY_HERE"
api_url = f'http://api.openweathermap.org/data/2.5/weather?q={location}&appid={api_key}'
response = requests.get(api_url)
weather = response.json()

print(f"Current temperature in New York: {weather['main']['temp']}°C")
print(f"Condition: {weather['weather'][0]['description']}")
```

::: {.notes}
**Aim**
This slide demonstrates how to retrieve current weather data using a weather API, showcasing a practical application of API usage in Python.

**Context**
Having covered the fundamentals of APIs, HTTP methods, and data formats like JSON, this slide presents a concrete example of using a weather API to fetch current weather information. It builds upon the knowledge gained from previous slides and sets the stage for the upcoming example of retrieving a 5-day forecast.
:::

# Weather API Example: 5-Day Forecast

```python
import requests

city = 'New York'
api_key = "YOUR_API_KEY_HERE"
forecast_url = f'http://api.openweathermap.org/data/2.5/forecast?q={city}&appid={api_key}'
response = requests.get(api_url)
forecast = response.json()

for entry in forecast['list']:
    date = entry['dt_txt']
    temp = entry['main']['temp']
    condition = entry['weather'][0]['description']
    print(f"Date: {date}, Temp: {temp}°C, Condition: {condition}")
```

::: {.notes}
**Aim**
This slide demonstrates how to retrieve a 5-day weather forecast using a weather API, building upon the previous example of fetching the current weather.

**Context**
After introducing the concept of APIs, explaining key terms, and demonstrating how to make a basic API request to retrieve the current weather, this slide expands on that knowledge by showing how to fetch a 5-day forecast. This example leads into the subsequent slides on error handling, authentication, and building a simple weather app.
:::

# Error Handling in API Requests

```python
import requests

try:
    response = requests.get(api_url, params=params)
    response.raise_for_status()
    data = response.json()
except requests.exceptions.HTTPError as err:
    print(f"HTTP error occurred: {err}")
except Exception as err:
    print(f"An error occurred: {err}")
```

- Always handle potential errors to prevent crashes

::: {.notes}
**Aim**
The aim of this slide is to emphasise the importance of implementing error handling when making API requests to ensure the stability and reliability of your application.

**Context**
This slide follows the introduction to making API requests using Python's `requests` library and handling API responses. It precedes slides on authenticating with APIs and building a simple weather app, providing a critical consideration for developing robust API-based applications.

**Always handle potential errors to prevent crashes**
When making API requests, it's crucial to anticipate and handle potential errors that may occur. These errors can range from network issues to invalid requests or server-side problems. By implementing proper error handling, you can gracefully manage these situations and prevent your application from crashing unexpectedly. Use try-except blocks to catch and handle exceptions, display informative error messages to users, and implement fallback mechanisms or retry logic when appropriate. By proactively handling errors, you enhance the reliability and user experience of your application.
:::

# Authenticating with APIs

- Many APIs require **API Keys** for access
- Obtain an API key by signing up with the service
- Include the key in your requests

::: {.notes}
**Aim**
This slide aims to explain the process of authenticating with APIs, which often requires obtaining and using API keys to access the service.

**Context**
After introducing APIs, how they work, and how to make requests using Python's `requests` library, this slide focuses on the important aspect of authentication. It leads into the next slides on securely managing API keys and building a practical weather app using an authenticated API.

**Many APIs require API Keys for access** 
To protect their services and manage access, many API providers require users to obtain an API key. This key acts as a unique identifier and allows the API provider to track and control how their service is being used. Without a valid API key, requests to the API may be rejected or limited in functionality.

**Obtain an API key by signing up with the service**
To get an API key, you typically need to sign up for an account with the API provider. This process usually involves providing some basic information and agreeing to their terms of service. Once you have an account, you can generate or request an API key through their developer portal or API management dashboard.

**Include the key in your requests**
Once you have obtained an API key, you need to include it in your API requests to authenticate yourself and gain access to the service. The exact method of including the API key varies between different APIs. Common approaches include adding the key as a query parameter in the URL, including it in the request headers, or sending it in the request body. It's important to refer to the API documentation for specific instructions on how to include the API key in your requests.
:::

# Building a Simple Weather App

1. **Get User Input:** Ask for a city name
2. **Make API Request:** Fetch current weather
3. **Display Results:** Show temperature and condition

```python
import requests

city = input("Enter city name: ")
api_url = "https://api.openweathermap.org/data/2.5/weather"
params = {
    "q": city,
    "units": "metric",
    "appid": "YOUR_API_KEY"
}

response = requests.get(api_url, params=params)
weather = response.json()

print(f"Current temperature in {city}: {weather['main']['temp']}°C")
print(f"Condition: {weather['weather'][0]['description']}")
```

::: {.notes}
**Aim**
The aim of this slide is to demonstrate how to build a simple weather app using the concepts and techniques covered in the presentation.

**Context**
This slide builds upon the knowledge gained from previous slides about APIs, data formats, Python libraries, and handling API responses. It serves as a practical example that ties together the concepts covered throughout the presentation, allowing the audience to see how they can be applied to create a functional weather app.
:::

# Secure API Key Management

* Why
  - Protect Your Account
  - Avoid Accidental Exposure
  - Maintain Control
 
* Best Practices for API Key Management
  - Never Hardcode API Keys
  - Use External Files or Prompts
  - Exclude Secrets from Version Control

::: {.notes}
**Aim**
This slide aims to educate the audience on the importance of securely managing API keys and provide practical methods to protect sensitive information.

**Context**
Having learned about APIs, making requests, and handling responses, it is crucial to address the security aspects of using APIs. This slide serves as a bridge between the technical understanding of APIs and the best practices for securely managing API keys, leading to the practical implementation of secure key management in the subsequent slides.

**Protect Your Account**
API keys are like passwords for your account, granting access to sensitive data and functionality. Protecting your API keys is essential to maintain the security of your account and prevent unauthorised access. Treat your API keys with the same level of confidentiality as you would with your passwords.

**Avoid Accidental Exposure**
Accidentally exposing your API keys can have serious consequences, such as allowing others to make requests on your behalf or incurring unexpected charges. It is crucial to be cautious when handling API keys and ensure they are not inadvertently shared or made public, especially in code snippets or public repositories.

**Maintain Control**
Keeping your API keys secure gives you control over who can access your account and the associated resources. If your API keys are compromised, it is important to revoke them immediately and generate new ones. Regularly rotating your API keys adds an extra layer of security and helps maintain control over your account.

**Never Hardcode API Keys**
Hardcoding API keys directly into your source code is a dangerous practice. If your code is version-controlled or shared, anyone with access to the code repository can easily find and misuse your API keys. Instead, use alternative methods to store and access your API keys securely.

**Use External Files or Prompts**
One recommended approach is to store API keys in external files, such as configuration files or environment variables, separate from your code. Another option is to prompt the user to enter the API key at runtime, ensuring that the key is not stored in the code itself. These methods help keep your API keys secure and prevent accidental exposure.

**Exclude Secrets from Version Control**
When using version control systems like Git, it is essential to exclude files containing sensitive information, such as API keys, from being tracked. Use techniques like adding these files to your `.gitignore` file to ensure they are not accidentally committed and pushed to remote repositories, where they could be accessed by others.
:::

# Method 1: Using a Secrets File (`api_key.txt`)

- **Advantages:**
  - Keeps API keys separate from your code.
  - Easy to manage and update without altering the codebase.

- **Disadvantages:**
  - Requires handling the file securely.
  - Must ensure the file is not uploaded to public repositories.

```python
with open('api_key.txt', 'r') as file:
    api_key = file.read().strip()
```

::: {.notes}
**Aim**
To introduce students to the method of using a separate file to store API keys, highlighting its advantages and disadvantages.

**Context**
After covering the basics of APIs and how to make requests using Python, this slide is part of a section on secure API key management. It is followed by another method of handling API keys, which prompts the user to enter the key when running the script.

**Advantages:**

**Keeps API keys separate from your code.** Storing API keys in a separate file, such as `api_key.txt`, ensures that sensitive information is not mixed with the main codebase. This separation makes it easier to manage and maintain the code, as changes to the API key do not require modifying the script itself.

**Easy to manage and update without altering the codebase.** When API keys need to be updated or changed, having them in a separate file allows for quick and easy modifications without touching the main script. This approach reduces the risk of accidentally introducing errors or bugs into the codebase while updating the API key.

**Disadvantages:**

**Requires handling the file securely.** When using a separate file to store API keys, it is critical to ensure that the file itself is handled securely. This means setting appropriate file permissions to restrict access to the file and ensuring that only authorized users or processes can read its contents.

**Must ensure the file is not uploaded to public repositories.** When working with version control systems like Git, it is crucial to prevent the accidentally uploading of the API key file to public repositories. This can be achieved by adding the file to the `.gitignore` file, which instructs Git to exclude the specified files from version control. Failing to do so may result in the API key being exposed to the public, compromising the security of the associated API account.
:::

# Method 2: Prompting the User to Enter the API Key

- **Advantages:**
  - No need to store the API key in a file.
  - Reduces the risk of accidental exposure through file sharing.

- **Disadvantages:**
  - Requires manual entry each time the notebook is run.
  - Less convenient for repetitive tasks.

```python
# Get the API key from user input
api_key = input("Enter your OpenWeatherMap API key: ")
```

::: {.notes}
**Aim**
This slide aims to present an alternative method for securely managing API keys by prompting the user to enter the key manually.

**Context**
Following the discussion on the first method of using a secrets file to store the API key, this slide introduces a second approach. It compares the advantages and disadvantages of both methods, providing the audience with options to choose from based on their specific requirements and preferences.

**Advantages:**

**No need to store the API key in a file.** By prompting the user to enter the API key manually, this method eliminates the need to store the key in a separate file. This approach reduces the risk of accidentally exposing the key if the file is shared or compromised. It provides an added layer of security, as the key is only present in memory during the execution of the notebook.

**Reduces the risk of accidental exposure through file sharing.** When the API key is not stored in a file, it significantly reduces the chances of accidentally sharing the key with others. This is particularly important when collaborating on projects or sharing the notebook with team members. By keeping the key input separate from the notebook itself, it minimizes the risk of unintentional exposure.

**Disadvantages:**

**Requires manual entry each time the notebook is run.** The main drawback of this method is that it requires the user to manually enter the API key every time the notebook is executed. This can be inconvenient, especially if the notebook needs to be run frequently or if multiple users are working on the same project. It adds an extra step to the workflow and may be prone to input errors.

**Less convenient for repetitive tasks.** If the notebook is part of a repetitive task or an automated process, manually entering the API key each time can be cumbersome. It disrupts the automation and requires human intervention, which may not be feasible in certain scenarios. In such cases, using a secrets file or an alternative method for securely storing the key may be more appropriate.

**[]**
To get the API key from user input, you can use the input() function in Python. This function prompts the user with a message and waits for them to enter a value, which is then returned as a string. For example:

api_key = input("Enter your API key: ")

This line of code will display the message "Enter your API key: " to the user and store their input in the api_key variable. It's important to note that the input() function always returns a string, so if you need the value in another data type (e.g., integer or float), you'll need to convert it accordingly.

When prompting the user for sensitive information like an API key, it's a good practice to remind them not to share the key with anyone and to keep it secure. You can also provide instructions on how to obtain an API key if they don't have one already.
:::

# Both methods into a function:

```python
# Function to get the API key securely
def get_api_key():
    """
    Reads the API key from a file or prompts the user to input it.
    """
    try:
        with open('api_key.txt', 'r') as file:
            api_key = file.read().strip()
    except FileNotFoundError:
        api_key = input("Enter your OpenWeatherMap API key: ")
    return api_key

# Get the API key
api_key = get_api_key()
```

::: {.notes}
**Aim**
To demonstrate how to securely manage API keys in Python by encapsulating key retrieval methods into a reusable function.

**Context**
After exploring two different methods for securely managing API keys (using a separate file and prompting the user for input), this slide shows how to combine both approaches into a single function. This allows for a more modular and reusable approach to API key management in the weather app being built throughout the presentation.

Encapsulating both API key retrieval methods (reading from a file and prompting the user) into a single function offers several benefits:

1. Reusability: The function can be called whenever an API key is needed, reducing code duplication.

2. Flexibility: The function can be modified to handle different scenarios or fallback options for obtaining the API key.

3. Modularity: Separating the key retrieval logic from the main application code improves readability and maintainability.

Here's an example of how such a function might be implemented in Python:

```python
def get_api_key():
    try:
        with open("api_key.txt", "r") as file:
            api_key = file.read().strip()
    except FileNotFoundError:
        api_key = input("Enter your API key: ")
    return api_key
```

This function attempts to read the API key from a file named `api_key.txt`. If the file is not found, it prompts the user to enter the key manually. The function returns the obtained API key, which can then be used in the weather app.
:::

# Implementing Secure API Key Management in Google Colab

- **Uploading `api_key.txt`:**
  - Use Colab's file upload feature to add `api_key.txt` to your environment.
  - Access the file using the provided function to read the API key.
  
- **Security Considerations:**
  - **Do Not Share the Notebook:** Ensure that the notebook is not shared publicly with the `api_key.txt` file.
  - **Use `.gitignore` If Using Git:** Add `api_key.txt` to `.gitignore` to prevent it from being committed to Git repositories.

::: {.notes}
**Aim**
This slide aims to provide instructions on securely managing API keys in Google Colab notebooks to prevent unauthorised access.

**Context**
Following the previous slide on secure API key management methods, this slide focuses specifically on implementing secure API key management in Google Colab. It provides practical steps for uploading the `api_key.txt` file and discusses important security considerations when working with API keys in Colab notebooks.

**Uploading `api_key.txt`:**
To use the `api_key.txt` file in Google Colab, you need to upload it to your Colab environment. Colab provides a built-in file upload feature that allows you to easily add external files to your notebook. By uploading the `api_key.txt` file, you can access its contents within your Colab notebook using the provided function, which reads the API key from the file.

**Use Colab's file upload feature to add `api_key.txt` to your environment.**
In Google Colab, you can find the file upload feature in the sidebar or under the "Files" menu. Click on the upload button and select the `api_key.txt` file from your local machine. Once uploaded, the file will be available in your Colab notebook's file system, allowing you to access its contents using the appropriate file reading functions.

**Access the file using the provided function to read the API key.**
To read the API key from the uploaded `api_key.txt` file, you can use the provided function in your Colab notebook. This function typically opens the file, reads its contents, and returns the API key as a string. By using this function, you can assign the API key to a variable and use it in your code to authenticate API requests.

**Security Considerations:**
When working with API keys in Google Colab, it's crucial to follow security best practices to protect your API key from unauthorised access. One important consideration is to avoid sharing the notebook publicly if it contains the `api_key.txt` file. Sharing the notebook with the API key file can expose your key to others, potentially leading to misuse or unauthorised access to the API.

**Do Not Share the Notebook:** Ensure that the notebook is not shared publicly with the `api_key.txt` file.
If you need to share your Colab notebook with others, make sure to remove the `api_key.txt` file before sharing. You can either delete the file from the notebook's file system or exclude it from the notebook's contents. By keeping the API key file separate and not including it in the shared notebook, you can prevent unauthorised access to your API key.

**Use `.gitignore` If Using Git:** Add `api_key.txt` to `.gitignore` to prevent it from being committed to Git repositories.
If you're using version control systems like Git to manage your Colab notebooks, it's important to add the `api_key.txt` file to your `.gitignore` file. The `.gitignore` file specifies which files and directories should be ignored by Git and not committed to the repository. By including `api_key.txt` in `.gitignore`, you ensure that the file is not accidentally pushed to remote repositories, keeping your API key secure.
:::

# Building a Simple Weather App with Plot
1. **Get API Key:** Use best practice for eky management
2. **Get User Input:** Ask for a city name
3. **Make API Request:** Fetch current weather forecast
4. **Extract Dates and Temps:** Extract 4-hourly temps for each day
5. **Calculate Average Temp:** For each day, find the average temp
6. **Display/Plot Results:** Show average temperature plot

::: {.notes}
**Aim**
This slide aims to demonstrate how to build a simple weather application in Python that retrieves weather data from an API and visualises it using a plot.

**Context**
After covering the fundamentals of APIs, JSON parsing, and error handling, this slide builds upon the previous weather API examples to create a practical application. It ties together the concepts learned throughout the presentation, showcasing how to retrieve and process real-world data to build a functional weather app with visualisations.
:::

# Step 3: Get the five day forecast
```python
def get_five_day_forecast(city, api_key):
    forecast_url = f'http://api.openweathermap.org/data/2.5/forecast?q={city}&appid={api_key}'
    response = requests.get(api_url, params=params)
    forecast = response.json()
    return forecast
```

::: {.notes}
**Aim**
The aim of this slide is to explain the process of retrieving the five-day weather forecast data using the API.

**Context**
This slide is part of the "Building a Simple Weather App with Plot" section, following the introduction to the weather API example and the current weather data retrieval. It focuses on the next step of fetching the five-day forecast data, which will be used in subsequent slides to extract, process, and visualise the temperature data.
:::

# Step 4: Extract dates and temps
```python
def get_dates_temps(forecast):
    dates = []
    temps = []
        
    for entry in forecast:
        date = entry['dt_txt'].split(' ')[0]
        temp = entry['main']['temp']
        dates.append(date)
        temps.append(temp)
    return dates, temps
```

::: {.notes}
**Aim**
This slide aims to demonstrate how to extract specific data points from the JSON response, focusing on the dates and temperatures from the five-day forecast.

**Context**
After obtaining the five-day forecast data in the previous slide, the next step is to extract the relevant information, specifically the dates and temperatures. This process sets the stage for calculating the average temperature and plotting the data in the subsequent slides.
:::

# Step 5: Average Temp
```python
def get_average_temps_dates(dates,temps):
    # Get unique dates
    unique_dates = list(dict.fromkeys(dates))
    avg_temps = []
    
    # Calculate average temperature for each unique date
    for date in unique_dates:
        date_temps = [temp for d, temp in zip(dates, temps) if d == date]
        avg_temp = sum(date_temps) / len(date_temps)
        avg_temps.append(round(avg_temp, 2))
    
    return unique_dates, avg_temps
```

::: {.notes}
**Aim**
This slide aims to explain how to calculate the average temperature from the extracted five-day forecast data.

**Context**
After extracting the dates and temperatures from the five-day forecast data in the previous slide, this slide focuses on calculating the average temperature. The next slide will cover plotting the dates and temperatures to visualise the data.

**[No bullet points provided]**
As no bullet points were provided for this slide, I would suggest adding content that explains the process of calculating the average temperature from the extracted five-day forecast data. This could include:

1. Iterating through the list of temperatures
2. Summing up all the temperature values
3. Dividing the sum by the number of temperature values to obtain the average

Additionally, you may want to include a code snippet demonstrating how to calculate the average temperature using Python.
:::

# Step 6: Plot date and temps

```python
def plot_dates_temps(dates, temps):
    # Plot the temp and dates
    plt.figure(figsize=(10,6))
    plt.bar(dates, temps, color='skyblue')
    plt.xlabel('Date')
    plt.ylabel('Temperature (°C)')
    plt.title(f'6-Day Temperature Forecast for {city}')
    plt.xticks(dates, rotation=45) # Ensure all dates are shown on the x-axis
    plt.tight_layout()  # Adjust layout to prevent overlap
    plt.show()
```

::: {.notes}
**Aim**
The aim of this slide is to demonstrate how to plot the extracted date and temperature data using Python's matplotlib library.

**Context**
This slide follows the previous steps of getting the five-day forecast data, extracting the relevant date and temperature information, and calculating the average temperature. It is the final step in building the weather app, where the processed data is visualised using a plot.

**[No bullet points provided]**
As no specific bullet points were provided in the prompt, I will provide a general explanation of what could be covered in this slide.

To plot the date and temperature data, you can use Python's matplotlib library. First, import the necessary modules, such as matplotlib.pyplot. Then, create a figure and axis object using plt.subplots(). Set the x-axis values to the extracted dates and the y-axis values to the corresponding temperatures. You can customise the plot by adding labels for the x and y axes, a title for the plot, and adjusting the figure size if needed. Finally, display the plot using plt.show().

It's important to ensure that the date and temperature data are properly formatted and have the same length before plotting. You may need to convert the date strings to datetime objects and the temperature values to floats. If there are any missing or invalid data points, you should handle them appropriately, such as by removing or interpolating them.

By plotting the date and temperature data, you can provide a visual representation of the weather forecast, making it easier to interpret and analyse the trends over the five-day period.
:::

# Implement Weather App
1. **Get API Key:** Use best practice for eky management
2. **Get User Input:** Ask for a city name
3. **Make API Request:** Fetch current weather forecast
4. **Extract Dates and Temps:** Extract 4-hourly temps for each day
5. **Calculate Average Temp:** For each day, find the average temp
6. **Display/Plot Results:** Show average temperature plot

```python
api_key = get_api_key()
city = input("Enter city name: ")
forecast = get_five_day_forecast(city, api_key)
dates, temps = get_dates_temps(forecast['list'])
plot_dates_temps(dates,temps)
```

::: {.notes}
**Aim**
The aim of this slide is to provide an overview of the steps involved in implementing a weather app using APIs and Python.

**Context**
This slide builds upon the previous slides that introduced APIs, HTTP methods, JSON, and the Python `requests` library. It serves as a practical application of the concepts covered earlier, demonstrating how to integrate various components to create a functional weather app.
:::

# Best Practices When Using APIs

- **Read Documentation:** Understand endpoints and parameters
- **Handle Errors:** Anticipate and manage potential issues
- **Respect Rate Limits:** Avoid exceeding the allowed number of requests
- **Secure Your API Keys:** Do not expose them in public repositories

::: {.notes}
**Aim**
This slide aims to provide learners with essential best practices to follow when working with APIs to ensure efficient, secure, and reliable usage.

**Context**
Having covered the fundamentals of APIs, including their structure, usage, and practical examples using Python's `requests` library, this slide focuses on the important considerations developers should keep in mind when interacting with APIs. The best practices discussed here are crucial for building robust and secure applications that rely on APIs.

**Read Documentation: Understand endpoints and parameters**
Before using an API, it is essential to thoroughly read and understand its documentation. The documentation provides detailed information about the available endpoints, their functionality, and the required parameters. By familiarising yourself with the API's structure and capabilities, you can effectively utilise its features and avoid common pitfalls. Take the time to explore the documentation, including any code examples or tutorials, to gain a clear understanding of how to interact with the API correctly.

**Handle Errors: Anticipate and manage potential issues**
When working with APIs, it is crucial to anticipate and handle potential errors gracefully. API requests can fail for various reasons, such as invalid parameters, authentication issues, or server-side problems. Implement proper error handling mechanisms in your code to catch and manage these errors. This may involve checking the response status codes, parsing error messages, and providing informative feedback to the user. By handling errors effectively, you can ensure a smooth user experience and maintain the stability of your application.

**Respect Rate Limits: Avoid exceeding the allowed number of requests**
Many APIs enforce rate limits to prevent abuse and ensure fair usage among developers. These limits typically restrict the number of requests you can make within a specific timeframe. It is essential to be aware of and respect these rate limits to avoid being temporarily or permanently blocked by the API provider. Implement mechanisms to track and control the frequency of your API requests, such as using caching, implementing exponential backoff, or leveraging rate limit information provided in the API responses. By staying within the allowed limits, you can maintain a good relationship with the API provider and ensure the long-term viability of your application.

**Secure Your API Keys: Do not expose them in public repositories**
API keys are sensitive information that grant access to API services. It is crucial to keep your API keys secure and protect them from unauthorised access. Avoid exposing your API keys in public repositories, such as GitHub, where they can be easily discovered by others. Instead, use secure methods to store and manage your API keys, such as environment variables, configuration files, or secret management services. By keeping your API keys private, you can prevent misuse and ensure the security of your application and the API services you rely on.
:::

# Resources for Learning More

- [Official Python `requests` Documentation](https://docs.python-requests.org/)
- [OpenWeatherMap API](https://openweathermap.org/api)
- [REST API Tutorial](https://restfulapi.net/)

::: {.notes}
**Aim**
The aim of this slide is to provide learners with valuable resources to further expand their knowledge and skills in APIs, Python, and related topics.

**Context**
After covering the fundamentals of APIs, Python's `requests` library, and building a weather app, this slide offers learners the next steps in their learning journey. It directs them to official documentation and tutorials that can help solidify their understanding and explore more advanced concepts.

**[Official Python `requests` Documentation](https://docs.python-requests.org/)**
The official Python `requests` documentation is an essential resource for mastering the `requests` library. It provides comprehensive information on all the features, methods, and parameters available in the library. Learners can find detailed explanations, code examples, and best practices for making HTTP requests, handling responses, and working with different types of authentication. The documentation also covers advanced topics like session management, custom headers, and proxy support.

**[OpenWeatherMap API](https://openweathermap.org/api)**
The OpenWeatherMap API documentation is a valuable resource for learners interested in integrating weather data into their applications. It provides detailed information on the various endpoints available, such as current weather, weather forecasts, and historical data. The documentation explains the request parameters, response formats, and authentication requirements. It also includes code examples in multiple programming languages to help learners quickly get started with making API requests to OpenWeatherMap.

**[REST API Tutorial](https://restfulapi.net/)**
The REST API Tutorial is a comprehensive resource for learning about RESTful APIs. It covers the fundamental concepts of REST, including resources, URIs, HTTP methods, and status codes. The tutorial explains how to design and implement RESTful APIs, handle different data formats like JSON and XML, and secure APIs using authentication and authorization mechanisms. It also discusses best practices for API versioning, error handling, and documentation. Learners can gain a deep understanding of RESTful principles and apply them to their own API projects.
:::

# Conclusion

- **APIs** enable communication between applications
- **URLs** and **Endpoints** are key to accessing APIs
- Use Python's `requests` library to interact with APIs
- Weather examples make learning practical and engaging

::: {.notes}
**Aim**
The aim of this slide is to summarise the key points covered in the presentation and reinforce the main takeaways for the audience.

**Context**
This slide serves as the culmination of the presentation, tying together the concepts and examples discussed throughout the various sections. It follows the practical examples of using APIs with Python's `requests` library to interact with weather data, and precedes the slide on additional resources for further learning.

**APIs enable communication between applications**
Application Programming Interfaces, or APIs, are crucial for facilitating communication and data exchange between different software applications. They define a set of rules and protocols that allow applications to interact with each other seamlessly. By leveraging APIs, developers can access and utilise the functionality and data provided by external services or systems, enabling them to build more powerful and integrated applications.

**URLs and Endpoints are key to accessing APIs**
To interact with APIs effectively, it is essential to understand the role of URLs (Uniform Resource Locators) and endpoints. URLs serve as the addresses that identify the location of specific resources or services on the web. Endpoints, which are part of the URL, define the specific functionality or data that an API provides. By making HTTP requests to the appropriate URLs and endpoints, applications can retrieve data, send instructions, or perform various operations through the API.

**Use Python's `requests` library to interact with APIs**
Python's `requests` library simplifies the process of making HTTP requests and interacting with APIs. It provides a high-level, user-friendly interface for sending GET, POST, PUT, DELETE, and other HTTP methods. With `requests`, developers can easily send requests to API endpoints, pass parameters, handle authentication, and receive responses in various formats such as JSON. The library abstracts away the low-level details, making API communication more intuitive and efficient.

**Weather examples make learning practical and engaging**
Throughout the presentation, weather-related examples were used to demonstrate the practical application of APIs and Python's `requests` library. By focusing on real-world scenarios like retrieving current weather data and fetching five-day forecasts, the concepts become more relatable and easier to grasp. These examples showcase how APIs can be used to access valuable information and integrate it into custom applications, making the learning experience more engaging and meaningful for the audience.
:::



---
author: Michael Borck
format:
  docx:
    highlight-style: github
    toc: false
  html:
    embed-resources: true
    toc: true
    toc-expand: 2
  pdf:
    colorlinks: true
    toc: false
  pptx:
    reference-doc: ../../../_assets/template.pptx
title: 'Introduction to Python''s Data Structures: Unleashing Weather Insights'
---

# Copyright
![](../../../_assets/curtin-copy-right.png)

# Acknowledgement of Country
I acknowledge the traditional custodians of the land on which I work and live,
and recognise their continuing connection to land, water and community. I pay
respect to Elders past, present and emerging.

![](../../../_assets/ack_country.png)

# Today

- Introduction to Data Structures
- Lists
- Dictionaries
- Tuples
- Weather Data Analysis Example

::: {.notes}
**Aim**
The purpose of this slide is to provide an overview of the key topics that will be covered in today's presentation on data structures in Python.

**Context**
After acknowledging the traditional owners of the land and covering copyright information, this slide sets the scene for the rest of the presentation. It outlines the main data structures that will be discussed in detail, before moving on to explain what data structures are and why they are important in the following slides.

**Introduction to Data Structures**
This presentation will introduce the fundamental concepts of data structures in Python programming. We will explore three essential built-in data structures: lists, dictionaries, and tuples. Understanding these data structures is crucial for organising and manipulating data effectively in Python programs.

**Lists**
Lists are one of the most versatile and commonly used data structures in Python. They are ordered, mutable, and allow duplicate elements. We will cover the key features of lists, how to create them, and perform basic operations such as accessing, modifying, and iterating over elements.

**Dictionaries**
Dictionaries are unordered collections of key-value pairs, providing a efficient way to store and retrieve data based on unique keys. We will explore the key features of dictionaries, how to create them, and perform common operations like accessing values, modifying entries, and checking for key existence.

**Tuples**
Tuples are ordered, immutable collections of elements, often used to group related data. We will discuss the key characteristics of tuples, how to create them, and perform basic operations such as accessing elements and determining the length of a tuple.

**Weather Data Analysis Example**
To demonstrate the practical application of data structures, we will walk through an example of analysing weather data using lists, dictionaries, and tuples. This example will showcase how these data structures can be used to store, organise, and extract meaningful information from real-world datasets.
:::

# What are Data Structures?

Data structures are ways to organise and store data in programming. They help us
manage information efficiently and are fundamental to solving problems with
code.

::: {.notes}
**Aim**
This slide aims to introduce the concept of data structures and provide an overview of their importance in programming and software development.

**Context**
The previous slides focused on the introduction, copyright information, and acknowledgement of country. This slide marks the beginning of the main content, starting with the fundamental concept of data structures. Subsequent slides will delve into specific data structures like lists, dictionaries, and tuples, along with their key features and basic operations.

**What are data structures?**
Data structures are fundamental building blocks in programming that allow efficient organisation, storage, and retrieval of data. They provide a way to structure and manage data within a program, enabling developers to write more organised and optimised code. Common examples of data structures include arrays, linked lists, stacks, queues, trees, and graphs. Each data structure has its own characteristics, strengths, and weaknesses, making them suitable for different scenarios and requirements.
:::

# Why are Data Structures Important?

- They help organise data effectively
- They make it easier to work with large amounts of information
- Different data structures are suited for different tasks

::: {.notes}
**Aim**
This slide aims to highlight the significance of data structures in AI and machine learning by outlining their key benefits and applications.

**Context**
Having introduced the concept of data structures in the previous slide, this slide delves deeper into their importance. It sets the stage for the following slides, which will explore specific data structures like lists, dictionaries, and tuples, and their roles in organising and manipulating data effectively.

**They help organise data effectively** Data structures provide a systematic way to arrange and store data in a computer's memory. By organising data in a logical and efficient manner, data structures enable quick access, retrieval, and modification of information. This is particularly crucial in AI and machine learning, where vast amounts of data need to be processed and analysed. Well-organised data facilitates faster algorithms, improves memory utilisation, and enhances overall performance.

**They make it easier to work with large amounts of information** AI and machine learning often involve dealing with massive datasets. Data structures offer a means to manage and manipulate these large volumes of data efficiently. They provide built-in methods and operations that simplify common tasks such as searching, sorting, inserting, and deleting elements. By leveraging appropriate data structures, developers can write cleaner, more concise code and focus on solving the core problems rather than getting bogged down in low-level details.

**Different data structures are suited for different tasks** No single data structure is optimal for all scenarios. Each data structure has its own strengths and weaknesses, making it suitable for specific tasks. For example, lists are ideal for storing and accessing ordered collections of elements, while dictionaries excel at fast key-value lookups. Tuples are useful for representing fixed-sise, immutable sequences of items. Choosing the right data structure based on the problem at hand is crucial for efficient and effective AI and machine learning implementations.
:::

# Lists: Versatile and Dynamic

Lists are ordered collections of items that can be of any type.

## Key Features of Lists

- Can contain different types of data (numbers, strings, etc.)
- Items are accessed by their position (index)
- Can be changed after creation (mutable)
- Created using square brackets
- Support various operations like adding, removing, and updating items
- Useful for storing and manipulating sequences of elements
  
::: {.notes}
**Aim**
To introduce lists as a versatile and dynamic data structure in Python, highlighting their key features and applications.

**Context**
This slide comes after an introduction to data structures and their importance in programming. It serves as the first in-depth exploration of a specific data structure, setting the stage for subsequent slides on dictionaries and tuples. The slide aims to provide a solid foundation for understanding lists before moving on to more complex data structures.

**Can contain different types of data (numbers, strings, etc.)**
Lists in Python are heterogeneous, meaning they can store elements of different data types within a single list. For example, a list can contain integers, floats, strings, and even other lists or complex objects. This flexibility allows lists to be used in a wide variety of scenarios, from simple collections of numbers to more complex data structures.

**Items are accessed by their position (index)**
Elements in a list are ordered and accessed by their position or index. In Python, indices start at 0 for the first element and increment by 1 for each subsequent element. This allows for efficient access to individual elements within the list using square bracket notation, such as my_list[0] to access the first element.

**Can be changed after creation (mutable)**
Lists in Python are mutable, which means they can be modified after they are created. Elements can be added, removed, or changed using various built-in methods and operations. This mutability allows for flexible manipulation of list contents, such as appending new elements, removing specific items, or updating values at particular indices. The ability to modify lists in-place is a powerful feature that distinguishes them from immutable data structures like tuples.
:::

# Creating a List

```python
fruits = ["apple", "banana", "cherry"]
numbers = [1, 2, 3, 4, 5]
mixed = [1, "hello", 3.14]
```

::: {.notes}
**Aim**
This slide aims to introduce the process of creating lists in Python, highlighting their simplicity and flexibility.

**Context**
After discussing the key features and importance of lists, this slide naturally follows by showing how to create lists in Python. It precedes slides on basic list operations, serving as a foundation for understanding list manipulation.

**Empty List**
To create an empty list, simply use square brackets with no elements inside:

my_list = []

This initialises a new, empty list that you can later populate with elements as needed.

**List with Initial Elements**
You can also create a list with initial elements by placing them inside the square brackets, separated by commas:

my_list = [1, 2, 3, 4, 5]

This creates a list containing the elements 1, 2, 3, 4, and 5 in that order. Lists can hold elements of different data types, such as integers, floats, strings, or even other lists.

**List Comprehension**
List comprehension provides a concise way to create lists based on existing lists or other iterable objects. It follows this syntax:

new_list = [expression for item in iterable if condition]

For example, to create a list of squares of numbers from 1 to 5:

squares = [x**2 for x in range(1, 6)]

This creates the list [1, 4, 9, 16, 25] by squaring each number in the range 1 to 5.
:::

# Basic List Operations

- Adding items: `fruits.append("orange")`
- Accessing items: `fruits` (gets the first item)
- Changing items: `fruits = "grape"`
- Removing items: `fruits.remove("cherry")`

::: {.notes}
**Aim**
This slide aims to introduce the fundamental operations that can be performed on lists in Python, enabling learners to manipulate and modify list elements effectively.

**Context**
After discussing the key features and creation of lists in the previous slides, this slide delves into the essential operations that can be performed on lists. The following slides will explore other data structures such as dictionaries and tuples, building upon the foundation established by this slide.

**Adding items: `fruits.append("orange")`**
The `append()` method is used to add an element to the end of a list. In the example provided, the string "orange" is appended to the `fruits` list. This operation modifies the list in-place, expanding its sise by one element. The `append()` method is useful when you need to dynamically add items to a list based on certain conditions or user input.

**Accessing items: `fruits[0]` (gets the first item)**
Lists in Python are sero-indexed, meaning the first element has an index of 0. To access an element in a list, you can use square brackets `[]` and provide the index of the desired element. In the example, `fruits[0]` retrieves the first item in the `fruits` list. You can access elements using positive indices (0 to len(fruits)-1) or negative indices (-1 to -len(fruits)).

**Changing items: `fruits[1] = "grape"`**
To modify an element in a list, you can assign a new value to a specific index using the square bracket notation. In the example, `fruits[1] = "grape"` assigns the string "grape" to the second element (index 1) of the `fruits` list, replacing the existing value at that position. This allows you to update or replace elements in a list as needed.

**Removing items: `fruits.remove("cherry")`**
The `remove()` method is used to remove the first occurrence of a specified element from a list. In the example, `fruits.remove("cherry")` removes the string "cherry" from the `fruits` list. If the element appears multiple times, only the first occurrence will be removed. If the element is not found, a `ValueError` will be raised. Alternatively, you can use the `del` statement with an index to remove an element at a specific position.
:::

# Dictionaries: Key-Value Pairs

Dictionaries store data in key-value pairs.

## Key Features of Dictionaries

- Unordered collection of key-value pairs
- Keys must be unique
- Fast for looking up values
- Can contain various data types as values
- Created using curly braces
- Keys and values are separated by colons

::: {.notes}
**Aim**
This slide aims to introduce dictionaries as a key-value pair data structure and explain their fundamental characteristics.

**Context**
After discussing lists and their features, this slide shifts the focus to dictionaries, another essential data structure in programming. The following slides will delve into creating dictionaries and performing basic operations on them.

**Key Features of Dictionaries**
Dictionaries are a powerful data structure that allows for efficient storage and retrieval of data using key-value pairs. Each entry in a dictionary consists of a unique key and its associated value. Keys are used to access and manipulate the corresponding values, providing a convenient way to organise and retrieve information. Dictionaries are unordered, meaning the elements are not stored in a specific sequence, and they can contain various data types as values.

**Creating a Dictionary**
To create a dictionary in Python, you can use curly braces {} or the dict() constructor. Keys and values are separated by colons, and each key-value pair is separated by commas. For example, you can create a dictionary of student grades like this: grades = {"Alice": 85, "Bob": 92, "Charlie": 78}. You can also create an empty dictionary and add key-value pairs later using square bracket notation or the update() method.

**Basic Dictionary Operations**
Dictionaries support various operations for accessing, modifying, and manipulating data. You can access values by their keys using square bracket notation, such as grades["Alice"] to retrieve Alice's grade. You can add new key-value pairs or update existing ones using the same notation. To remove a key-value pair, you can use the del statement or the pop() method. Other common operations include checking if a key exists using the in keyword, retrieving all keys or values using the keys() and values() methods, and iterating over key-value pairs using loops.

**Unordered collection of key-value pairs**
Unlike lists, which are ordered sequences, dictionaries store data as key-value pairs without any specific order. Each key in a dictionary is associated with a corresponding value, allowing for efficient retrieval of values based on their keys. This unordered nature means that the elements in a dictionary are not accessed by their position or index, but rather by their unique keys.

**Keys must be unique**
In a dictionary, each key must be unique within the dictionary. This uniqueness constraint ensures that there are no duplicate keys, and each key maps to a single value. If you attempt to add a key-value pair with a key that already exists in the dictionary, the previous value associated with that key will be overwritten by the new value. This property allows dictionaries to maintain a one-to-one mapping between keys and values.

**Fast for looking up values**
Dictionaries are optimised for fast value lookups based on keys. When you provide a key to access a value in a dictionary, Python uses a efficient hashing mechanism to quickly locate the corresponding value. This makes dictionaries highly efficient for retrieving values, especially when dealing with large amounts of data. The time complexity for accessing values in a dictionary is typically O(1) on average, making it a preferred choice when fast lookups are crucial.
:::

# Creating a Dictionary

```python
person = {
    "name": "John",
    "age": 30,
    "city": "New York"
}
```

::: {.notes}
**Aim**
The aim of this slide is to introduce how to create a dictionary in Python.

**Context**
This slide follows on from the previous slide about the key features of dictionaries. It provides a practical example of creating a dictionary before moving on to basic dictionary operations in the next slide.

**Creating a Dictionary**
To create a dictionary in Python, we use curly braces {} and separate each key-value pair with a colon :. Multiple key-value pairs are separated by commas. For example:

my_dict = {"apple": 3, "banana": 5, "orange": 2}

This creates a dictionary called my_dict with three key-value pairs. The keys are strings ("apple", "banana", "orange") and the values are integers (3, 5, 2) representing the quantity of each fruit.

We can also create an empty dictionary using empty curly braces:

empty_dict = {}

This creates an empty dictionary called empty_dict which we can add key-value pairs to later.

Dictionaries are mutable, meaning we can change, add or remove key-value pairs after creation.
:::

# Basic Dictionary Operations

- Adding/updating items: `person["job"] = "Engineer"`
- Accessing values: `person["name"]`
- Removing items: `del person["age"]`

::: {.notes}
**Aim**
This slide aims to introduce the basic operations that can be performed on Python dictionaries, such as adding, accessing, and removing items.

**Context**
After discussing lists and their features, the presentation moves on to dictionaries, another essential data structure in Python. The previous slide covered the creation of dictionaries, and this slide builds upon that by explaining the fundamental operations that can be performed on dictionaries.

**Adding/updating items: `person["job"] = "Engineer"`**
To add a new key-value pair to a dictionary or update the value of an existing key, you can use the square bracket notation followed by the key and assign the desired value to it. In the example shown, we are adding or updating the "job" key in the "person" dictionary with the value "Engineer". If the key already exists, its corresponding value will be updated; otherwise, a new key-value pair will be added to the dictionary.

**Accessing values: `person["name"]`**
To retrieve the value associated with a specific key in a dictionary, you can use the square bracket notation followed by the key. In the given example, `person["name"]` will return the value associated with the "name" key in the "person" dictionary. It's important to note that if you try to access a key that doesn't exist in the dictionary, a `KeyError` will be raised.

**Removing items: `del person["age"]`**
To remove a key-value pair from a dictionary, you can use the `del` statement followed by the dictionary name and the key you want to remove within square brackets. In the example provided, `del person["age"]` will remove the key-value pair with the key "age" from the "person" dictionary. After this operation, the "age" key and its corresponding value will no longer exist in the dictionary.
:::

# Tuples: Immutable Collections

Tuples are similar to lists but cannot be changed after creation.

## Key Features of Tuples

- Ordered collection of items
- Cannot be modified after creation (immutable)
- Often used for fixed sets of data
- Created using parentheses
- Elements are separated by commas

::: {.notes}
**Aim**
The purpose of this slide is to introduce tuples as immutable collections in Python and highlight their key characteristics.

**Context**
Having covered lists and dictionaries, this slide shifts focus to tuples, another fundamental data structure in Python. The subsequent slides will delve into the key features of tuples, their creation, and basic operations.

**Key Features of Tuples**
Tuples are ordered, immutable sequences in Python. They allow you to store and group related items together. Once a tuple is created, its elements cannot be modified, added, or removed. This immutability makes tuples suitable for scenarios where data integrity and consistency are crucial. Tuples are defined using parentheses () and elements are separated by commas. They support indexing and slicing operations, allowing you to access individual elements or subsets of the tuple.

**Creating a Tuple**
To create a tuple in Python, you enclose a comma-separated sequence of elements within parentheses. For example, my_tuple = (1, 2, 3) creates a tuple with three integers. You can also create a tuple without parentheses by separating elements with commas, like my_tuple = 1, 2, 3. Tuples can hold elements of different data types, such as integers, floats, strings, or even other tuples. If you need to create a tuple with a single element, you must include a trailing comma after the element to differentiate it from an expression in parentheses.

**Basic Tuple Operations**
Tuples support various operations for accessing and manipulating their elements. You can use indexing to retrieve individual elements by their position, starting from 0 for the first element. For example, my_tuple[0] retrieves the first element. Slicing allows you to extract a portion of the tuple by specifying a range of indices. Tuples also support the + operator for concatenation, creating a new tuple by joining two or more tuples together. The * operator can be used to repeat a tuple a specified number of times. Additionally, you can use the len() function to determine the number of elements in a tuple and the in keyword to check if an element exists within the tuple.

**Ordered collection of items** Tuples are ordered sequences, meaning that the items in a tuple have a defined order. This order is determined when the tuple is created and remains fixed throughout its lifetime. Each item in a tuple can be accessed by its index, similar to lists.

**Cannot be modified after creation (immutable)** One of the defining features of tuples is their immutability. Once a tuple is created, its contents cannot be changed, added to, or removed. This immutability provides a level of data integrity and allows tuples to be used as keys in dictionaries or elements in sets.

**Often used for fixed sets of data** Tuples are commonly used to represent fixed collections of related data. Examples include representing coordinates (x, y), employee records (name, ID, department), or RGB colour values (red, green, blue). The immutability of tuples makes them suitable for scenarios where data should not be accidentally modified.
:::

# Creating a Tuple

```python
coordinates = (10, 20)
rgb_color = (255, 0, 0)
```

::: {.notes}
**Aim**
The aim of this slide is to explain how to create a tuple in Python.

**Context**
This slide is part of a larger presentation on data structures in Python, such as lists and dictionaries. Having covered lists and dictionaries, the presentation now moves on to tuples, which are another important data structure. The slide on creating a tuple follows the one on key features of tuples and precedes the slide on basic tuple operations.
:::

# Basic Tuple Operations

- Accessing items: `coordinates`
- Cannot add, remove, or change items

::: {.notes}
**Aim**
The purpose of this slide is to introduce the basic operations that can be performed on tuples in Python.

**Context**
This slide follows on from the previous slides introducing tuples and their key features. It provides more detail on how to work with tuples in practice. The next slide will give a practical example of using tuples to store weather data.

**Accessing items: `coordinates`**
To access individual elements within a tuple, you can use indexing. For example, if we have a tuple called `coordinates` storing latitude and longitude values like this: `coordinates = (-37.8136, 144.9631)`, we can access the latitude using `coordinates[0]` and the longitude using `coordinates[1]`. Indexing starts at 0 for the first element.

**Cannot add, remove, or change items**
One of the key features of tuples is that they are immutable, meaning their contents cannot be changed once the tuple is created. You cannot add new elements to a tuple, remove elements from a tuple, or modify the existing elements. If you need to update the values, you would have to create a new tuple. This immutability is useful when you want to ensure data remains constant throughout your program.
:::

# Weather Data Example

Let's use these data structures to store and analyse simple weather data.

```python
# List of daily temperatures
temperatures = [22, 24, 19, 21, 23, 25, 20]

# Dictionary of weather information
weather_station = {
    "city": "Sydney",
    # Tuple for fixed location data
    "location" = (-33.8688, 151.2093),  # Latitude and Longitude
    "temperatures": temperatures,
    "conditions": ["Sunny", "Cloudy", "Rainy", "Sunny", "Sunny", "Cloudy", "Rainy"]
}
```

::: {.notes}
**Aim**
This slide aims to illustrate how data structures can be applied to real-world data, using weather data as a practical example.

**Context**
After covering the key data structures of lists, dictionaries and tuples, this slide demonstrates their application to a real-world dataset. It leads into the next slide, which will explore some simple analysis that can be performed on the weather data using these data structures.
:::

# Simple Analysis

```python
# Average temperature
average_temp = sum(temperatures) / len(temperatures)
print(f"Average temperature: {average_temp:.1f}°C")

# Number of sunny days
sunny_days = weather_station["conditions"].count("Sunny")
print(f"Number of sunny days: {sunny_days}")

# Print location
location = weather_station["location"]
print(f"Weather station location: {location}")
```

::: {.notes}
**Aim**
The aim of this slide is to showcase how the weather data example can be used for simple analysis.

**Context**
The previous slide introduced a weather data example to illustrate how data structures like lists, dictionaries, and tuples can be used together to represent and organise real-world data. This slide builds on that example by demonstrating how the weather data can be analysed using simple techniques.
:::

# Summary

- Lists are versatile for storing collections of items
- Dictionaries are great for organising related data
- Tuples are useful for fixed sets of data

::: {.notes}
**Aim**
To summarise the key data structures covered in the presentation and highlight their main use cases.

**Context**
Having explored lists, dictionaries and tuples in detail, including their features, creation and basic operations, this final slide ties together the main points. It reminds the audience of the distinct strengths of each data structure, providing a concise overview to wrap up the presentation.

**Lists are versatile for storing collections of items**
Lists are highly flexible and can store a wide variety of data types, including numbers, strings and even other lists. Their ability to grow or shrink dynamically makes them suitable for scenarios where the number of items is not known in advance or may change over time. Lists provide convenient methods for adding, removing and modifying elements, making them a go-to choice for many programming tasks.

**Dictionaries are great for organising related data**
Dictionaries excel at storing and retrieving data in key-value pairs, allowing for efficient lookup and organisation of related information. By using meaningful keys, dictionaries provide a clear and intuitive way to structure and access data. They are particularly useful when working with data that has a natural mapping or association, such as user profiles, configuration settings or word counts in a text analysis task.

**Tuples are useful for fixed sets of data**
Tuples are immutable sequences, meaning their elements cannot be changed once created. This property makes them suitable for representing fixed collections of data, such as coordinates, database records or function return values. Tuples are generally faster than lists for accessing elements, as they are optimised for performance. They are commonly used to group related pieces of data together and can serve as keys in dictionaries.
:::



---
title: "Introduction to GUIs with Python"
subtitle: "Making Weather Applications Fun!"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Copyright Information

![](../../../_assets/curtin-copy-right.png)

# Acknowledgement of Country

I acknowledge the traditional custodians of the land on which I work and live,
and recognise their continuing connection to land, water and community. I pay
respect to elders past, present and emerging.

![](../../../_assets/ack_country.png)

# Today's Journey:
1. Understanding GUIs and their importance
2. Comparing text-based and GUI inputs
3. Exploring ipywidgets for Google Colab
4. Learning Tkinter for desktop applications
5. Building a simple weather app GUI
6. Brief look at advanced GUI options

- Key Takeaways:
  - Learn two main ways to create GUIs in Python
  - Understand when to use each method
  - Gain hands-on experience with real-world examples

::: {.notes}
**Aim**
This slide aims to provide an overview of the presentation's key learning objectives and set expectations for the audience.

**Context**
The "Today's Journey:" slide follows the "Acknowledgement of Country" and serves as a roadmap for the rest of the presentation. It outlines the main topics that will be covered, including an introduction to GUIs, a comparison of GUI creation methods in Python, and practical examples using ipywidgets and Tkinter.

**Key Takeaways:**
The key takeaways serve as a summary of the presentation's main learning objectives. By the end of the session, attendees should have a clear understanding of the two primary methods for creating GUIs in Python, be able to discern when to use each method based on their specific requirements, and have gained practical experience through hands-on examples.

**Learn two main ways to create GUIs in Python**
This presentation will focus on two popular methods for creating graphical user interfaces (GUIs) in Python: ipywidgets and Tkinter. ipywidgets is a library designed for use within Jupyter notebooks and Google Colab, while Tkinter is a built-in Python module that provides a standard GUI toolkit. Attendees will learn the basics of each method and explore their unique features and capabilities.

**Understand when to use each method**
Choosing the appropriate GUI creation method depends on various factors, such as the development environment, project requirements, and target audience. This presentation will discuss the strengths and limitations of both ipywidgets and Tkinter, helping attendees make informed decisions when selecting a method for their own projects. Factors such as ease of use, platform compatibility, and integration with other tools will be considered.

**Gain hands-on experience with real-world examples**
To reinforce the concepts covered in the presentation, attendees will have the opportunity to work through practical, real-world examples using both ipywidgets and Tkinter. These examples will demonstrate how to create interactive widgets, handle user input, and build functional applications. By engaging in hands-on exercises, attendees will develop a deeper understanding of each method and gain the confidence to apply their newly acquired skills to their own projects.
:::

# What is a GUI?
- A GUI (Graphical User Interface) is a visual way to interact with your program
- GUIs make your apps user-friendly and intuitive
- Examples: Weather apps on your phone or computer

::: {.notes}
**Aim**
The aim of this slide is to introduce the concept of a GUI and explain its purpose in making programs user-friendly.

**Context**
After discussing the broader topics of AI and machine learning, this slide shifts focus to the user interface aspect, specifically GUIs. It sets the stage for the following slides which will delve into using Python to create GUIs.

**A GUI (Graphical User Interface) is a visual way to interact with your program**
A GUI provides a visual and intuitive way for users to interact with a program, as opposed to a text-based command line interface. It consists of graphical elements such as windows, buttons, menus, and icons that users can manipulate with a mouse or touchscreen. GUIs abstract away the underlying complexity of the program, allowing users to focus on their tasks without needing to understand the code behind it.

**GUIs make your apps user-friendly and intuitive**
By presenting a visual interface, GUIs make applications more user-friendly and intuitive to navigate. Users can easily understand the available functions and options without needing to remember specific commands or syntax. Well-designed GUIs guide users through the application's features, making it easier to accomplish tasks and reduce the learning curve. This user-friendliness is essential for applications aimed at a broad audience, including those who may not be technically savvy.

**Examples: Weather apps on your phone or computer**
Weather applications on smartphones and computers are prime examples of how GUIs enhance user experience. These apps present information such as current weather conditions, forecasts, and radar maps in a visually appealing and easy-to-understand format. Users can quickly access the desired information by tapping on icons, selecting from menus, or interacting with sliders and buttons. The GUI design of weather apps makes it simple for users to input their location, view weather details, and customize settings without needing to understand the complex data processing happening behind the scenes.
:::

# Python and GUIs
- You'll learn two ways to create GUIs in Python:
  1. `ipywidgets` for Google Colab
  2. `tkinter` for your local computer
- Focus on these libraries to build interactive weather apps

::: {.notes}
**Aim**
This slide aims to introduce the two main libraries used for creating graphical user interfaces (GUIs) in Python, specifically in the context of building interactive weather applications.

**Context**
Having introduced the concept of GUIs in the previous slide, this slide narrows the focus to Python and the specific libraries used for GUI development. The following slides will delve into each library, providing step-by-step guidance on creating weather apps using ipywidgets and Tkinter.

**You'll learn two ways to create GUIs in Python:** In this presentation, we will explore two popular Python libraries for creating GUIs: ipywidgets and Tkinter. ipywidgets is particularly well-suited for use within Jupyter notebooks and Google Colab, while Tkinter is a standard GUI library that comes bundled with Python installations. By learning both libraries, you'll be equipped to create interactive GUIs in various environments.

**Focus on these libraries to build interactive weather apps:** Throughout the presentation, we will apply our knowledge of ipywidgets and Tkinter to build interactive weather applications. Weather apps provide an engaging and practical example of how GUIs can be used to present data and allow user interaction. By focusing on these specific libraries and the weather app example, you'll gain hands-on experience in creating functional and visually appealing GUIs in Python.
:::

# From Text to GUI: A Comparison
- Text-based Input:
  ```python
  city = input("Enter city name: ")
  print(f"Getting weather for {city}...")
  ```
- ipywidgets (for Colab):
  ```python
  import ipywidgets as widgets
  city_input = widgets.Text(description='City:')
  button = widgets.Button(description="Get Weather")
  display(city_input, button)
  ```
- Tkinter GUI (for local Python):
  ```python
  import tkinter as tk
  entry = tk.Entry(window)
  button = tk.Button(window, text="Get Weather")
  ```
- Similarities:
  - All methods take user input
  - All can trigger actions based on input
- Differences:
  - Text-based is simplest to code, but least interactive
  - ipywidgets works in Colab, great for quick prototypes
  - Tkinter allows for standalone apps, most flexible

::: {.notes}
**Aim**
This slide aims to compare different methods of getting user input in Python: text-based input, ipywidgets in Google Colab, and Tkinter for local Python apps.

**Context**
Having introduced GUIs and how Python can be used to create them, this slide delves into the specifics of three approaches. It sets the stage for the following slides, which will provide hands-on examples of using ipywidgets and Tkinter to build interactive applications.

**Text-based Input:**
Text-based input is the simplest way to get user input in Python. It involves using the built-in `input()` function, which prompts the user to enter text in the console. While straightforward to implement, text-based input provides a basic user experience and is less interactive compared to other methods.

**ipywidgets (for Colab):**
ipywidgets is a library that allows you to create interactive widgets in Jupyter notebooks, including Google Colab. With ipywidgets, you can add GUI elements like buttons, text boxes, and sliders directly in the notebook cells. This makes it convenient for creating quick prototypes and interactive demonstrations without the need for a separate GUI framework.

**Tkinter GUI (for local Python):**
Tkinter is a standard GUI library that comes bundled with Python. It provides a wide range of widgets and tools for building standalone desktop applications with graphical user interfaces. Tkinter offers more flexibility and customization options compared to ipywidgets, allowing you to create fully-featured applications that can be run locally on a user's machine.

**Similarities:**
All three methods—text-based input, ipywidgets, and Tkinter—serve the purpose of receiving user input in a Python program. They allow you to prompt the user for information or actions, which can then be processed by your code. Regardless of the method used, the fundamental concept of capturing and responding to user input remains the same.

**All methods take user input**
Whether it's through the console with text-based input, interactive widgets in ipywidgets, or GUI elements in Tkinter, all three approaches provide a way for users to enter data or trigger actions. This user input can be in the form of text, button clicks, slider movements, or other interactions, depending on the chosen method.

**All can trigger actions based on input**
Once the user provides input, your Python code can respond accordingly. This could involve performing calculations, updating displays, making API requests, or any other desired actions. The specific actions triggered by user input will depend on the logic you implement in your program, regardless of the input method used.

**Differences:**
While all three methods serve the purpose of getting user input, they differ in terms of their ease of implementation, level of interactivity, and the contexts in which they are typically used. Text-based input is the simplest but least interactive, ipywidgets is well-suited for quick prototypes in Colab, and Tkinter provides the most flexibility for building standalone applications.

**Text-based is simplest to code, but least interactive**
Text-based input using the `input()` function is the most straightforward to implement in Python. It requires minimal setup and can be added to your code with just a few lines. However, it provides a command-line interface, which may not be as user-friendly or visually appealing as graphical interfaces. Users interact by typing in the console, which can be less intuitive compared to clicking buttons or manipulating widgets.

**ipywidgets works in Colab, great for quick prototypes**
ipywidgets integrates seamlessly with Jupyter notebooks, including Google Colab. This makes it an excellent choice for creating interactive prototypes, demonstrations, or data exploration tools directly within the notebook environment. With ipywidgets, you can quickly add GUI elements to your code cells and create interactive experiences without the need for a separate GUI framework. However, ipywidgets is primarily designed for use within notebooks and may not be suitable for building standalone applications.

**Tkinter allows for standalone apps, most flexible**
Tkinter is a powerful and flexible GUI library that allows you to create standalone desktop applications with Python. It provides a wide range of widgets, such as buttons, text boxes, labels, and menus, which can be arranged and customized to build professional-looking interfaces. Tkinter apps can be run independently on a user's machine, making it ideal for distributing your software. However, building Tkinter GUIs requires more code and setup compared to ipywidgets or text-based input.
:::

# Python and GUIs
- You'll learn two ways to create GUIs in Python:
  1. `ipywidgets` for Google Colab
  2. `tkinter` for your local computer
- Focus on these libraries to build interactive weather apps
- GUIs build upon your knowledge of text-based inputs, adding visual elements
- Each method has its strengths, choosing depends on your needs

::: {.notes}
**Aim**
The purpose of this slide is to introduce the two main libraries for creating graphical user interfaces (GUIs) in Python and highlight their relevance to building interactive weather applications.

**Context**
Having defined GUIs in the previous slide, this slide narrows the focus to Python-specific GUI tools. It sets the stage for the upcoming content, which will compare text-based and GUI approaches, and provide hands-on examples using ipywidgets and Tkinter.

**You'll learn two ways to create GUIs in Python:**
This presentation will cover two popular Python libraries for building GUIs: ipywidgets and Tkinter. ipywidgets is a library for creating interactive widgets in Jupyter notebooks, while Tkinter is a standard GUI package that comes bundled with Python. By learning these two approaches, you'll be equipped to create GUIs in various contexts.

**Focus on these libraries to build interactive weather apps**
Throughout this presentation, we'll apply our knowledge of ipywidgets and Tkinter to create interactive weather applications. Weather apps provide a practical and engaging context for learning GUI development, as they involve user input, data retrieval, and dynamic displays. By building weather apps, you'll gain hands-on experience with GUI concepts and techniques.

**GUIs build upon your knowledge of text-based inputs, adding visual elements**
Creating GUIs involves building upon the fundamentals of Python programming, such as handling user input and displaying output. However, GUIs introduce visual elements like buttons, text boxes, and labels, which enhance the user experience. As you learn about GUIs, you'll see how they extend the capabilities of text-based programs and provide a more intuitive interface for users.

**Each method has its strengths, choosing depends on your needs**
Both ipywidgets and Tkinter have their own strengths and use cases. ipywidgets is particularly well-suited for creating interactive widgets within Jupyter notebooks, making it ideal for data exploration and visualization. On the other hand, Tkinter is a versatile library that allows you to create standalone GUI applications that can be run independently of Jupyter. The choice between the two depends on your specific requirements and the context in which you're developing your application.
:::

# Getting Started with ipywidgets in Google Colab
- To use ipywidgets, run this in a Colab cell:
  ```python
  !pip install ipywidgets
  ```
- Colab automatically supports ipywidgets after installation

::: {.notes}
**Aim**
This slide aims to provide instructions on setting up ipywidgets in Google Colab for creating interactive GUIs in Python.

**Context**
After introducing the concept of GUIs and their importance in Python programming, this slide focuses on the practical steps to start using ipywidgets in Google Colab. The following slides will demonstrate how to create and interact with various ipywidgets components.

**To use ipywidgets, run this in a Colab cell:** To begin using ipywidgets in Google Colab, you need to execute a specific command in a Colab cell. This command installs the necessary dependencies and sets up the environment for creating interactive widgets. By running this command, you ensure that your Colab notebook is ready to work with ipywidgets.

**Colab automatically supports ipywidgets after installation** Once you have run the installation command, Google Colab automatically supports ipywidgets without requiring any further configuration. This means that you can immediately start creating and using interactive widgets in your Colab notebook. Colab takes care of the necessary setup, allowing you to focus on building your GUI components.
:::

# Your First ipywidget
- Create a simple text input for a weather app:
  ```python
  import ipywidgets as widgets
  city_input = widgets.Text(description='City:', placeholder='Enter city name')
  display(city_input)
  ```
- Try typing a city name in the input box!

::: {.notes}
**Aim**
The purpose of this slide is to demonstrate how to create a simple text input widget using ipywidgets and show its functionality in the context of a weather app.

**Context**
This slide follows an introduction to ipywidgets in Google Colab, providing a practical example of widget usage. It precedes slides that cover adding a button and making widgets work together to create a complete weather app using ipywidgets.

**Create a simple text input for a weather app:**
To create a text input widget, use the `widgets.Text` class from the ipywidgets library. This class allows users to enter and edit text in a single-line input field. By setting the `placeholder` parameter, you can provide a hint or example of the expected input, such as "Enter a city name". The text input widget can be displayed using the `display` function from IPython.

**Try typing a city name in the input box!**
Encourage your audience to interact with the text input widget by typing a city name into the input box. This hands-on experience helps them understand the functionality of the widget and its role in the weather app. As they type, explain that the entered city name can be accessed programmatically through the `value` attribute of the text input widget, which will be used later to fetch weather data for the specified city.
:::

# Adding a Button
- Create a button to submit your weather query:
  ```python
  button = widgets.Button(description="Get Weather")
  display(button)
  ```
- The button appears, but doesn't do anything yet

::: {.notes}
**Aim**
This slide aims to introduce the process of adding a button to the weather app GUI, which will later be used to submit the user's weather query.

**Context**
Having introduced the concept of GUIs and the basics of ipywidgets, this slide focuses on adding a specific widget - a button - to the weather app. The following slides will cover making the button functional and integrating it with other widgets.

**Create a button to submit your weather query:**
To allow users to interact with the weather app, we need to provide a way for them to submit their weather queries. A button is a common and intuitive way to do this. By creating a button widget, we give users a clear point of interaction within the GUI. The code for adding a button will be demonstrated, showing how to instantiate the widget and specify its properties such as the label text.

**The button appears, but doesn't do anything yet:**
At this stage, the button will be visible in the GUI, but it won't have any functionality associated with it. This is because we haven't yet defined what should happen when the button is clicked. The presenter will emphasise that this is normal and expected at this point in the development process. The next steps will involve linking the button to a function that will be executed when the button is clicked, allowing it to actually perform an action and interact with other parts of the program.
:::

# Making Widgets Work Together
- Combine input and button to display weather info:
  ```python
  output = widgets.Output()
  
  def on_button_click(b):
      with output:
          print(f"Getting weather for {city_input.value}...")
  
  button.on_click(on_button_click)
  display(city_input, button, output)
  ```
- Now you can enter a city and click the button!

::: {.notes}
**Aim**
This slide demonstrates how to combine ipywidgets to create interactive functionality, allowing users to enter a city and retrieve weather information by clicking a button.

**Context**
Having introduced ipywidgets and shown how to create individual widgets like text inputs and buttons, this slide builds on that knowledge by illustrating how to make widgets work together. This sets the stage for the subsequent slide, which presents a complete weather app using ipywidgets.

**Combine input and button to display weather info:**
By connecting an input widget (for entering a city) and a button widget, we can create an interactive experience where the user provides input and triggers an action. When the button is clicked, the value from the input widget is retrieved and used to fetch the corresponding weather information. This interaction between widgets is a key concept in building functional GUIs.

**Now you can enter a city and click the button!**
With the input and button widgets combined, users can now interact with the app more intuitively. They simply need to type the name of a city into the input field and click the button to initiate the weather retrieval process. This interactive flow makes the app more user-friendly and engaging, as users can easily specify their desired location and obtain weather information with a single click.
:::

# Complete Weather App with ipywidgets
```python
import ipywidgets as widgets

city_input = widgets.Text(description='City:', placeholder='Enter city name')
button = widgets.Button(description="Get Weather")
output = widgets.Output()

def get_weather(city):
    # In a real app, you'd fetch actual weather data here
    return f"It's sunny and 22°C in {city}!"

def on_button_click(b):
    with output:
        output.clear_output()
        print(get_weather(city_input.value))

button.on_click(on_button_click)
display(city_input, button, output)
```

::: {.notes}
**Aim**
Showcase a complete weather app built using ipywidgets, demonstrating the practical application of the concepts covered in the presentation.

**Context**
After introducing ipywidgets and guiding the audience through the process of creating simple widgets and making them interact, this slide presents a fully functional weather app. It serves as a culmination of the ipywidgets section before transitioning to Tkinter and discussing when to use each toolkit.
:::

# Moving Beyond Google Colab
- ipywidgets works great in Colab, but what about on your own computer?
- Enter `tkinter`: Python's built-in GUI library for local app

::: {.notes}
**Aim**
This slide aims to introduce tkinter as a solution for creating GUI applications locally, beyond the Google Colab environment.

**Context**
After exploring ipywidgets for building interactive GUIs within Google Colab, this slide transitions to discussing GUI development on a local computer. It sets the stage for introducing tkinter, Python's built-in GUI library, which will be covered in the subsequent slides.

**ipywidgets works great in Colab, but what about on your own computer?**
While ipywidgets is an excellent library for creating interactive widgets and GUIs within the Google Colab environment, it may not be the most suitable choice when developing GUI applications on your local machine. Google Colab is a web-based platform, and ipywidgets is designed to work seamlessly within Jupyter notebooks. However, when it comes to building standalone GUI applications that can run on your computer, you need a library that is compatible with the local environment.

**Enter `tkinter`: Python's built-in GUI library for local app**
This is where tkinter comes into play. Tkinter is Python's standard GUI library that comes built-in with the Python installation. It provides a set of tools and widgets for creating graphical user interfaces that can run as standalone applications on your local computer. Tkinter offers a wide range of GUI elements such as windows, buttons, labels, text boxes, and more, allowing you to build feature-rich and interactive applications. With tkinter, you can create GUIs that have a native look and feel, integrating seamlessly with the operating system. In the upcoming slides, we will explore tkinter in more detail and learn how to create GUI applications using this powerful library.
:::

# Why Tkinter Doesn't Work on Google Colab
- Tkinter requires a local display to show windows
- Google Colab runs in the cloud without a graphical interface
- Colab is designed for web-based interactions, not desktop applications
- That's why we use ipywidgets in Colab - it's web-friendly!
- To use Tkinter, you'll need to run Python on your own computer

::: {.notes}
**Aim**
This slide aims to explain why Tkinter, a popular Python GUI toolkit, is not compatible with Google Colab, a web-based Python environment.

**Context**
After introducing ipywidgets as a GUI solution for Google Colab, this slide addresses a potential question learners might have: why not use Tkinter, a well-known Python GUI toolkit, in Colab? The slide then transitions to introducing Tkinter for use on learners' own computers.

**Tkinter requires a local display to show windows**
Tkinter is designed to create desktop applications with graphical user interfaces. It requires a local display server to render the windows and widgets of the application. Without a local display, Tkinter cannot function properly.

**Google Colab runs in the cloud without a graphical interface**
Google Colab is a cloud-based Jupyter notebook environment. It runs on remote servers and provides access through a web browser. Colab does not have a local graphical display server, which is necessary for Tkinter to operate.

**Colab is designed for web-based interactions, not desktop applications**
The primary purpose of Google Colab is to facilitate interactive development, data analysis, and machine learning in a web-based environment. It is optimised for running code, displaying outputs, and sharing results through the browser, rather than creating standalone desktop applications.

**That's why we use ipywidgets in Colab - it's web-friendly!**
Ipywidgets is a library specifically designed for creating interactive widgets in Jupyter notebooks, including Google Colab. It leverages the web-based nature of Colab and allows you to build interactive GUIs that can be displayed and controlled directly within the notebook.

**To use Tkinter, you'll need to run Python on your own computer**
If you want to develop desktop applications using Tkinter, you'll need to run Python locally on your own computer. This ensures that you have access to the necessary display server and can create and interact with Tkinter windows and widgets directly on your machine.
:::

# Introduction to Tkinter
- Tkinter is Python's built-in GUI library
- It comes pre-installed with Python on your computer
- Tkinter allows you to create standalone desktop applications
- You'll run these apps directly on your computer, not in a browser

::: {.notes}
**Aim**
This slide introduces Tkinter, Python's built-in GUI library, and highlights its key features and capabilities for creating standalone desktop applications.

**Context**
After discussing GUIs in general and exploring ipywidgets in Google Colab, the presentation now shifts focus to Tkinter, a powerful library for creating desktop applications. The following slides will provide a step-by-step guide on using Tkinter to build a weather app.

**Tkinter is Python's built-in GUI library**
Tkinter comes as part of the standard Python distribution, making it readily accessible to developers. As a built-in library, Tkinter is well-documented and has a large community of users, providing ample resources and support for those learning to create GUIs with Python.

**It comes pre-installed with Python on your computer**
Since Tkinter is included with Python, there's no need to install additional packages or libraries. This makes it convenient for developers to start building GUIs without the hassle of managing external dependencies, ensuring a smooth and efficient development process.

**Tkinter allows you to create standalone desktop applications**
With Tkinter, developers can create fully-functional desktop applications that run independently on a user's computer. These applications have access to system resources and can perform a wide range of tasks, from simple utilities to complex software solutions.

**You'll run these apps directly on your computer, not in a browser**
Unlike web-based applications that run in a browser, Tkinter applications are executed directly on the user's computer. This allows for better performance, offline functionality, and direct access to system resources, providing a native and seamless user experience.
:::

# Your First Tkinter Window
- Create a basic window with tkinter:
  ```python
  import tkinter as tk
  
  window = tk.Tk()
  window.title("My Weather App")
  window.mainloop()
  ```
- Save this as `weather_app.py` and run it with `python weather_app.py`

::: {.notes}
**Aim**
The aim of this slide is to guide the audience through creating their first basic window using the Tkinter library in Python.

**Context**
After discussing the limitations of using ipywidgets in Google Colab, the presentation introduces Tkinter as an alternative for building GUI applications. This slide provides a practical example of how to create a simple Tkinter window, setting the stage for the following slides that will expand on adding widgets and functionality to the application.

**Create a basic window with tkinter:**
To create a basic window using Tkinter, you need to import the library and create an instance of the Tk class, which represents the main window of your application. You can set the title of the window using the `title()` method and specify its dimensions using the `geometry()` method. Finally, you need to call the `mainloop()` method to display the window and start the event loop that handles user interactions.

**Save this as `weather_app.py` and run it with `python weather_app.py`**
After writing the code to create a basic Tkinter window, save the file with a descriptive name, such as `weather_app.py`. To run the application, open a terminal or command prompt, navigate to the directory where you saved the file, and execute the command `python weather_app.py`. This will launch your Tkinter application, displaying the window you created.
:::

# Adding Widgets to Your Tkinter Window
- Let's add a label and text entry for the city:
  ```python
  import tkinter as tk
  
  window = tk.Tk()
  window.title("My Weather App")
  
  label = tk.Label(window, text="Enter City:")
  label.pack()
  
  entry = tk.Entry(window)
  entry.pack()
  
  window.mainloop()
  ```

::: {.notes}
**Aim**
This slide aims to demonstrate how to add a label and text entry widget to a Tkinter window to allow the user to input a city name.

**Context**
Having introduced Tkinter and shown how to create a basic window, the presentation now progresses to adding interactive elements. This slide builds upon the previous one about creating a Tkinter window and leads into the next slides on creating buttons and displaying results.

**Let's add a label and text entry for the city:**
To allow the user to input a city name, we need to add two widgets to our Tkinter window: a label and a text entry. The label provides a text description of what the user should enter, while the text entry is an input field where the user can type the city name. These widgets are positioned within the window using a geometry manager, such as pack, grid, or place. By adding these interactive elements, we make our application more functional and user-friendly.
:::

# Creating a Button in Tkinter
- Add a button to get the weather:
  ```python
  button = tk.Button(window, text="Get Weather")
  button.pack()
  ```
- Add this code before `window.mainloop()`

::: {.notes}
**Aim**
This slide aims to demonstrate how to add a button to a Tkinter window and explain where the code for creating the button should be placed.

**Context**
Having introduced Tkinter and shown how to create a basic window, the presentation now progresses to adding interactive elements to the window. This slide focuses on adding a button, which is a fundamental interactive component in most GUI applications. The subsequent slides will cover displaying results and making the app functional, building upon the concepts introduced here.

**Add a button to get the weather:** 
To add a button to your Tkinter window, you can use the `Button` widget. The button is created with the `Button()` constructor, which takes the window as its first argument. You can specify the text to display on the button using the `text` parameter. For example, to create a button that says "Get Weather", you would use:

```python
get_weather_button = Button(window, text="Get Weather")
```

**Add this code before `window.mainloop()`**
It's important to place the code for creating and configuring the button before the `window.mainloop()` call. The `mainloop()` function starts the event loop and displays the window, so any code that modifies the window should come before it. If you add the button code after `mainloop()`, the button will not appear in the window. For example:

```python
window = Tk()
# ...
get_weather_button = Button(window, text="Get Weather")
window.mainloop()
```
:::

# Displaying Results in Tkinter
- Create a label to show the weather results:
  ```python
  result_label = tk.Label(window, text="")
  result_label.pack()
  ```
- Add this code before `window.mainloop()`

::: {.notes}
**Aim**
This slide aims to demonstrate how to display the results of the weather app in a Tkinter window.

**Context**
After creating the basic structure of the Tkinter window and adding widgets such as buttons, the next step is to display the results of the weather app. This slide builds upon the previous slides that introduced Tkinter and showed how to create a window and add widgets.

**Create a label to show the weather results:**
To display the weather results in the Tkinter window, you need to create a label widget. The label will be used to show the text output from the weather app. You can create a label using the `Label()` function from Tkinter, specifying the parent window and the initial text to display. For example: `result_label = Label(window, text="")`.

**Add this code before `window.mainloop()`**
It's important to add the code for creating and positioning the label before the `window.mainloop()` line in your Tkinter app. The `mainloop()` function starts the event loop and displays the window, so any widgets you want to appear in the window must be created and positioned before calling `mainloop()`. Make sure to place the label creation code in the appropriate location to ensure it appears in the window when the app is run.
:::

# Making Your Tkinter App Functional
- Let's add some action to the button:
  ```python
  def get_weather():
      city = entry.get()
      # In a real app, you'd fetch actual weather data here
      weather = f"It's sunny and 22°C in {city}!"
      result_label.config(text=weather)
  
  button.config(command=get_weather)
  ```
- Add this code before `window.mainloop()`

::: {.notes}
**Aim**
This slide aims to demonstrate how to make the button in the Tkinter app functional by adding code that responds to user interactions.

**Context**
Having created a basic Tkinter window with a button in the previous slides, this slide builds on that foundation by showing how to make the button actually do something when clicked. This is a crucial step in creating a fully functional GUI application with Tkinter.

**Let's add some action to the button:**
Now that we have a button displayed in our Tkinter window, it's time to make it interactive. By default, the button doesn't do anything when clicked. To change this, we need to define a function that will be called whenever the button is pressed. This function can contain any code we want to execute when the button is clicked, such as updating labels, performing calculations, or opening new windows.

**Add this code before `window.mainloop()`**
To associate a function with a button click event, we need to modify the button creation code. Before calling `window.mainloop()`, which starts the main event loop of the Tkinter application, we'll add a command parameter to the button constructor. This parameter takes the name of the function (without parentheses) that should be called when the button is clicked. By placing this code before `window.mainloop()`, we ensure that the button's functionality is defined before the application starts running.
:::

# Complete Tkinter Weather App
```python
import tkinter as tk

def get_weather():
    city = entry.get()
    # In a real app, you'd fetch actual weather data here
    weather = f"It's sunny and 22°C in {city}!"
    result_label.config(text=weather)

window = tk.Tk()
window.title("My Weather App")

label = tk.Label(window, text="Enter City:")
label.pack()

entry = tk.Entry(window)
entry.pack()

button = tk.Button(window, text="Get Weather", command=get_weather)
button.pack()

result_label = tk.Label(window, text="")
result_label.pack()

window.mainloop()
```

::: {.notes}
**Aim**
The aim of this slide is to showcase the final result of the Tkinter weather app project.

**Context**
This slide serves as the culmination of the Tkinter section of the presentation. It follows the progression from introducing Tkinter, creating a window, adding widgets, making the app functional, and finally arriving at the completed weather app. The next slide discusses running the Tkinter app, and subsequent slides compare ipywidgets and Tkinter, and explore the broader world of GUIs.
:::

# Running Your Tkinter App
- Save the complete code as `weather_app.py`
- Open your terminal or command prompt
- Navigate to the folder containing your script
- Run the command: `python weather_app.py`
- Your weather app will appear in a new window!

::: {.notes}
**Aim**
This slide aims to guide the audience through the process of running their completed Tkinter weather application.

**Context**
After introducing Tkinter and walking through the creation of a functional weather app, this slide provides the final steps to save and run the application. It prepares the audience to use their new skills independently and see their app in action.

**Save the complete code as `weather_app.py`** 
Once you have finished coding your Tkinter weather app, save the entire script in a file named `weather_app.py`. This file will contain all the necessary code to create the GUI and fetch weather data. Choose a location on your computer that you can easily navigate to using the command line.

**Open your terminal or command prompt** 
To run your Tkinter app, you'll need to use the command line. On macOS, open the Terminal application. For Windows users, open the Command Prompt. If you're using Linux, open your preferred terminal emulator. Familiarise yourself with the basic commands for navigating through directories in your command line interface.

**Navigate to the folder containing your script** 
Using the `cd` command followed by the appropriate file path, navigate to the directory where you saved your `weather_app.py` file. For example, if your file is saved in a folder called `tkinter_projects` on your desktop, you would type `cd Desktop/tkinter_projects` and press Enter to move into that directory.

**Run the command: `python weather_app.py`** 
Once you're in the correct directory, type `python weather_app.py` and press Enter to execute your script. This command tells your computer to run the Python interpreter and execute the code contained in the `weather_app.py` file. Make sure you have Python installed on your system and accessible from the command line.

**Your weather app will appear in a new window!** 
After running the command, your Tkinter weather app will launch in a new window. You'll see the GUI elements you created, such as the input field, button, and label for displaying the weather information. Interact with your app by entering a city name and clicking the button to fetch the current weather data. Celebrate your success in creating a functional GUI application using Python and Tkinter!
:::

# When to Use Each
- Use ipywidgets when:
  - Working in Google Colab or Jupyter Notebooks
  - Quickly prototyping ideas
  - Sharing interactive code online
- Use tkinter when:
  - Creating standalone desktop applications
  - Building apps that don't require an internet connection
  - Developing more complex GUI structures

::: {.notes}
**Aim**
The aim of this slide is to provide guidance on when to choose ipywidgets versus tkinter for building GUI applications in Python.

**Context**
Having introduced both ipywidgets and tkinter, this slide helps learners understand the strengths and appropriate use cases for each library. It sets the stage for the upcoming slides that discuss expanding GUI skills and exploring the broader world of GUI development.

**Use ipywidgets when:**
ipywidgets is the ideal choice when working within Google Colab or Jupyter Notebooks. Its seamless integration allows for quick prototyping of ideas and interactive exploration of code. The ability to easily share ipywidget-based apps online makes it a great option for collaborating with others or showcasing your work.

**Working in Google Colab or Jupyter Notebooks**
Google Colab and Jupyter Notebooks provide a browser-based environment for developing and running Python code. ipywidgets is built to work smoothly within these platforms, allowing you to create interactive widgets directly in your notebook cells. This integration makes it convenient to experiment with GUI elements alongside your data analysis or machine learning code.

**Quickly prototyping ideas**
ipywidgets enables rapid prototyping of interactive features. With just a few lines of code, you can create sliders, buttons, text inputs, and other widgets to control and visualise your Python scripts. This speed of development is particularly useful when testing out new ideas or iterating on existing ones.

**Sharing interactive code online**
One of the key advantages of ipywidgets is the ability to share your interactive code online. By hosting your Jupyter Notebook on a platform like GitHub or Binder, others can access and run your ipywidget-based apps through their web browser. This ease of sharing facilitates collaboration and allows you to showcase your work to a wider audience.

**Use tkinter when:**
tkinter is the go-to choice when creating standalone desktop applications that don't rely on an internet connection. It provides a wide range of widgets and allows for the development of more complex GUI structures compared to ipywidgets. If your goal is to build a feature-rich, offline-capable Python app, tkinter is the way to go.

**Creating standalone desktop applications**
tkinter is designed for building standalone desktop applications. Unlike ipywidgets, which are tied to the browser-based environment of Google Colab or Jupyter Notebooks, tkinter apps can be packaged and distributed as executable files. This allows users to run your application on their local machines without the need for a web browser or internet connection.

**Building apps that don't require an internet connection**
Since tkinter apps are standalone, they can function fully offline. This is particularly useful when developing applications for environments with limited or no internet connectivity. With tkinter, you can create self-contained Python programs that run independently of web-based resources.

**Developing more complex GUI structures**
tkinter offers a wider range of widgets and layout options compared to ipywidgets. This flexibility allows for the creation of more intricate and feature-rich GUI structures. From multi-window interfaces to custom dialog boxes and menus, tkinter provides the tools to build sophisticated desktop applications that go beyond the capabilities of ipywidgets.
:::

# Expanding Your GUI Skills
- Next steps to explore:
  - Learn about layout management in tkinter
  - Explore styling and theming your GUI
  - Try other GUI libraries like PyQt or Kivy
  - Integrate real weather APIs into your app

::: {.notes}
**Aim**
The aim of this slide is to provide the audience with guidance on how they can further develop their GUI skills beyond the basics covered in the presentation.

**Context**
Having demonstrated how to create functional weather apps using both ipywidgets in Google Colab and Tkinter, this slide serves as a bridge to more advanced GUI topics. It encourages the audience to explore these areas independently to continue their learning journey.

**Next steps to explore:**
This bullet point introduces the main theme of the slide, which is to provide the audience with specific areas they can investigate to expand their GUI skills.

**Learn about layout management in tkinter**
Layout management is a critical aspect of creating professional-looking GUIs. By learning how to effectively use geometry managers like pack, grid, and place in Tkinter, the audience can create well-organised and responsive user interfaces that adapt to different window sizes and resolutions.

**Explore styling and theming your GUI**
Styling and theming can greatly enhance the visual appeal and user experience of a GUI application. The audience should explore how to customise colours, fonts, and other visual properties using Tkinter's styling options or by leveraging external libraries like ttk (Themed Tkinter) for a more modern and polished look.

**Try other GUI libraries like PyQt or Kivy**
While Tkinter is a great starting point for GUI development in Python, there are many other powerful libraries worth exploring. PyQt is a comprehensive set of Python bindings for the Qt framework, offering a wide range of widgets and tools for building feature-rich desktop applications. Kivy, on the other hand, is an open-source library for developing cross-platform applications with a focus on touch-based interfaces and mobile devices.

**Integrate real weather APIs into your app**
To make the weather app examples more practical and useful, the audience should consider integrating real-time weather data from external APIs. Popular weather APIs like OpenWeatherMap or WeatherAPI.com offer free and paid plans for accessing current weather conditions, forecasts, and other meteorological data. By learning how to make HTTP requests and parse JSON responses, the audience can create dynamic and informative weather applications.
:::

# The Broader World of GUIs
- We've focused on ipywidgets and Tkinter, but there's more to explore:
- Web Interfaces:
  - Frameworks like Flask or Django let you create web-based GUIs
  - Example: A weather website where users enter their city
- Mobile Apps:
  - Tools like Kivy or BeeWare can create Python-based mobile apps
  - Platforms like Anvil let you build web apps that work on phones
- Remember:
  - Start with the basics (ipywidgets, Tkinter) to learn core concepts
  - These advanced options build on the fundamentals you're learning now

::: {.notes}
**Aim**
This slide aims to provide a glimpse into the broader world of GUI development beyond ipywidgets and Tkinter, introducing web interfaces and mobile app development.

**Context**
Having covered the basics of GUI development with ipywidgets and Tkinter, this slide expands students' horizons by touching on more advanced GUI options. It serves as a bridge between the foundational concepts already covered and the potential for further exploration in the field.

**We've focused on ipywidgets and Tkinter, but there's more to explore:** The world of GUI development extends far beyond the scope of this presentation. While ipywidgets and Tkinter provide a solid foundation, there are numerous other tools and frameworks available for creating graphical user interfaces across different platforms.

**Web Interfaces:** Web-based GUIs offer the advantage of being accessible through a web browser, making them platform-independent. Frameworks such as Flask and Django, which are built on top of Python, enable developers to create interactive web interfaces. These frameworks handle the backend logic and provide tools for rendering HTML templates, handling user input, and managing data.

**Example: A weather website where users enter their city** To illustrate the concept of a web-based GUI, consider a weather website where users can input their city name to retrieve current weather information. This involves creating a user-friendly interface with input fields and buttons, handling user input on the backend, making API calls to retrieve weather data, and dynamically updating the webpage with the retrieved information.

**Mobile Apps:** Python can also be used to develop mobile applications for platforms like iOS and Android. Tools such as Kivy and BeeWare provide frameworks for building cross-platform mobile apps using Python. These frameworks abstract away platform-specific details and allow developers to write code once and deploy it on multiple mobile platforms.

**Platforms like Anvil let you build web apps that work on phones** In addition to traditional mobile app development, platforms like Anvil offer a simplified approach to creating mobile-friendly web applications. Anvil provides a drag-and-drop interface for building web apps visually, and the resulting apps are responsive and work seamlessly on mobile devices.

**Remember:** As you explore more advanced GUI options, it's crucial to remember that the concepts and principles you've learned with ipywidgets and Tkinter form the foundation of GUI development. Understanding event handling, widget placement, and data flow between components is essential regardless of the specific framework or tool you choose.

**Start with the basics (ipywidgets, Tkinter) to learn core concepts** Mastering the fundamentals through hands-on experience with ipywidgets and Tkinter will equip you with the necessary problem-solving skills and logical thinking required for tackling more complex GUI projects. These basic tools serve as stepping stones, allowing you to grasp the core concepts before diving into more advanced frameworks.

**These advanced options build on the fundamentals you're learning now** As you progress in your GUI development journey, you'll find that the advanced options mentioned, such as web frameworks and mobile app development tools, build upon the same principles you're learning now. The skills you acquire working with ipywidgets and Tkinter, such as layout management, event handling, and data binding, will be applicable and transferable to these more advanced contexts.
:::

# Wrap-up and Q&A
- We've covered a lot:
  1. Text-based inputs
  2. ipywidgets for interactive notebooks
  3. Tkinter for desktop applications
  4. Brief intro to web and mobile possibilities
- Focus on mastering ipywidgets and Tkinter first
- The skills you're learning apply to more advanced frameworks too
- Any questions about what we've covered or the broader world of GUIs?

::: {.notes}
**Aim**
The purpose of this slide is to summarise the key points covered in the presentation and open the floor for questions from the audience.

**Context**
This is the final slide of the presentation, following slides that have introduced GUIs, demonstrated how to create GUIs using ipywidgets and Tkinter, and explored the broader world of GUI frameworks. It aims to reinforce the main takeaways and provide an opportunity for clarification and discussion.

**We've covered a lot:**
Throughout this presentation, we've introduced the concept of GUIs and explored how to create them using Python. We started with ipywidgets in Google Colab, learning how to create widgets, make them interact, and build a complete weather app. We then moved on to Tkinter, covering the basics of creating windows, adding widgets, and building a functional weather app. Finally, we discussed when to use each framework and touched on the broader world of GUIs.

**Focus on mastering ipywidgets and Tkinter first**
While there are many GUI frameworks available, it's important to start with the basics. ipywidgets and Tkinter are excellent starting points, as they provide a solid foundation in GUI development. By mastering these frameworks, you'll gain the skills and understanding needed to work with more advanced options in the future. Don't feel pressured to learn everything at once; take your time to become proficient with these tools first.

**The skills you're learning apply to more advanced frameworks too**
The concepts and techniques you've learned while working with ipywidgets and Tkinter are transferable to other GUI frameworks. The process of creating widgets, laying out your interface, and handling user interactions is similar across many frameworks. As you explore more advanced options, you'll find that the skills you've developed will serve you well. Keep practicing and building projects to solidify your understanding.

**Any questions about what we've covered or the broader world of GUIs?**
Now is your opportunity to ask any questions you may have about the topics we've covered or GUI development in general. Whether you need clarification on a specific concept, want to know more about a particular framework, or are curious about best practices, feel free to ask. Remember, there are no silly questions, and your fellow learners may benefit from the discussion as well. Don't hesitate to speak up and seek the information you need to further your understanding of GUIs.
:::



---
title: "Debugging the Weather: Testing Your Code with Python"
subtitle: "From print statements to doctests—Master the basics of testing and debugging with a weather twist!"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Copyright Information

![](../../../_assets/curtin-copy-right.png)

# Acknowledgement of Country

I acknowledge the traditional custodians of the land on which I work and live,
and recognise their continuing connection to land, water and community. I pay
respect to elders past, present and emerging.

![](../../../_assets/ack_country.png)

# Today’s Goals

- Understand the difference between testing and debugging
- Describe one approach to debugging
- State why we test
- List common testing strategies


# Problem-Solving Methodology

1. **State the problem clearly**
   - Example: *Predict tomorrow’s weather based on today’s data.*

2. **Describe the input and output**
   - Input: Weather data (e.g., temperature, humidity, wind speed)
   - Output: Weather prediction (sunny, rainy, etc.)

3. **Work a simple example by hand**
   - If today’s temperature is 25°C and wind speed is 5 km/h, predict tomorrow’s temperature.

4. **Develop an algorithm (and convert to Python)**
   - Example algorithm: Use an average of the last 5 days' temperature to predict tomorrow’s.

5. **Test solution with a variety of data**
   - Test using multiple data points: What if it’s 35°C? Or 0°C?

6. **Feedback Loop(s)**
   - Test -> Debug -> Refine -> Retest

*"I'm not a great programmer, I'm just a good programmer with great habits"*  
— Kent Beck



# Great Habits for Testing and Debugging

- **Comments**: Describe what your code is doing.
- **Docstrings**: Add documentation to your functions (this will help with doctests!).
- **Use/Create functions**: Break tasks into reusable pieces.
- **Use/Create modules**: Organize your code.
- **Make small frequent commits**: Helps isolate where bugs come from.



# What is a Bug?

*A software bug is an error, flaw, or fault in computer software that causes it to produce an incorrect or unexpected result, or behave in unintended ways.*  
— Wikipedia



# Debugging: The Process of Fixing Bugs

1. **Types of Errors**:
   - **Syntax Errors**: Mistakes in the code’s format.
   - **Run-Time Errors**: Errors that occur when the program is running (e.g., division by zero).
   - **Logic Errors**: The code runs but produces incorrect results (e.g., wrong weather prediction).

2. **Debugging with `print()`**:
   - Use `print()` to display variables and track how values change in your program.
   - Example:
     ```python
     def predict_weather(temp):
         print(f"Current temperature: {temp}")
         if temp > 25:
             return "Sunny"
         else:
             return "Cloudy"
     print(predict_weather(30))  # Should print "Sunny"
     ```



# Debugging Strategies

- **Step/Trace through code**: Use `print()` to trace how data flows.
- **Inspect Objects**: Use `type()` to check what kind of data your variables are holding.
- **Apply Trial and Error**: Try different values, step through your logic slowly.
- **Compare to similar code**: Use working code as a reference.
- **Ask for help**: Reach out to peers, forums, or Google.
- **Use an IDE**: Syntax highlighting and autocompletion can catch errors before you even run your code.



# Why Test?

- **Reliable**: Ensure the software behaves as expected.
- **Reproducible**: Others can verify your results.
- **Shareable**: Collaborators can see that your code works.

**_"Testing leads to failure, and failure leads to understanding."_**  
— Burt Rutan



# Testing: What Are We Testing?

1. **Requirements**: Does the weather prediction match the user’s needs?
2. **Design**: Does the code structure make sense?
3. **Code/Implementation**: Are the calculations and logic correct?
4. **Documentation**: Are there enough docstrings and comments?



# You Are Already Testing!

- Validating inputs:
  - Example: What if someone enters an invalid temperature like "hot" instead of a number?

- Testing a variety of inputs (data):
  - Example: What happens if today's temperature is -10°C vs. 40°C?

- Checking outputs to meet requirements:
  - Does the predicted weather make sense based on the input?

**We are just giving more structure to this process.**



# Types of Tests

1. **Unit Testing**: Test an individual, isolated function or module.
   - Example: Test if the `predict_weather()` function returns the correct output for different temperatures.

2. **Integration Testing**: Ensure multiple parts of the program work together.
   - Example: Test if weather prediction works when integrated with a larger weather dashboard application.

3. **End-to-End Testing**: Simulate a real user interacting with your program.
   - Example: Test the entire workflow of entering today's weather and predicting tomorrow's weather in your app.

4. **Acceptance Testing**: Ensure the program meets the user’s requirements.
   - Example: The program should correctly predict "Sunny" when the temperature is above 25°C.




Absolutely! Here's a slide reviewing REPL (Read-Eval-Print Loop) to provide context before introducing `doctest`:



# Review: What is the Python REPL?

The Python REPL stands for **Read-Eval-Print Loop** and is an interactive environment that lets you type and execute Python code line by line.

# How REPL Works:

1. **Read**: The REPL reads your input (Python code).
2. **Eval**: It evaluates or executes the code you entered.
3. **Print**: It displays the result of your code.
4. **Loop**: The process repeats, allowing you to try more code.

# Why Use REPL?

- **Instant Feedback**: You can quickly test and run small pieces of code.
- **Interactive Learning**: It’s great for experimenting with Python features.
- **Debugging**: Use it to test functions and explore data interactively.

# Example: REPL in Action

```python
>>> temperature = 30
>>> if temperature > 25:
...     print("Sunny")
... else:
...     print("Cloudy")
...
Sunny
```

In this example:
- You entered a condition based on temperature.
- The REPL evaluated the condition and printed "Sunny" as the result.



### How REPL Connects to Doctests

- **Doctests** mimic the Python shell (REPL) experience inside your code.
- You can write your function's expected behaviour in a way that looks like what you'd do in the REPL.



# Simple Example: Testing with `doctest`

You can embed tests inside your function’s docstrings using `doctest`. Here's a weather example:

```python
def predict_weather(temp):
    """
    Predict tomorrow's weather based on today's temperature.

    >>> predict_weather(30)
    'Sunny'
    >>> predict_weather(20)
    'Cloudy'
    """
    if temp > 25:
        return "Sunny"
    else:
        return "Cloudy"
```

You can run `doctest` to check if the output matches the expected results. To run `doctest`, add this to the bottom of your script:
```python
if __name__ == "__main__":
    import doctest
    doctest.testmod()
```


# Doctests: Testing in Your Docstrings

Doctests allow you to write test cases directly in your function's docstring,
mimicking how you would test code in the Python shell. They are great for small
functions and help you document the expected behavior of your code.

# How Doctests Work

- Doctests simulate the Python shell (REPL) and check if the output matches the expected result written in the docstring.
- You write the function's input and output in a way that looks like a Python session, and `doctest` automatically checks if the function produces the correct result.

# Doctest Example (Weather Prediction)

```python
def predict_weather(temp):
    """
    Predict tomorrow's weather based on today's temperature.
    
    This function returns 'Sunny' if the temperature is above 25°C, 
    otherwise it returns 'Cloudy'.
    
    Example usage in the Python shell:
    
    >>> predict_weather(30)
    'Sunny'
    >>> predict_weather(20)
    'Cloudy'
    """
    if temp > 25:
        return "Sunny"
    else:
        return "Cloudy"
```

# Why Use Doctests?

- **Readable**: It combines documentation and testing in one place.
- **Simple**: You don't need separate testing files for small functions.
- **Automated**: Doctests verify that your code behaves as described.

# Running Doctests

To run doctests, include the following at the bottom of your Python file:
```python
if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

This will run the tests inside your docstrings, checking if the actual outputs match the expected ones.



# Doctest vs. Python Shell

When you run `doctest`, it behaves as if you are manually entering the input and checking the output in the Python shell (REPL):

**Python Shell Session**:
```python
>>> predict_weather(30)
'Sunny'
>>> predict_weather(20)
'Cloudy'
```

**Doctest in Docstring**:
```python
"""
>>> predict_weather(30)
'Sunny'
>>> predict_weather(20)
'Cloudy'
"""
```

Doctests save you time by automating these shell interactions and ensuring your code works as expected!



# Testing Strategy in Jupyter Notebooks

There are different ways to test notebooks:

- **Write python script to test notebook**: You can import your functions from the notebook and test them using a Python script.
- **Write test and code in one notebook**: You can use `assert()`, `doctest`, or other testing libraries directly in the notebook.
  
Example in a notebook:
```python
# Code cell:
def predict_weather(temp):
    return "Sunny" if temp > 25 else "Cloudy"

# Test cell:
assert predict_weather(30) == "Sunny"
assert predict_weather(20) == "Cloudy"
```



Here's a slide explaining how to use `doctest` in Jupyter notebooks, tailored for your audience:



# Using Doctests in Jupyter Notebooks

1. **Write Your Function with a Doctest**:
   Include the test cases directly in your function’s docstring.

   ```python
   def predict_weather(temp):
       """
       Predict tomorrow's weather based on today's temperature.

       >>> predict_weather(30)
       'Sunny'
       >>> predict_weather(20)
       'Cloudy'
       """
       if temp > 25:
           return "Sunny"
       else:
           return "Cloudy"
   ```

2. **Run Doctests with `doctest.testmod()`**:
   You can run your doctests in a Jupyter notebook using the `doctest` module.

   ```python
   import doctest
   doctest.testmod()
   ```

3. **View the Results**:
   If all tests pass, there will be no output.
   If any tests fail, `doctest` will show where the function’s output didn’t match the expected result.



# Example in Jupyter Notebook

- First, define the function with doctests in the cell.
- Then, in a new cell, run the following code to check the tests:

```python
import doctest
doctest.testmod()
```

### Key Points:

- In Jupyter notebooks, `doctest` works just like in standard Python scripts.
- The tests will run, and you can verify that your function behaves as expected, just like in the Python shell.


# Building a Test Suite

1. **Build up a suite of tests**: Create a set of tests that cover different parts of your program.
2. **Run all tests in one go**: Use a script or notebook to run all tests automatically.
3. **Test sane cases, then edge cases**: Test common scenarios first, then unusual inputs.
   - Example: What happens when you input extreme temperatures like -100°C or 100°C?



# Review: Can you…

- Understand the difference between testing and debugging?
- Describe one approach to debugging?
- State why we test?
- List common testing strategies?



---
title: "Debugging the Weather: Testing Your Code with Python"
subtitle: "From print statements to doctests—Master the basics of testing and debugging with a weather twist!"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Copyright Information

![](../../../_assets/curtin-copy-right.png)

# Acknowledgement of Country

I acknowledge the traditional custodians of the land on which I work and live,
and recognise their continuing connection to land, water and community. I pay
respect to elders past, present and emerging.

![](../../../_assets/ack_country.png)

# Today’s Goals

- Understand the difference between testing and debugging
- Describe one approach to debugging
- State why we test
- List common testing strategies

::: {.notes}
**Aim**
The aim of this slide is to clearly outline the learning objectives for the session and set expectations for what participants will gain from the presentation.

**Context**
This slide follows the Acknowledgement of Country and copyright information. It sets the stage for the rest of the presentation, which covers debugging, testing strategies, and practical examples using Python REPL and Jupyter Notebooks. The topics mentioned in the goals will be explored in more detail throughout the subsequent slides.

**Understand the difference between testing and debugging**
Testing and debugging are often confused, but they serve distinct purposes. Testing involves validating that the code behaves as expected and produces the desired output. In contrast, debugging is the process of identifying and fixing issues or bugs in the code. Understanding this difference is crucial for developing a comprehensive approach to ensuring code quality and reliability.

**Describe one approach to debugging**
One common approach to debugging is using print statements strategically throughout the code to track the values of variables and identify where the issue might be occurring. By outputting the state of the program at different points, developers can narrow down the location of the bug and gain insights into what might be causing it. This technique, along with others, will be explored further in the presentation.

**State why we test**
Testing is an essential part of the software development process. It helps ensure that the code is functioning as intended, handles edge cases gracefully, and produces reliable results. By catching bugs and issues early, testing can save time and resources in the long run. Additionally, testing helps maintain code quality, improves reliability, and provides confidence in the software's behaviour.

**List common testing strategies**
There are various testing strategies that developers can employ, each with its own strengths and use cases. Some common testing strategies include unit testing, where individual components or functions are tested in isolation; integration testing, which verifies how different parts of the system work together; and end-to-end testing, which tests the entire application flow from start to finish. Other strategies, such as regression testing and acceptance testing, will also be discussed in the presentation.
:::

# Problem-Solving Methodology

1. **State the problem clearly**
   - Example: *Predict tomorrow’s weather based on today’s data.*

2. **Describe the input and output**
   - Input: Weather data (e.g., temperature, humidity, wind speed)
   - Output: Weather prediction (sunny, rainy, etc.)

3. **Work a simple example by hand**
   - If today’s temperature is 25°C and wind speed is 5 km/h, predict tomorrow’s temperature.

4. **Develop an algorithm (and convert to Python)**
   - Example algorithm: Use an average of the last 5 days' temperature to predict tomorrow’s.

5. **Test solution with a variety of data**
   - Test using multiple data points: What if it’s 35°C? Or 0°C?

6. **Feedback Loop(s)**
   - Test -> Debug -> Refine -> Retest

*"I'm not a great programmer, I'm just a good programmer with great habits"*  
— Kent Beck

::: {.notes}
**Aim**
This slide aims to introduce a simple problem-solving methodology using the example of predicting tomorrow's weather based on today's data.

**Context**
After setting the goals for the presentation, this slide provides a practical example of problem-solving in the context of AI and machine learning. It sets the stage for discussing good habits for testing and debugging, which will be covered in the following slides.

**Example: *Predict tomorrow's weather based on today's data.***
In this example, we will use a simple problem to demonstrate the problem-solving methodology in AI and machine learning. The goal is to predict tomorrow's weather based on the data available today, such as temperature, humidity, and wind speed.

**Input: Weather data (e.g., temperature, humidity, wind speed)**
The input for this problem is the weather data available today. This may include measurements such as temperature in degrees Celsius, relative humidity as a percentage, and wind speed in kilometres per hour. These input variables will be used to make predictions about tomorrow's weather.

**Output: Weather prediction (sunny, rainy, etc.)**
The output of the problem is the predicted weather for tomorrow. This could be a categorical variable, such as sunny, cloudy, or rainy, or it could be a numerical prediction, such as the expected temperature. The output depends on the specific problem and the approach used to solve it.

**If today's temperature is 25°C and wind speed is 5 km/h, predict tomorrow's temperature.**
To make the problem more concrete, let's consider a specific example. If today's temperature is 25°C and the wind speed is 5 km/h, we want to predict what the temperature will be tomorrow. This example helps to illustrate the type of input data and the desired output for the problem.

**Example algorithm: Use an average of the last 5 days' temperature to predict tomorrow's.**
One simple approach to solving this problem is to use the average temperature from the last five days as the prediction for tomorrow's temperature. This is just one example of an algorithm that could be used. In practice, more sophisticated algorithms and machine learning techniques would likely be employed.

**Test using multiple data points: What if it's 35°C? Or 0°C?**
To evaluate the effectiveness of the chosen algorithm, it's important to test it using multiple data points. For example, we should consider how well the algorithm performs when the input temperature is much higher, such as 35°C, or much lower, such as 0°C. Testing with a range of inputs helps to identify the strengths and weaknesses of the algorithm.

**Test -> Debug -> Refine -> Retest**
The problem-solving methodology in AI and machine learning involves an iterative process of testing, debugging, refining, and retesting. After testing the algorithm with multiple data points, any issues or bugs should be identified and fixed. The algorithm can then be refined based on the insights gained from testing. Finally, the refined algorithm should be retested to ensure that the changes have had the desired effect. This cycle continues until the algorithm performs satisfactorily.
:::

# Great Habits for Testing and Debugging

- **Comments**: Describe what your code is doing.
- **Docstrings**: Add documentation to your functions (this will help with doctests!).
- **Use/Create functions**: Break tasks into reusable pieces.
- **Use/Create modules**: Organize your code.
- **Make small frequent commits**: Helps isolate where bugs come from.

::: {.notes}
**Aim**
This slide aims to provide developers with a set of good coding habits that can make testing and debugging easier and more effective.

**Context**
Having discussed the problem-solving methodology, this slide focuses on specific habits developers should adopt to prevent bugs and streamline the debugging process. The subsequent slides will delve into the nature of bugs, debugging strategies, and various types of testing.

**Comments: Describe what your code is doing.** 
Adding comments to your code is crucial for clarity and maintainability. Comments should explain the purpose and functionality of code sections, making it easier for you and other developers to understand the code's intent. This is especially helpful when revisiting code after a long time or when collaborating with others.

**Docstrings: Add documentation to your functions (this will help with doctests!).** 
Docstrings are a way to document functions, classes, and modules in Python. They provide a brief description of the purpose, parameters, and return values of a function. By including docstrings, you not only make your code more readable and understandable but also enable the use of doctests, which allow you to write test cases within the docstrings themselves.

**Use/Create functions: Break tasks into reusable pieces.** 
Functions are a fundamental concept in programming that allow you to break down complex tasks into smaller, reusable pieces of code. By creating functions for specific tasks, you can improve code organization, reduce duplication, and make your code more modular and easier to test. Functions also promote code reuse, saving time and effort in the long run.

**Use/Create modules: Organize your code.** 
Modules are files containing Python code that can be imported and used in other Python programs. By organizing related functions, classes, and variables into modules, you can create a clear structure for your codebase. This makes it easier to navigate, maintain, and test your code. Modules also help avoid naming conflicts and allow for better code reusability across different projects.

**Make small frequent commits: Helps isolate where bugs come from.** 
Version control systems like Git are essential tools for managing and tracking changes in your codebase. By making small, frequent commits, you create a detailed history of your code's evolution. This practice helps isolate where bugs might have been introduced, as you can compare the code before and after a specific commit. Small commits also make it easier to revert changes if needed and facilitate collaboration with other developers.
:::

# What is a Bug?

*A software bug is an error, flaw, or fault in computer software that causes it to produce an incorrect or unexpected result, or behave in unintended ways.*  
— Wikipedia

::: {.notes}
**Aim**
This slide aims to explain what a bug is in the context of software development and programming.

**Context**
The slide "What is a Bug?" follows the "Problem-Solving Methodology" and precedes the slides on "Debugging: The Process of Fixing Bugs" and "Debugging Strategies". It provides a foundation for understanding the concept of bugs before delving into the process and strategies for debugging.
:::

# Debugging: The Process of Fixing Bugs

1. **Types of Errors**:
   - **Syntax Errors**: Mistakes in the code’s format.
   - **Run-Time Errors**: Errors that occur when the program is running (e.g., division by zero).
   - **Logic Errors**: The code runs but produces incorrect results (e.g., wrong weather prediction).

2. **Debugging with `print()`**:
   - Use `print()` to display variables and track how values change in your program.
   - Example:
     ```python
     def predict_weather(temp):
         print(f"Current temperature: {temp}")
         if temp > 25:
             return "Sunny"
         else:
             return "Cloudy"
     print(predict_weather(30))  # Should print "Sunny"
     ```

::: {.notes}
**Aim**
This slide aims to introduce the concept of debugging and explain the different types of bugs that can occur in code.

**Context**
Having covered problem-solving methodology and good habits for testing and debugging, this slide delves into the specifics of debugging, explaining what bugs are and the process of fixing them. It leads into the next slide which covers debugging strategies.

**Syntax Errors** Syntax errors occur when there are mistakes in the format of the code, such as missing brackets, incorrect indentation, or typos. These errors prevent the code from running at all, as the computer cannot interpret the instructions. Python will usually provide an error message indicating the line number and the nature of the syntax error, making them relatively easy to identify and fix.

**Run-Time Errors** Run-time errors happen when the program is executing and encounters an unexpected situation it cannot handle, such as dividing by zero, trying to access an index that doesn't exist, or running out of memory. These errors cause the program to crash or exit unexpectedly. Python will provide a traceback showing the line of code where the error occurred and the type of exception that was raised.

**Logic Errors** Logic errors are bugs where the code runs without crashing, but produces incorrect or unexpected results. These can be the most difficult to identify and fix, as there is no error message to point out the issue. Examples include using the wrong formula in a calculation, having incorrect conditionals in an if statement, or accidentally introducing an infinite loop. Careful testing with a variety of inputs is necessary to identify logic errors.

**Use `print()` to display variables and track how values change in your program.** One simple but effective debugging technique is to insert `print()` statements at key points in the code to display the values of variables. This allows you to track how the values change as the program runs and identify where unexpected behaviour is occurring. Remember to remove or comment out these `print()` statements once the bug is fixed.

**Example:** The slide includes an example demonstrating the use of `print()` statements for debugging. Walking through a concrete example helps solidify understanding of the concept and technique.
:::

# Debugging Strategies

- **Step/Trace through code**: Use `print()` to trace how data flows.
- **Inspect Objects**: Use `type()` to check what kind of data your variables are holding.
- **Apply Trial and Error**: Try different values, step through your logic slowly.
- **Compare to similar code**: Use working code as a reference.
- **Ask for help**: Reach out to peers, forums, or Google.
- **Use an IDE**: Syntax highlighting and autocompletion can catch errors before you even run your code.

::: {.notes}
**Aim**
This slide aims to provide students with practical strategies they can use to effectively debug their code when encountering issues or unexpected behaviour.

**Context**
The "Debugging Strategies" slide follows on from an introduction to the concept of bugs and the debugging process. It precedes slides on testing, which is another key aspect of ensuring code correctness. The strategies presented here are general techniques that can be applied in various contexts and languages.

**Step/Trace through code** When faced with unexpected behaviour, a powerful technique is to add `print()` statements at key points in your code. This allows you to see the exact values of variables at each step and trace the flow of execution. By comparing the actual output with your expected output, you can pinpoint where the issue lies.

**Inspect Objects** Python provides the `type()` function, which allows you to check the data type of a variable. This is particularly useful when working with complex data structures or when receiving unexpected errors related to data types. By inspecting your objects, you can ensure they are of the expected type and narrow down potential sources of bugs.

**Apply Trial and Error** Sometimes, the best way to understand a problem is to experiment. Try inputting different values, both valid and invalid, and observe how your code responds. Step through your logic one piece at a time, and verify that each part behaves as intended. This iterative process can help you isolate issues and better understand the boundaries of your code.

**Compare to similar code** When stuck, it can be helpful to refer to code that you know works correctly. This could be code you've written previously, examples from the course materials, or even snippets found online. By comparing your code to a working reference, you can often spot differences or missing pieces that are causing the issue.

**Ask for help** If you've tried debugging on your own but are still stuck, don't hesitate to reach out for help. Discuss the problem with your peers, as they may have encountered similar issues or can provide a fresh perspective. Online forums and communities are also great resources. If all else fails, a targeted Google search can often lead you to insights or solutions.

**Use an IDE** While not strictly a debugging technique, using an Integrated Development Environment (IDE) can prevent many common bugs in the first place. IDEs offer features like syntax highlighting, which makes spotting syntactical errors much easier. They also often provide autocompletion, which can prevent typos and help you use functions correctly. By catching these issues early, you can spend less time debugging and more time writing great code.
:::

# Why Test?

- **Reliable**: Ensure the software behaves as expected.
- **Reproducible**: Others can verify your results.
- **Shareable**: Collaborators can see that your code works.

**_"Testing leads to failure, and failure leads to understanding."_**  
— Burt Rutan

::: {.notes}
**Aim**
This slide aims to explain the importance of testing in software development, particularly in the context of AI and machine learning.

**Context**
The "Why Test?" slide follows the "Debugging Strategies" slide and precedes the "Testing: What Are We Testing?" slide. It builds upon the understanding of debugging and introduces the concept of testing as a proactive approach to ensuring software quality. The subsequent slides delve deeper into various testing methodologies and their applications.

**Reliable** Testing is crucial to ensure that the software behaves as expected under various conditions. By thoroughly testing the code, developers can identify and fix potential issues before they manifest in production environments. Reliable software instils confidence in users and stakeholders, as they can trust that the system will perform its intended functions consistently and accurately.

**Reproducible** Reproducibility is a fundamental aspect of scientific research, and it extends to software development as well. When tests are properly designed and documented, others can independently verify the results, ensuring that the software's behaviour is consistent across different environments and configurations. Reproducible tests contribute to the overall reliability and credibility of the software.

**Shareable** In collaborative software development, it is essential to have a means of demonstrating that the code works as intended. By sharing test results and test suites, collaborators can quickly assess the functionality and quality of the code. This fosters effective communication, enables faster iterations, and facilitates seamless integration of contributions from multiple developers.
:::

# Testing: What Are We Testing?

1. **Requirements**: Does the weather prediction match the user’s needs?
2. **Design**: Does the code structure make sense?
3. **Code/Implementation**: Are the calculations and logic correct?
4. **Documentation**: Are there enough docstrings and comments?

::: {.notes}
**Aim**
This slide aims to introduce the concept of testing in the context of AI and machine learning, and to explore the different aspects and components that are typically tested.

**Context**
Having discussed the importance and benefits of testing in the previous slide, this slide delves deeper into the specifics of what is actually being tested in AI and machine learning systems. The subsequent slides will cover different types of tests and provide practical examples of testing techniques.

**Bullet Point 1** 

**Bullet Point 2** 

**Bullet Point 3** 

**Bullet Point 4** 

**Bullet Point 5**
:::

# You Are Already Testing!

- Validating inputs:
  - Example: What if someone enters an invalid temperature like "hot" instead of a number?

- Testing a variety of inputs (data):
  - Example: What happens if today's temperature is -10°C vs. 40°C?

- Checking outputs to meet requirements:
  - Does the predicted weather make sense based on the input?

**We are just giving more structure to this process.**

::: {.notes}
**Aim**
The aim of this slide is to demonstrate that the audience is already familiar with the fundamentals of testing in their everyday interactions with AI and machine learning systems.

**Context**
This slide follows the "Why Test?" and "Testing: What Are We Testing?" slides, which introduce the importance and scope of testing. It precedes the "Types of Tests" slide, which delves into more formal testing methodologies. The slide helps bridge the gap between the audience's existing knowledge and the upcoming technical content.

**Validating inputs:** When interacting with AI systems, we instinctively validate the data we provide to ensure it is in the expected format and range. This validation is a form of testing that helps prevent errors and unexpected behaviour.

**Example: What if someone enters an invalid temperature like "hot" instead of a number?** This example illustrates the importance of input validation. If a weather prediction system accepts a non-numeric value like "hot" instead of a temperature, it may crash or produce nonsensical results. Testing the system with various inputs, including invalid ones, helps identify and fix such issues.

**Testing a variety of inputs (data):** We often test AI systems with a wide range of inputs to assess their robustness and performance under different conditions. This is similar to how we might check if a weather prediction system works well for different temperature ranges.

**Example: What happens if today's temperature is -10°C vs. 40°C?** Testing a weather prediction system with extreme temperatures helps ensure that it can handle a wide range of inputs and produce reasonable outputs. If the system fails or generates unusual predictions for certain temperatures, it indicates a need for improvement.

**Checking outputs to meet requirements:** When using AI systems, we naturally check if the outputs align with our expectations and requirements. This is a form of testing that helps verify the system's correctness and usefulness.

**Does the predicted weather make sense based on the input?** In the context of a weather prediction system, we would compare the predicted weather with the input temperature to see if it makes sense. For example, if the input is -10°C, we would expect the predicted weather to be cold and possibly snowy, not hot and sunny. Testing the system's outputs against our domain knowledge and common sense is crucial for ensuring its reliability.
:::

# Types of Tests

1. **Unit Testing**: Test an individual, isolated function or module.
   - Example: Test if the `predict_weather()` function returns the correct output for different temperatures.

2. **Integration Testing**: Ensure multiple parts of the program work together.
   - Example: Test if weather prediction works when integrated with a larger weather dashboard application.

3. **End-to-End Testing**: Simulate a real user interacting with your program.
   - Example: Test the entire workflow of entering today's weather and predicting tomorrow's weather in your app.

4. **Acceptance Testing**: Ensure the program meets the user’s requirements.
   - Example: The program should correctly predict "Sunny" when the temperature is above 25°C.


::: {.notes}
**Aim**
The aim of this slide is to introduce the different types of tests used in AI and machine learning development, with examples to illustrate each type.

**Context**
This slide follows on from discussing the importance and purpose of testing in AI and machine learning. It provides specific examples of different test types, before subsequent slides dive into more details on testing methodologies and tools.

**Example: Test if the `predict_weather()` function returns the correct output for different temperatures.** This is an example of a unit test, which focuses on testing an individual component or function in isolation. Here, we would pass different temperature inputs to the `predict_weather()` function and check that it returns the expected output for each case. Unit tests help verify the correctness of specific parts of the code.

**Example: Test if weather prediction works when integrated with a larger weather dashboard application.** This exemplifies an integration test, which checks how different components or modules work together. In this case, we would test if the weather prediction functionality integrates correctly with the broader weather dashboard application. Integration tests help identify issues that may arise when combining parts of the system.

**Example: Test the entire workflow of entering today's weather and predicting tomorrow's weather in your app.** This is a system or end-to-end test, which tests the complete functionality of the application from start to finish. It would involve entering today's weather data, running the prediction, and verifying that tomorrow's weather is correctly displayed. System tests ensure the application works as intended from a user's perspective.

**Example: The program should correctly predict "Sunny" when the temperature is above 25°C.** This is an example of a requirements-based or acceptance test. It checks that the application meets a specific requirement or criteria. In this case, we would test that the program outputs "Sunny" whenever the input temperature exceeds 25°C. Acceptance tests help validate that the software satisfies the specified requirements.
:::

# Review: What is the Python REPL?

The Python REPL stands for **Read-Eval-Print Loop** and is an interactive environment that lets you type and execute Python code line by line.

::: {.notes}
**Aim**
The aim of this slide is to review and refresh the audience's understanding of the Python REPL.

**Context**
This slide follows on from a discussion of testing and debugging strategies in Python. It serves as a refresher on the Python REPL before diving into practical examples of using the REPL for testing and debugging code, such as with doctests and in Jupyter notebooks.
:::

# How REPL Works:

1. **Read**: The REPL reads your input (Python code).
2. **Eval**: It evaluates or executes the code you entered.
3. **Print**: It displays the result of your code.
4. **Loop**: The process repeats, allowing you to try more code.

::: {.notes}
**Aim**
The aim of this slide is to explain how the Read-Eval-Print Loop (REPL) works in Python.

**Context**
This slide follows on from a review of what the Python REPL is. It provides more detail on the inner workings of the REPL before discussing why it is useful and showing it in action through examples.

**Bullet Point 1** [Read] In the first step, the REPL reads the Python expression or statement that you enter. It parses this input into a form that the Python interpreter can understand and execute.

**Bullet Point 2** [Eval] Next, the REPL evaluates the parsed expression or executes the parsed statement. This is where the actual Python code is run by the interpreter.

**Bullet Point 3** [Print] After the evaluation/execution step, the REPL prints the result of the expression or any output from the executed statement. This allows you to immediately see the outcome of your code.

**Bullet Point 4** [Loop] Finally, the REPL loops back to the beginning, ready to read the next input. This loop continues indefinitely, allowing you to keep entering and running Python code, until you signal to exit the REPL.
:::

# Why Use REPL?

- **Instant Feedback**: You can quickly test and run small pieces of code.
- **Interactive Learning**: It’s great for experimenting with Python features.
- **Debugging**: Use it to test functions and explore data interactively.

::: {.notes}
**Aim**
This slide aims to highlight the key benefits of using the Python REPL for coding and learning.

**Context**
After introducing the concept of the Python REPL in the previous slide, this slide delves into the practical advantages of using it. The following slides will provide specific examples and use cases to reinforce these benefits.

**Instant Feedback** The Python REPL allows you to enter code and see the results immediately, without the need to write a complete script or program. This instant feedback loop enables quick testing of ideas, syntax, and logic, making it an invaluable tool for iterative development and experimentation.

**Interactive Learning** The REPL provides an interactive environment that encourages hands-on learning and exploration of Python features. You can try out different commands, expressions, and libraries, and observe their behaviour in real-time. This interactive approach facilitates a deeper understanding of Python concepts and helps build confidence in using the language.

**Debugging** The REPL is a powerful tool for debugging and troubleshooting code. You can test individual functions, explore data structures, and inspect variables at runtime. By running code step-by-step and examining intermediate results, you can identify issues and fix bugs more efficiently. The REPL's interactive nature makes it easier to isolate problems and experiment with potential solutions.
:::

# Example: REPL in Action

```python
>>> temperature = 30
>>> if temperature > 25:
...     print("Sunny")
... else:
...     print("Cloudy")
...
Sunny
```

In this example:
- You entered a condition based on temperature.
- The REPL evaluated the condition and printed "Sunny" as the result.



### How REPL Connects to Doctests

- **Doctests** mimic the Python shell (REPL) experience inside your code.
- You can write your function's expected behaviour in a way that looks like what you'd do in the REPL.

::: {.notes}
**Aim**
This slide aims to demonstrate how the Python REPL works in practice, using a simple example to illustrate the process of entering code and seeing the evaluated result.

**Context**
After introducing the concept of the Python REPL and explaining how it works and why it's useful, this slide provides a concrete example of the REPL in action. It leads into the next section on testing, showing how the REPL experience can be mimicked within code using doctests.

**You entered a condition based on temperature.** In this example, you would have typed a line of code into the Python REPL that checks a condition based on the temperature. This could be something like `if temperature > 20: print("Sunny")`, which checks if the `temperature` variable is greater than 20 and prints "Sunny" if the condition is true.

**The REPL evaluated the condition and printed "Sunny" as the result.** After entering the code, the REPL immediately evaluated the condition. Assuming the `temperature` variable was set to a value greater than 20, the condition would be true, and the REPL would execute the `print` statement, displaying "Sunny" as the output.

**Doctests mimic the Python shell (REPL) experience inside your code.** Doctests are a way of writing tests directly in your code's docstrings. They are written in a format that looks like an interactive Python shell session, with lines of code followed by the expected output. This allows you to specify your function's expected behaviour in a way that resembles the REPL experience.

**You can write your function's expected behaviour in a way that looks like what you'd do in the REPL.** When writing doctests, you include example code snippets that demonstrate how your function should be used and what output it should produce. These code snippets are written just like you would enter them in the REPL, making it easy to understand and test your function's behaviour.
:::

# Simple Example: Testing with `doctest`

You can embed tests inside your function’s docstrings using `doctest`. Here's a weather example:

```python
def predict_weather(temp):
    """
    Predict tomorrow's weather based on today's temperature.

    >>> predict_weather(30)
    'Sunny'
    >>> predict_weather(20)
    'Cloudy'
    """
    if temp > 25:
        return "Sunny"
    else:
        return "Cloudy"
```

You can run `doctest` to check if the output matches the expected results. To run `doctest`, add this to the bottom of your script:
```python
if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

::: {.notes}
**Aim**
Demonstrate how to write a simple test using Python's `doctest` module.

**Context**
Having introduced the concept of testing and the Python REPL, this slide provides a concrete example of how to write tests using `doctest`. It leads into the next few slides which explain doctests in more detail, including how they work, why they are useful, and how to run them.
:::

# Doctests: Testing in Your Docstrings

Doctests allow you to write test cases directly in your function's docstring,
mimicking how you would test code in the Python shell. They are great for small
functions and help you document the expected behavior of your code.

::: {.notes}
**Aim**
To introduce doctests as a way to write tests directly in the docstring of a function, and explain how they work.

**Context**
This slide builds on the previous discussion of testing by introducing a specific technique called doctests. It leads into the next few slides which provide examples of doctests in action and explain their benefits.
:::

# How Doctests Work

- Doctests simulate the Python shell (REPL) and check if the output matches the expected result written in the docstring.
- You write the function's input and output in a way that looks like a Python session, and `doctest` automatically checks if the function produces the correct result.

::: {.notes}
**Aim**
This slide aims to explain how doctests work by simulating a Python shell and automatically checking if a function's output matches the expected result.

**Context**
After introducing the concept of testing and different types of tests, the presentation dives into doctests as a specific testing method. This slide follows an example of using doctests and precedes slides on why and how to use doctests in practice.

**Doctests simulate the Python shell (REPL) and check if the output matches the expected result written in the docstring.** Doctests are a way to write tests directly in the docstring of a function. They mimic the interactive Python shell by including input and expected output as if you were typing commands and seeing the results in the shell. When you run the doctests, the testing framework automatically executes the function with the given input and compares the actual output to the expected output specified in the docstring. If they match, the test passes; if not, it fails.

**You write the function's input and output in a way that looks like a Python session, and `doctest` automatically checks if the function produces the correct result.** To create a doctest, you format the expected input and output in the docstring to resemble a Python interactive session. This includes the `>>>` prompt, function calls, and expected output. The `doctest` module then parses this information and runs the tests automatically, without the need for separate test files or special assert statements. This makes doctests a convenient way to include tests close to the source code and maintain them together with the function's documentation.
:::

# Doctest Example (Weather Prediction)

```python
def predict_weather(temp):
    """
    Predict tomorrow's weather based on today's temperature.
    
    This function returns 'Sunny' if the temperature is above 25°C, 
    otherwise it returns 'Cloudy'.
    
    Example usage in the Python shell:
    
    >>> predict_weather(30)
    'Sunny'
    >>> predict_weather(20)
    'Cloudy'
    """
    if temp > 25:
        return "Sunny"
    else:
        return "Cloudy"
```

::: {.notes}
**Aim**
This slide demonstrates how to use doctest to test a simple weather prediction function, showcasing the practical application of doctests in Python code.

**Context**
Having introduced the concept of doctests and how they work in the previous slides, this example builds on that foundation by presenting a concrete use case. The subsequent slides will discuss the benefits of using doctests and how to run them effectively.
:::

# Why Use Doctests?

- **Readable**: It combines documentation and testing in one place.
- **Simple**: You don't need separate testing files for small functions.
- **Automated**: Doctests verify that your code behaves as described.

::: {.notes}
**Aim**
This slide aims to explain the key benefits of using doctests for testing Python code.

**Context**
After introducing the concept of doctests and showing a simple example, this slide follows on to highlight the main advantages of using doctests. It leads into the next slides which cover running doctests and comparing them to using the Python shell.

**Readable** By including test cases directly in the docstring, doctests make it easy to see the expected behaviour of a function right next to its documentation. This keeps the tests closely tied to the code they are testing, making them more readable and maintainable. Having the tests and documentation in one place also makes it simpler for other developers to understand how the function is intended to be used.

**Simple** For small, focused functions, doctests provide a lightweight way to include tests without needing to create separate test files or use a full-featured testing framework. This reduces boilerplate and keeps the code concise. Doctests are ideal for unit testing individual functions in isolation.

**Automated** When doctests are run, they automatically compare the actual output of the code against the expected output written in the docstring. This verifies that the code behaves correctly according to its documentation. Having this automated testing helps catch regressions and ensures the code remains reliable as it is modified.
:::

# Running Doctests

To run doctests, include the following at the bottom of your Python file:
```python
if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

This will run the tests inside your docstrings, checking if the actual outputs match the expected ones.

::: {.notes}
**Aim**
The aim of this slide is to explain how to run doctests and demonstrate their practical application in testing code.

**Context**
This slide follows on from an introduction to doctests and examples of how they can be used for testing code. It precedes slides on testing strategies in Jupyter Notebooks and building a comprehensive test suite.

**Running Doctests**
To run doctests, you can use the `python -m doctest` command followed by the name of the Python file containing the doctests. This command searches for pieces of text that look like interactive Python sessions within the file's docstrings and runs them as tests. Any output produced by the code is compared to the expected output specified in the docstring. If they match, the test passes; if there are differences, the test fails and the differences are reported. Running doctests is a quick and easy way to check that your code is working as intended and to catch any regressions when making changes.
:::

# Doctest vs. Python Shell

When you run `doctest`, it behaves as if you are manually entering the input and checking the output in the Python shell (REPL):

**Python Shell Session**:
```python
>>> predict_weather(30)
'Sunny'
>>> predict_weather(20)
'Cloudy'
```

**Doctest in Docstring**:
```python
"""
>>> predict_weather(30)
'Sunny'
>>> predict_weather(20)
'Cloudy'
"""
```

Doctests save you time by automating these shell interactions and ensuring your code works as expected!

::: {.notes}
**Aim**
Compare and contrast the features and use cases of doctest and the Python shell for testing code.

**Context**
This slide builds on the previous content about using the Python REPL and doctest for testing. It aims to help learners understand when to choose one testing approach over the other by directly comparing them. The comparison provides a foundation for the subsequent slides on testing strategies and building test suites.

****
Doctest allows you to write tests directly in your docstrings, keeping the tests close to the code they are testing. This makes it easy to understand how a function is intended to be used and what its expected outputs are for given inputs. Doctest tests serve as executable documentation. In contrast, the Python shell is a more free-form environment for interactive testing where you manually enter expressions and check the output.

****
Running doctests is automated - you can run all tests in a file or module with a single command. This makes it easy to frequently re-run your test suite as you make changes. Testing in the Python shell is more manual - you need to re-enter expressions to re-run tests, and it's up to you to manually verify the output is as expected.

****
Doctest is best suited for testing pure functions that have well-defined inputs and outputs and don't depend on global state. The Python shell is more flexible and can be used for testing any kind of code, but is especially useful for exploratory testing and debugging where you want to inspect program state or try out different scenarios interactively. Using both together is often helpful.
:::

# Testing Strategy in Jupyter Notebooks

There are different ways to test notebooks:

- **Write python script to test notebook**: You can import your functions from the notebook and test them using a Python script.
- **Write test and code in one notebook**: You can use `assert()`, `doctest`, or other testing libraries directly in the notebook.
  
Example in a notebook:
```python
# Code cell:
def predict_weather(temp):
    return "Sunny" if temp > 25 else "Cloudy"

# Test cell:
assert predict_weather(30) == "Sunny"
assert predict_weather(20) == "Cloudy"
```

::: {.notes}
**Aim**
The aim of this slide is to introduce two strategies for testing code in Jupyter Notebooks.

**Context**
This slide is part of a section on testing strategies in a presentation about AI and machine learning. It follows slides explaining what testing is and why it's important. The next slide shows an example of using doctests in Jupyter Notebooks.

**Write python script to test notebook** You can write your functions in a Jupyter Notebook, then create a separate Python script that imports those functions and tests them. This allows you to keep your notebook focused on the main code while having a dedicated space for more comprehensive tests. The testing script can use Python's built-in unittest module or other testing frameworks.

**Write test and code in one notebook** Alternatively, you can include tests directly in the Jupyter Notebook alongside your code. Simple tests can be done using Python's assert() function, which raises an AssertionError if the condition is false. For more structured tests, the doctest module allows you to write tests in the docstrings of your functions. Other testing libraries like pytest can also be used directly in the notebook.
:::

# Using Doctests in Jupyter Notebooks

1. **Write Your Function with a Doctest**:
   Include the test cases directly in your function’s docstring.

   ```python
   def predict_weather(temp):
       """
       Predict tomorrow's weather based on today's temperature.

       >>> predict_weather(30)
       'Sunny'
       >>> predict_weather(20)
       'Cloudy'
       """
       if temp > 25:
           return "Sunny"
       else:
           return "Cloudy"
   ```

2. **Run Doctests with `doctest.testmod()`**:
   You can run your doctests in a Jupyter notebook using the `doctest` module.

   ```python
   import doctest
   doctest.testmod()
   ```

3. **View the Results**:
   If all tests pass, there will be no output.
   If any tests fail, `doctest` will show where the function’s output didn’t match the expected result.

::: {.notes}
**Aim**
This slide demonstrates how to use doctests within Jupyter Notebooks to test code and ensure it works as expected.

**Context**
The previous slides introduced doctests and explained how they work. This slide builds on that knowledge by showing how to apply doctests in the context of Jupyter Notebooks. The following slides will cover building a comprehensive test suite.

****
To use doctests in Jupyter Notebooks, simply include the doctests within the docstring of a function or class, just as you would in a regular Python script. When you run the cell containing the function or class definition, the doctests will be executed automatically.

****
If a doctest fails, an exception will be raised, and the notebook will display the traceback, indicating which test case failed and what the expected and actual outputs were. This allows you to quickly identify and fix any issues with your code.

****
It's good practice to include doctests for key functionality in your Jupyter Notebooks. This ensures that your code remains reliable and behaves as expected, even as you make changes and additions to your notebook over time.

****
Remember to strike a balance between thoroughness and brevity in your doctests. Focus on testing the most important aspects of your code, and use clear, concise test cases that cover a range of scenarios.

****
By incorporating doctests into your Jupyter Notebooks, you can create a self-documenting and self-testing codebase that is easier to maintain and less prone to errors. This is particularly valuable in the context of data analysis and machine learning projects, where accuracy and reproducibility are paramount.
:::

# Example in Jupyter Notebook

- First, define the function with doctests in the cell.
- Then, in a new cell, run the following code to check the tests:

```python
import doctest
doctest.testmod()
```

### Key Points:

- In Jupyter notebooks, `doctest` works just like in standard Python scripts.
- The tests will run, and you can verify that your function behaves as expected, just like in the Python shell.

::: {.notes}
**Aim**
This slide demonstrates how to use doctests within Jupyter Notebooks to test functions and ensure they behave as expected.

**Context**
After discussing the importance of testing and introducing doctests, this slide shows how to apply doctests in the context of Jupyter Notebooks. It is followed by a slide on building a comprehensive test suite.

**First, define the function with doctests in the cell.** Begin by writing your function in a Jupyter Notebook cell, including doctests within the function's docstring. These doctests serve as examples of how the function should behave given certain inputs, and they also act as a form of documentation for the function's expected behaviour.

**Then, in a new cell, run the following code to check the tests:** After defining your function with doctests, create a new cell below it. In this cell, use the `doctest.run_docstring_examples()` function, passing your function's name as an argument. This code will execute the doctests associated with your function.

**In Jupyter notebooks, `doctest` works just like in standard Python scripts.** The `doctest` module in Jupyter Notebooks functions identically to how it works in regular Python scripts. You can define your functions with doctests and run them using the same methods, making the testing process consistent across different environments.

**The tests will run, and you can verify that your function behaves as expected, just like in the Python shell.** When you run the cell containing the `doctest.run_docstring_examples()` function, the doctests associated with your function will execute. The output will indicate whether the tests passed or failed, allowing you to verify that your function behaves correctly based on the expected inputs and outputs defined in the doctests. This process is similar to testing your functions in the Python shell.
:::

# Building a Test Suite

1. **Build up a suite of tests**: Create a set of tests that cover different parts of your program.
2. **Run all tests in one go**: Use a script or notebook to run all tests automatically.
3. **Test sane cases, then edge cases**: Test common scenarios first, then unusual inputs.
   - Example: What happens when you input extreme temperatures like -100°C or 100°C?

::: {.notes}
**Aim**
This slide aims to demonstrate the importance of testing edge cases and extreme inputs when building a robust test suite.

**Context**
After discussing the basics of testing, types of tests, and using doctests in Python, this slide expands on the concept of building a comprehensive test suite. It encourages students to think critically about potential edge cases and boundary conditions that could break their code.

**Example: What happens when you input extreme temperatures like -100°C or 100°C?**
When building a test suite, it's crucial to consider not only the expected inputs but also extreme or unexpected ones. For example, if you're writing a function that processes temperature data, you should test how it handles inputs like -100°C or 100°C. These extreme values might be outside the normal operating range and could potentially cause your code to fail or produce incorrect results. By including such test cases, you can ensure your code is robust and can gracefully handle these edge cases, either by raising appropriate errors or returning sensible default values. This approach helps uncover hidden bugs and improves the overall reliability of your software.
:::

# Review: Can you…

- Understand the difference between testing and debugging?
- Describe one approach to debugging?
- State why we test?
- List common testing strategies?

::: {.notes}
**Aim**
This slide aims to review and reinforce key concepts and skills related to testing and debugging covered earlier in the presentation.

**Context**
The "Review: Can you..." slide is positioned towards the end of the presentation, following detailed coverage of debugging strategies, the importance of testing, types of tests, and practical examples using REPL and doctests. This review slide helps consolidate the knowledge gained and ensures students have grasped the fundamental concepts before concluding the lesson.

**Understand the difference between testing and debugging?**
Testing involves evaluating a program's behaviour and verifying that it produces the expected outputs for various inputs. In contrast, debugging is the process of identifying, locating, and fixing errors or bugs in the code that cause the program to behave incorrectly. Testing helps uncover bugs, while debugging is the systematic approach to resolving those issues.

**Describe one approach to debugging?**
One effective approach to debugging is the "divide and conquer" strategy. This involves narrowing down the problematic area of the code by systematically isolating smaller sections and testing them independently. By progressively eliminating code that works as expected, you can focus on the specific part causing the issue, making it easier to identify and fix the bug.

**State why we test?**
We test our code to ensure it functions as intended, producing the desired outputs for different input scenarios. Testing helps uncover bugs, edge cases, and unexpected behaviour early in the development process. By catching and fixing issues promptly, we improve the reliability, quality, and maintainability of our software, reducing the risk of errors in production and providing a better user experience.

**List common testing strategies?**
Some common testing strategies include unit testing, where individual components or functions are tested in isolation; integration testing, which verifies the interaction between different modules; and system testing, which evaluates the entire system's performance. Other strategies include regression testing to ensure new changes don't break existing functionality, acceptance testing to validate user requirements, and exploratory testing to uncover unforeseen issues.
:::



---
title: "Debugging the Weather: Testing Your Code with Python"
subtitle: "From print statements to doctests—Master the basics of testing and debugging with a weather twist!"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Copyright Information

![](../../../_assets/curtin-copy-right.png)

# Acknowledgement of Country

I acknowledge the traditional custodians of the land on which I work and live,
and recognise their continuing connection to land, water and community. I pay
respect to elders past, present and emerging.

![](../../../_assets/ack_country.png)

# Today’s Goals

- Understand the difference between testing and debugging
- Describe one approach to debugging
- State why we test
- List common testing strategies


# Problem-Solving Methodology

1. **State the problem clearly**
   - Example: *Predict tomorrow’s weather based on today’s data.*

2. **Describe the input and output**
   - Input: Weather data (e.g., temperature, humidity, wind speed)
   - Output: Weather prediction (sunny, rainy, etc.)

3. **Work a simple example by hand**
   - If today’s temperature is 25°C and wind speed is 5 km/h, predict tomorrow’s temperature.

4. **Develop an algorithm (and convert to Python)**
   - Example algorithm: Use an average of the last 5 days' temperature to predict tomorrow’s.

5. **Test solution with a variety of data**
   - Test using multiple data points: What if it’s 35°C? Or 0°C?

6. **Feedback Loop(s)**
   - Test -> Debug -> Refine -> Retest

*"I'm not a great programmer, I'm just a good programmer with great habits"*  
— Kent Beck



# Great Habits for Testing and Debugging

- **Comments**: Describe what your code is doing.
- **Docstrings**: Add documentation to your functions (this will help with doctests!).
- **Use/Create functions**: Break tasks into reusable pieces.
- **Use/Create modules**: Organize your code.
- **Make small frequent commits**: Helps isolate where bugs come from.



# What is a Bug?

*A software bug is an error, flaw, or fault in computer software that causes it to produce an incorrect or unexpected result, or behave in unintended ways.*  
— Wikipedia



# Debugging: The Process of Fixing Bugs

1. **Types of Errors**:
   - **Syntax Errors**: Mistakes in the code’s format.
   - **Run-Time Errors**: Errors that occur when the program is running (e.g., division by zero).
   - **Logic Errors**: The code runs but produces incorrect results (e.g., wrong weather prediction).

2. **Debugging with `print()`**:
   - Use `print()` to display variables and track how values change in your program.
   - Example:
     ```python
     def predict_weather(temp):
         print(f"Current temperature: {temp}")
         if temp > 25:
             return "Sunny"
         else:
             return "Cloudy"
     print(predict_weather(30))  # Should print "Sunny"
     ```



# Debugging Strategies

- **Step/Trace through code**: Use `print()` to trace how data flows.
- **Inspect Objects**: Use `type()` to check what kind of data your variables are holding.
- **Apply Trial and Error**: Try different values, step through your logic slowly.
- **Compare to similar code**: Use working code as a reference.
- **Ask for help**: Reach out to peers, forums, or Google.
- **Use an IDE**: Syntax highlighting and autocompletion can catch errors before you even run your code.



# Why Test?

- **Reliable**: Ensure the software behaves as expected.
- **Reproducible**: Others can verify your results.
- **Shareable**: Collaborators can see that your code works.

**_"Testing leads to failure, and failure leads to understanding."_**  
— Burt Rutan



# Testing: What Are We Testing?

1. **Requirements**: Does the weather prediction match the user’s needs?
2. **Design**: Does the code structure make sense?
3. **Code/Implementation**: Are the calculations and logic correct?
4. **Documentation**: Are there enough docstrings and comments?



# You Are Already Testing!

- Validating inputs:
  - Example: What if someone enters an invalid temperature like "hot" instead of a number?

- Testing a variety of inputs (data):
  - Example: What happens if today's temperature is -10°C vs. 40°C?

- Checking outputs to meet requirements:
  - Does the predicted weather make sense based on the input?

**We are just giving more structure to this process.**



# Types of Tests

1. **Unit Testing**: Test an individual, isolated function or module.
   - Example: Test if the `predict_weather()` function returns the correct output for different temperatures.

2. **Integration Testing**: Ensure multiple parts of the program work together.
   - Example: Test if weather prediction works when integrated with a larger weather dashboard application.

3. **End-to-End Testing**: Simulate a real user interacting with your program.
   - Example: Test the entire workflow of entering today's weather and predicting tomorrow's weather in your app.

4. **Acceptance Testing**: Ensure the program meets the user’s requirements.
   - Example: The program should correctly predict "Sunny" when the temperature is above 25°C.




Absolutely! Here's a slide reviewing REPL (Read-Eval-Print Loop) to provide context before introducing `doctest`:



# Review: What is the Python REPL?

The Python REPL stands for **Read-Eval-Print Loop** and is an interactive environment that lets you type and execute Python code line by line.

# How REPL Works:

1. **Read**: The REPL reads your input (Python code).
2. **Eval**: It evaluates or executes the code you entered.
3. **Print**: It displays the result of your code.
4. **Loop**: The process repeats, allowing you to try more code.

# Why Use REPL?

- **Instant Feedback**: You can quickly test and run small pieces of code.
- **Interactive Learning**: It’s great for experimenting with Python features.
- **Debugging**: Use it to test functions and explore data interactively.

# Example: REPL in Action

```python
>>> temperature = 30
>>> if temperature > 25:
...     print("Sunny")
... else:
...     print("Cloudy")
...
Sunny
```

In this example:
- You entered a condition based on temperature.
- The REPL evaluated the condition and printed "Sunny" as the result.



### How REPL Connects to Doctests

- **Doctests** mimic the Python shell (REPL) experience inside your code.
- You can write your function's expected behaviour in a way that looks like what you'd do in the REPL.



# Simple Example: Testing with `doctest`

You can embed tests inside your function’s docstrings using `doctest`. Here's a weather example:

```python
def predict_weather(temp):
    """
    Predict tomorrow's weather based on today's temperature.

    >>> predict_weather(30)
    'Sunny'
    >>> predict_weather(20)
    'Cloudy'
    """
    if temp > 25:
        return "Sunny"
    else:
        return "Cloudy"
```

You can run `doctest` to check if the output matches the expected results. To run `doctest`, add this to the bottom of your script:
```python
if __name__ == "__main__":
    import doctest
    doctest.testmod()
```


# Doctests: Testing in Your Docstrings

Doctests allow you to write test cases directly in your function's docstring,
mimicking how you would test code in the Python shell. They are great for small
functions and help you document the expected behavior of your code.

# How Doctests Work

- Doctests simulate the Python shell (REPL) and check if the output matches the expected result written in the docstring.
- You write the function's input and output in a way that looks like a Python session, and `doctest` automatically checks if the function produces the correct result.

# Doctest Example (Weather Prediction)

```python
def predict_weather(temp):
    """
    Predict tomorrow's weather based on today's temperature.
    
    This function returns 'Sunny' if the temperature is above 25°C, 
    otherwise it returns 'Cloudy'.
    
    Example usage in the Python shell:
    
    >>> predict_weather(30)
    'Sunny'
    >>> predict_weather(20)
    'Cloudy'
    """
    if temp > 25:
        return "Sunny"
    else:
        return "Cloudy"
```

# Why Use Doctests?

- **Readable**: It combines documentation and testing in one place.
- **Simple**: You don't need separate testing files for small functions.
- **Automated**: Doctests verify that your code behaves as described.

# Running Doctests

To run doctests, include the following at the bottom of your Python file:
```python
if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

This will run the tests inside your docstrings, checking if the actual outputs match the expected ones.



# Doctest vs. Python Shell

When you run `doctest`, it behaves as if you are manually entering the input and checking the output in the Python shell (REPL):

**Python Shell Session**:
```python
>>> predict_weather(30)
'Sunny'
>>> predict_weather(20)
'Cloudy'
```

**Doctest in Docstring**:
```python
"""
>>> predict_weather(30)
'Sunny'
>>> predict_weather(20)
'Cloudy'
"""
```

Doctests save you time by automating these shell interactions and ensuring your code works as expected!



# Testing Strategy in Jupyter Notebooks

There are different ways to test notebooks:

- **Write python script to test notebook**: You can import your functions from the notebook and test them using a Python script.
- **Write test and code in one notebook**: You can use `assert()`, `doctest`, or other testing libraries directly in the notebook.
  
Example in a notebook:
```python
# Code cell:
def predict_weather(temp):
    return "Sunny" if temp > 25 else "Cloudy"

# Test cell:
assert predict_weather(30) == "Sunny"
assert predict_weather(20) == "Cloudy"
```



Here's a slide explaining how to use `doctest` in Jupyter notebooks, tailored for your audience:



# Using Doctests in Jupyter Notebooks

1. **Write Your Function with a Doctest**:
   Include the test cases directly in your function’s docstring.

   ```python
   def predict_weather(temp):
       """
       Predict tomorrow's weather based on today's temperature.

       >>> predict_weather(30)
       'Sunny'
       >>> predict_weather(20)
       'Cloudy'
       """
       if temp > 25:
           return "Sunny"
       else:
           return "Cloudy"
   ```

2. **Run Doctests with `doctest.testmod()`**:
   You can run your doctests in a Jupyter notebook using the `doctest` module.

   ```python
   import doctest
   doctest.testmod()
   ```

3. **View the Results**:
   If all tests pass, there will be no output.
   If any tests fail, `doctest` will show where the function’s output didn’t match the expected result.



# Example in Jupyter Notebook

- First, define the function with doctests in the cell.
- Then, in a new cell, run the following code to check the tests:

```python
import doctest
doctest.testmod()
```

### Key Points:

- In Jupyter notebooks, `doctest` works just like in standard Python scripts.
- The tests will run, and you can verify that your function behaves as expected, just like in the Python shell.


# Building a Test Suite

1. **Build up a suite of tests**: Create a set of tests that cover different parts of your program.
2. **Run all tests in one go**: Use a script or notebook to run all tests automatically.
3. **Test sane cases, then edge cases**: Test common scenarios first, then unusual inputs.
   - Example: What happens when you input extreme temperatures like -100°C or 100°C?



# Review: Can you…

- Understand the difference between testing and debugging?
- Describe one approach to debugging?
- State why we test?
- List common testing strategies?



# Testing

ISYS2001\, School of Marketing and Management

![](img/15_Testing0.png)

I acknowledge the traditional custodians of the land on which I work and live\, and recognise their continuing connection to land\, water and community\. I pay respect to elders past\, present and emerging\.

# Today

Understand the difference between testing and debugging

Describe one approach of debugging

State why we test

List common testing strategies

# Problem Solving Methodology

State the problem clearly

Describe the input and output

Work a simple example by hand

Develop and algorithm \(and convert to Python\)

__Test solution with a variety of data__

<span style="color:#333333">Feedback Loop\(s\)</span>

"I'm not a great programmer\, I'm just a good programmer with great habits"

Kent Beck

# Great Habits

Comments

Docstrings

Use/Create functions

Use/Create modules

Make small frequent commits

_A _  _software bug _  _is an error\, flaw or fault in computer software that causes it to produce an incorrect or unexpected result\, or to behave in unintended ways\._  _ _

Wikipedia   https://en\.wikipedia\.org/wiki/Software\_bug

_Debugging_  _ is the process to correct the bugs found during testing\._

# Types of Errors

Syntax Errors

Run\-Time Errors

Logic Error

# Debugging

* Step/Trace through code
  * __print\(\)__
  * logging\(\)
* Inspect Objects
  * __type\(\)__
  * inspect module
* Python debugger – pdb
  * __breakpoint\(\)__
  * traceback and other methods not enough

# Debugging Strategies

* Apply Trail and Error
* Compare to similar code
* Copy and paste for working code
* Ask for help \(peer\, forum\, google\)
* Use IDE
  * Syntax Highlighting
  * Auto completion
  * Linting

_Program _  _testing_  _ can be used to show the presence of bugs\, but never to show their absence\! _ Dijkstra \(1970\)

# Why Test

Reliable

Reproducible

Shareable

_Testing leads to failure\, and failure leads to understanding\. _

Burt Rutan

# What to test?

---

Requirements
Design
Code/Implementation
Documentation


# You already doing tests!

Validate input

Try variety of inputs \(data\)

We check output meet requirements

_We are provide more structure to the process_

# Types of Test

Unit – test an individual isolated component

Integration – test multiple units work together

End\-to\-End – act as user\, test entire stack

Acceptance Test – verify user store works as expected

---

Unit  Test an individual, isolated component

Integration  Test that multiple units work together OR "tests that confirm our code works against code we don't own" (like external APIs, databases, caches, etc)

End-to-End  Tests that act as a user actually using the application; tests the entire stack from top-to-bottom

Acceptance Domain-driven tests that verify a user story (also comparable to a use case, customer test, command/query, feature, or vertical slice) works as expected.



# Test Driven Development

A discipline where you grow software in small increments \(steps\) where you write the test before the implementation\.

![](img/15_Testing1.png)

# Approach Notebooks

* Write python script to test notebook
  * Package: testbook
* Write test and code in one notebook
  * Packages:  __assert\(\)\, __  __doctest__ \, unittest\, nose2 etc\.\.
* ‘Testing Notebook’ and import notebook\(s\)
  * Packages:  __assert\(\)\, __  __doctest__ \, unittest\, nose2 etc\.\.

---

Write test script to import notebook 
Write test and code in one notebook
Add ‘noise’
Run notebook, always run tests
Refactor notebook into modules, independently test modules



# Testing Everything

* Build up a suite of Tests
* Run all test with one cell/notebook/script
* Regression testing
* Test Table
  * Sane test\, then edge cases

# Can you…

Understand the difference between testing and debugging

Describe one approach of debugging

State why we test

List common testing strategies



---
title: "Debugging the Weather: Testing Your Code with Python"
subtitle: "From print statements to doctests—Master the basics of testing and debugging with a weather twist!"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# Copyright Information

![](../../../_assets/curtin-copy-right.png)

# Acknowledgement of Country

I acknowledge the traditional custodians of the land on which I work and live,
and recognise their continuing connection to land, water and community. I pay
respect to elders past, present and emerging.

![](../../../_assets/ack_country.png)

# Today’s Goals

- Understand the difference between testing and debugging
- Describe one approach to debugging
- State why we test
- List common testing strategies


# Problem-Solving Methodology

1. **State the problem clearly**
   - Example: *Predict tomorrow’s weather based on today’s data.*

2. **Describe the input and output**
   - Input: Weather data (e.g., temperature, humidity, wind speed)
   - Output: Weather prediction (sunny, rainy, etc.)

3. **Work a simple example by hand**
   - If today’s temperature is 25°C and wind speed is 5 km/h, predict tomorrow’s temperature.

4. **Develop an algorithm (and convert to Python)**
   - Example algorithm: Use an average of the last 5 days' temperature to predict tomorrow’s.

5. **Test solution with a variety of data**
   - Test using multiple data points: What if it’s 35°C? Or 0°C?

6. **Feedback Loop(s)**
   - Test -> Debug -> Refine -> Retest

*"I'm not a great programmer, I'm just a good programmer with great habits"*  
— Kent Beck



# Great Habits for Testing and Debugging

- **Comments**: Describe what your code is doing.
- **Docstrings**: Add documentation to your functions (this will help with doctests!).
- **Use/Create functions**: Break tasks into reusable pieces.
- **Use/Create modules**: Organize your code.
- **Make small frequent commits**: Helps isolate where bugs come from.



# What is a Bug?

*A software bug is an error, flaw, or fault in computer software that causes it to produce an incorrect or unexpected result, or behave in unintended ways.*  
— Wikipedia



# Debugging: The Process of Fixing Bugs

1. **Types of Errors**:
   - **Syntax Errors**: Mistakes in the code’s format.
   - **Run-Time Errors**: Errors that occur when the program is running (e.g., division by zero).
   - **Logic Errors**: The code runs but produces incorrect results (e.g., wrong weather prediction).

2. **Debugging with `print()`**:
   - Use `print()` to display variables and track how values change in your program.
   - Example:
     ```python
     def predict_weather(temp):
         print(f"Current temperature: {temp}")
         if temp > 25:
             return "Sunny"
         else:
             return "Cloudy"
     print(predict_weather(30))  # Should print "Sunny"
     ```



# Debugging Strategies

- **Step/Trace through code**: Use `print()` to trace how data flows.
- **Inspect Objects**: Use `type()` to check what kind of data your variables are holding.
- **Apply Trial and Error**: Try different values, step through your logic slowly.
- **Compare to similar code**: Use working code as a reference.
- **Ask for help**: Reach out to peers, forums, or Google.
- **Use an IDE**: Syntax highlighting and autocompletion can catch errors before you even run your code.



# Why Test?

- **Reliable**: Ensure the software behaves as expected.
- **Reproducible**: Others can verify your results.
- **Shareable**: Collaborators can see that your code works.

**_"Testing leads to failure, and failure leads to understanding."_**  
— Burt Rutan



# Testing: What Are We Testing?

1. **Requirements**: Does the weather prediction match the user’s needs?
2. **Design**: Does the code structure make sense?
3. **Code/Implementation**: Are the calculations and logic correct?
4. **Documentation**: Are there enough docstrings and comments?



# You Are Already Testing!

- Validating inputs:
  - Example: What if someone enters an invalid temperature like "hot" instead of a number?

- Testing a variety of inputs (data):
  - Example: What happens if today's temperature is -10°C vs. 40°C?

- Checking outputs to meet requirements:
  - Does the predicted weather make sense based on the input?

**We are just giving more structure to this process.**



# Types of Tests

1. **Unit Testing**: Test an individual, isolated function or module.
   - Example: Test if the `predict_weather()` function returns the correct output for different temperatures.

2. **Integration Testing**: Ensure multiple parts of the program work together.
   - Example: Test if weather prediction works when integrated with a larger weather dashboard application.

3. **End-to-End Testing**: Simulate a real user interacting with your program.
   - Example: Test the entire workflow of entering today's weather and predicting tomorrow's weather in your app.

4. **Acceptance Testing**: Ensure the program meets the user’s requirements.
   - Example: The program should correctly predict "Sunny" when the temperature is above 25°C.




Absolutely! Here's a slide reviewing REPL (Read-Eval-Print Loop) to provide context before introducing `doctest`:



# Review: What is the Python REPL?

The Python REPL stands for **Read-Eval-Print Loop** and is an interactive environment that lets you type and execute Python code line by line.

# How REPL Works:

1. **Read**: The REPL reads your input (Python code).
2. **Eval**: It evaluates or executes the code you entered.
3. **Print**: It displays the result of your code.
4. **Loop**: The process repeats, allowing you to try more code.

# Why Use REPL?

- **Instant Feedback**: You can quickly test and run small pieces of code.
- **Interactive Learning**: It’s great for experimenting with Python features.
- **Debugging**: Use it to test functions and explore data interactively.

# Example: REPL in Action

```python
>>> temperature = 30
>>> if temperature > 25:
...     print("Sunny")
... else:
...     print("Cloudy")
...
Sunny
```

In this example:
- You entered a condition based on temperature.
- The REPL evaluated the condition and printed "Sunny" as the result.



### How REPL Connects to Doctests

- **Doctests** mimic the Python shell (REPL) experience inside your code.
- You can write your function's expected behaviour in a way that looks like what you'd do in the REPL.



# Simple Example: Testing with `doctest`

You can embed tests inside your function’s docstrings using `doctest`. Here's a weather example:

```python
def predict_weather(temp):
    """
    Predict tomorrow's weather based on today's temperature.

    >>> predict_weather(30)
    'Sunny'
    >>> predict_weather(20)
    'Cloudy'
    """
    if temp > 25:
        return "Sunny"
    else:
        return "Cloudy"
```

You can run `doctest` to check if the output matches the expected results. To run `doctest`, add this to the bottom of your script:
```python
if __name__ == "__main__":
    import doctest
    doctest.testmod()
```


# Doctests: Testing in Your Docstrings

Doctests allow you to write test cases directly in your function's docstring,
mimicking how you would test code in the Python shell. They are great for small
functions and help you document the expected behavior of your code.

# How Doctests Work

- Doctests simulate the Python shell (REPL) and check if the output matches the expected result written in the docstring.
- You write the function's input and output in a way that looks like a Python session, and `doctest` automatically checks if the function produces the correct result.

# Doctest Example (Weather Prediction)

```python
def predict_weather(temp):
    """
    Predict tomorrow's weather based on today's temperature.
    
    This function returns 'Sunny' if the temperature is above 25°C, 
    otherwise it returns 'Cloudy'.
    
    Example usage in the Python shell:
    
    >>> predict_weather(30)
    'Sunny'
    >>> predict_weather(20)
    'Cloudy'
    """
    if temp > 25:
        return "Sunny"
    else:
        return "Cloudy"
```

# Why Use Doctests?

- **Readable**: It combines documentation and testing in one place.
- **Simple**: You don't need separate testing files for small functions.
- **Automated**: Doctests verify that your code behaves as described.

# Running Doctests

To run doctests, include the following at the bottom of your Python file:
```python
if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

This will run the tests inside your docstrings, checking if the actual outputs match the expected ones.



# Doctest vs. Python Shell

When you run `doctest`, it behaves as if you are manually entering the input and checking the output in the Python shell (REPL):

**Python Shell Session**:
```python
>>> predict_weather(30)
'Sunny'
>>> predict_weather(20)
'Cloudy'
```

**Doctest in Docstring**:
```python
"""
>>> predict_weather(30)
'Sunny'
>>> predict_weather(20)
'Cloudy'
"""
```

Doctests save you time by automating these shell interactions and ensuring your code works as expected!



# Testing Strategy in Jupyter Notebooks

There are different ways to test notebooks:

- **Write python script to test notebook**: You can import your functions from the notebook and test them using a Python script.
- **Write test and code in one notebook**: You can use `assert()`, `doctest`, or other testing libraries directly in the notebook.
  
Example in a notebook:
```python
# Code cell:
def predict_weather(temp):
    return "Sunny" if temp > 25 else "Cloudy"

# Test cell:
assert predict_weather(30) == "Sunny"
assert predict_weather(20) == "Cloudy"
```



Here's a slide explaining how to use `doctest` in Jupyter notebooks, tailored for your audience:



# Using Doctests in Jupyter Notebooks

1. **Write Your Function with a Doctest**:
   Include the test cases directly in your function’s docstring.

   ```python
   def predict_weather(temp):
       """
       Predict tomorrow's weather based on today's temperature.

       >>> predict_weather(30)
       'Sunny'
       >>> predict_weather(20)
       'Cloudy'
       """
       if temp > 25:
           return "Sunny"
       else:
           return "Cloudy"
   ```

2. **Run Doctests with `doctest.testmod()`**:
   You can run your doctests in a Jupyter notebook using the `doctest` module.

   ```python
   import doctest
   doctest.testmod()
   ```

3. **View the Results**:
   If all tests pass, there will be no output.
   If any tests fail, `doctest` will show where the function’s output didn’t match the expected result.



# Example in Jupyter Notebook

- First, define the function with doctests in the cell.
- Then, in a new cell, run the following code to check the tests:

```python
import doctest
doctest.testmod()
```

### Key Points:

- In Jupyter notebooks, `doctest` works just like in standard Python scripts.
- The tests will run, and you can verify that your function behaves as expected, just like in the Python shell.


# Building a Test Suite

1. **Build up a suite of tests**: Create a set of tests that cover different parts of your program.
2. **Run all tests in one go**: Use a script or notebook to run all tests automatically.
3. **Test sane cases, then edge cases**: Test common scenarios first, then unusual inputs.
   - Example: What happens when you input extreme temperatures like -100°C or 100°C?



# Review: Can you…

- Understand the difference between testing and debugging?
- Describe one approach to debugging?
- State why we test?
- List common testing strategies?



---
title: "Python Essentials"
subtitle: "Overview and Setup"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../course-documents/custom-reference-doc.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

# 
![](../images/curtin-copy-right.png)


# Acknowledge of Country
I acknowledge the traditional custodians of the land on which I work and live,
and recognise their continuing connection to land, water and community. I pay
respect to elders past, present and emerging.

![](../images/ack_country_small.png)


# This Week
- Intro to Python
- Running Python
- Cloud Development Environment
- Version Control Basics
- Python Fundamentals
- AI Coding Assistance

# How to Learn: Course Approach

- Read, then practice immediately
- Engage with interactive exercises
- Get instant feedback
- Build solid foundation
- Prepare for advanced concepts

# Python: The Absolute Minimum

- High-level, interpreted programming language
- Known for readability
- Versatile: web, data, AI
- Large, supportive community
- Extensive standard library

# How to Run Python

- IDLE: Integrated Development Environment
- Jupyter Notebook: Interactive coding
- Python scripts: .py files
- Command line execution
- Online platforms (e.g., Repl.it)

# Setting up Google Account

- Visit accounts.google.com
- Click 'Create account'
- Fill in required information
- Verify your account
- Explore Google services

# Google Colab: Cloud Environment

- Access via colab.research.google.com
- Free, cloud-based Jupyter notebooks
- No setup required
- Collaboration features
- GPU access for computation

# Your First Python Program

- Open a new Colab notebook
- Type: print("Hello, World!")
- Click 'Run' or Shift+Enter
- See output below cell
- Congratulations, you're programming!

# Setting up GitHub Account

- Visit github.com
- Click 'Sign up'
- Choose a username
- Provide email and password
- Verify your account

# Saving Colab to GitHub

- In Colab: File > Save
- Choose 'GitHub' as destination
- Authorize Colab-GitHub connection
- Name your repository
- Commit changes

# AI Coding Assistance

- Automate boring tasks
- Follow coding rules
- Provide tutoring
- Support pair programming
- Enhance learning experience

# Automate Boring Tasks

  - Format code
  - Improve structure
  - Run tests
  - Write documentation

# AI Follow Coding Rules

  - Detect mistakes
  - Suggest improvements
  - Learn your style
  - Real-time feedback

# AI as Tutor

  - Personalized learning
  - Instant help
  - Contextual assistance
  - Code feedback

# AI Pair Programming

  - Continuous support
  - Share knowledge
  - Problem-solving
  - Boost productivity

# Enhance Learning

- Engage learners
- Suggest alternatives
- Inspire innovation
- Encourage exploration

# Variables in Python

- Named storage for data
- Created upon value assignment
- Can change during program
- Follow naming conventions
- Case-sensitive

# Basic Python Data Types

- Integers: Whole numbers
- Floats: Decimal numbers
- Strings: Text data
- Booleans: True or False
- Lists: Ordered collections

# Documenting Code

- Single-line: Use #
- Multi-line: Use """..."""
- Explain code purpose
- Improve code readability
- Temporarily disable code

# Recap

- Python basics introduced
- Development environment set up
- First program written
- Version control initiated
- Core concepts covered

# Next Week

- Python data types
- Operators and expressions
- Variables and assignment


---
title: "Your First Google Colab Notebook"
subtitle: "Python Essentials"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

Welcome to your first coding experience with Google Colab! We'll go through several steps to set up your environment, write some code, and save your work to GitHub.

## Step 1: Log into Google

1. Open your web browser and go to google.com
2. Click the "Sign In" button in the top-right corner.
3. Enter your Google account email and password.
4. If you don't have a Google account, click "Create account" and follow the prompts.

## Step 2: Access Google Colab

1. Once logged in, go to colab.research.google.com
2. Click on "New Notebook" to create a new Colab notebook.

## Step 3: Rename Your Notebook

1. Look at the top-left corner of your Colab window. You'll see the current name of your notebook (probably "Untitled0.ipynb" or similar).
2. Click on this name.
3. A text box will appear. Type in a meaningful name for your notebook, like "My_First_Python_Program".
4. Press Enter to save the new name.

## Step 4: Write Your First Code

In the first code cell, type the following:

```python
print("Hello, World!")
```

Run the cell by clicking the play button or pressing Shift+Enter.

You should see the output "Hello, World!" printed below the cell.

Congratulations! You've just written and executed your first Python program.

## Step 3: Set Up GitHub

1. If you don't have a GitHub account, go to github.com and sign up.
2. Log in to your GitHub account.
3. Click the '+' icon in the top-right corner and select 'New repository'.
4. Name your repository (e.g., "python-learning").
5. Set the repository to Private (this is a unit requirement to prevent plagiarism).
6. Click "Create repository".

## Step 4: Link Colab to GitHub

1. In Colab, click on the gear icon in the top-right to open Settings.
2. Go to the "GitHub" tab.
3. Click on "Allow access to private repositories".
4. Follow the prompts to authorize Colab to access your GitHub account.

## Step 5: Save to GitHub

1. In Colab, click "File" > "Save a copy in GitHub".
2. Select your newly created repository.
3. Add a commit message (e.g., "First Python program").
4. Make sure "Include a link to Colaboratory" is checked.
5. Click "OK" to save.

## Step 6: Follow-up Exercises

1. Modify the string to print "Hello, Weather!"

2. Print the single character 'E'

3. Change the code to print "Hello Alex!" (Replace Alex with your name)

4. Try leaving off a quote character. What happens? Was the error message helpful? Did it give any clues about what went wrong?

Remember to save your changes to GitHub after completing the exercises!

Good luck, and have fun with your first coding experience!


---
title: "Saving Your Google Colab Notebook to GitHub"
subtitle: "Version Control and Sharing Made Easy"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

Saving your Google Colab notebooks to GitHub is an excellent way to version control your work and share it with others. Here's what you need to know:

1. **Initiate the Save Process**
   - In your Colab notebook, click on "File" in the top menu
   - Select "Save a copy in GitHub" from the dropdown

2. **Choose GitHub as Destination**
   - If this is your first time, you'll need to authorize Colab to access your GitHub account
   - Click "Authorize googlecolab" when prompted

3. **Select Repository and Branch**
   - Choose the repository where you want to save your notebook
   - Select the branch (usually "main" or "master")
   - If the repository doesn't exist, you can create a new one

4. **Name Your File**
   - The filename will default to your Colab notebook name
   - You can change it if desired, but keep the ".ipynb" extension

5. **Add a Commit Message**
   - Write a brief description of your changes
   - This helps track the history of your notebook

6. **Finalize the Save**
   - Click "OK" to save your notebook to GitHub
   - Colab will push your changes to the selected repository

Remember, each time you save to GitHub, you're creating a new commit. This allows you to track changes over time and collaborate with others effectively.

Pro Tip: Check the "Include a link to Colaboratory" box when saving. This adds a button to your GitHub repository that allows others to open your notebook directly in Colab.


---
title: "Python"
subtitle: "Your First Step in Coding"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

#### What is Python?

Python is a popular, general-purpose programming language created by Guido van Rossum over 30 years ago. It is widely used because it is easy to learn and read, making it a great choice for beginners.

#### Key Features of Python

- **High-Level Language**: Python is close to human language, which makes it easier to write and understand.

- **Readability**: Python's design emphasizes readability, allowing you to write clear and logical code.

- **Versatile Uses**: Python can be used in many areas, including web development, data analysis, artificial intelligence, and scientific computing.

- **Supportive Community**: Python has a large, active community that offers extensive support and resources for learners and developers.

- **Standard Library**: Python comes with many built-in tools and modules that help with various tasks, reducing the need for external libraries.

#### Why Learn Python?

Python is often the first programming language taught to beginners because of its simplicity and readability. Its versatility and strong community support make it a valuable skill for many programming and data-related jobs.

#### Summary

Python is a high-level programming language known for its readability and versatility. It has a large, supportive community and an extensive standard library, making it an excellent choice for both beginners and professionals.

By understanding these fundamental aspects of Python, you'll be well on your way to starting your programming journey with one of the most popular and powerful languages available.

---
title: "Basic Python Data Types"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

Python has several built-in data types that allow you to work with different kinds of data. Here are the fundamental ones you need to know:

1. **Integers (int)**
   - Whole numbers without decimal points
   - Examples: -3, 0, 42
   - Used for counting, indexing, etc.
   - Create with: `x = 5`

2. **Floats (float)**
   - Numbers with decimal points
   - Examples: 3.14, -0.001, 2.0
   - Used for precise calculations
   - Create with: `y = 3.14`

3. **Strings (str)**
   - Text data enclosed in quotes
   - Examples: "Hello", 'Python', "123"
   - Used for names, messages, etc.
   - Create with: `name = "Alice"`

4. **Booleans (bool)**
   - Represent True or False
   - Used for logical operations
   - Only two possible values: True, False
   - Create with: `is_valid = True`

5. **Lists**
   - Ordered collections of items
   - Can contain mixed data types
   - Created using square brackets []
   - Example: `numbers = [1, 2, 3, 4]`

Understanding these basic data types is crucial for effective Python programming. Each type has its own methods and operations. You can check the type of a variable using the `type()` function:

```python
x = 5
print(type(x))  # Output: <class 'int'>
```

Remember, Python is dynamically typed, meaning you don't need to declare the type of a variable explicitly. The interpreter infers the type based on the assigned value.

Pro Tip: Pay attention to data types when performing operations. Mixing types can lead to unexpected results or errors. For example, `"5" + 2` will cause an error because you can't add a string and an integer directly.

---
title: "Python's print() Function"
subtitle: "Your First Step in Coding"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

The `print()` function is often the first command new Python programmers learn. It's a simple yet powerful tool for displaying information on the screen.

**Basic Syntax:**
```python
print("Hello, World!")
```

**Key Points:**
• `print` is a built-in Python function (always lowercase).
• Text to be displayed goes inside parentheses.
• Strings (text) are enclosed in quotation marks.

**Style Tips:**
• No space between `print` and the opening parenthesis.
• Quotation marks hug the text inside.

**Remember:** When the code runs, quotation marks aren't displayed - they're just for Python to recognize strings.

By mastering `print()`, you've taken your first step into the world of Python programming!


---
title: "3 ways to run Python code (but only 2 are important)"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

Technically, there are three different ways to run Python code:

1. In an interactive shell environment on the command line (useful for quick
   calculations and checks, but not much else).
2. In an IPython environment or Jupyter Notebook, which consists of runnable
   “cells” and in-line outputs/visualisations.
3. As a standalone .py script, e.g., `main.py` or `your_script.py` (generally
   executed on the command line with a command like `python your_script.py`).

In industry, the most important of these three approaches are Jupyter notebooks, and running Python scripts.   We’ll focus on these two ways to run Python in “real-world”.

* Running Jupyter Notebooks
* Running Python scripts (later in course)

We can choose to run locally or in the cloud.  Locally means we may have to
install Python, for let's skip that step, let’s look at how to practice them in
the cloud. In the cloud we run Python code on remote servers accessed over the
internet. This also means you can access your code and data from any device.  We
are also using GitHub to store and share our code.  GitHub is great for sharing
code with others, and for keeping track of changes to your code.

I’ve picked these platforms because they are free, beginner-friendly, and widely used in industry. 

---
title: "Setting up Google Account"
subtitle: "Your First Step to Google Services"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

Setting up a Google Account is an essential first step for accessing many Google services. Here's the absolute minimum you need to know:

1. **Visit the Sign-Up Page**
   - Open your web browser and go to accounts.google.com
   - Click on the "Create account" button

2. **Provide Personal Information**
   - Enter your first and last name
   - Choose a username (this will be your email address)
   - Create a strong password and confirm it

3. **Additional Details**
   - Enter your phone number (optional but recommended for account recovery)
   - Provide your date of birth and gender
   - You may be asked for a recovery email address

4. **Verify Your Account**
   - Google will send a verification code to your phone or email
   - Enter this code when prompted to confirm your identity

5. **Accept Terms and Conditions**
   - Review Google's Terms of Service and Privacy Policy
   - Click "I agree" to create your account

6. **Explore Google Services**
   - Your account is now active
   - You can access Gmail, Google Drive, YouTube, and other Google services

Remember, your Google Account is the key to a wide range of services, so keep your login information secure. Consider enabling two-factor authentication for added security.


---
title: "How Coding Benefits from AI"
subtitle: "Artificial Intelligence Coding Assistants"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

Artificial Intelligence (AI) coding assistants are transforming how we learn and write code. These tools can significantly enhance your programming experience. Here's what you need to know:

**Getting Rid of Boring Tasks:** AI can automate mundane and repetitive tasks
such as formatting code, improving code structure, running tests, and writing
documentation. This allows you to focus on the creative aspects of coding,
saving time and reducing the chance of errors.

**Helping with Coding Rules:** AI can help you follow coding rules by detecting
mistakes, suggesting improvements, and learning your coding style to offer
relevant tips. It can be integrated into your coding tools to provide real-time
feedback and make your code more efficient and readable.

**Using AI as a Tutor:** AI can act as a personalized tutor by identifying your
strengths and weaknesses, offering instant help and explanations, and providing
feedback on your code. This makes learning to code more interactive and tailored
to your needs.

**Pairing Up with AI:** AI can serve as a virtual pair programming partner,
offering continuous support, sharing knowledge, assisting with problem-solving,
and boosting your productivity. This collaboration helps ensure high-quality
code and enhances your learning experience.

**Enhancing Learning:** Effective learning in programming is not just about
memorising syntax or following rigid rules. It's about developing
problem-solving skills, fostering creativity, and building the confidence to
tackle new challenges.  AI create an environment that engages learners, suggests
alternatives, inspires innovation, and encourages exploration.

While AI coding assistants are powerful tools, they're not infallible. Always review and understand the code they generate. Use them as aids to enhance your learning and productivity, not as substitutes for developing your own coding skills and understanding.

Pro Tip: Start with simple tasks when using AI assistance, and gradually increase complexity as you become more comfortable with the tool's capabilities and limitations.

---
title: "Documenting Code"
subtitle: "Python Essentials"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

Documenting your code is a crucial skill for any programmer. It helps others (and your future self) understand your code. Here's what you need to know to get started:

1. **Why Document Code?**
   - Makes code easier to understand and maintain
   - Helps others (and you) follow your logic
   - Serves as a roadmap for future development

2. **Single-line Comments**
   - Use # for brief explanations
   - Example: # Calculate the average score
   - Ideal for short, in-line clarifications

3. **Multi-line Comments**
   - Use """ or ''' for longer explanations
   - Useful for describing complex functions or classes
   - Example:
     """
     This function calculates the
     average of a list of numbers.
     """

4. **Best Practices**
   - Explain 'why' rather than 'what' the code does
   - Keep comments up-to-date with code changes
   - Use clear, concise language

5. **Code Readability**
   - Well-documented code is easier to debug
   - Comments can outline the structure of your program
   - Use comments to break down complex algorithms

Remember, good documentation is an ongoing process. As you write code, think about how to make it clear and understandable. This is your first step towards professional-level documentation practices.

Pro Tip: Start documenting your code from day one. It's a habit that will serve you well throughout your programming career.

---
title: "Programming as a way of thinking"
subtitle: "Python Essentials"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

Programming is a way of thinking. It is a way of breaking down complex problems
into smaller, more manageable parts. It is a way of designing systems that
perform tasks efficiently and effectively. It is a way of creating solutions to
problems that can be shared, reused, and improved over time.

Programming is a way of thinking that is both creative and analytical. It
requires imagination and logic, intuition and precision. It is a way of
exploring the world, understanding how things work, and making things happen.

Programming is a way of thinking that is both practical and theoretical. It is
a way of solving real-world problems and exploring abstract concepts. It is a
way of building things that work and understanding why they work.

Programming is a way of thinking that is both individual and collaborative. It
is a way of working alone and with others, of creating things on your own and
contributing to projects with many people. It is a way of learning from others
and teaching others, of sharing knowledge and building on the ideas of others.

Programming is a way of thinking that is both challenging and rewarding. It is a
way of facing difficult problems and finding elegant solutions. It is a way of
learning new things and mastering new skills. It is a way of creating things
that are useful, beautiful, and fun.


We're going to start with the ABCs of programming and build from there. As we go, you'll pick up important words that programmers use, like "operator" and "value". Think of it as learning a new language - the language of computers. Knowing these words is super helpful. It's like having the right tools in your toolbox. They'll help you read coding books, chat with other coders, figure out what went wrong when your program hiccups, and even talk to AI helpers about coding. It's all about giving you the know-how to speak 'computer' fluently!

---
title: "Setting Up a GitHub Account"
subtitle: "Your First Step in Version Control"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

GitHub is a platform for version control and collaboration. Setting up an account is your first step towards using this powerful tool. Here's what you need to know:

1. **Visit GitHub's Website**
   - Open your web browser
   - Go to github.com

2. **Start the Sign-up Process**
   - Click the 'Sign up' button, usually in the top-right corner
   - You'll be taken to the registration page

3. **Choose Your Username**
   - Enter a unique username
   - This will be your GitHub identity, visible to others
   - Choose wisely - it's hard to change later

4. **Provide Your Email**
   - Use a valid email address
   - You'll need this for account verification and notifications

5. **Create a Strong Password**
   - Choose a secure password
   - GitHub will indicate the password strength as you type

6. **Verify Your Account**
   - GitHub will send a verification code to your email
   - Enter this code on GitHub to confirm your account

7. **Complete the Setup**
   - Answer a few questions about your preferences (optional)
   - You may be asked to solve a puzzle to prove you're not a robot

Remember, your GitHub account is often viewed by potential employers and collaborators. Keep it professional and start exploring the world of code repositories and open-source projects!

---
title: "Google Colaboratory"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

Google Colaboratory, or Colab for short, is a free cloud-based platform that
allows you to write and execute Python code through your browser. Here's the
absolute minimum you need to know:

1. **Accessing Colab**
   - Open your web browser and go to colab.research.google.com
   - Sign in with your Google account

2. **Understanding Colab Notebooks**
   - Colab uses Jupyter notebooks, which combine code, output, and text
   - Notebooks are divided into cells: code cells for Python code and text cells for explanations

3. **No Setup Required**
   - Colab comes pre-installed with popular Python libraries
   - You can start coding immediately without any local installation

4. **Running Code**
   - To run a code cell, click the play button next to it or use Shift+Enter
   - Output appears directly below the code cell

5. **Collaboration Features**
   - Share your notebook by clicking the "Share" button in the top-right corner
   - Others can view or edit your notebook, similar to Google Docs

6. **Free GPU Access**
   - Colab provides free access to GPUs for faster computations
   - To use a GPU, go to Runtime > Change runtime type > Hardware accelerator > GPU

7. **Saving Your Work**
   - Notebooks are automatically saved in your Google Drive
   - You can also save to GitHub or download as .ipynb files

Remember, Colab sessions have time limits and may disconnect after periods of
inactivity. Always save your work frequently. Colab is an excellent tool for
learning Python, data analysis, and even machine learning without the need for
powerful local hardware.

---
title: "First Program in Python"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

Writing your first Python program is an exciting step in your coding journey. We'll use Google Colab to create a simple "Hello, World!" program. Here's what you need to know:

1. **Open a New Colab Notebook**
   - Go to colab.research.google.com
   - Click on "New Notebook" or File > New Notebook

2. **Write Your First Code**
   - In the first cell, type the following exactly:
     ```python
     print("Hello, World!")
     ```
   - This command tells Python to display the text "Hello, World!"

3. **Run the Code**
   - Click the play button next to the cell, or
   - Press Shift+Enter on your keyboard

4. **View the Output**
   - Look below the code cell
   - You should see:
     ```
     Hello, World!
     ```

5. **Understand What Happened**
   - `print()` is a Python function that displays text
   - The text inside the parentheses and quotes is the message to display

Congratulations! You've just written and run your first Python program. This simple example demonstrates the basics of writing code and seeing its output. Remember, in Python, accuracy matters - even small errors like missing parentheses can prevent your code from running correctly.

Try modifying the message inside the quotes to print something different. Each time you make a change, run the cell again to see your new output.

---
title: "Variables in Python"
subtitle: "Understanding Named Storage for Data"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

Variables are fundamental building blocks in Python programming. They allow you to store and manipulate data in your code. Here's what you need to know:

1. **Named Storage for Data**
   - Variables are like labeled containers for information
   - They can hold various types of data (numbers, text, etc.)
   - Example: `age = 25` stores the number 25 in a variable named 'age'

2. **Creation by Assignment**
   - Variables are created when you first assign them a value
   - Use the equals sign (=) for assignment
   - Example: `name = "Alice"` creates a variable 'name' with the value "Alice"

3. **Mutable Nature**
   - Variables can change value during program execution
   - Simply reassign a new value to update
   - Example:
     ```python
     x = 10
     x = 20  # x now holds the value 20
     ```

4. **Naming Conventions**
   - Use lowercase letters, numbers, and underscores
   - Start with a letter or underscore, not a number
   - Use descriptive names (e.g., `user_age` instead of `ua`)
   - Avoid Python keywords (like 'if', 'for', 'while')

5. **Case Sensitivity**
   - Python distinguishes between uppercase and lowercase
   - `name`, `Name`, and `NAME` are three different variables
   - Be consistent to avoid confusion

Remember, variables are essential for storing and manipulating data in your programs. They allow you to write flexible and reusable code. Practice creating and using variables to become comfortable with these concepts.

Pro Tip: Use meaningful variable names to make your code more readable and easier to understand, both for yourself and others who might read your code.

---
title: "PyInputPlus & Python's Stormy Exception Handling"
subtitle: "Navigating Weather Woes with Smart Input Validation"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Copyright Information

![](../../../_assets/curtin-copy-right.png)

# Acknowledge of Country

I acknowledge the traditional custodians of the land on which I work and live,
and recognise their continuing connection to land, water and community. I pay
respect to elders past, present and emerging.

![](../../../_assets/ack_country.png)

# Today

1. Summary
2. Introduction to PyInputPlus
2. Basic PyInputPlus Functions
3. Advanced PyInputPlus Features
4. Exception Handling in Python
5. Combining PyInputPlus and Exception Handling

::: {.notes}
**Aim**
Provide an overview of the topics that will be covered in today's presentation on AI and machine learning.

**Context**
This slide serves as an agenda for the presentation, following the Copyright Information and Acknowledgement of Country slides. It sets the stage for the subsequent slides, which will delve into specific concepts and examples related to AI and machine learning using Python.
:::

# Six Things
- Input
- Output
- Calculations (expressions)
- Store values (assignment)
- Make decisions (if-then, booblean)
- Repeate things (for, while, list comphresnsion)

::: {.notes}
**Aim**
The aim of this slide is to introduce the six fundamental elements of programming that form the foundation of any coding language.

**Context**
This slide serves as a bridge between the introductory slides and the more in-depth exploration of Python concepts. It sets the stage for the following slides, which delve into the specifics of Python programming, such as PyInputPlus, exception handling, and creating robust user input functions.

**Input** 
In programming, input refers to the data or information that is provided to a program for processing. This can include user input from the keyboard, data from files, or information from other sources. Input is essential for making programs interactive and dynamic, allowing them to respond to different scenarios and user needs.

**Output** 
Output is the result or information that a program produces after processing the input. This can be in the form of text displayed on the screen, data written to a file, or any other form of communication between the program and the user or other systems. Effective output is crucial for conveying the results of a program's computations and making them understandable to the user.

**Calculations (expressions)**
Calculations, or expressions, are the mathematical or logical operations performed on data within a program. These can include arithmetic operations like addition, subtraction, multiplication, and division, as well as more complex operations involving functions and variables. Expressions allow programs to manipulate and transform data to produce desired results.

**Store values (assignment)**
Storing values, or assignment, involves assigning a value to a variable for later use in the program. Variables act as containers for data, allowing programmers to reference and manipulate values throughout the code. Assignment is a fundamental concept in programming, as it enables the creation of reusable and modular code.

**Make decisions (if-then, boolean)**
Making decisions, or conditional statements, allow programs to execute different code blocks based on whether a specific condition is true or false. If-then statements and boolean expressions are used to evaluate conditions and determine the flow of the program. This enables programs to respond to different scenarios and make decisions based on input or computed values.

**Repeat things (for, while, list comprehension)**
Repeating things, or iteration, involves executing a block of code multiple times. This can be achieved using loops like for and while, which allow programs to iterate over a sequence of values or continue executing until a specific condition is met. List comprehension is a concise way to create lists based on existing lists or other iterable objects. Iteration is essential for automating repetitive tasks and processing large amounts of data efficiently.
:::

# Methodology
1. Understand the problem
2. Determine inputs/outputs
3. Work the problem by hand
4. Create the Algorithm
5. Convert to Python
6. Test with a variety of inputs

::: {.notes}
**Aim**
This slide provides an overview of the methodology used in the AI and machine learning project.

**Context**
The "Methodology" slide follows the "Six Things" slide and precedes the "Python Concepts" slide. It serves as a bridge between the high-level overview and the technical details of the project, providing a foundation for understanding the subsequent slides on Python programming and exception handling.
:::

# Python Concepts
- Values (Literals)
- Data Types (everything has a datatype)
  - str (string)
  - int (integer)
  - float (real number, decimal number)
  - list []
- Expressions
  - Mathematical operations  evaluates to value
  - Relational Operators  Boolean Expressions
  - Assignment. Store/save a value to a variable
  - if-else (selection)
  - Repetition (for, while) 
- Functions
  - builtins
  - import (other packages to extend python)
  - custom (create yourt own)

::: {.notes}
**Aim**
The aim of this slide is to provide an overview of key Python concepts that are essential for understanding and working with the Python programming language.

**Context**
This slide is part of a larger presentation on AI and machine learning, and it serves to lay the foundation for understanding Python, which is a commonly used language in these fields. The concepts covered in this slide will be built upon in subsequent slides, such as those discussing PyInputPlus and exception handling.

**Values (Literals)**
In Python, values or literals are the actual data that is processed by the program. These can be numbers, strings, or other data types. For example, `5`, `"hello"`, and `3.14` are all values or literals in Python.

**Data Types (everything has a datatype)**
Every value in Python has a specific data type, which determines the kind of data it represents and the operations that can be performed on it. Some common data types include integers, floating-point numbers, and strings. Python is a dynamically-typed language, meaning that you don't need to explicitly declare the data type of a variable; Python infers it based on the value assigned.

**str (string)**
A string is a sequence of characters enclosed in single quotes (`'...'`) or double quotes (`"..."`). Strings are used to represent text data in Python. For example, `"Hello, world!"` is a string.

**int (integer)**
An integer is a whole number, positive or negative, without any decimal points. For example, `42`, `-7`, and `0` are all integers in Python.

**float (real number, decimal number)**
A floating-point number, or float, is a number with a decimal point. Floats are used to represent real numbers in Python. For example, `3.14`, `-2.5`, and `1.0` are all floats.

**list []**
A list is an ordered, mutable collection of items enclosed in square brackets (`[...]`). Lists can contain elements of different data types and are commonly used to store and manipulate collections of related data. For example, `[1, 2, 3]` is a list of integers, and `["apple", "banana", "cherry"]` is a list of strings.

**Expressions**
An expression is a combination of values, variables, operators, and function calls that evaluates to a single value. For example, `2 + 3` is an expression that evaluates to the value `5`.

**Mathematical operations → evaluates to value**
Python supports various mathematical operations, such as addition (`+`), subtraction (`-`), multiplication (`*`), division (`/`), and more. These operations evaluate to a single value. For example, the expression `5 * 2` evaluates to the value `10`.

**Relational Operators → Boolean Expressions**
Relational operators are used to compare values and create Boolean expressions that evaluate to either `True` or `False`. Some common relational operators include equal to (`==`), not equal to (`!=`), greater than (`>`), and less than (`<`). For example, the expression `5 > 3` evaluates to `True`.

**Assignment. Store/save a value to a variable**
Assignment is the process of storing a value in a variable, which is a named location in the computer's memory. The assignment operator (`=`) is used to assign a value to a variable. For example, `x = 5` assigns the value `5` to the variable `x`.

**if-else (selection)**
The `if-else` statement is used for conditional execution of code blocks based on the truth value of a condition. If the condition is `True`, the code block under the `if` statement is executed; otherwise, the code block under the `else` statement (if present) is executed.

**Repetition (for, while)**
Python provides two main ways to perform repetition or iteration: the `for` loop and the `while` loop. A `for` loop is used to iterate over a sequence (such as a list or string) or other iterable objects, executing a block of code for each item. A `while` loop repeatedly executes a block of code as long as a given condition is `True`.

**Functions**
Functions are reusable blocks of code that perform a specific task. Python has two types of functions: built-in functions and user-defined functions. Functions can take input parameters and return output values.

**builtins**
Python comes with a set
:::

# Environment

- Google Colab (Python Notebook) 
  - Code Cells
  - Text Cells (Markdown)
  - Interactively run cells
  - Output in notebook
- Github
  - Cloud storage
  - version control
- Workflow
  - Edit/Prototype in notebook
  - Frequently save to GitHub

::: {.notes}
**Aim**
The purpose of this slide is to introduce the development environment and tools used for AI and machine learning, focusing on Google Colab and GitHub.

**Context**
This slide is part of the "Environment" section of the presentation, which comes after an introduction to Python concepts. It provides an overview of the tools and workflow used in the course, before diving into specific topics like PyInputPlus and exception handling.

**Google Colab (Python Notebook)** Google Colab is a cloud-based Python notebook environment that allows you to write, execute, and share Python code. It provides a convenient platform for developing and running machine learning models without the need for local setup.

**Code Cells** In Google Colab, you can create code cells to write and execute Python code. These cells allow you to break down your code into manageable chunks and run them independently, making it easier to test and debug your code.

**Text Cells (Markdown)** Text cells in Google Colab support Markdown, a lightweight markup language for formatting text. You can use Markdown to add headings, lists, links, and other formatting elements to your notebook, making it more readable and organised.

**Interactively run cells** One of the key features of Google Colab is the ability to run cells interactively. You can execute code cells individually or in groups, allowing you to test and refine your code incrementally. This interactive nature of Colab makes it an ideal environment for experimentation and learning.

**Output in notebook** When you run code cells in Google Colab, the output is displayed directly below the cell. This includes any text, images, or visualisations generated by your code. Having the output in the notebook makes it easy to analyse results and share your work with others.

**Github** GitHub is a web-based platform for version control and collaboration. It allows you to store and manage your code repositories, track changes, and collaborate with others on projects. In this course, you will use GitHub to store and share your Colab notebooks.

**Cloud storage** By using Google Colab and GitHub, you can store your code and notebooks in the cloud. This means you can access your work from any device with an internet connection, without the need for local storage or setup. Cloud storage also provides a backup of your work, ensuring that you don't lose your progress.

**version control** GitHub provides powerful version control features, allowing you to track changes to your code over time. You can create branches to experiment with new features, merge changes back into the main branch, and revert to previous versions if needed. Version control is essential for managing complex projects and collaborating with others.

**Workflow** The typical workflow in this course involves editing and prototyping your code in Google Colab notebooks, then frequently saving your work to GitHub. This allows you to iterate quickly, test new ideas, and maintain a record of your progress.

**Edit/Prototype in notebook** Google Colab provides a fast and easy way to edit and prototype your code. You can quickly make changes, run cells, and see the results in real-time. This makes it an ideal environment for experimenting with new concepts and refining your machine learning models.

**Frequently save to GitHub** To ensure that your work is backed up and accessible from anywhere, it's important to frequently save your Colab notebooks to GitHub. This also allows you to share your work with others, collaborate on projects, and maintain a record of your progress throughout the course.
:::

# Introduction to PyInputPlus

- What is PyInputPlus?
  - A Python module for easy, robust input validation
- Why use PyInputPlus?
  - Simplifies input validation (for beginners)
  - Reduces boilerplate code
  - Handles common input scenarios out-of-the-box

::: {.notes}
**Aim**
The aim of this slide is to introduce PyInputPlus, a Python module that simplifies input validation and reduces boilerplate code.

**Context**
This slide is part of a larger presentation on AI and machine learning with Python. It follows an introduction to key Python concepts and precedes more detailed slides on PyInputPlus functions and features.

**What is PyInputPlus?**
PyInputPlus is a Python module that provides a set of functions for accepting and validating user input. It extends Python's built-in input() function, adding features like type conversion, range checking, and regular expression matching.

**A Python module for easy, robust input validation**
PyInputPlus makes it easy to validate user input without writing extensive custom validation code. It can check that input is of the correct type (e.g., integer, float, string), falls within a specified range, matches a regular expression pattern, and more.

**Why use PyInputPlus?**
There are several reasons to use PyInputPlus in your Python projects. It can save development time, reduce the amount of code you need to write, and help ensure that your programs can handle a variety of input scenarios gracefully.

**Simplifies input validation (for beginners)**
For beginning Python programmers, validating user input can be challenging. PyInputPlus provides a simple, intuitive interface for common input validation tasks, making it easier for beginners to write programs that accept user input safely.

**Reduces boilerplate code**
Without PyInputPlus, validating user input often requires writing similar code across multiple parts of a program. PyInputPlus allows you to replace this boilerplate code with concise function calls, reducing code duplication and making your programs more readable.

**Handles common input scenarios out-of-the-box**
PyInputPlus comes with built-in support for many common input scenarios, such as accepting integers, floats, and strings; enforcing minimum and maximum values; and validating against regular expressions. This means you can handle a wide variety of input cases without writing custom validation logic.
:::

# PyInputPlus

- Installing PyInputPlus
  ```
  pip install pyinputplus
  ```
- Importing PyInputPlus
  ```python
  import pyinputplus as pyip
  ```

::: {.notes}
**Aim**
This slide aims to introduce the PyInputPlus module and provide instructions on installing and importing it for use in Python projects.

**Context**
The PyInputPlus slide follows the "Introduction to PyInputPlus" slide and precedes slides that delve into the basic functions and advanced features of the module. It serves as a starting point for users to set up PyInputPlus before exploring its capabilities in the subsequent slides.

**Installing PyInputPlus**
To begin using PyInputPlus, users must first install the module. This can be done by running the command `pip install pyinputplus` in the terminal or command prompt. It is important to ensure that Python and pip are properly installed and configured on the system before attempting to install PyInputPlus. Once the installation is complete, the module will be available for use in Python projects.

**Importing PyInputPlus**
After successfully installing PyInputPlus, users can import the module into their Python scripts or interactive sessions. To do this, they should include the statement `import pyinputplus as pyip` at the beginning of their code. This statement allows users to refer to the PyInputPlus module using the alias `pyip` throughout their code, making it more convenient to access its functions and features.
:::

# Basic PyInputPlus Functions

- Numeric input validation
  - `inputNum()`: For any number (integer or float)
  - `inputInt()`: For integers only
  - `inputFloat()`: For floating-point numbers
- String input validation
  - `inputStr()`: For string input with optional constraints
  - `inputChoice()`: For selecting from a list of choices
- Yes/No and Boolean inputs
  - `inputYesNo()`: Returns 'yes' or 'no'
  - `inputBool()`: Returns True or False
- Date and time inputs
  - `inputDate()`: For date input
  - `inputTime()`: For time input

::: {.notes}
**Aim**
This slide introduces the basic functions provided by the PyInputPlus library for validating and handling various types of user input in Python programs.

**Context**
Having covered fundamental Python concepts and the PyInputPlus library, this slide dives into the specific functions available for handling numeric, string, boolean, and date/time inputs. The following slides will expand on more advanced features and exception handling with PyInputPlus.

**Numeric input validation** PyInputPlus offers functions for validating numeric input from users. The `inputNum()` function accepts any number, either an integer or a floating-point value. For more specific validation, `inputInt()` ensures the input is strictly an integer, while `inputFloat()` validates input as a floating-point number.

**String input validation** The `inputStr()` function is used for validating string input from users. It allows for optional constraints to be specified, such as a minimum and maximum length or a regular expression pattern that the input must match. The `inputChoice()` function is useful when you want the user to select from a predefined list of choices.

**Yes/No and Boolean inputs** PyInputPlus provides functions for handling yes/no and boolean input. The `inputYesNo()` function prompts the user for input and returns either 'yes' or 'no'. The `inputBool()` function is similar but returns the boolean values True or False based on the user's input.

**Date and time inputs** For validating date and time input, PyInputPlus offers the `inputDate()` and `inputTime()` functions, respectively. These functions ensure that the user enters a valid date or time string and can automatically convert the input to a `datetime` object for further processing.
:::

# Advanced PyInputPlus Features

- Creating custom prompt messages
  ```python
  temp = pyip.inputFloat("Enter temperature in Celsius: ")
  ```
- Handling default values
  ```python
  city = pyip.inputStr("Enter city name (default: Perth): ", default="Perth")
  ```
- Using timeouts and retry limits
  ```python
  user_input = pyip.inputStr(timeout=10, limit=3)
  ```

::: {.notes}
**Aim**
This slide aims to introduce advanced features of PyInputPlus that allow for customisation and more robust user input handling.

**Context**
Having covered the basic PyInputPlus functions in the previous slide, this slide builds on that foundation to explore more advanced capabilities. The following slides will then focus on exception handling, which is important when working with user input.

**Creating custom prompt messages** PyInputPlus allows you to specify custom prompt messages for each input function. This enables you to provide clearer instructions or context to the user about the expected input. By using the `prompt` parameter, you can supply a string that will be displayed before the user enters their input.

**Handling default values** In cases where you want to provide a default value that is used if the user doesn't enter anything, PyInputPlus has you covered. The `default` parameter allows you to specify a value that will be returned if the user simply presses Enter without typing anything. This can streamline user input and reduce friction in your program's flow.

**Using timeouts and retry limits** PyInputPlus offers functionality to prevent your program from getting stuck waiting for user input indefinitely. The `timeout` parameter lets you set a maximum number of seconds to wait for input before raising a `TimeoutException`. Similarly, the `limit` parameter allows you to specify a maximum number of tries a user has to enter valid input before a `RetryLimitException` is raised. These features help make your program more resilient and responsive.
:::

# Exception Handling

- What are exceptions?
  - Runtime errors that disrupt normal program flow
- Why exceptions still occur with PyInputPlus
  - Network issues, file I/O errors, etc.

::: {.notes}
**Aim**
This slide aims to introduce the concept of exceptions in Python programming and explain why they can still occur when using the PyInputPlus module.

**Context**
The "Exception Handling" slide follows the "Advanced PyInputPlus Features" slide and precedes examples of specific exception types. It provides a foundation for understanding exceptions before demonstrating how to handle them in the context of PyInputPlus and Python programming in general.

**What are exceptions?**
In Python, exceptions are events that occur during program execution, disrupting the normal flow of instructions. These events are typically triggered when the program encounters an error or an unexpected situation that it cannot resolve on its own. Exceptions can be caused by various factors, such as invalid user input, attempting to access a non-existent file, or dividing a number by zero. When an exception occurs, the program halts execution and raises an exception object, which can be caught and handled by the program to prevent a complete crash.

**Runtime errors that disrupt normal program flow**
Exceptions are a type of runtime error, meaning they occur while the program is running, as opposed to syntax errors, which are detected by the Python interpreter before the program starts executing. When an exception is raised, it disrupts the normal flow of the program, and if not handled properly, it can lead to the termination of the program. This disruption allows the program to handle the error gracefully, provide meaningful feedback to the user, and potentially recover from the error state, depending on the nature of the exception and the implemented exception handling mechanism.

**Why exceptions still occur with PyInputPlus**
Although PyInputPlus is a powerful module that simplifies user input validation and handling, it does not eliminate the possibility of exceptions occurring in a program. PyInputPlus focuses on validating user input and ensuring that the input meets specified criteria, such as data type, value range, or regular expression patterns. However, exceptions can still arise from factors beyond the scope of user input validation, such as network connectivity issues when attempting to retrieve data from a remote source, file input/output (I/O) errors when reading from or writing to files, or system-related errors like insufficient memory or permissions.

**Network issues, file I/O errors, etc.**
Network issues can lead to exceptions when a program using PyInputPlus attempts to retrieve data from a remote server or API. These issues may include network connectivity problems, timeouts, or server-side errors. File I/O errors can occur when a program tries to read from or write to a file using PyInputPlus functions, and the file is not found, the program lacks sufficient permissions to access the file, or the file is corrupted. Other exceptions may arise from system-related issues, such as running out of memory or attempting to perform an operation without the necessary permissions. In these cases, PyInputPlus alone cannot prevent the exceptions, and the program must implement proper exception handling techniques to manage these situations gracefully.
:::

#  Exception Example: InvalidSyntax
![](../assets/Slide1.png)

::: {.notes}
**Aim**
This slide aims to demonstrate an example of an InvalidSyntax exception in Python.

**Context**
This slide is part of the "Exception Handling" section of the presentation, which follows the introduction to Python concepts and the PyInputPlus module. It precedes slides on other common exception types, such as DivisionByZero and FileNotFound, and leads into the discussion of try-except blocks and handling specific exceptions.
:::

#  Exception Example: InvalidSyntax
![](../assets/Slide2.png)

::: {.notes}
**Aim**
The aim of this slide is to provide an example of an InvalidSyntax exception and demonstrate how it can occur in Python code.

**Context**
This slide is part of a broader section on exception handling in Python. It follows an introduction to exception handling concepts and precedes slides showcasing other common exception types, such as DivisionByZero and FileNotFound. The slide serves to illustrate a specific, real-world scenario where an InvalidSyntax exception may be encountered.
:::

#  Exception Example: InvalidSyntax
![](../assets/Slide3.png)

::: {.notes}
**Aim**
This slide examines a specific exception, InvalidSyntax, to demonstrate how Python handles syntax errors during code execution.

**Context**
This slide is part of the "Exception Handling" section of the presentation, which follows the introduction to Python concepts and the PyInputPlus library. It precedes slides on other exception examples, such as DivisionByZero and FileNotFound, and leads into the discussion of try-except blocks and handling specific exceptions.
:::

#  Exception Example: InvalidSyntax
![](../assets/Slide4.png)

::: {.notes}
**Aim**
The aim of this slide is to demonstrate an example of an InvalidSyntax exception in Python.

**Context**
This slide is part of a series of slides that cover exception handling in Python. It follows a slide that introduces the concept of exceptions and precedes slides that cover other common types of exceptions.
:::

#  Exception Example: InvalidSyntax
![](../assets/Slide5.png)

::: {.notes}
**Aim**
The aim of this slide is to demonstrate an example of an InvalidSyntax exception in Python.

**Context**
This slide is part of the "Exception Handling" section of the presentation, following an introduction to exceptions and preceding examples of other specific exception types, such as DivisionByZero and FileNotFound. The slide is intended to provide a concrete example to help the audience understand the concept of InvalidSyntax exceptions.
:::

#  Exception Example: DivisionByZero
![](../assets/Slide6.png)

::: {.notes}
**Aim**
This slide aims to demonstrate an example of the DivisionByZero exception in Python and how it can be handled.

**Context**
This slide is part of the Exception Handling section of the presentation, following the slide on the InvalidSyntax exception example. It provides another common exception scenario and sets the stage for discussing try-except blocks and handling specific exceptions in the subsequent slides.
:::

#  Exception Example: DivisionByZero
![](../assets/Slide7.png)

::: {.notes}
**Aim**
The purpose of this slide is to provide an example of a DivisionByZero exception and explain how it can occur in Python code.

**Context**
This slide is part of the Exception Handling section of the presentation, which covers various types of exceptions and how to handle them in Python. It follows the slides on InvalidSyntax exceptions and precedes the slides on FileNotFound exceptions.
:::

#  Exception Example: FileNotFound
![](../assets/Slide8.png)

::: {.notes}
**Aim**
The aim of this slide is to provide an example of a FileNotFound exception and demonstrate how it can occur in Python code.

**Context**
This slide is part of the "Exception Handling" section of the presentation, which covers various types of exceptions that can occur in Python programs. It follows the slides on InvalidSyntax and DivisionByZero exceptions and precedes the slides on try-except blocks and handling specific exceptions.
:::

#  Exception Example: FileNotFound
![](../assets/Slide9.png)

::: {.notes}
**Aim**
The aim of this slide is to demonstrate how to handle a FileNotFound exception in Python.

**Context**
This slide is part of a series on exception handling in Python, following examples of InvalidSyntax and DivisionByZero exceptions. It leads into slides on try-except blocks and handling specific exceptions.

**[Bullet Point 1]**

**[Bullet Point 2]**
:::

# Try-except blocks
  ```python
  try:
      # Code that might raise an exception
  except ExceptionType:
      # Handle the exception
  ```

::: {.notes}
**Aim**
This slide aims to introduce try-except blocks as a way to handle exceptions and errors in Python code.

**Context**
The presentation has covered various Python concepts, including an introduction to PyInputPlus and its functions. The previous slides have also discussed exception handling and provided examples of different types of exceptions. This slide on try-except blocks builds upon the concept of exception handling and demonstrates how to use these blocks to handle exceptions gracefully.

**Exception Handling**
Try-except blocks are a fundamental aspect of exception handling in Python. They allow developers to anticipate and handle potential errors or exceptions that may occur during the execution of their code. By using try-except blocks, developers can prevent their programs from crashing abruptly when encountering exceptions, and instead, they can provide alternative paths or error messages to handle the situation gracefully.

**Handling specific exceptions**
Within try-except blocks, developers can specify the types of exceptions they want to handle. This allows for targeted exception handling, where specific actions can be taken based on the type of exception encountered. For example, if a program expects a FileNotFoundError, it can be caught and handled differently than a ZeroDivisionError. By handling specific exceptions, developers can provide more meaningful error messages and take appropriate actions to recover from the error.

**Raising exceptions**
In addition to handling exceptions, Python allows developers to raise exceptions manually using the raise keyword. This is useful when developers want to indicate that a specific condition or error has occurred in their code. By raising exceptions, developers can control the flow of their program and provide custom error messages to help with debugging and error handling.

**Handling PyInputPlus-specific exceptions**
PyInputPlus is a library that provides functions for getting user input with additional validation features. It has its own set of exceptions that can be raised when user input does not meet the specified criteria. When using PyInputPlus functions within a try-except block, developers can catch and handle these specific exceptions, such as TimeoutException or RetryLimitException, to provide appropriate feedback to the user and handle the input validation process effectively.

**Creating robust user input functions**
By combining the concepts of exception handling and PyInputPlus, developers can create robust user input functions that handle various scenarios gracefully. These functions can use try-except blocks to catch and handle exceptions that may occur during user input, such as invalid input types or timeouts. By incorporating exception handling, developers can ensure that their user input functions are resilient and provide a better user experience by handling errors and providing informative feedback to the user.
:::

#  Exception Handling
![](../assets/Slide12.png)

::: {.notes}
**Aim**
The aim of this slide is to introduce exception handling in Python and explain how it is used to handle errors and unexpected situations in code.

**Context**
This slide follows on from the previous slides that introduced basic Python concepts and the PyInputPlus module. It is part of a series of slides that cover various aspects of Python programming, leading up to more advanced topics in AI and machine learning.

**Exceptions**
Python uses special objects called exceptions to manage errors that arise during program execution. When an error occurs, Python creates an exception object that contains information about the error, such as its type and the location in the code where it occurred. The process of creating this object and dealing with the error is called raising an exception.

**Handling Exceptions**
If an exception is not handled by the program, it will terminate abruptly and display an error message. To prevent this, you can write code to handle exceptions gracefully. This is done using the try and except statements in Python. The try block contains the code that might raise an exception, and the except block specifies what to do if an exception occurs.

**Types of Exceptions**
Python has many built-in exceptions that cover a wide range of error conditions, such as ZeroDivisionError, FileNotFoundError, and TypeError. You can also define your own custom exceptions by creating a new exception class. It's important to choose the appropriate exception type to handle specific errors in your code.

**Best Practices**
When handling exceptions, it's best to be as specific as possible. Catch only the exceptions that you can handle meaningfully. Avoid using bare except clauses that catch all exceptions, as this can mask potential bugs in your code. If you need to perform cleanup actions after an exception occurs, use the finally block, which runs regardless of whether an exception was raised or not.
:::

#  Exception Handling
![](../assets/Slide13.png)

::: {.notes}
**Aim**
This slide aims to introduce the concept of exception handling in Python and its importance in creating robust programs.

**Context**
The "Exception Handling" slide is part of the Python Concepts section, following the introduction to PyInputPlus. It sets the foundation for the subsequent slides that provide specific examples of different exceptions and how to handle them using try-except blocks.

**[No bullet points provided]**
Exception handling is a critical aspect of programming in Python. When writing code, it's common to encounter errors or exceptions that can cause the program to crash or behave unexpectedly. Exception handling allows developers to anticipate and handle these errors gracefully, preventing the program from abruptly terminating and providing meaningful feedback to the user. By using try-except blocks, developers can catch and handle specific exceptions, allowing the program to continue running even if an error occurs. This slide will introduce the basic concepts of exception handling and set the stage for more detailed examples in the following slides.
:::

#  Exception Handling
![](../assets/Slide14.png)

::: {.notes}
**Aim**
This slide aims to introduce the concept of exception handling in Python and highlight its importance in creating robust programs.

**Context**
The "Exception Handling" slide follows the introduction of basic Python concepts and the PyInputPlus module. It serves as a foundation for the upcoming slides, which delve into specific exception examples and how to handle them effectively.

**[Bullet Point 1]** Exceptions are events that occur during program execution, disrupting the normal flow of instructions. They typically indicate errors or unexpected situations, such as dividing by zero, accessing a non-existent file, or using an undefined variable. When an exception is raised, it can cause the program to terminate abruptly if not handled properly.

**[Bullet Point 2]** Exception handling is a mechanism in Python that allows you to catch and respond to exceptions gracefully. By using try-except blocks, you can anticipate potential exceptions and provide alternative paths of execution. This helps prevent program crashes and enables you to handle errors in a controlled manner, providing meaningful feedback to users or taking corrective actions.

**[Bullet Point 3]** Proper exception handling is crucial for building reliable and user-friendly programs. It allows you to handle expected and unexpected errors, maintain program stability, and provide informative error messages to users. By anticipating and handling exceptions, you can improve the overall quality and robustness of your code, making it more resilient to various scenarios.

**[Bullet Point 4]** Python provides a rich set of built-in exception classes that cover a wide range of error scenarios. Some common exceptions include ValueError for invalid input, FileNotFoundError for missing files, and ZeroDivisionError for division by zero. You can also define your own custom exception classes to handle specific error cases in your program.

**[Bullet Point 5]** When an exception occurs, Python raises an exception object that contains information about the error, such as the exception type and a traceback. By catching and examining these exception objects, you can gain insights into the nature of the error and take appropriate actions based on the specific exception type. This allows for fine-grained control over error handling.
:::

# Handling specific exceptions
  ```python
  try:
      temperature = float(input("Enter temperature: "))
  except ValueError:
      print("Invalid input. Please enter a number.")
  ```

::: {.notes}
**Aim**
The aim of this slide is to explain how to handle specific exceptions in Python programs.

**Context**
This slide builds on the previous slides which introduced exception handling and provided examples of different types of exceptions. It leads into the next slide on raising exceptions.

**[Bullet Point 1]** Python allows you to catch and handle specific exceptions using multiple except clauses. Each except clause can specify a different exception to catch. This allows you to take different actions depending on the exception that occurred. For example, you might want to print one error message if a FileNotFoundError occurs and another for a ValueError.

**[Bullet Point 2]** When using multiple except clauses, more specific exceptions must be listed before more general ones. For instance, IOError is more general than FileNotFoundError, so the FileNotFoundError except clause must come first in your code. Otherwise, the FileNotFoundError would be caught by the more general IOError except clause, and the specific handling code would never be executed.

**[Bullet Point 3]** You can also combine an except clause with an else clause. Code in the else block will only execute if no exceptions were raised by the code in the try block. This can be useful for code that should run only if no exceptions occurred.

**[Bullet Point 4]** Finally, a try statement can have a finally clause. The code in a finally clause is guaranteed to execute, no matter what exceptions occur. This is useful for clean-up code that should always run, like closing files or database connections. The finally clause will execute after any except clauses (if an exception occurred) or after the else clause (if no exception occurred).
:::

# Raising exceptions
  ```python
  if temperature > 100:
      raise ValueError("Temperature too high!")
  ```

::: {.notes}
**Aim**
The purpose of this slide is to introduce the concept of raising exceptions in Python and explain when it is appropriate to do so.

**Context**
This slide follows on from the previous slides about exception handling, which covered the basics of try-except blocks and handling specific exceptions. It leads into the next slide about handling PyInputPlus-specific exceptions.
:::

# Handling PyInputPlus-specific exceptions
  ```python
  from pyinputplus import RetryLimitException, TimeoutException

  try:
      response = pyip.inputStr(limit=3, timeout=10)
  except RetryLimitException:
      print("You've reached the maximum number of attempts.")
  except TimeoutException:
      print("Input timed out.")
  ```

::: {.notes}
**Aim**
The aim of this slide is to introduce techniques for handling exceptions specific to the PyInputPlus module.

**Context**
This slide follows on from the general exception handling content and focuses on the specifics of PyInputPlus. It precedes a slide on creating robust user input functions, which will likely build upon the concepts covered here.
:::

# Creating robust user input functions
  ```python
  def get_weather_input():
      try:
          city = pyip.inputStr("Enter city name: ")
          temp = pyip.inputFloat("Enter temperature in Celsius: ")
          return city, temp
      except Exception as e:
          print(f"An error occurred: {e}")
          return None, None
  ```

::: {.notes}
**Aim**
The aim of this slide is to provide an overview of how to create user input functions that are robust and can handle various types of input effectively.

**Context**
This slide builds upon the concepts introduced in the previous slides on PyInputPlus and exception handling. It aims to combine these concepts to demonstrate how to create user input functions that are reliable and can handle a wide range of input scenarios.
:::

# Today

1. Summary
2. Introduction to PyInputPlus
2. Basic PyInputPlus Functions
3. Advanced PyInputPlus Features
4. Exception Handling in Python
5. Combining PyInputPlus and Exception Handling

::: {.notes}
**Aim**
To provide an overview of the topics that will be covered in today's presentation on AI and machine learning.

**Context**
This slide serves as an introduction to the presentation, following the Copyright Information and Acknowledgement of Country slides. It sets the stage for the subsequent slides, which will delve into specific aspects of AI and machine learning, such as methodology, Python concepts, and exception handling.
:::



---
title: "Web Scraping in Python: A Weather-Themed Guide for Beginners"
subtitle: "Learning the Basics with `requests`, `BeautifulSoup`, and `pandas`"
author: "Michael Borck"
format: 
  pptx:
    reference-doc: ../../../_assets/template.pptx
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
# Copyright Information

![](../../../_assets/curtin-copy-right.png)



# Acknowledge of Country

I acknowledge the traditional custodians of the land on which I work and live,
and recognise their continuing connection to land, water and community. I pay
respect to elders past, present and emerging.

![](../../../_assets/ack_country.png)



# Today's Overview

- Introduction to Web Scraping
- Ethical Considerations
- Tools and Libraries
- HTML Basics
- Practical Implementation
- Best Practices and Additional Resources



::: {.notes}
**Aim**
The aim of this slide is to provide an overview of the key topics that will be covered in the presentation on web scraping using Python.

**Context**
Following the introductory slides on copyright information and acknowledgement of country, this slide outlines the main sections of the presentation. The subsequent slides will delve into each of these topics in greater detail, providing a comprehensive guide to web scraping using Python.

**Introduction to Web Scraping** This section will define web scraping, explain its purpose, and discuss the various applications of web scraping in different industries. It will also briefly touch on the types of data that can be extracted through web scraping.

**Ethical Considerations** Before diving into the technical aspects of web scraping, it is crucial to address the ethical considerations involved. This section will cover topics such as respecting website terms of service, avoiding excessive requests that may burden servers, and ensuring compliance with data privacy regulations.

**Tools and Libraries** This section will introduce the key tools and libraries used for web scraping in Python, such as requests for making HTTP requests, BeautifulSoup for parsing HTML, and pandas for data manipulation and analysis. It will also mention the need to install these libraries before proceeding with the practical implementation.

**HTML Basics** To effectively scrape data from websites, a basic understanding of HTML is necessary. This section will cover the fundamentals of HTML structure, tags, and attributes, which will be essential for locating and extracting desired data from web pages.

**Practical Implementation** This section will walk through the step-by-step process of web scraping using Python. It will demonstrate how to make HTTP requests, parse HTML using BeautifulSoup, extract specific data such as links and tables, and save the scraped data to a CSV file. Code examples and explanations will be provided to facilitate understanding.

**Best Practices and Additional Resources** The final section will discuss best practices for web scraping, such as rate limiting to avoid overloading servers and handling exceptions gracefully. It will also provide additional resources, including documentation, tutorials, and online communities, for further learning and troubleshooting.
:::

# Introduction to Web Scraping

- Definition: Automatically extracting data from websites
- Common Use Cases: Data gathering, price comparison, weather data aggregation

Example:
```python
import requests

# Simple example of fetching a weather page
url = "https://example.com/weather"
response = requests.get(url)
print(f"Status code: {response.status_code}")
print(f"Content: {response.text[:100]}...")  # Print first 100 characters
```



::: {.notes}
**Aim**
This slide aims to introduce the concept of web scraping, providing a definition and common use cases to set the foundation for the presentation.

**Context**
Following the overview slide, "Introduction to Web Scraping" is the first content slide of the presentation. It serves as a starting point for the audience to grasp the basic concept before delving into ethical considerations, tools, and techniques in the subsequent slides.

**Definition: Automatically extracting data from websites**
Web scraping is the process of automatically collecting data from websites using software or scripts. Instead of manually copying and pasting information, web scraping allows you to extract large amounts of data quickly and efficiently. This data can be text, images, links, or any other structured content available on the web pages.

**Common Use Cases: Data gathering, price comparison, weather data aggregation**
Web scraping has various applications across industries. It is commonly used for gathering data for research, analysis, or business intelligence purposes. For example, companies can scrape competitor websites to compare prices and monitor the market. Another use case is aggregating weather data from multiple sources to provide comprehensive forecasts. Web scraping enables the collection of data that may not be readily available through APIs or other means.
:::

# Ethical Considerations in Web Scraping

- Always check `robots.txt`
- Abide by the website's terms of service
- Avoid overwhelming the server (rate-limiting)
- Consider legal and ethical implications

Example of checking robots.txt:
```python
import requests

def check_robots_txt(url):
    robots_url = f"{url}/robots.txt"
    response = requests.get(robots_url)
    if response.status_code == 200:
        print(f"Robots.txt content:\n{response.text}")
    else:
        print(f"No robots.txt found at {robots_url}")

check_robots_txt("https://curtin.edu.au")
```



::: {.notes}
**Aim**
This slide aims to highlight the key ethical considerations that should be taken into account when performing web scraping to ensure responsible and respectful data collection practices.

**Context**
Having introduced the concept of web scraping and its applications, it is crucial to address the ethical implications before delving into the technical aspects and tools. This slide serves as a bridge between the introduction and the hands-on sections, emphasising the importance of ethical web scraping practices.

**Always check `robots.txt`**
The `robots.txt` file is a standard used by websites to communicate their crawling preferences to web scrapers. It is essential to respect the website's wishes by checking this file before scraping. The file specifies which pages or sections of the website are allowed or disallowed for scraping. Ignoring the `robots.txt` file can be considered unethical and may lead to legal consequences.

**Abide by the website's terms of service**
In addition to `robots.txt`, websites often have terms of service (TOS) or legal disclaimers that outline acceptable usage policies. These terms may explicitly prohibit web scraping or specify conditions under which scraping is permitted. It is crucial to thoroughly review and comply with the website's TOS to avoid violating their guidelines and potentially facing legal repercussions.

**Avoid overwhelming the server (rate-limiting)**
Web scraping can put a significant load on the target website's server, especially if the scraping is aggressive or poorly implemented. To prevent overwhelming the server and disrupting its normal functionality, it is important to incorporate rate-limiting techniques. This involves adding delays between requests, limiting the number of concurrent requests, and being mindful of the website's resources. Respectful web scraping practices help maintain a healthy internet ecosystem.

**Consider legal and ethical implications**
Web scraping can raise legal and ethical concerns, particularly when it involves sensitive or personal data. It is crucial to consider the purpose of scraping and assess whether it aligns with ethical principles. Scraping copyrighted material, personal information, or data protected by privacy laws should be approached with caution. Consulting with legal experts and staying informed about relevant regulations can help navigate potential legal and ethical pitfalls.
:::

# Tools for Web Scraping in Python

- `requests` for making HTTP requests
- `BeautifulSoup` for parsing HTML/XML documents
- `pandas` for data manipulation (especially tables)
- `scrapy` for large scale scraping
- `Selenium` for scraping dynamic content



::: {.notes}
**Aim**
This slide aims to introduce the key Python libraries and tools commonly used for web scraping tasks.

**Context**
Having discussed the ethical considerations in web scraping, we now move on to the practical tools and libraries available in Python for scraping web data. The slide sets the stage for subsequent slides that dive deeper into using these tools for various web scraping tasks.

**`requests` for making HTTP requests** The `requests` library simplifies the process of making HTTP requests to web servers from Python. It abstracts away the low-level details and provides a user-friendly interface for sending GET, POST, and other types of requests. With `requests`, you can easily fetch the HTML content of web pages, which is the first step in web scraping.

**`BeautifulSoup` for parsing HTML/XML documents** Once you have obtained the HTML content using `requests`, you need to parse and extract the desired data from it. `BeautifulSoup` is a powerful library that allows you to parse HTML and XML documents efficiently. It provides intuitive methods to navigate and search the parsed tree, making it convenient to locate and extract specific elements, such as tags, attributes, and text content.

**`pandas` for data manipulation (especially tables)** `pandas` is a data manipulation library that excels at handling structured data, particularly tabular data. In the context of web scraping, `pandas` is particularly useful when dealing with data in HTML tables. It provides functions to read HTML tables directly into `DataFrame` objects, allowing for easy data cleaning, transformation, and analysis using the rich functionalities of `pandas`.

**`scrapy` for large scale scraping** While `requests` and `BeautifulSoup` are great for small to medium-sized scraping tasks, `scrapy` is a framework designed for large-scale web scraping projects. It provides a complete ecosystem for building and managing web spiders, handling requests, parsing responses, and storing scraped data. `scrapy` offers features like concurrent requests, built-in caching, and support for various output formats, making it suitable for more complex and intensive scraping tasks.

**`Selenium` for scraping dynamic content** Some websites heavily rely on JavaScript to dynamically render content on the client-side. In such cases, using `requests` alone may not be sufficient as it cannot execute JavaScript. `Selenium` is a tool that automates web browsers, allowing you to interact with web pages as a user would. It can be used in combination with Python to scrape dynamic content by simulating user actions like clicking buttons, filling forms, and waiting for elements to load.
:::

# Installing the Necessary Libraries

Install the required libraries using pip:

```
pip install requests beautifulsoup4 pandas
```

Consider using a virtual environment for your project.



::: {.notes}
**Aim**
This slide aims to guide participants through the process of installing the required Python libraries for web scraping.

**Context**
Having discussed the ethical considerations and tools for web scraping in Python, this slide will provide practical instructions on setting up the necessary libraries. It acts as a foundation before delving into the technical aspects of web scraping in subsequent slides.
:::

# Understanding URLs

- Breakdown of a URL (scheme, domain, path, query parameters)
- Dynamic vs. Static URLs

Example:
```python
from urllib.parse import urlparse, parse_qs

url = "https://example.com/weather?city=New York&units=metric"
parsed_url = urlparse(url)
query_params = parse_qs(parsed_url.query)

print(f"Scheme: {parsed_url.scheme}")
print(f"Domain: {parsed_url.netloc}")
print(f"Path: {parsed_url.path}")
print(f"Query parameters: {query_params}")
```



::: {.notes}
**Aim**
The aim of this slide is to provide an overview of the structure and components of URLs and to explain the difference between dynamic and static URLs.

**Context**
This slide follows an introduction to web scraping and ethical considerations, and precedes slides on the basics of HTML and making HTTP requests. Understanding URLs is a fundamental concept for web scraping, as it allows us to locate and access specific web pages and resources.

**Breakdown of a URL (scheme, domain, path, query parameters)**
A URL (Uniform Resource Locator) is a standardised address used to locate and access resources on the internet. It consists of several components:
- Scheme: Specifies the protocol used to access the resource, such as HTTP or HTTPS.
- Domain: Identifies the web server hosting the resource, such as example.com.
- Path: Specifies the location of the resource within the website's directory structure, like /page.html.
- Query parameters: Optional key-value pairs appended to the URL after a question mark (?), used to pass data to the server, e.g., ?key1=value1&key2=value2.

**Dynamic vs. Static URLs**
URLs can be classified as either dynamic or static:
- Static URLs have fixed content that remains the same each time the page is accessed. They are typically used for pages that don't require server-side processing or user input.
- Dynamic URLs, on the other hand, generate content on-the-fly based on user input, database queries, or other server-side processes. They often include query parameters and may change each time the page is accessed.
:::

# Basics of HTML

Key HTML Elements: `<div>`, `<span>`, `<a>`, `<table>`, `<tr>`, etc.

Example:
```html
<div id="weather-container">
  <h1>Weather Forecast</h1>
  <table>
    <tr>
      <th>Day</th>
      <th>Temperature</th>
      <th>Condition</th>
    </tr>
    <tr>
      <td>Monday</td>
      <td>25°C</td>
      <td>Sunny</td>
    </tr>
    <!-- More rows... -->
  </table>
</div>
```



::: {.notes}
**Aim**
The aim of this slide is to provide a brief introduction to the basics of HTML.

**Context**
This slide follows on from the "Understanding URLs" slide, which focused on the structure and components of URLs. Understanding HTML is crucial for web scraping, as it forms the structure and content of web pages. The following slides will cover the tools and techniques for web scraping in Python, building on this foundational knowledge of HTML.
:::

# Making an HTTP Request with `requests`

Example:
```python
import requests

url = "https://wttr.in/perth"
response = requests.get(url)

if response.status_code == 200:
    print("Successfully fetched the weather page")
    print(f"Content: {response.text[:200]}...")  # Print first 200 characters
else:
    print(f"Failed to fetch the page. Status code: {response.status_code}")
```



::: {.notes}
**Aim**
To demonstrate how to make an HTTP request using the `requests` library in Python.

**Context**
Having learned about the basics of HTML and URLs, we are now ready to start making HTTP requests to retrieve web pages. This slide focuses on using the `requests` library, which is a popular and user-friendly library for making HTTP requests in Python. The next slide will cover parsing the retrieved HTML using `BeautifulSoup`.
:::

# Parsing HTML with `BeautifulSoup`

Example:
```python
from bs4 import BeautifulSoup

html_content = """
<html>
  <body>
    <h1>Weather Forecast</h1>
    <p class="temperature">25°C</p>
    <p class="condition">Sunny</p>
  </body>
</html>
"""

soup = BeautifulSoup(html_content, 'html.parser')
temperature = soup.find('p', class_='temperature').text
condition = soup.find('p', class_='condition').text

print(f"Temperature: {temperature}")
print(f"Condition: {condition}")
```



::: {.notes}
**Aim**
This slide aims to introduce the BeautifulSoup library and demonstrate how it can be used to parse HTML content.

**Context**
After discussing the basics of HTML and making HTTP requests using the `requests` library, this slide focuses on parsing the retrieved HTML content using BeautifulSoup. The following slides will build upon this foundation, showing how to extract specific elements like links and tables from the parsed HTML.

**Parsing HTML with `BeautifulSoup`** BeautifulSoup is a popular Python library used for parsing HTML and XML documents. It provides a convenient way to extract data from web pages by allowing you to navigate the parsed tree structure using various methods and selectors. BeautifulSoup can handle imperfect or messy HTML and still extract the desired information effectively. To use BeautifulSoup, you first create a BeautifulSoup object by passing the HTML content and the parser to be used (e.g., 'html.parser'). Once the object is created, you can use methods like `find()`, `find_all()`, and CSS selectors to locate specific elements within the parsed HTML tree. BeautifulSoup's intuitive API makes it easy to extract text, attributes, and navigate between different elements in the document.
:::

# Extracting All Links from a Webpage

Example:
```python
import requests
from bs4 import BeautifulSoup

url = "https://curtin.edu.au"
response = requests.get(url)
soup = BeautifulSoup(response.text, 'html.parser')

for link in soup.find_all('a'):
    href = link.get('href')
    text = link.text
    print(f"Link: {text} -> {href}")
```



::: {.notes}
**Aim**
The aim of this slide is to demonstrate how to extract all hyperlinks from a webpage using Python and BeautifulSoup.

**Context**
After learning about making HTTP requests with `requests` and parsing HTML with `BeautifulSoup`, this slide builds on that knowledge to show a practical application. It leads into the next slides on extracting tables from webpages using `BeautifulSoup` and `pandas`.

**Bullet Point 1** To extract all links from a webpage, first make an HTTP request to the desired URL using the `requests` library. This will return the HTML content of the page.

**Bullet Point 2** Next, create a `BeautifulSoup` object by passing the HTML content and the parser type (e.g., 'html.parser') to the `BeautifulSoup` constructor. This allows you to parse and navigate the HTML structure.

**Bullet Point 3** Use the `find_all()` method of the `BeautifulSoup` object to locate all the `<a>` tags in the HTML, as these tags represent hyperlinks. You can pass the tag name 'a' as an argument to `find_all()`.

**Bullet Point 4** Iterate over the resulting list of `<a>` tags. For each tag, access the 'href' attribute using square bracket notation (e.g., `link['href']`). This attribute contains the URL of the hyperlink.

**Bullet Point 5** Append each extracted URL to a list to store all the links found on the webpage. You can then use this list for further analysis or processing as needed.

**Bullet Point 6** Remember to handle any relative URLs by joining them with the base URL of the webpage to create absolute URLs. You can use the `urljoin()` function from the `urllib.parse` module for this purpose.
:::

# Extracting Tables with `BeautifulSoup`

Example:
```python
html_content = """
<table id="weather-forecast">
  <tr>
    <th>Day</th>
    <th>Temperature</th>
    <th>Condition</th>
  </tr>
  <tr>
    <td>Monday</td>
    <td>25°C</td>
    <td>Sunny</td>
  </tr>
  <tr>
    <td>Tuesday</td>
    <td>22°C</td>
    <td>Cloudy</td>
  </tr>
</table>
"""

soup = BeautifulSoup(html_content, 'html.parser')
table = soup.find('table', id='weather-forecast')

for row in table.find_all('tr')[1:]:  # Skip header row
    columns = row.find_all('td')
    day = columns[0].text
    temp = columns[1].text
    condition = columns[2].text
    print(f"{day}: {temp}, {condition}")
```



::: {.notes}
**Aim**
This slide aims to demonstrate how to extract tables from webpages using the `BeautifulSoup` library in Python.

**Context**
After covering the basics of HTML parsing with `BeautifulSoup`, this slide focuses on a specific use case: extracting tabular data. The following slide will explore an alternative approach using the `pandas` library, and subsequent slides will cover saving the extracted data and ethical considerations in web scraping.
:::

# Using `pandas` to Extract Tables

Example:
```python
import pandas as pd

url = "https://en.wikipedia.org/wiki/Global_surface_temperature#Global_temperature_record"
tables = pd.read_html(url)
weather_df = tables[0]  # Assuming the weather table is the first table on the page
print(weather_df.head())
```



::: {.notes}
**Aim**
The aim of this slide is to demonstrate how to use the `pandas` library to extract tables from web pages.

**Context**
This slide follows on from the previous slide about extracting tables using `BeautifulSoup`. It provides an alternative approach using the `pandas` library, which can simplify the process of extracting tabular data from HTML. The next slide will cover saving the extracted data to a CSV file.
:::

# Saving Data to a CSV File

Example:
```python
# Assuming we have a cleaned DataFrame 'weather_df'
weather_df.to_csv('weather_data.csv', index=False)
print("Data saved to weather_data.csv")
```



::: {.notes}
**Aim**
The purpose of this slide is to demonstrate how to save the data extracted from web scraping to a CSV file for further analysis or use.

**Context**
After learning how to extract data from webpages using `requests`, `BeautifulSoup`, and `pandas`, the next logical step is to save this data in a format that can be easily accessed and manipulated later. This slide will show how to save the scraped data to a CSV file, which is a common and versatile format for storing tabular data. The following slides will cover topics such as rate limiting and advanced web scraping techniques.
:::

# Rate Limiting: Being a Good Web Citizen

- Importance: Avoid overwhelming servers and getting blocked
- Simple implementation: Add delays between requests

Example:
```python
import time
import requests

def fetch_with_delay(url, delay=1):
    response = requests.get(url)
    print(f"Fetched {url}: Status {response.status_code}")
    time.sleep(delay)  # Wait for 1 second before next request
    return response

# Usage
urls = ["https://example.com/weather/day1", "https://example.com/weather/day2"]
for url in urls:
    fetch_with_delay(url)
```



::: {.notes}
**Aim**
The aim of this slide is to emphasise the importance of rate limiting when web scraping and provide guidance on how to implement it.

**Context**
This slide follows on from the discussion of ethical considerations in web scraping and the technical details of making HTTP requests and parsing HTML. It serves as a bridge to the more advanced topics that will be covered later in the presentation.

**Importance: Avoid overwhelming servers and getting blocked**
Rate limiting is crucial when web scraping to avoid placing excessive load on the servers you are scraping. Sending too many requests in a short period can overwhelm the server, potentially causing it to slow down or even crash. Moreover, many websites have mechanisms in place to detect and block suspicious activity, such as scraping without rate limiting. Ignoring rate limits can lead to your IP address being blocked, preventing further access to the site.

**Simple implementation: Add delays between requests**
One straightforward way to implement rate limiting is to add delays between your requests. After making a request and processing the response, your scraper should pause for a set amount of time before sending the next request. This delay helps mimic human browsing behaviour and reduces the burden on the server. The length of the delay can be adjusted based on the specific website's terms of service and the volume of data you need to scrape.
:::

# Advanced Topics

- `Scrapy` for large-scale scraping projects
- `Selinumn` for dynamic content
- Use of header (mimic a browser)
- Handling CAPTCHAs and IP Blocks
- APIs as an alternative to scraping (e.g., OpenWeatherMap API)
- Deep dive into robots.txt and terms of service
- Understanding and respecting website policies



::: {.notes}
**Aim**
This slide aims to introduce advanced topics in web scraping that go beyond the basics covered in previous slides.

**Context**
Having covered the fundamentals of web scraping, including tools, HTML parsing, and basic data extraction, this slide delves into more complex aspects of web scraping. It explores techniques for handling dynamic content, large-scale projects, and challenging scenarios like CAPTCHAs. The slide also discusses the importance of respecting website policies and suggests APIs as an alternative to scraping.

**Scrapy for large-scale scraping projects**
Scrapy is a powerful and popular Python framework designed for large-scale web scraping projects. It provides a high level of customisation and flexibility, allowing you to efficiently crawl and extract data from multiple pages and websites. Scrapy handles tasks such as request scheduling, parallel processing, and data pipeline management, making it an excellent choice for complex scraping tasks.

**Selenium for dynamic content**
Some websites heavily rely on JavaScript to render content dynamically, making it difficult to scrape using traditional methods. Selenium is a tool that automates web browsers, allowing you to interact with dynamic web pages as if you were a human user. With Selenium, you can load and navigate through dynamic content, click buttons, fill forms, and extract data that may not be immediately available in the HTML source code.

**Use of headers (mimic a browser)**
When sending HTTP requests to a website, it's sometimes necessary to mimic the behaviour of a browser to avoid being detected as a scraper. One way to achieve this is by setting appropriate headers in your requests. Headers such as "User-Agent", "Referer", and "Accept-Language" can be customised to resemble those sent by popular browsers, making your requests appear more legitimate to the target website.

**Handling CAPTCHAs and IP blocks**
Websites may employ various measures to prevent automated scraping, such as CAPTCHAs and IP blocking. CAPTCHAs are designed to distinguish human users from bots by presenting challenges that are difficult for computers to solve. To handle CAPTCHAs, you may need to use specialised libraries or services that can solve them automatically. IP blocking occurs when a website detects suspicious activity from an IP address and blocks it. To mitigate this, you can implement techniques like rotating IP addresses, using proxies, or introducing delays between requests.

**APIs as an alternative to scraping (e.g., OpenWeatherMap API)**
In some cases, websites offer APIs (Application Programming Interfaces) that provide structured access to their data. Using APIs can be a more reliable and efficient alternative to web scraping. APIs often have well-defined endpoints, authentication mechanisms, and documentation, making it easier to retrieve data in a structured format. For example, the OpenWeatherMap API allows you to access weather data for various locations without the need for scraping.

**Deep dive into robots.txt and terms of service**
Before scraping a website, it's crucial to familiarise yourself with its robots.txt file and terms of service. The robots.txt file is a standard used by websites to communicate their crawling policies to web robots. It specifies which pages or sections of the website are allowed or disallowed for scraping. The terms of service outline the legal guidelines and restrictions set by the website owner regarding the use of their content. Violating these guidelines can lead to legal consequences.

**Understanding and respecting website policies**
Web scraping should be conducted in an ethical and respectful manner. It's essential to understand and adhere to the website's policies regarding scraping. Some websites may explicitly prohibit scraping or have specific requirements for accessing their content. Respectful web scraping involves limiting the frequency of requests to avoid overloading the website's servers, properly identifying your scraper, and complying with any stated terms of service. Building a good reputation as a responsible scraper is important for long-term success in web scraping projects.
:::

# Conclusion

- Recap: Web scraping workflow, tools, and ethical practices
- Remember to always scrape responsibly
- Practice and explore different websites to improve your skills

Any questions?

::: {.notes}
**Aim**
The aim of this slide is to summarise the key points covered throughout the presentation and reinforce the importance of responsible web scraping practices.

**Context**
This final slide follows on from the "Advanced Topics" section and brings together all the concepts, tools, and techniques discussed in the presentation. It serves as a reminder of the main takeaways and encourages the audience to apply their newfound knowledge in a responsible and ethical manner.

**Recap: Web scraping workflow, tools, and ethical practices**
Throughout this presentation, we have covered the essential components of web scraping, including the basic workflow, the tools available in Python, such as `requests` and `BeautifulSoup`, and the ethical considerations one must keep in mind when scraping websites. By understanding the fundamentals of web scraping and the importance of adhering to ethical guidelines, you can effectively extract valuable data while respecting the rights of website owners and the integrity of the web.

**Remember to always scrape responsibly**
As emphasised in the "Ethical Considerations in Web Scraping" section, it is crucial to scrape responsibly and respect the terms of service, robots.txt files, and other guidelines set by website owners. Avoid overloading servers with excessive requests, cache data when possible, and be mindful of the impact your scraping activities may have on the target website. By being a responsible web scraper, you can maintain a positive relationship with website owners and ensure the sustainability of web scraping as a valuable data gathering technique.

**Practice and explore different websites to improve your skills**
To become proficient in web scraping, it is essential to practice and apply the concepts learned in this presentation to a variety of websites. Start with simple, static websites and gradually move on to more complex, dynamic ones. Experiment with different libraries and techniques, such as handling pagination, interacting with APIs, and scraping data from JavaScript-rendered pages. By exploring diverse websites and challenging yourself with new scraping scenarios, you will develop a strong foundation in web scraping and be well-equipped to tackle real-world data extraction tasks.
:::





Based on your 12-module course schedule and the concept of micro-lessons, here's a suggested series of micro-lessons for each week. I've aimed for 8 micro-lessons per week, which should provide a good balance between comprehensive coverage and manageable workload for students.

Week 1: Overview and Setup
1. Python: The Absolute Minimum You Need to Know
2. How to run python (idle, jupyter notebook, python script)
3. Google Colab: Your Cloud Python Environment
4. Running Your First Python Program
5. Saving Your Colab Notebooks with GitHub
6. Variables: The Absolute Minimum You Need to Know
7. Basic Data Types in Python
8. Print Statements: Outputting Information
9. Input Function: Getting User Data

Week 2: Python Basics
1. Arithmetic Operators in Python
2. String Manipulation: The Basics
3. Type Conversion in Python
4. Conditional Statements: if, elif, else
5. Comparison Operators
6. Logical Operators: and, or, not
7. Basic Error Handling: try and except
8. Writing Clean, Readable Code

Week 3: Control Structures
1. While Loops: The Absolute Minimum You Need to Know
2. For Loops: Iterating Through Sequences
3. Break and Continue Statements
4. Nested Loops: Loops Within Loops
5. List Comprehensions: Concise Loop Alternatives
6. The range() Function
7. Iterating Over Dictionaries
8. Control Flow: Putting It All Together

Week 4: Data Structures
1. Lists: The Absolute Minimum You Need to Know
2. Tuples: Immutable Sequences
3. Dictionaries: Key-Value Pairs
4. Sets: Unique, Unordered Collections
5. List Methods: Modifying Lists
6. Dictionary Methods: Working with Key-Value Pairs
7. Nested Data Structures
8. Choosing the Right Data Structure

Week 5: Functions and Modules
1. Defining Functions: The Basics
2. Function Parameters and Arguments
3. Return Statements in Functions
4. Default and Keyword Arguments
5. Variable Scope in Functions
6. Lambda Functions: One-Line Functions
7. Importing Modules in Python
8. Creating Your Own Modules

Week 6: Data Visualization
1. Introduction to Matplotlib
2. Creating Basic Plots with Matplotlib
3. Customizing Plot Appearance
4. Multiple Plots in One Figure
5. Introduction to Seaborn
6. Statistical Data Visualization with Seaborn
7. Interactive Plots with Plotly
8. Choosing the Right Chart Type

Week 8: Web Scraping
1. HTML Basics for Web Scraping
2. Introduction to BeautifulSoup
3. Extracting Data from HTML
4. Navigating HTML Trees
5. Handling Dynamic Websites
6. Web Scraping Ethics and Best Practices
7. Storing Scraped Data
8. Error Handling in Web Scraping

Week 9: API Usage
1. Understanding APIs: The Basics
2. Making HTTP Requests with Python
3. Parsing JSON Data
4. Authentication in APIs
5. Rate Limiting and API Etiquette
6. Error Handling in API Requests
7. Storing API Data
8. Working with Different API Types

Week 10: Script Development
1. Command-Line Arguments in Python
2. File I/O: Reading and Writing Files
3. Working with CSV Files
4. JSON File Handling
5. Logging in Python
6. Config Files: Managing Settings
7. Creating Executable Scripts
8. Best Practices in Script Development

Week 11: Graphical User Interfaces
1. Introduction to Tkinter
2. Creating Windows and Frames
3. Tkinter Widgets: Buttons and Labels
4. Entry Fields and Text Boxes
5. Dropdown Menus and Checkboxes
6. Layouts and Geometry Management
7. Event Handling in GUIs
8. Creating Responsive GUIs

Week 12: Testing Techniques
1. Introduction to Unit Testing
2. Writing Your First Unit Test
3. Test-Driven Development Basics
4. Mocking in Python Tests
5. Integration Testing: The Basics
6. Performance Testing Your Code
7. Code Coverage and Its Importance
8. Continuous Integration for Python Projects

Week 13: Review and Future Directions
1. Code Refactoring Techniques
2. Optimizing Python Code
3. Introduction to Object-Oriented Programming
4. Version Control with Git
5. Python for Data Science: An Overview
6. Machine Learning with Python: A Glimpse
7. Web Development with Python: Possibilities
8. Building Your Programming Portfolio

This structure provides a comprehensive coverage of the course topics through micro-lessons, allowing students to focus on specific concepts while building towards a complete understanding of Python programming and its applications in weather data analysis.

Citations:
[1] https://www.reddit.com/r/learnpython/comments/11kcko1/best_way_to_learn_python/
[2] https://www.udemy.com/course/micro-learning-python-basic-course-with-practice-30-days/
[3] https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3724377/
[4] https://www.artsycourseexperts.com/microlearning-teaching-one-small-thing/

# Pairing Up with AI

Pair programming is when two people work together on the same code. AI can act
as a virtual partner in this process, offering several benefits:

1. **Continuous Support:** AI can work alongside you, providing ongoing feedback
   and suggestions to ensure your code is of high quality.
2. **Knowledge Sharing:** AI can share useful tips and insights, helping you
   learn new coding techniques and best practices.
3. **Problem Solving:** AI can help you solve complex problems by suggesting
   solutions and identifying potential issues.
4. **Boosting Productivity:** Pairing up with AI can make you more efficient and
   productive, as it handles routine tasks while you focus on the important
   parts of coding.


# Getting Rid of Boring Tasks

Coding often involves repetitive and tedious tasks that can be boring and
time-consuming. AI can handle these tasks for you, allowing you to focus on the
fun and creative parts of coding. Here are some examples of how AI can help:

1. **Formatting Code:** AI can automatically arrange your code neatly according to standard rules, so you don't have to worry about it.
2. **Improving Code Structure:** AI can suggest ways to reorganize your code to make it cleaner and easier to understand without changing what it does.
3. **Testing:** AI can create and run tests on your code to find mistakes and suggest fixes, saving you time and effort.
4. **Writing Documentation:** AI can help write explanations and comments for your code, making it easier for others (and your future self) to understand.

By taking over these tasks, AI not only saves time but also helps reduce mistakes, leading to more efficient and reliable coding.


Here's a micro-lesson on "Enhance Learning: The Absolute Minimum You Need to Know":

Enhancing learning in programming involves creating an environment that fosters engagement, creativity, and exploration. Here's what you need to know:

1. **Engage Learners**
   - Use interactive coding exercises
   - Implement gamification elements
   - Provide real-world, relevant examples
   - Encourage peer-to-peer discussions

2. **Suggest Alternatives**
   - Present multiple solutions to problems
   - Introduce various coding styles and approaches
   - Discuss trade-offs between different methods
   - Encourage critical thinking about code choices

3. **Inspire Innovation**
   - Introduce cutting-edge technologies and concepts
   - Showcase innovative projects and applications
   - Encourage learners to brainstorm novel ideas
   - Host coding challenges or hackathons

4. **Encourage Exploration**
   - Provide resources for self-directed learning
   - Set open-ended projects with minimal constraints
   - Introduce debugging as a learning opportunity
   - Promote experimentation with new libraries or tools

5. **Foster a Growth Mindset**
   - Emphasize learning from mistakes
   - Celebrate effort and progress, not just results
   - Encourage asking questions and seeking help
   - Highlight the ongoing nature of learning in tech

Remember, effective learning in programming is not just about memorizing syntax or following rigid rules. It's about developing problem-solving skills, fostering creativity, and building the confidence to tackle new challenges. By creating an environment that engages learners, suggests alternatives, inspires innovation, and encourages exploration, you can significantly enhance the learning experience and prepare learners for real-world programming scenarios.

Pro Tip: Regularly seek feedback from learners and adapt your teaching methods accordingly. What works for one group might not work for another, so flexibility and responsiveness are key to enhancing the learning experience.



Based on the information provided and best practices for educational content, presenting this micro lesson in multiple formats would be most effective. Here's a recommendation for how to approach this:

1. Jupyter Notebook:
Present the lesson in a Jupyter Notebook, which allows for an interactive, hands-on experience. This aligns with the principle that "writing code is the best way to learn how to code" [1]. The notebook can include:

• Explanatory text about the `print()` function
• Code cells with examples
• Interactive exercises for students to try

2. Short Video (2-3 minutes):
Create a brief video demonstration that complements the Jupyter Notebook [5][6]. The video should:

• Show the instructor typing and running the `print("Hello, World!")` code
• Include enthusiastic narration explaining the concept
• Use on-screen annotations to highlight key points
• End with a call-to-action for students to try it themselves

3. Text-based Lesson:
Provide a concise, written version of the lesson for students who prefer reading or need a quick reference.

By offering these three formats, you cater to different learning styles and reinforce the concept through multiple channels. This approach allows students to:

• Read the concept (text-based lesson)
• See and hear it explained (video)
• Practice it hands-on (Jupyter Notebook)

For the follow-up exercises, incorporate them into the Jupyter Notebook as additional cells where students can experiment with variations like:

• Printing a single character
• Creating a weather-related greeting
• Personalizing the output with their name

This multi-modal approach adheres to best practices for educational videos [5][6] while leveraging the interactive capabilities of Jupyter Notebooks [2][3]. It also sets the stage for more complex concepts as students progress towards building their weather dashboard over the 12-week course.




## Python Variables: A Micro Lesson

In Python, variables are like containers that hold information. Let's explore how they work:

**Basic Concept:**
```python
favorite_color = "blue"
print(favorite_color)
```
This code creates a variable `favorite_color` and assigns it the value "blue". When we print the variable, Python displays: `blue`

**Key Points:**
• Variables store data for later use in your program.
• You can name variables almost anything, but choose names that make sense.
• Variable names can't contain spaces or start with numbers.

**Changing Values:**
Variables can be updated:
```python
age = 25
print(age)  # Outputs: 25
age = 26
print(age)  # Now outputs: 26
```

**Variables vs. Strings:**
• Variables are not enclosed in quotes: `name = "Alice"`
• Strings (text) are always in quotes: `"Hello, World!"`

**Using Variables in print():**
```python
greeting = "Welcome to Python!"
print(greeting)
```
This displays: `Welcome to Python!`

**Remember:**
• Python doesn't care about variable names, but clear names help you and others understand your code.
• Follow naming conventions: use lowercase with underscores for readability.

Practice creating and using variables to reinforce these concepts!

Citations:
[1] https://pythonnumericalmethods.berkeley.edu/notebooks/chapter02.01-Variables-and-Assignment.html
[2] https://geo-python.github.io/site/notebooks/L1/gcp-1-variable-naming.html
[3] https://www.freecodecamp.org/news/python-print-variable-how-to-print-a-string-and-variable/
[4] https://cs.stanford.edu/people/nick/py/python-var.html
[5] https://stackoverflow.com/questions/159720/what-is-the-naming-convention-in-python-for-variables-and-functions

# Helping with Coding Rules

When you're writing code, there are certain rules and best practices you should follow to make sure your code works well and is easy to read. AI can help you with these rules in several ways:

1. **Finding Mistakes:** AI can quickly spot errors and typos in your code, giving you instant feedback so you can fix them right away.
2. **Suggesting Improvements:** AI can offer tips on how to write better code, making it more efficient and easier to understand.
3. **Learning Your Style:** AI can adapt to your way of coding and offer suggestions that fit your style, making the feedback more relevant and useful.
4. **Integrating with Coding Tools:** AI can be built into the tools you use for coding, providing real-time help and suggestions as you write your code.


---
title: "HOw to Use Micro lessons"
format: 
  pdf:
      toc: false
      colorlinks: true
    docx:
      toc: false
      highlight-style: github
    html:
      toc: true
      toc-expand: 2
      embed-resources: true
--- 

Study each lesson for 5-10 minutes, then immediately practice with the online exercises for 10-15 minutes, followed by a break to enhance retention.

Use a physical keyboard for coding exercises, as mobile devices are not suitable for learning to code effectively.

Follow the precise formatting and syntax instructions, even if they seem overly strict, as this helps develop attention to detail crucial for coding.

Commit to short, focused 15-25 minute study sessions to master Python fundamentals, rather than attempting to absorb large amounts of information at once.

This learning method combines reading with interactive online exercises, promising faster learning and longer retention of Python concepts.

Immediate practice after reading embeds knowledge in long-term memory, with instant feedback correcting mistakes like a one-on-one teacher.

The approach keeps you engaged and motivated, making the learning process more interesting and less boring.

Read-then-practice ensures true understanding and retention, avoiding the self-deception often associated with passive reading or highlighting.

This method builds a solid foundation of Python knowledge, preparing learners for more advanced concepts in later chapters.

# Using AI as a Tutor

AI can also be a great tutor, helping you learn to code in a personalized and interactive way:

1. **Customized Learning:** AI can identify your strengths and weaknesses and
   create a learning path that focuses on what you need to improve.
2. **Instant Help:** AI-powered assistants can provide real-time answers to your
   questions, helping you understand coding concepts and solve problems on the
   spot.
3. **Contextual Assistance:** AI can offer relevant explanations and examples
   based on the code you're working on, making it easier to learn new things.
4. **Feedback and Review:** AI can review your code and provide constructive
   feedback, helping you learn from your mistakes and improve your coding
   skills.


