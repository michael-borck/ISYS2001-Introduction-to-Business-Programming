---
title: "Weather Adventures in Python Land"
subtitle: "Python Essentials"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## Part 1: Basic Concepts in Pseudocode

1. Write pseudocode for a program that suggests what to wear based on the temperature. If it's above 25°C, suggest light clothing. If it's between 15°C and 25°C, suggest a light jacket. If it's below 15°C, suggest warm clothing.

2. Create pseudocode for a program that checks if it's a good day for a picnic. It's a good day if it's not raining AND the temperature is between 20°C and 30°C.

3. Write pseudocode for a program that counts the number of rainy days in a week. Use a loop to check each day's weather condition.

4. Create pseudocode for a program that calculates the average temperature for a 5-day period. Use a loop to input temperatures and calculate the average.

5. Write pseudocode for a program that issues a heat wave warning. A heat wave is when the temperature is above 35°C for three consecutive days. Use a loop and counting mechanism.

## Part 2: Structuring English Descriptions into Pseudocode

6. Read the following paragraph and structure it into pseudocode:

   "A weather station needs to monitor air quality. It measures the Air Quality Index (AQI) every hour. If the AQI is above 150, it should trigger an alert. The station should continue monitoring until it has recorded 24 readings or until an alert has been triggered, whichever comes first."

7. Convert this weather forecasting process into pseudocode:

   "To predict tomorrow's weather, we look at today's temperature, humidity, and wind speed. If today's temperature is higher than yesterday's and the humidity is increasing, we predict a higher chance of rain. If the wind speed is also increasing, we predict stormy weather. Otherwise, if temperature and humidity are stable, we predict similar weather to today. We continue this process for a 7-day forecast."

8. Transform this severe weather alert system into pseudocode:

   "A severe weather alert system monitors temperature, wind speed, and precipitation. It issues different levels of alerts based on combinations of these factors. A 'Yellow Alert' is issued if any two of the following conditions are met: temperature above 35°C, wind speed above 60 km/h, or precipitation above 30 mm/hour. An 'Orange Alert' is issued if all three conditions are met. A 'Red Alert' is issued if any of the conditions are: temperature above 40°C, wind speed above 100 km/h, or precipitation above 50 mm/hour. The system checks conditions every 30 minutes and maintains the highest level alert until conditions improve."

## Part 3: Reflection and Analysis

9. Look back at your pseudocode for questions 6-8. Identify which parts were the most challenging to structure logically. Why do you think these were difficult?

10. For one of the complex scenarios (questions 6-8), list three questions you would ask a GenAI tutor to help you refine or improve your pseudocode solution.

11. Choose one of your pseudocode solutions and describe how you would extend it to handle more complex scenarios or additional weather factors.



---
title: "STAFF ANSWER: Data visualisation with Python and Pandas"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

### Tasks

#### Task 1: Load the Dataset

**Note 1: Assume the students has downloaded from unit's blackboard site and upload csv file to Google Colab virtual machine**

**Note 2: This is CRITICAL for all questions, assuming it has been uploaded to Google Colab virtual machine, in the file tab, right click on file and select 'copy path', and can use this as the 'filename' name path in the *pd.read_csv('path_to_weather_data.csv')* below**

1. Load the weather dataset into a Pandas DataFrame.
   - Use the `pd.read_csv()` function to read the CSV file.
   - Display the first 5 rows of the DataFrame using the `.head()` method.

   **Questions:**
   - What are the column names in your dataset?
   - How many rows and columns does the dataset have?

   **Code Example:**
   ```python
   import pandas as pd

   # Load the dataset, assume in same folder as script
   df = pd.read_csv('mock_weather_data_seasonal.csv')

   # Display the first 5 rows
   print(df.head())
   ```

#### Task 2: Line Plot for Temperature Trends
2. Generate a line plot to visualize temperature trends over time.
   - Use the `plt.plot()` function from Matplotlib to plot the data.
   - Set appropriate labels for the x-axis (e.g., date) and y-axis (temperature).
   - Include a title for your plot.

   **Questions:**
   - What trends do you observe in the temperature over time?
   - Are there any noticeable patterns or anomalies?

   **Code Example:**
   ```python
   import matplotlib.pyplot as plt

   # Line plot for temperature trends
   plt.figure(figsize=(10, 5))
   plt.plot(df['Date'], df['Temperature'], label='Temperature', color='blue')
   plt.xlabel('Date')
   plt.ylabel('Temperature (°C)')
   plt.title('Temperature Trends Over Time')
   plt.xticks(rotation=45)
   plt.legend()
   plt.show()
   ```

#### Task 3: Scatter Plot for Temperature vs. Humidity
3. Create a scatter plot to explore the relationship between temperature and humidity.
   - Use the `plt.scatter()` function from Matplotlib.
   - Set labels for the axes and include a title.

   **Questions:**
   - Describe the relationship between temperature and humidity. Is there a correlation?
   - How would you describe the strength and direction of this relationship?

   **Code Example:**
   ```python
   # Scatter plot for Temperature vs. Humidity
   plt.figure(figsize=(8, 5))
   plt.scatter(df['Temperature'], df['Humidity'], color='green')
   plt.xlabel('Temperature (°C)')
   plt.ylabel('Humidity (%)')
   plt.title('Temperature vs. Humidity')
   plt.show()
   ```

#### Task 4: Bar Plot for Monthly Precipitation
4. Design a bar plot to compare monthly precipitation levels.
   - Group the data by month and calculate the total precipitation for each month.
   - Use the `plt.bar()` function to create the bar plot.
   - Set labels and a title.

   **Questions:**
   - Which month has the highest total precipitation?
   - Are there any months with significantly lower or higher precipitation levels?

   **Code Example:**
   ```python
   # Converting date column to datetime format and extracting the month
   df['Date'] = pd.to_datetime(df['Date'])
   df['Month'] = df['Date'].dt.month

   # Grouping by month and summing up precipitation
   monthly_precipitation = df.groupby('Month')['Precipitation'].sum()

   # Bar plot for Monthly Precipitation
   plt.figure(figsize=(10, 5))
   plt.bar(monthly_precipitation.index, monthly_precipitation.values, color='skyblue')
   plt.xlabel('Month')
   plt.ylabel('Total Precipitation (mm)')
   plt.title('Monthly Precipitation Levels')
   plt.xticks(ticks=range(1, 13), labels=['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])
   plt.show()
   ```

#### Task 5: Multi-Panel Figure with Subplots
5. Combine the line plot, scatter plot, and bar plot into a multi-panel figure using subplots.
   - Use the `plt.subplots()` function to create a multi-panel layout.
   - Arrange the plots for easy comparison and analysis.

   **Questions:**
   - How do the different visualizations complement each other?
   - What insights can you draw by comparing these visualizations side by side?

   **Code Example:**
   ```python
   # Creating subplots
   fig, axs = plt.subplots(2, 2, figsize=(15, 10))

   # Line plot in the first subplot
   axs[0, 0].plot(df['Date'], df['Temperature'], color='blue')
   axs[0, 0].set_title('Temperature Trends Over Time')
   axs[0, 0].set_xlabel('Date')
   axs[0, 0].set_ylabel('Temperature (°C)')

   # Scatter plot in the second subplot
   axs[0, 1].scatter(df['Temperature'], df['Humidity'], color='green')
   axs[0, 1].set_title('Temperature vs. Humidity')
   axs[0, 1].set_xlabel('Temperature (°C)')
   axs[0, 1].set_ylabel('Humidity (%)')

   # Bar plot in the third subplot
   axs[1, 0].bar(monthly_precipitation.index, monthly_precipitation.values, color='skyblue')
   axs[1, 0].set_title('Monthly Precipitation Levels')
   axs[1, 0].set_xlabel('Month')
   axs[1, 0].set_ylabel('Total Precipitation (mm)')

   # Hide the fourth subplot (empty)
   axs[1, 1].axis('off')

   # Adjust layout
   plt.tight_layout()
   plt.show()
   ```



---
title: "STAFF ANSWER: Python Functions Worksheet"
subtitle: "Python Essentials"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

This worksheet is designed to introduce students to Python functions within the
context of weather data analysis. It covers key concepts including function
definition, use of built-in functions, creation of custom functions, and
introduction to NumPy for more advanced data manipulation.

## Key learning objectives:

- Understanding and implementing Python functions
- Applying built-in Python functions to real-world data
- Creating custom functions for specific tasks
- Using NumPy for efficient data manipulation and analysis
- Critically thinking about how to use AI tools in the learning process

## Worksheet structure:

The worksheet is structured to progressively build skills:

- It starts with guidance on using AI tools responsibly, encouraging students to
  think critically and use AI as a learning aid rather than a solution provider.
- Basic function concepts are introduced, allowing students to explain functions
  in their own words and understand the syntax.
- Built-in functions are explored using weather data, introducing practical
  applications.
- Students then create custom weather-related functions, applying their
  understanding to solve specific problems.
- NumPy is introduced for more advanced data manipulation, showing how libraries
  can enhance data analysis capabilities.
- The conclusion and additional exercises encourage reflection and provide
  opportunities for further exploration.

## Expected outcomes:

- Students should be able to define and use functions in Python.
- They should understand how to manipulate lists using built-in functions.
- Students should be able to create custom functions for specific tasks related
  to weather data.
- They should have a basic understanding of NumPy and its capabilities for data
  analysis.
- Students should develop critical thinking skills about using AI in their
  learning process.

## Areas of Student Difficulty:

Potential areas for student difficulty:

- Understanding the concept of functions and their syntax
- Translating mathematical formulas into Python code (e.g., Celsius to
  Fahrenheit conversion)
- Grasping the more complex concepts in NumPy

Instructors should be prepared to provide additional explanation and examples
for these areas. Encouraging pair programming or group discussions can also help
students work through challenging concepts.

The optional exercises provide opportunities for more advanced students to
explore further or for assignment extensions. They introduce more complex
calculations (heat index) and additional libraries (pandas and matplotlib),
which can serve as a bridge to more advanced data analysis topics.

## 1. GenAI Exercise

Question 1: Think of a weather-related programming task you're unsure how to approach. Write a strategic question you could ask an AI assistant to help you learn without directly solving the problem for you.

Answer: A good strategic question could be: "What are the key steps and considerations I should keep in mind when designing a function to calculate the 'feels like' temperature based on actual temperature and wind speed? Can you explain the general approach without providing the actual code?"

## 2. Introduction to Functions

Question 2: Explain in your own words what a function is in Python and why we use them.

Answer: A function in Python is a reusable block of code that performs a specific task. We use functions to:
1. Organise code into manageable, logical units
2. Avoid repetition by allowing code reuse
3. Make programs more readable and easier to maintain
4. Break down complex problems into smaller, more manageable parts
5. Enable easier testing and debugging of individual components

Question 3: Write the general syntax for defining a function in Python. Use comments to explain each part.

Answer:
```python
def function_name(parameter1, parameter2):  # Function signature
    """
    Docstring: Briefly describe what the function does,
    its parameters, and what it returns.
    """
    # Function body: code that performs the task
    # ...
    
    return result  # Optional: return a value
```

## 3. Using Built-in Functions

Question 4: How would you calculate the number of days in the dataset using a built-in function?

Answer: 
```python
num_days = len(temperatures)
```

Question 5: Write a line of code to calculate the total temperature for the week.

Answer:
```python
total_temperature = sum(temperatures)
```

Question 6: Calculate the average humidity. (Hint: You'll need to use two built-in functions)

Answer:
```python
average_humidity = sum(humidity) / len(humidity)
```

## 4. Creating Weather-related Functions

Question 7: Write a function called `celsius_to_fahrenheit` that converts a temperature from Celsius to Fahrenheit.

Answer:
```python
def celsius_to_fahrenheit(celsius):
    return (celsius * 9/5) + 32
```

Question 8: Create a function named `average_temperature` that takes a list of temperatures and returns the average.

Answer:
```python
def average_temperature(temp_list):
    return sum(temp_list) / len(temp_list)
```

Question 9: Define a function called `weather_description` that takes temperature and humidity as parameters and returns a description based on the given criteria.

Answer:
```python
def weather_description(temperature, humidity):
    if temperature > 25 and humidity < 60:
        return "Hot and Dry"
    elif temperature > 25 and humidity >= 60:
        return "Hot and Humid"
    elif 15 <= temperature <= 25 and humidity < 60:
        return "Pleasant"
    elif 15 <= temperature <= 25 and humidity >= 60:
        return "Comfortable but Humid"
    else:
        return "Cool"
```

## 5. Using Third-party Libraries: NumPy

Question 10: Using NumPy, create an array called `temp_array` from the `temperatures` list.

Answer:
```python
temp_array = np.array(temperatures)
```

Question 11: Using Numpy, Calculate the following statistics for `temp_array`:

Answer:
```python
mean_temp = np.mean(temp_array)
max_temp = np.max(temp_array)
min_temp = np.min(temp_array)
std_temp = np.std(temp_array)
```

## 6. Putting It All Together

Question 12: Create a simple weather dashboard that uses the functions you've created earlier.

Answer:
```python
import numpy as np

def celsius_to_fahrenheit(celsius):
    return (celsius * 9/5) + 32

def average_temperature(temp_list):
    return sum(temp_list) / len(temp_list)

def weather_description(temperature, humidity):
    if temperature > 25 and humidity < 60:
        return "Hot and Dry"
    elif temperature > 25 and humidity >= 60:
        return "Hot and Humid"
    elif 15 <= temperature <= 25 and humidity < 60:
        return "Pleasant"
    elif 15 <= temperature <= 25 and humidity >= 60:
        return "Comfortable but Humid"
    else:
        return "Cool"

temperatures = [22, 24, 19, 21, 25, 23, 20]
humidity = [60, 55, 65, 58, 50, 57, 62]

print("Weather Dashboard")
print("-----------------")

# Daily weather descriptions
print("Daily Weather Descriptions:")
weather_counts = {}
for temp, hum in sip(temperatures, humidity):
    desc = weather_description(temp, hum)
    print(f"Temperature: {temp}°C, Humidity: {hum}% - {desc}")
    weather_counts[desc] = weather_counts.get(desc, 0) + 1

# Average temperature
avg_temp_c = average_temperature(temperatures)
avg_temp_f = celsius_to_fahrenheit(avg_temp_c)
print(f"\nAverage Temperature: {avg_temp_c:.1f}°C ({avg_temp_f:.1f}°F)")

# Hottest and coldest days
temp_array = np.array(temperatures)
hottest_day = np.argmax(temp_array) + 1
coldest_day = np.argmin(temp_array) + 1
print(f"Hottest day: Day {hottest_day} with {np.max(temp_array)}°C")
print(f"Coldest day: Day {coldest_day} with {np.min(temp_array)}°C")

# Weather category summary
print("\nWeather Category Summary:")
for category, count in weather_counts.items():
    print(f"{category}: {count} day(s)")
```

## 7. Reflection

Question 13: Briefly explain how functions have helped in organising and simplifying the code in this weather data analysis exercise.

Answer: Functions have significantly improved the organisation and simplicity of the code in this weather data analysis exercise in several ways:

1. Modularity: By breaking down tasks into functions like `celsius_to_fahrenheit`, `average_temperature`, and `weather_description`, we've created reusable components that can be easily understood and maintained.

2. Abstraction: Functions hide the complexity of certain operations. For example, users of the `weather_description` function don't need to know the specific criteria for each weather category.

3. Readability: The main dashboard code is much more readable because it uses descriptive function names that clearly convey their purpose.

4. Reusability: Functions like `celsius_to_fahrenheit` and `average_temperature` can be reused multiple times without duplicating code.

5. Easier testing and debugging: Each function can be tested independently, making it easier to identify and fix issues.

6. Flexibility: If we need to change how a particular calculation is done (e.g., the criteria for weather descriptions), we only need to modify the relevant function rather than changing multiple parts of the code.

This approach results in code that is more maintainable, scalable, and easier to understand, demonstrating the power of functional programming in Python.


## Additional Exercises (Optional)

1. Create a new NumPy array that contains the temperature differences between
   consecutive days.

Answer:
```python
import numpy as np

temperatures = [22, 24, 19, 21, 25, 23, 20]
temp_array = np.array(temperatures)
temp_diff = np.diff(temp_array)
print("Temperature differences:", temp_diff)
```

2. Use NumPy to find all days where the temperature was above 23°C. Return both
   the temperatures and their indices.

Answer:
```python
import numpy as np

temperatures = [22, 24, 19, 21, 25, 23, 20]
temp_array = np.array(temperatures)
above_23 = np.where(temp_array > 23)
print("Indices of days above 23°C:", above_23[0])
print("Temperatures above 23°C:", temp_array[above_23])
```

3. Write a function that converts wind speed from m/s to km/h.

Answer:
```python
def ms_to_kmh(speed_ms):
    return speed_ms * 3.6

# Example usage
wind_speed_ms = 10
wind_speed_kmh = ms_to_kmh(wind_speed_ms)
print(f"{wind_speed_ms} m/s is equal to {wind_speed_kmh} km/h")
```

4. Create a function that calculates the heat index given temperature (in
   Celsius) and relative humidity.

Answer:
```python
def calculate_heat_index(T, R):
    # Constants for the heat index calculation
    c1 = -8.78469475556
    c2 = 1.61139411
    c3 = 2.33854883889
    c4 = -0.14611605
    c5 = -0.012308094
    c6 = -0.0164248277778
    c7 = 0.002211732
    c8 = 0.00072546
    c9 = -0.000003582

    HI = (c1 + c2*T + c3*R + c4*T*R + c5*T**2 + c6*R**2 + 
          c7*T**2*R + c8*T*R**2 + c9*T**2*R**2)
    
    return HI

# Example usage
temperature = 30  # °C
humidity = 70     # %
heat_index = calculate_heat_index(temperature, humidity)
print(f"Heat Index: {heat_index:.2f}°C")
```

5. How would you use pandas to read weather data from a CSV file named
   'weather_data.csv' and display the first 5 rows?

Answer:
```python
import pandas as pd

# Read the CSV file
df = pd.read_csv('weather_data.csv')

# Display the first 5 rows
print(df.head())
```

6. Describe how you would create a scatter plot using matplotlib to show the relationship between temperature and humidity.

Answer:

To create a scatter plot showing the relationship between temperature and
humidity using matplotlib, you would follow these steps:

1. Import the necessary libraries (matplotlib.pyplot and potentially numpy).
2. Prepare your data (temperature and humidity lists or arrays).
3. Create a figure and axis object.
4. Use the `scatter()` function to plot the data.
5. Add labels and a title to the plot.
6. Display the plot.

Here's an example of how you might implement this:

```python
import matplotlib.pyplot as plt
import numpy as np

# Sample data
temperatures = [22, 24, 19, 21, 25, 23, 20]
humidity = [60, 55, 65, 58, 50, 57, 62]

# Create the scatter plot
plt.figure(figsise=(10, 6))
plt.scatter(temperatures, humidity, color='blue', alpha=0.6)

# Add labels and title
plt.xlabel('Temperature (°C)')
plt.ylabel('Humidity (%)')
plt.title('Temperature vs. Humidity')

# Add a trend line (optional)
s = np.polyfit(temperatures, humidity, 1)
p = np.poly1d(s)
plt.plot(temperatures, p(temperatures), "r--")

# Display the plot
plt.grid(True)
plt.show()
```

This code will create a scatter plot with temperature on the x-axis and humidity
on the y-axis. Each point represents a day's data. The red dashed line is a
linear trend line to help visualise any potential correlation between
temperature and humidity.

Remember to adjust the data and labels as necessary for your specific dataset.
If you're working with real data from a CSV file, you might combine this with
the pandas approach from the previous question to read and plot the data.

---
title: "STAFF ANSWER: Fetching Data from the OpenWeatherMap API"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## Overview
This guide is designed to help tutors deliver a worksheet on fetching data from
the OpenWeatherMap API. It covers key concepts, potential challenges, and tips
for effective instruction.

## Key Concepts to Emphasise

1. **APIs and Their Importance**
   - Explain APIs as interfaces for software communication
   - Highlight benefits: data access, functionality, integration, scalability

2. **OpenWeatherMap API Basics**
   - Explain the purpose of the OpenWeatherMap API
   - Guide students through API key acquisition and activation

3. **Making API Requests**
   - Introduce the `requests` library
   - Explain HTTP methods (GET) and status codes

4. **Handling JSON Responses**
   - Explain JSON format and its importance in API communication
   - Show how to parse JSON data in Python

5. **Error Handling in API Requests**
   - Emphasize the importance of robust error handling
   - Demonstrate handling different HTTP status codes

6. **Data Processing and Storage**
   - Show how to extract relevant data from API responses
   - Introduce pandas for data manipulation and CSV file handling

7. **Data Visualization**
   - Use matplotlib for creating simple visualisations of weather data

8. **API Best Practices**
   - Discuss rate limiting and its importance
   - Explain caching and efficient API usage

9. **Security Considerations**
   - Emphasise the importance of secure API key management
   - Demonstrate different methods for handling API keys

## Potential Challenges and Solutions

1. **API Key Activation Delay**
   - Inform students that it may take 15-20 minutes for new API keys to activate
   - Have a backup API key ready for demonstration if needed

2. **Rate Limiting Issues**
   - Explain how to implement delays between requests
   - Show how to handle rate limit errors gracefully

3. **JSON Parsing Errors**
   - Remind students to check the structure of the API response
   - Demonstrate debugging techniques for JSON parsing

4. **Incorrect Location Inputs**
   - Show how to handle cases where the entered location doesn't exist
   - Implement input validation and error messages

## Hands-on Activities

1. **API Key Management Exercise**
   - Have students implement both file-based and user input methods for API key management

2. **Multi-City Weather Comparison**
   - Guide students in fetching and comparing weather data for multiple cities

3. **Custom Weather App Development**
   - Walk through the process of building a simple weather app step by step

## Tips for Effective Instruction

1. **Live Coding**: Demonstrate concepts through live coding sessions

2. **Incremental Approach**: Build the weather app incrementally, explaining each step

3. **Encourage Experimentation**: Allow time for students to modify code and explore the API

4. **Real-World Applications**: Discuss practical applications of weather data in various fields

5. **Error Analysis**: When errors occur, use them as teaching moments to improve debugging skills

6. **Peer Programming**: Encourage students to work in pairs for complex tasks

7. **Q&A Sessions**: Allocate time for students to ask questions and clarify doubts


---
title: "Fetching Data from the OpenWeatherMap API"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## Objectives
- Understand what APIs are and why they're useful
- Learn how to fetch weather data using the OpenWeatherMap API
- Understand how to handle API responses and errors
- Save fetched data to a CSV file
- Perform basic data manipulation and visualisation with weather data
- Learn about API rate limits and best practices

## Introduction to APIs and OpenWeatherMap

### What are APIs?
API stands for Application Programming Interface. It's a set of rules and
protocols that allow different software applications to communicate with each
other. APIs enable developers to access specific features or data from other
services or applications without needing to understand their internal workings.

### Why are APIs useful?
1. **Data Access**: APIs allow access to valuable data from external sources.
2. **Functionality**: They enable the use of pre-built functionalities, saving
   development time.
3. **Integration**: APIs facilitate easy integration between different systems
   and services.
4. **Scalability**: They allow applications to scale by leveraging external
   services.

### Introduction to OpenWeatherMap API
The OpenWeatherMap API provides weather data for various locations worldwide.
It's a great example of how APIs can provide valuable data for applications.

## Introduction to OpenWeatherMap API
The OpenWeatherMap API provides weather data for various locations. You need to
sign up and get an API key to access the data.

### Steps to Get API Key
1. Go to [OpenWeatherMap](https://home.openweathermap.org/users/sign_up) and sign up for an account.
2. After signing up, navigate to the API keys section and generate a new API key.
3. Keep this API key safe, as you will need it to make API requests.

> Note: Once you have your API key, it can take between 15-20 mins to become active

## 2. Fetching Weather Data
We'll use the `requests` library to fetch weather data from the OpenWeatherMap API.

### Import Required Libraries
```python
import requests
import pandas as pd  # We needed this later, lets import it now
```


### Fetch some Data
Lets fetch some data..  Replace `'your_api_key_here'` with your actual API key and fetch data for a sample location.

```python
# Setup important variables
api_key = 'your_api_key_here'
location = 'Perth'

# Make request to website endpoint
url = f"http://api.openweathermap.org/data/2.5/weather?q={location}&appid={api_key}"
response = requests.get(url)

# Print response
response
```

> Note: A response code of 200 means the request was successful. Other codes, like 404 (not found) or 401 (unauthorised), indicate various errors.

What happens if the location does not exist, try a location that does not exist.  

Try:
```python
location='ABCDEFG'
```

```python
# Either modify the above cell or add code with incorrect location here
```


### Define Function to Fetch Weather Data
Let's create a function to fetch weather data for a specific location.

Why are we putting this into a function?

```python
def fetch_weather_data(api_key, location):
    url = f"http://api.openweathermap.org/data/2.5/weather?q={location}&appid={api_key}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        return data
    else:
        print(f"Failed to fetch data: {response.status_code}")
        return None
```


Let us use the new function.  We will look at API key security soon, but for now lets replace `'your_api_key_here'` with your actual API key and fetch data for a sample location.

```python
api_key = 'your_api_key_here'
location = 'Perth'
data = fetch_weather_data(api_key, location)
data
```

## 3. Parsing and Displaying Data
The data returned form an API call is in JSON format.  The requests library will convert this to Python dictionary for us but
we don't need all the information.  The process of extracting just the relevant details, is often called parsing. We'll parse the JSON response and extract relevant information.  As we might want to do this often, lets put this into a function.

```python
def parse_weather_data(data):
    if data:
        weather = {
            "Location": data["name"],
            "Temperature (K)": data["main"]["temp"],
            "Humidity (%)": data["main"]["humidity"],
            "Weather": data["weather"][0]["description"]
        }
        return weather
    else:
        return None

api_key = 'your_api_key_here'
location = 'Perth'
data = fetch_weather_data(api_key, location)
parsed_data = parse_weather_data(data)
parsed_data
```


## Saving Data to a CSV File
We use pandas library for most of of data handling. Lets save the fetched data to a CSV file using pandas.

### Convert Data to DataFrame
```python
def save_to_csv(data, filename):
    df = pd.DataFrame([data])
    df.to_csv(filename, index=False)

save_to_csv(parsed_data, 'data/raw/weather_data.csv')
```

# Read and Display the CSV File
```python
df = pd.read_csv('data/raw/weather_data.csv')
df
```

## 5. Error Handling
It's important to handle errors that may occur during API requests. We've
already added basic error handling in the `fetch_weather_data` function. Let's
test it with an invalid location.

### Test Error Handling
```python
invalid_location = 'InvalidCity'
invalid_data = fetch_weather_data(api_key, invalid_location)
invalid_data
```

## Data Manipulation and Visualisation

Let's perform some basic data manipulation and create a simple visualisation.

```python
# Fetch data for multiple cities
cities = ['New York', 'London', 'Tokyo', 'Sydney', 'Moscow']
weather_data = []

for city in cities:
    data = fetch_weather_data(api_key, city)
    if data:
        weather_data.append(parse_weather_data(data))

# Create a DataFrame
df = pd.DataFrame(weather_data)

# Convert temperature from Kelvin to Celsius
df['Temperature (C)'] = df['Temperature (K)'] - 273.15

# Create a bar plot of temperatures
plt.figure(figsize=(10, 6))
plt.bar(df['Location'], df['Temperature (C)'])
plt.title('Temperature Comparison Across Cities')
plt.xlabel('City')
plt.ylabel('Temperature (°C)')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Display humidity levels
print(df[['Location', 'Humidity (%)']])
```

## API Rate Limits and Best Practices

When working with APIs, it's crucial to be aware of rate limits and follow best
practices:

1. **Check the documentation**: Always review the API documentation for rate
   limits. OpenWeatherMap has different limits based on your subscription level.

2. **Implement rate limiting**: In your code, implement delays between requests
   to avoid hitting rate limits.

3. **Cache responses**: For data that doesn't change frequently, consider
   caching responses to reduce the number of API calls.

4. **Use bulk requests when possible**: Some APIs offer bulk data retrieval. Use
   these features when available to minimise the number of requests.

5. **Handle errors gracefully**: Implement proper error handling, especially for
   rate limit errors (usually HTTP 429 status code).

Example of implementing a simple delay:

```python
import time

def fetch_weather_data_with_delay(api_key, location, delay=1):
    data = fetch_weather_data(api_key, location)
    time.sleep(delay)  # Wait for 1 second before the next request
    return data

# Usage
for city in cities:
    data = fetch_weather_data_with_delay(api_key, city)
    # Process data...
```

Remember, respecting API rate limits is not just about avoiding errors - it's
about being a good API citizen and ensuring fair usage for all users.

## Secure API Key Management

# Method 1: Using a Secrets File (`api_key.txt`)

- **Advantages:**
  - Keeps API keys separate from your code.
  - Easy to manage and update without altering the codebase.

- **Disadvantages:**
  - Requires handling the file securely.
  - Must ensure the file is not uploaded to public repositories.

```python
# Make sure you have upload api_key.txt to the Colab folder.
with open('api_key.txt', 'r') as file:
    api_key = file.read().strip()
```

# Method 2: Prompting the User to Enter the API Key

- **Advantages:**
  - No need to store the API key in a file.
  - Reduces the risk of accidental exposure through file sharing.

- **Disadvantages:**
  - Requires manual entry each time the notebook is run.
  - Less convenient for repetitive tasks.

```python
# Get the API key from user input
api_key = input("Enter your OpenWeatherMap API key: ")
```

Lets create a function to manage the API key, if the file exists, try to extract
the key, otherwise prompt the user for the key.

```python
# Function to get the API key securely
def get_api_key():
    """
    Reads the API key from a file or prompts the user to input it.
    """
    try:
        with open('api_key.txt', 'r') as file:
            api_key = file.read().strip()
    except FileNotFoundError:
        api_key = input("Enter your OpenWeatherMap API key: ")
    return api_key
```

## Building a Simple Weather App with Plot
Using the functions you have created above, code from the lecture notes, and
seek help from GenAI if needed implement the following program.

1. **Get API Key:** Use best practice for eky management
2. **Get User Input:** Ask for a city name
3. **Make API Request:** Fetch current weather forecast
4. **Extract Dates and Temps:** Extract 4-hourly temps for each day
5. **Calculate Average Temp:** For each day, find the average temp
6. **Display/Plot Results:** Show average temperature plot

```python
```

---
title: "STAFF ANSWERS: Python Data Structures Worksheet: Weather Edition"
subtitle: "Python Essentials"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

Here are the staff answers for the Python Data Structures Worksheet: Weather Edition:

## Section 1: Choosing the Right Data Structure

1. List
   ```python
   days_of_week = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
   ```
   Explanation: A list is appropriate because the order of days is important, and the collection is fixed.

2. List of tuples
   ```python
   weekly_temps = [(25, 15), (27, 16), (26, 14), (28, 17), (30, 18), (29, 17), (26, 15)]
   ```
   Explanation: Each day's high and low temperatures form a pair, which is best represented as a tuple. The week's data is then stored in a list.

3. Dictionary
   ```python
   weather_event = {"date": "2024-08-12", "type": "hurricane", "severity": 4}
   ```
   Explanation: A dictionary allows us to store key-value pairs for different attributes of the weather event.

4. List of tuples
   ```python
   weather_stations = [(40.7128, -74.0060), (34.0522, -118.2437), (51.5074, -0.1278)]
   ```
   Explanation: Each coordinate pair is represented as a tuple, and multiple stations are stored in a list.

5. List
   ```python
   monthly_rainfall = [50, 45, 60, 55, 70, 65, 40, 35, 55, 75, 80, 70]
   ```
   Explanation: A list allows for easy indexing by month (assuming January is index 0) and maintains order.

6. Dictionary
   ```python
   city_weather = {"New York": "Sunny", "London": "Rainy", "Tokyo": "Cloudy"}
   ```
   Explanation: A dictionary allows for quick lookup of weather conditions by city name.

7. Dictionary
   ```python
   wind_direction = {"morning": "NE", "afternoon": "E", "evening": "SE", "night": "S"}
   ```
   Explanation: A dictionary allows for easy association of time periods with wind directions.

8. List of dictionaries
   ```python
   severe_weather_alerts = [
       {"type": "Tornado", "location": "Oklahoma City", "expiration": "2024-08-12 18:00"},
       {"type": "Flash Flood", "location": "Miami", "expiration": "2024-08-13 10:00"}
   ]
   ```
   Explanation: Each alert is represented as a dictionary, and multiple alerts are stored in a list.

9. Dictionary
   ```python
   monthly_avg_temp = {"January": 5, "February": 7, "March": 10, "April": 15, "May": 20, "June": 25, "July": 28, "August": 27, "September": 23, "October": 18, "November": 12, "December": 7}
   ```
   Explanation: A dictionary allows for quick lookup of average temperature by month name.

10. Dictionary
    ```python
    hourly_temps = {0: 20, 1: 19, 2: 18, 3: 17, 4: 16, 5: 15, 6: 16, 7: 18, 8: 20, 9: 22, 10: 24, 11: 26, 12: 28, 13: 29, 14: 30, 15: 30, 16: 29, 17: 28, 18: 26, 19: 24, 20: 23, 21: 22, 22: 21, 23: 20}
    ```
    Explanation: A dictionary allows for quick access to temperature by hour (0-23).

## Section 2: Implementing Data Structures in Python

1. ```python
   weekly_temperatures = [28, 30, 29, 31, 27, 26, 29]
   ```

2. a) ```python
      print(max(weekly_temperatures))
      ```
   b) ```python
      print(sum(weekly_temperatures) / len(weekly_temperatures))
      ```

3. ```python
   weather_station = ("Central Park", 40.7829, -73.9654)
   ```

4. ```python
   weather_forecast = {
       "Day 1": {"condition": "Sunny", "temperature": 28},
       "Day 2": {"condition": "Partly Cloudy", "temperature": 26},
       "Day 3": {"condition": "Cloudy", "temperature": 24}
   }
   ```

5. a) ```python
      print(weather_forecast["Day 2"]["temperature"])
      ```
   b) ```python
      weather_forecast["Day 3"]["condition"] = "Rainy"
      ```

6. ```python
   rainfall_data = [
       ("January", 50), ("February", 45), ("March", 60), ("April", 55),
       ("May", 70), ("June", 65), ("July", 40), ("August", 35),
       ("September", 55), ("October", 75), ("November", 80), ("December", 70)
   ]
   ```

7. ```python
   max_rainfall = max(rainfall_data, key=lambda x: x[1])
   print(f"The month with the highest rainfall is {max_rainfall[0]} with {max_rainfall[1]}mm")
   ```

8. ```python
   city_temperatures = {
       "New York": [28, 30, 29, 31, 27, 26, 29],
       "London": [20, 22, 21, 23, 19, 18, 20],
       "Tokyo": [31, 32, 33, 31, 30, 29, 32]
   }
   ```

9. ```python
   for city, temps in city_temperatures.items():
       avg_temp = sum(temps) / len(temps)
       print(f"Average temperature in {city}: {avg_temp:.1f}°C")
   ```

10. ```python
    weather_alerts = [
        {"type": "Thunderstorm", "location": "Chicago", "severity": 3},
        {"type": "Hurricane", "location": "Miami", "severity": 5},
        {"type": "Heatwave", "location": "Phoenix", "severity": 4}
    ]

    severe_alerts = [alert for alert in weather_alerts if alert["severity"] >= 4]
    for alert in severe_alerts:
        print(f"Severe alert: {alert['type']} in {alert['location']}")
    ```

*Advanced/Bonus Questions:*

11. ```python
    temperature_categories = []
    for temp in weekly_temperatures:
        if temp < 20:
            temperature_categories.append("Cool")
        elif 20 <= temp <= 25:
            temperature_categories.append("Mild")
        else:
            temperature_categories.append("Warm")
    ```

12. ```python
    seasons = {"Spring": 0, "Summer": 0, "Autumn": 0, "Winter": 0}
    for i, (month, rainfall) in enumerate(rainfall_data):
        season = ["Winter", "Winter", "Spring", "Spring", "Spring", "Summer", "Summer", "Summer", "Autumn", "Autumn", "Autumn", "Winter"][i]
        seasons[season] += rainfall
    ```

13. ```python
    most_consistent_city = min(city_temperatures, key=lambda city: max(city_temperatures[city]) - min(city_temperatures[city]))
    print(f"The city with the most consistent temperature is {most_consistent_city}")
    ```

14. ```python
    import random

    temperature = 20
    temperature_readings = [temperature]

    while 15 <= temperature <= 30:
        change = random.uniform(-3, 3)
        temperature += change
        temperature_readings.append(round(temperature, 1))

    print(f"Temperature readings: {temperature_readings}")
    print(f"Simulation ended after {len(temperature_readings)} days")
    ```

15. ```python
    location = input("Enter a location: ")
    location_alerts = [alert for alert in weather_alerts if alert["location"].lower() == location.lower()]
    sorted_alerts = sorted(location_alerts, key=lambda x: x["severity"], reverse=True)

    if sorted_alerts:
        print(f"Alerts for {location}:")
        for alert in sorted_alerts:
            print(f"Type: {alert['type']}, Severity: {alert['severity']}")
    else:
        print(f"No alerts found for {location}")
    ```

These answers demonstrate proper use of Python data structures and incorporate weather-related scenarios to make the exercises more engaging and practical.

---
title: "Python Data Structures Worksheet: Weather Edition"
subtitle: "Python Essentials"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## Section 1: Choosing the Right Data Structure

For each scenario, choose the most appropriate data structure (list, tuple, or dictionary) and briefly explain why. If possible, write out how you would represent the data using the chosen structure.

1. You need to store the names of the seven days of the week for a weather forecast application.

2. A weather station needs to record the daily high and low temperatures for a week.

3. You want to store information about a specific weather event, including the date, type of event (e.g., "hurricane", "thunderstorm"), and severity rating.

4. An application needs to store the latitude and longitude coordinates of multiple weather stations.

5. You're creating a program to track monthly rainfall totals for a year.

6. A weather app needs to store city names and their corresponding weather conditions.

7. You want to keep track of the wind direction at different times of the day (morning, afternoon, evening, night).

8. An app needs to store a list of severe weather alerts, where each alert has a type, location, and expiration time.

9. You're developing a system to record the average temperature for each month of the year. The system should allow for easy retrieval of the average temperature for a specific month. 

10. A weather monitoring system needs to store hourly temperature readings for a day, with the ability to quickly access the temperature at a specific hour.

## Section 2: Implementing Data Structures in Python

Complete the following Python exercises to practice working with lists, tuples, and dictionaries in a weather context. The advanced/bonus questions are marked with an asterisk (*).

1. Create a list called `weekly_temperatures` with seven daily high temperatures.
   ```python
   weekly_temperatures = # Your code here
   ```

2. Using the `weekly_temperatures` list, write code to:
   a) Print the highest temperature of the week
   b) Print the average temperature for the week

3. Create a tuple called `weather_station` with the name, latitude, and longitude of a weather station.
   ```python
   weather_station = # Your code here
   ```

4. Create a dictionary called `weather_forecast` for a 3-day forecast. Each day should have a "condition" and "temperature" key.
   ```python
   weather_forecast = # Your code here
   ```

5. Using the `weather_forecast` dictionary:
   a) Print the temperature for the second day
   b) Change the condition of the third day to "Rainy"

6. Create a list of tuples called `rainfall_data`, where each tuple contains a month name and its rainfall amount.
   ```python
   rainfall_data = # Your code here
   ```

7. Using the `rainfall_data` list, write code to find and print the month with the highest rainfall.

8. Create a dictionary called `city_temperatures` where keys are city names and values are lists of daily temperatures for a week.
   ```python
   city_temperatures = # Your code here
   ```

9. Using the `city_temperatures` dictionary, calculate and print the average temperature for each city.

10. Create a list of dictionaries called `weather_alerts`, where each dictionary represents a weather alert with "type", "location", and "severity" keys.
    ```python
    weather_alerts = # Your code here
    ```

    Then, write code to print all "severe" weather alerts.

*Advanced/Bonus Questions:*

11. * Using a for loop and if statements, categorize each day in `weekly_temperatures` as "Cool" (below 20°C), "Mild" (20-25°C), or "Warm" (above 25°C). Store the results in a new list called `temperature_categories`.

12. * Using the `rainfall_data` list, create a new dictionary where keys are seasons ("Spring", "Summer", "Autumn", "Winter") and values are the total rainfall for that season. Assume the list starts with January.

13. * Using the `city_temperatures` dictionary, find and print the name of the city with the most consistent temperature (i.e., the smallest difference between its highest and lowest temperature).

14. * Create a while loop that simulates daily temperature readings. Start with a temperature of 20°C and randomly increase or decrease it by 0-3°C each day. Stop the loop when the temperature goes below 15°C or above 30°C. Store the temperatures in a list.

15. * Using the `weather_alerts` list, write code that asks the user to input a location and then prints all alerts for that location, sorted by severity (assume severity is a number from 1-5, with 5 being the most severe).


---
title: "Building a Simple Weather App GUI in Google Colab with ipywidgets"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

### **Introduction:**

Graphical User Interfaces (GUIs) allow users to interact with applications
visually, providing a more intuitive experience compared to text-based
interfaces. In this worksheet, we will explore how to build a simple interactive
weather app using Python’s `ipywidgets` library in Google Colab. This app will
allow users to input a city name and display simulated weather information. This
activity reinforces basic GUI concepts, while also giving you a practical
introduction to building interactive widgets in a Jupyter/Colab environment.

### **Objectives:**
By the end of this worksheet, you will be able to:

1. Understand the basic concepts of GUIs.
2. Build and display simple interactive widgets using `ipywidgets` in Google Colab.
3. Create input fields, buttons, and labels to simulate a weather application.
4. Write Python code to handle user inputs and display output based on these inputs.
5. Create a basic visualisation of a 5-day temperature trend using `matplotlib`.
6. Combine different GUI elements to create a cohesive application.


---

### **Frequently Save Your Work to GitHub**

As you progress through this worksheet, it's important to frequently save your
work by pushing the latest version of your notebook to GitHub. This helps
prevent data loss and allows you to track changes over time. Follow these steps
to save your notebook directly from Google Colab to GitHub:

1. **Save a Copy to GitHub**:
   - In your Google Colab notebook, go to the **File** menu.
   - Select **Save a copy in GitHub** from the dropdown menu.

2. **Enter a Commit Message**:
   - A popup box will appear asking for a commit message.
   - Type a meaningful commit message that describes your changes, for example:
     - *"Added weather fetching function"*
     - *"Created input widget for city name"*
     - *"Fixed bug in city input handling"*

3. **Select the Target Repository**:
   - In the same popup box, make sure you select the correct GitHub repository where you want to save the file.
   - You can also choose the branch if you're working with multiple branches.

4. **Click 'OK'**:
   - Once you’ve entered your commit message and selected the repository, click **OK** to save your notebook to GitHub.

By frequently saving your work using this method, you ensure that your progress
is well-documented and securely stored in your GitHub repository. This also
allows you to easily share your work and track changes over time.

---

### **Step-by-Step Guide: Creating the Weather App in ipywidgets**

#### **Step 1: Import Necessary Libraries**
Before starting, you need to import the `ipywidgets` library and other necessary modules. These libraries will allow us to create interactive elements in our app.

```python
import ipywidgets as widgets
from IPython.display import display
```

#### **Step 2: Create the Input Widget for City Name**
The first step in our weather app is to allow the user to input a city name. We’ll use the `Text` widget to create an input field.

```python
city_input = widgets.Text(
    placeholder='Enter city name',
    description='City:',
    disabled=False
)
```

- The `placeholder` attribute shows text inside the input box when it’s empty.
- The `description` attribute adds a label next to the input field.

#### **Step 3: Add a Button to Fetch Weather**
Now, let’s create a button that users will click to "fetch" the weather data. We use the `Button` widget for this.

```python
fetch_button = widgets.Button(
    description='Get Weather',
    disabled=False,
    button_style='primary'  # Optional styling
)
```

- The `description` attribute specifies the text displayed on the button.
- The `button_style` can be used to add some visual flair (optional).

#### **Step 4: Create a Label to Display Weather Information**
Next, we need a place to display the weather results. A `Label` widget is perfect for this task.

```python
weather_output = widgets.Label(value="")
```

- The `value` attribute initialises the label’s text, which we’ll update when the button is clicked.

#### **Step 5: Write the Function to Simulate Fetching Weather**
In this step, we create the logic that will simulate weather retrieval based on the input city name. Since we aren’t connecting to an actual weather API, we’ll display a mock result (e.g., "Sunny, 25°C").

```python
def fetch_weather(b):
    city = city_input.value
    # Simulate weather data
    weather = "Sunny, 25°C" if city else "No city entered"
    weather_output.value = f"Weather in {city}: {weather}"
```

- The function `fetch_weather` will get the value entered in the `city_input` widget and display a simulated weather result.

#### **Step 6: Bind the Button to the Function**
Now, let’s connect the button to the weather fetching function. We use the `on_click` method to trigger the function whenever the button is clicked.

```python
fetch_button.on_click(fetch_weather)
```

#### **Step 7: Display All the Widgets Together**
Finally, we use the `display()` function to show all the widgets in the notebook (input, button, and weather output).

```python
display(city_input, fetch_button, weather_output)
```

At this point, you should have a fully functioning weather app in Colab! The user can enter a city name, click the button, and see a simulated weather result.

---

### **Exercise: Customize Your Weather App**
Now that you've created the basic weather app, let’s extend it with a few extra features. Try to implement the following:

1. **Change the Placeholder Text**: Modify the placeholder text in the `city_input` field to say "Type your city here".
   
2. **Error Handling**: Update the `fetch_weather` function to display an error message if the user clicks "Get Weather" without entering a city name.

3. **Additional Button**: Add a second button that clears the weather result when clicked.


---

### **Reflection Questions:**
1. How does the `on_click` function help make the app interactive?
2. What is the benefit of using `ipywidgets` in Google Colab for quick prototyping of GUIs?
3. Can you think of another scenario (besides weather) where a simple GUI like this could be helpful?




### **Step-by-Step Guide: Creating the Weather App with Visualisation**

#### **Step 1: Import Necessary Libraries**
Before starting, you need to import the `ipywidgets` library, `matplotlib` for the graph, and other necessary modules.

```python
import ipywidgets as widgets
from IPython.display import display
import matplotlib.pyplot as plt
import numpy as np
```

#### **Step 2: Create the Input Widget for City Name**
The first step in our weather app is to allow the user to input a city name. We’ll use the `Text` widget to create an input field.

```python
city_input = widgets.Text(
    placeholder='Enter city name',
    description='City:',
    disabled=False
)
```

#### **Step 3: Add a Button to Fetch Weather and Plot Data**
Now, let’s create a button that users will click to fetch the weather data and display a temperature trend.

```python
fetch_button = widgets.Button(
    description='Get Weather and Show Trend',
    disabled=False,
    button_style='primary'  # Optional styling
)
```

#### **Step 4: Create a Label to Display Weather Information**
Next, we need a place to display the weather results (such as today's temperature) and the city name entered.

```python
weather_output = widgets.Label(value="")
```

#### **Step 5: Simulate 5-Day Temperature Trend Data**
For the sake of this exercise, we will simulate a 5-day temperature trend using `numpy` to generate random temperature data for the city.

```python
def get_temperature_trend(city):
    # Simulate a 5-day temperature trend
    np.random.seed(0)  # For reproducible results
    return 20 + 5 * np.random.randn(5)
```

#### **Step 6: Write the Function to Fetch Weather and Plot the Trend**
In this step, we create the logic that will simulate weather retrieval and display a temperature trend for the next 5 days using a line chart.

```python
def fetch_weather_and_plot(b):
    city = city_input.value
    if not city:
        weather_output.value = "No city entered"
    else:
        # Simulate fetching today's weather
        weather_output.value = f"Today's weather in {city}: Sunny, 25°C"
        
        # Get temperature trend
        temperatures = get_temperature_trend(city)
        
        # Plot the 5-day temperature trend
        plt.figure(figsize=(6,4))
        days = ['Day 1', 'Day 2', 'Day 3', 'Day 4', 'Day 5']
        plt.plot(days, temperatures, marker='o')
        plt.title(f"5-Day Temperature Trend for {city}")
        plt.ylabel("Temperature (°C)")
        plt.xlabel("Days")
        plt.grid(True)
        plt.show()
```

#### **Step 7: Bind the Button to the Function**
Now, let’s connect the button to the weather fetching and plotting function. We use the `on_click` method to trigger the function whenever the button is clicked.

```python
fetch_button.on_click(fetch_weather_and_plot)
```

#### **Step 8: Display All the Widgets Together**
Finally, we use the `display()` function to show all the widgets in the notebook (input, button, and weather output), and we add a plot to visualize the temperature trend.

```python
display(city_input, fetch_button, weather_output)
```

At this point, you should have a fully functioning weather app in Colab! The user can enter a city name, click the button, and see both the current weather and a 5-day temperature trend.

---

### **Exercise: Customise Your Weather App with Visualisation**
Now that you've created the basic weather app with visualisation, let’s extend it with a few extra features. Try to implement the following:

1. **Customise the Plot**: Add labels for the x and y axes and experiment with different plot styles in `matplotlib`.
   
2. **Randomise Temperature Trends**: Modify the `get_temperature_trend()` function to simulate different weather conditions based on the city entered (e.g., higher temperatures for tropical cities).

3. **Advanced Challenge (Optional)**: Connect to a real weather API (like OpenWeatherMap) and fetch real temperature data for the 5-day forecast.


---
title: "STAFF ANSWER: Building a Simple Weather App GUI in Google Colab with ipywidgets"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

### **Introduction:**
This staff guide provides solutions, explanations, and tips for assessing
students' progress through the worksheet. The main goal of the worksheet is to
help students learn about creating simple GUIs using `ipywidgets` in Google
Colab, and to introduce them to visualizing data with `matplotlib`.

---

### **Expected Outcomes:**

1. **Basic Weather App with ipywidgets**:
   - Students should successfully create a text input widget, a button, and a
     label to display simulated weather results.
   - The app should display a simulated weather message like "Weather in [City]:
     Sunny, 25°C" when a user enters a city and clicks the button.
   
2. **Extended Weather App with Visualization**:
   - Students will simulate a 5-day temperature trend for the entered city and
     plot this data using `matplotlib`.
   - The temperature trend will be random, but plotted with proper labels and a
     line graph.
   
3. **Version Control**:
   - Students are encouraged to frequently save their work to GitHub. They
     should submit their GitHub links or evidence of regular commits.

---

### **Frequently Save Your Work to GitHub**

Students should follow the instructions to save their work to GitHub. Look for:

- Regular commits with meaningful messages such as *"Added temperature trend
  plotting"*.
- Ensuring they push their final notebook with complete functionality (input,
  button, label, and visualization).

---

### **Step-by-Step Guide: Basic Weather App**

#### **Step 1: Import Necessary Libraries**

Expected Solution:
```python
import ipywidgets as widgets
from IPython.display import display
```

#### **Step 2: Input Widget for City Name**

Expected Solution:
```python
city_input = widgets.Text(
    placeholder='Enter city name',
    description='City:',
    disabled=False
)
```
Assessment:
- The widget should display an input box with the label "City:" and placeholder text "Enter city name."

#### **Step 3: Add a Button**

Expected Solution:
```python
fetch_button = widgets.Button(
    description='Get Weather',
    disabled=False,
    button_style='primary'  # Optional styling
)
```
Assessment:
- Ensure the button is created correctly with the label "Get Weather."

#### **Step 4: Create a Label for Weather Display**

Expected Solution:
```python
weather_output = widgets.Label(value="")
```
Assessment:
- Check that the label is initialized with an empty string.

#### **Step 5: Simulate Weather Fetching Function**

Expected Solution:
```python
def fetch_weather(b):
    city = city_input.value
    weather = "Sunny, 25°C" if city else "No city entered"
    weather_output.value = f"Weather in {city}: {weather}"
```
Assessment:
- Check that the function returns the correct message depending on whether a city is entered.
- Ensure that `"No city entered"` is displayed if the user clicks the button without entering a city.

#### **Step 6: Bind Button to Function**

Expected Solution:
```python
fetch_button.on_click(fetch_weather)
```

#### **Step 7: Display All Widgets**

Expected Solution:
```python
display(city_input, fetch_button, weather_output)
```

### **Exercise: Customize Your Weather App**

Students are expected to modify the app in various ways:

1. **Change Placeholder Text**:
   ```python
   city_input.placeholder = "Type your city here"
   ```

2. **Error Handling**:
   - The `fetch_weather` function should be updated to display an error message like:
   ```python
   if not city:
       weather_output.value = "Please enter a city name"
   ```

3. **Additional Button**:
   - Students should add a "Clear" button that resets the label to an empty string:
   ```python
   clear_button = widgets.Button(description="Clear")
   def clear_output(b):
       weather_output.value = ""
   clear_button.on_click(clear_output)
   display(clear_button)
   ```

---

### **Step-by-Step Guide: Weather App with Visualization**

#### **Step 1: Import Necessary Libraries**

Expected Solution:
```python
import ipywidgets as widgets
from IPython.display import display
import matplotlib.pyplot as plt
import numpy as np
```

#### **Step 2: Input Widget for City Name**

Expected Solution:
(Same as before, Step 2)

#### **Step 3: Add Button for Fetching Weather and Plotting**

Expected Solution:
```python
fetch_button = widgets.Button(
    description='Get Weather and Show Trend',
    disabled=False,
    button_style='primary'
)
```

#### **Step 4: Create Label for Weather Display**

Expected Solution:
(Same as before, Step 4)

#### **Step 5: Simulate 5-Day Temperature Trend Data**

Expected Solution:
```python
def get_temperature_trend(city):
    np.random.seed(0)  # For reproducible results
    return 20 + 5 * np.random.randn(5)
```
Assessment:
- The `get_temperature_trend` function should simulate temperature data using `numpy`.

#### **Step 6: Fetch Weather and Plot the Trend**

Expected Solution:
```python
def fetch_weather_and_plot(b):
    city = city_input.value
    if not city:
        weather_output.value = "No city entered"
    else:
        weather_output.value = f"Today's weather in {city}: Sunny, 25°C"
        temperatures = get_temperature_trend(city)
        plt.figure(figsize=(6, 4))
        days = ['Day 1', 'Day 2', 'Day 3', 'Day 4', 'Day 5']
        plt.plot(days, temperatures, marker='o')
        plt.title(f"5-Day Temperature Trend for {city}")
        plt.ylabel("Temperature (°C)")
        plt.xlabel("Days")
        plt.grid(True)
        plt.show()
```
Assessment:
- Ensure the function handles both weather text and temperature plotting.
- Check that the plot includes proper labels (days on x-axis, temperature on y-axis).

#### **Step 7: Bind Button to Function**

Expected Solution:
```python
fetch_button.on_click(fetch_weather_and_plot)
```

#### **Step 8: Display All Widgets**

Expected Solution:
(Same as before, Step 7)

---

### **Exercise: Customise Your Weather App with Visualization**

1. **Customise the Plot**:
   - Students should modify the plot to add titles, labels, and other custom styles.
   - For example, add axis labels:
   ```python
   plt.xlabel("Days of the Week")
   plt.ylabel("Temperature in °C")
   ```

2. **Randomise Temperature Trends**:
   - Modify the `get_temperature_trend()` function to provide a different range of temperatures based on the city entered.

3. **Advanced Challenge**:
   - This would involve connecting to a real weather API such as OpenWeatherMap to fetch real weather data. This is optional and requires students to understand how to interact with external APIs.

---

### **Reflection Questions (Answers)**

1. **How does the `on_click` function help make the app interactive?**
   - The `on_click` function binds the button to a function that is triggered when the user clicks the button, making the app responsive to user inputs.

2. **What is the benefit of using `ipywidgets` in Google Colab for quick prototyping of GUIs?**
   - `ipywidgets` makes it easy to create simple interactive elements without requiring complex front-end development knowledge. It's ideal for prototyping GUIs in a Jupyter/Colab environment.

3. **Can you think of another scenario (besides weather) where a simple GUI like this could be helpful?**
   - Examples might include a basic financial calculator, a to-do list app, or an interactive form for entering survey data.

---

### **Conclusion**

This guide provides a comprehensive solution and explanation for assessing the student's work. The goal is to ensure students understand the basic GUI elements and have the opportunity to apply these concepts in a simple, fun project.

---
title: "Weathering the Bugs: A Hands-on Guide to Testing and Debugging in Python"
subtitle: "Master the basics of debugging and testing with real-world weather data—one bug at a time!"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## **Introduction and Background**

Testing and debugging are essential parts of software development. As a developer, you need to ensure that your code works as expected and handle errors efficiently. In this worksheet, you’ll practice using simple debugging tools like `print()`, `assert()`, and `doctest` to verify that your code functions correctly.

This worksheet will guide you through the process of creating a Jupyter notebook where you’ll implement and test Python code in the context of weather data, which fits our ongoing theme.

## **Learning Objectives**
By the end of this worksheet, you will:
- Understand how to use `print()` to debug code.
- Write simple tests using `assert()`.
- Create and run `doctest` to validate function behavior.
- (Optional) Explore how to use Python's built-in debugger, `pdb`, for step-by-step debugging.



## **Exercise 1: Debugging with `print()`**

In this exercise, you’ll debug a weather prediction function using `print()` statements to identify and fix an error.

1. **Code Setup**: 
   Below is a weather prediction function. There's an error in the function that causes it to return incorrect results for certain inputs. Use `print()` statements to trace the values of variables and debug the function.

```python
def predict_weather(temp):
    if temp > 25:
        return "Sunny"
    if temp < 15:
        return "Cloudy"
    return "Rainy"
```

2. **Task**: 
   Add `print()` statements inside the function to trace the value of `temp` and understand where the logic might be going wrong.

3. **Question**: 
   What was the bug? Fix the function so it works as intended.

4. **Expected Output**:
   - `predict_weather(30)` should return `'Sunny'`
   - `predict_weather(10)` should return `'Cloudy'`
   - `predict_weather(20)` should return `'Rainy'`



## **Exercise 2: Testing with `assert()`**

In this exercise, you’ll use `assert()` to test a function’s output. The `assert()` statement will raise an error if the condition is false, which helps to test the correctness of your code.

1. **Code Setup**:
   Modify the `predict_weather()` function from Exercise 1 to use `assert()` for testing.

```python
def predict_weather(temp):
    if temp > 25:
        return "Sunny"
    if temp < 15:
        return "Cloudy"
    return "Rainy"
```

2. **Task**: 
   Write `assert()` statements to test the function with different inputs. For example:

```python
assert predict_weather(30) == 'Sunny'
assert predict_weather(10) == 'Cloudy'
assert predict_weather(20) == 'Rainy'
```

3. **Question**: 
   Does your function pass all the tests? If not, fix it and re-run the tests.



## **Exercise 3: Writing and Running Doctests**

Now, you’ll use `doctest` to write test cases directly in the function’s docstring.

1. **Code Setup**: 
   Modify your `predict_weather()` function to include doctests.

```python
def predict_weather(temp):
    """
    Predict tomorrow's weather based on today's temperature.

    >>> predict_weather(30)
    'Sunny'
    >>> predict_weather(10)
    'Cloudy'
    >>> predict_weather(20)
    'Rainy'
    """
    if temp > 25:
        return "Sunny"
    if temp < 15:
        return "Cloudy"
    return "Rainy"
```

2. **Task**: 
   Add the `doctest` module to your code and run it. Example:

```python
if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

3. **Question**: 
   Do your doctests pass? If not, fix the function and re-run the doctests.



## **Optional Exercise: Debugging with `pdb`**

If you're feeling adventurous, explore how to use the Python Debugger (`pdb`) to step through your code.

1. **Task**: 
   Add a `breakpoint()` in your `predict_weather()` function, and run the cell to step through the code.

```python
def predict_weather(temp):
    breakpoint()
    if temp > 25:
        return "Sunny"
    if temp < 15:
        return "Cloudy"
    return "Rainy"
```

2. **Steps**:
   - Run the code and use the `pdb` commands to navigate through the function.
   - Use `n` to step through the code and `p` to print variable values.

3. **Question**: 
   How did using `pdb` help you understand the behavior of the function?



---
title: "STAFF-ANSWER: Weathering the Bugs: A Hands-on Guide to Testing and Debugging in Python"
subtitle: "Master the basics of debugging and testing with real-world weather data—one bug at a time!"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
### **Exercise 1: Debugging with `print()`**

#### Code Setup:
The original function had an issue where temperatures between 15 and 25 returned
"Rainy" by default. However, the conditions weren’t structured properly to
handle this.

#### Debugging with `print()`:
We can insert `print()` statements to trace the value of `temp` and see how the logic flows.

```python
def predict_weather(temp):
    print(f"Current temperature: {temp}")
    if temp > 25:
        print("It's sunny!")
        return "Sunny"
    if temp < 15:
        print("It's cloudy!")
        return "Cloudy"
    print("It seems rainy.")
    return "Rainy"
```

#### Output after Debugging:
When testing the function with a value like `predict_weather(20)`, we noticed
that it directly jumped to "Rainy," even though we expected more conditions to
be checked.

#### Corrected Code:

```python
def predict_weather(temp):
    if temp > 25:
        return "Sunny"
    elif temp < 15:
        return "Cloudy"
    else:
        return "Rainy"
```

#### Expected Output:
```python
predict_weather(30)  # Sunny
predict_weather(10)  # Cloudy
predict_weather(20)  # Rainy
```

The issue was that the two `if` statements acted independently, so the second
condition (`if temp < 15`) wasn't executed properly. Changing the second `if` to
`elif` fixed this problem.



### **Exercise 2: Testing with `assert()`**

#### Code Setup:
We can now add `assert()` statements to test if the function behaves as expected.

```python
def predict_weather(temp):
    if temp > 25:
        return "Sunny"
    elif temp < 15:
        return "Cloudy"
    else:
        return "Rainy"
```

#### Testing with `assert()`:

```python
assert predict_weather(30) == 'Sunny'
assert predict_weather(10) == 'Cloudy'
assert predict_weather(20) == 'Rainy'
```

#### Output:
The code passes all the assertions, indicating that the function is working
correctly. If any of the conditions failed, `assert()` would raise an
`AssertionError`, helping us locate the issue.



### **Exercise 3: Writing and Running Doctests**

#### Code Setup:
Now we will add `doctest` cases inside the function's docstring.

```python
def predict_weather(temp):
    """
    Predict tomorrow's weather based on today's temperature.

    >>> predict_weather(30)
    'Sunny'
    >>> predict_weather(10)
    'Cloudy'
    >>> predict_weather(20)
    'Rainy'
    """
    if temp > 25:
        return "Sunny"
    elif temp < 15:
        return "Cloudy"
    else:
        return "Rainy"
```

#### Running the Doctests:

```python
if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

#### Output:
If all the doctests pass, there will be no output. If any of the tests fail,
`doctest` will provide a message showing where the actual output differed from
the expected result.



### **Optional Exercise: Debugging with `pdb`**

#### Code Setup with `pdb`:
Here’s how you can insert `breakpoint()` to step through the function using `pdb`.

```python
def predict_weather(temp):
    breakpoint()  # This will stop the execution and enter pdb mode
    if temp > 25:
        return "Sunny"
    elif temp < 15:
        return "Cloudy"
    else:
        return "Rainy"
```

#### Running the Code:
When you run the function in Jupyter or a Python shell, it will stop at the
`breakpoint()` and let you interact with the variables.

- Use `n` (next) to step through the code.
- Use `p temp` to print the value of `temp`.

Example:

```python
predict_weather(30)
```

You can then step through each line and check how the function is processing the input.

#### Output:
Using `pdb` allows you to inspect the state of the program at various stages,
making it easier to identify where things go wrong.

### **Summary of Results:**

- **Exercise 1**: Using `print()` helped us identify a logical error in the function.
- **Exercise 2**: We verified that our function passed a set of test cases using `assert()`.
- **Exercise 3**: We successfully wrote and executed `doctest` cases within the function's docstring.
- **Optional Exercise**: We explored using `pdb` to step through the code and interact with it line by line.


---
title: "Python Input Validation"
subtitle: "Python Essentials"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---
## Introduction

Input validation is a crucial aspect of programming that ensures the data
entered by users meets specific criteria before it's processed. This worksheet
will guide you through understanding and implementing input validation using the
PyInputPlus module in Python.

## Aim

To understand the importance of input validation and practice implementing it
using PyInputPlus in a weather utility application.

## Questions

1. In your own words, what is input validation?

2. Why do we need to validate input?

3. Why are we using the PyInputPlus module instead of the built-in input() function?

## Hands-on Exercise: Enhancing Our Weather Utility

Let's enhance our weather utility functions from Lecture 1 with PyInputPlus for input and proper exception handling:

### Task 1: Setting Up

First, install PyInputPlus using pip:

```
pip install pyinputplus
```

Then, import the module in your Python script:

```python
import pyinputplus as pyip
```

### Task 2: Implementing Input Validation

Create a function called `get_weather_data()` that:

1. Uses `pyip.inputStr()` to get the city name
2. Uses `pyip.inputFloat()` to get the temperature
3. Implements exception handling for potential errors
4. Uses `pyip.inputFloat()` with a minimum value for wind speed
5. Uses `pyip.inputChoice()` for wind direction

```python
def get_weather_data():
    try:
        city = pyip.inputStr("Enter city name: ")
        temp = pyip.inputFloat("Enter temperature in Celsius: ")
        wind_speed = pyip.inputFloat("Enter wind speed (km/h): ", min=0)
        wind_direction = pyip.inputChoice(["N", "S", "E", "W"], prompt="Enter wind direction (N/S/E/W): ")
        return city, temp, wind_speed, wind_direction
    except Exception as e:
        print(f"An error occurred: {e}")
        return None, None, None, None
```

### Task 3: Using the Function

Use the `get_weather_data()` function and print the results:

```python
city, temp, wind_speed, wind_direction = get_weather_data()
if city:
    print(f"Weather in {city}: {temp}°C, Wind: {wind_speed} km/h {wind_direction}")
else:
    print("Failed to get weather data.")
```

### Task 4: Celsius to Fahrenheit Conversion

Create a function to convert Celsius to Fahrenheit using PyInputPlus:

```python
def celsius_to_fahrenheit():
    celsius = pyip.inputFloat("Enter temperature in Celsius: ")
    fahrenheit = (celsius * 9/5) + 32
    print(f"{celsius}°C is equal to {fahrenheit}°F")
```

### Task 5: Testing

Run your script and test it with various inputs, including:
- Valid inputs
- Invalid inputs (e.g., non-numeric temperature)
- Edge cases (e.g., very high or low temperatures)

## Reflection

After completing the tasks, answer the following questions:

1. How does PyInputPlus simplify input validation compared to using the built-in
   input() function?

2. What challenges did you face while implementing input validation?

3. Can you think of any other weather-related data that could benefit from input
   validation? How would you implement it?

---
title: "Python Input Validation: Staff Answer Key and Instructor Guide"
subtitle: "Python Essentials"
format: 
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

### Introduction

This guide provides answers to the questions and tasks in the student worksheet,
along with additional notes for instructors to facilitate discussion and
learning.

### Questions

1. What is input validation?

**Answer:** Input validation is the process of checking and ensuring that data
entered by users meets specific criteria or constraints before it's processed by
a program. It helps maintain data integrity and prevent errors or security
vulnerabilities.

**Instructor Note:** Encourage students to discuss different types of validation
(e.g., type checking, range checking, format validation) and their importance in
various applications.

2. Why do we need to validate input?

**Answer:** We validate input to:
- Prevent errors and crashes in our program
- Ensure data integrity and consistency
- Enhance security by preventing malicious inputs
- Improve user experience by providing immediate feedback

**Instructor Note:** Discuss real-world examples of input validation failures
and their consequences.

3. Why are we using the PyInputPlus module instead of the built-in input() function?

**Answer:** PyInputPlus offers several advantages over the built-in input() function:
- Built-in input validation features
- Automatic re-prompting for invalid inputs
- Type-specific input functions (e.g., inputStr(), inputFloat())
- Easy implementation of complex validation rules

**Instructor Note:** Demonstrate the difference between using input() and
PyInputPlus functions to highlight the benefits.

### Hands-on Exercise: Enhancing Our Weather Utility

#### Task 1: Setting Up

**Instructor Note:** Ensure all students have successfully installed
PyInputPlus. Address any installation issues.

#### Task 2: Implementing Input Validation

**Sample Solution:**

```python
import pyinputplus as pyip

def get_weather_data():
    try:
        city = pyip.inputStr("Enter city name: ")
        temp = pyip.inputFloat("Enter temperature in Celsius: ")
        wind_speed = pyip.inputFloat("Enter wind speed (km/h): ", min=0)
        wind_direction = pyip.inputChoice(["N", "S", "E", "W"], prompt="Enter wind direction (N/S/E/W): ")
        return city, temp, wind_speed, wind_direction
    except Exception as e:
        print(f"An error occurred: {e}")
        return None, None, None, None
```

**Instructor Note:** Explain the purpose of each PyInputPlus function used and
how they contribute to input validation. Discuss the importance of exception
handling.

#### Task 3: Using the Function

**Sample Solution:**

```python
city, temp, wind_speed, wind_direction = get_weather_data()
if city:
    print(f"Weather in {city}: {temp}°C, Wind: {wind_speed} km/h {wind_direction}")
else:
    print("Failed to get weather data.")
```

**Instructor Note:** Demonstrate how the function handles both valid and invalid
inputs.

#### Task 4: Celsius to Fahrenheit Conversion

**Sample Solution:**

```python
def celsius_to_fahrenheit():
    celsius = pyip.inputFloat("Enter temperature in Celsius: ")
    fahrenheit = (celsius * 9/5) + 32
    print(f"{celsius}°C is equal to {fahrenheit:.2f}°F")
```

**Instructor Note:** Discuss the importance of formatting output (e.g., rounding
to two decimal places) and how it relates to data presentation.

#### Task 5: Testing

**Instructor Note:** Guide students through testing various scenarios:
- Valid inputs: e.g., "London", 20.5, 10, "N"
- Invalid inputs: e.g., "123" for city name, "abc" for temperature
- Edge cases: e.g., -273.15°C (absolute zero), 1000 km/h wind speed

### Reflection

1. How does PyInputPlus simplify input validation compared to using the built-in
   input() function?

**Sample Answer:** PyInputPlus simplifies input validation by providing built-in
functions for different data types, automatic re-prompting for invalid inputs,
and easy implementation of validation rules. This reduces the amount of code
needed for input validation and makes the process more robust and user-friendly.

2. What challenges did you face while implementing input validation?

**Sample Answer:** Challenges might include:
- Understanding the different PyInputPlus functions and their parameters
- Deciding on appropriate validation rules for each input
- Handling unexpected exceptions

3. Can you think of any other weather-related data that could benefit from input
   validation? How would you implement it?

**Sample Answer:** Additional weather data could include:
- Humidity (percentage): `pyip.inputInt("Enter humidity (%): ", min=0, max=100)`
- Precipitation (mm): `pyip.inputFloat("Enter precipitation (mm): ", min=0)`
- Cloud cover (oktas): `pyip.inputInt("Enter cloud cover (0-8 oktas): ", min=0, max=8)`

**Instructor Note:** Encourage students to think about real-world applications
of their weather utility and how input validation contributes to its reliability
and usability.

### Additional Discussion Points

- The balance between strict validation and user experience
- The role of input validation in data science and machine learning pipelines
- Security implications of input validation in web applications
- Best practices for error messages and user feedback in input validation

---
title: "Web Scraping in Python: Beginner's Worksheet"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

## Part 1: Understanding Web Scraping

1. In your own words, define web scraping:
   _________________________________________________________________
   _________________________________________________________________

2. List three common use cases for web scraping:
   a. _____________________________________________________________
   b. _____________________________________________________________
   c. _____________________________________________________________

## Part 2: Ethical Considerations

3. Why is it important to check a website's robots.txt file before scraping?
   _________________________________________________________________
   _________________________________________________________________

4. True or False: It's okay to scrape a website as quickly as possible to get the data you need.
   Answer: ____________

## Part 3: Python Libraries

5. Match the Python library to its primary use in web scraping:
   a. requests     ___ Parsing HTML
   b. BeautifulSoup  ___ Making HTTP requests
   c. pandas       ___ Data manipulation and analysis

6. Install the necessary libraries using pip. Write the command you would use:
   _________________________________________________________________

## Part 4: Basic HTML

7. Identify the following HTML elements:
   a. <div> _______________________________________________________
   b. <a href="..."> ______________________________________________
   c. <table> ______________________________________________________

## Part 5: Practical Exercise

8. Using the following HTML snippet, write Python code with BeautifulSoup to extract the temperature:

```html
<div class="weather-info">
  <h2>Today's Weather</h2>
  <p class="temperature">25°C</p>
  <p class="condition">Sunny</p>
</div>
```

Your code:
```python
from bs4 import BeautifulSoup

html_content = """
<div class="weather-info">
  <h2>Today's Weather</h2>
  <p class="temperature">25°C</p>
  <p class="condition">Sunny</p>
</div>
"""

soup = BeautifulSoup(html_content, 'html.parser')

# Your code here to extract the temperature


print(f"The temperature is: {temperature}")
```

## Part 6: Data Cleaning and Storage

9. Why might you need to clean data after scraping a website?
   _________________________________________________________________
   _________________________________________________________________

10. Write a line of Python code to save a pandas DataFrame called 'weather_df' to a CSV file named 'weather_data.csv':
    _________________________________________________________________

## Part 7: Advanced Topics

11. Briefly explain what Scrapy is used for in web scraping:
    _________________________________________________________________
    _________________________________________________________________

12. What is Selenium used for in the context of web scraping?
    _________________________________________________________________
    _________________________________________________________________

## Advanced Practical Exercise

13. Web Scraping and Data Visualisation Project

Your task is to scrape the first table from the Wikipedia page on global surface temperature, process the data, and create a visualization of the temperature trend.

URL: https://en.wikipedia.org/wiki/Global_surface_temperature#Global_temperature_record

Steps:
a) Use pandas to scrape the first table from the webpage.
b) Clean and prepare the data (hint: you may need to handle the 'Year' column).
c) Create a bar plot showing the temperature trend over time.

Here's a template to get you started:

```python
import pandas as pd
import matplotlib.pyplot as plt. # Or use panadas plotting

# Scrape the table
url = "https://en.wikipedia.org/wiki/Global_surface_temperature#Global_temperature_record"

# Sort the dataframe by year
# Your code here

# Create a bar plot
# Your code here to create a bar plot using matplotlib

# Show the plot
plt.show()
```

Hints:
- Use `pd.read_html(url)` to scrape all tables from the webpage.
- You may need to clean the 'Year' column to remove any non-numeric characters.
- Consider using `df['Year'] = pd.to_numeric(df['Year'], errors='coerce')` to convert 'Year' to numeric values.
- For the bar plot, you can use `plt.bar(df['Year'], df['Temperature'])` as a starting point.
- Don't forget to add labels and a title to your plot!

Bonus: Can you add a trend line to your plot?

---
title: "STAFF ANSWER: Web Scraping in Python: Beginner's Worksheet"
format:
  pdf:
      toc: false
      colorlinks: true
  docx:
      toc: false
      highlight-style: github
  html:
      toc: true
      toc-expand: 2
      embed-resources: true
---

#### Part 1: Understanding Web Scraping

1. **Define web scraping**:  
   Web scraping is the automated process of extracting data from websites, typically by using code to gather and parse the data from the HTML of web pages.

2. **Common use cases for web scraping**:  
   a. Gathering pricing data from e-commerce websites for comparison.  
   b. Collecting information such as reviews or ratings from websites for sentiment analysis.  
   c. Extracting large datasets from government or academic websites for research purposes.

#### Part 2: Ethical Considerations

3. **Importance of checking robots.txt**:  
   The `robots.txt` file provides instructions about which parts of the website should or should not be accessed by automated scrapers. Respecting this file ensures compliance with the site's preferences and avoids legal or ethical violations.

4. **True or False**: Scraping a website as quickly as possible is okay.  
   Answer: **False**  
   Rapid scraping can overwhelm the server, leading to denial of service for other users or violating the terms of service of the website.

#### Part 3: Python Libraries

5. **Match the Python library to its primary use**:  
   a. `requests` — Making HTTP requests.  
   b. `BeautifulSoup` — Parsing HTML.  
   c. `pandas` — Data manipulation and analysis.

6. **Command to install libraries**:  
   ```bash
   pip install requests beautifulsoup4 pandas
   ```

#### Part 4: Basic HTML

7. **Identify HTML elements**:  
   a. `<div>` — A container or section in HTML often used to group elements together.  
   b. `<a href="...">` — A hyperlink element used to link to another webpage or resource.  
   c. `<table>` — An element used to define a table for displaying data in rows and columns.

#### Part 5: Practical Exercise

8. **Python code with BeautifulSoup to extract temperature**:
   ```python
   from bs4 import BeautifulSoup

   html_content = """
   <div class="weather-info">
     <h2>Today's Weather</h2>
     <p class="temperature">25°C</p>
     <p class="condition">Sunny</p>
   </div>
   """

   soup = BeautifulSoup(html_content, 'html.parser')

   # Extracting temperature
   temperature = soup.find('p', class_='temperature').text

   print(f"The temperature is: {temperature}")
   ```

   **Output**:  
   The temperature is: 25°C

#### Part 6: Data Cleaning and Storage

9. **Why you might need to clean data after scraping**:  
   Data scraped from websites may contain extra characters, formatting inconsistencies, or irrelevant information. Cleaning the data ensures it's structured and ready for analysis.

10. **Save DataFrame to CSV**:
    ```python
    weather_df.to_csv('weather_data.csv', index=False)
    ```

#### Part 7: Advanced Topics

11. **Scrapy usage**:  
    Scrapy is a powerful and efficient Python framework used for large-scale web scraping projects, allowing for the scraping, processing, and storing of large amounts of web data.

12. **Selenium usage**:  
    Selenium is a tool used for automating web browsers, and in web scraping, it is especially useful for scraping websites that rely on JavaScript to load content dynamically.

#### Advanced Practical Exercise

13. **Web Scraping and Data Visualization Project**:
   ```python
    import pandas as pd
    import matplotlib.pyplot as plt

    # Scrape the table
    url = "https://en.wikipedia.org/wiki/Global_surface_temperature#Global_temperature_record"
    tables = pd.read_html(url)
    df = tables[0]  # Assuming the first table contains the data we need

    # Clean the data (not really needed, but...)
    df['Year'] = pd.to_numeric(df['Year'], errors='coerce')
    df = df.dropna(subset=['Year'])  # Drop rows where 'Year' couldn't be converted
    df = df.sort_values(by='Year')

    # Create a bar plot showing temperature trends over time
    plt.bar(df['Year'], df['Anomaly °C'])
    plt.xlabel('Year')
    plt.ylabel('Temperature Anomaly(°C)')
    plt.title('Global Surface Temperature Trend')
    plt.show()
   ```

   **Bonus (Trend Line)**:
   To add a trend line, you could use `numpy` to fit a line to the data:

   ```python
   import numpy as np

    # Fit a line to the data
    z = np.polyfit(df['Year'], df['Anomaly °C'], 1)
    p = np.poly1d(z)

    # Create a bar plot showing temperature trends over time
    plt.bar(df['Year'], df['Anomaly °C'])
    # Plot the trend line
    plt.plot(df['Year'], p(df['Year']), label='Trend Line', color='red')
    plt.xlabel('Year')
    plt.ylabel('Temperature Anomaly(°C)')
    plt.title('Global Surface Temperature Trend')
    plt.legend()
    plt.show()
   ```

