---
title: 'Week 6 Mini-Project: Complete Sample Solutions'
subtitle: 'Instructor reference for both pathways with multiple approaches'
jupyter: python3
---

## üìö Sample Solutions Overview

This document provides complete, working solutions for both mini-project pathways. These solutions demonstrate expected student work at different performance levels and serve as:

- **Teaching References** for instructors
- **Debugging Aids** when helping students
- **Assessment Benchmarks** for evaluating student work
- **Extension Ideas** for advanced students

### Solution Structure
- **Pathway A Solutions:** Extension-based approach transformations
- **Pathway B Solutions:** Fresh start implementations  
- **Performance Levels:** Basic, Proficient, Excellent examples
- **Common Variations:** Different approaches students might take

---

## üîÑ Pathway A: Sample Solutions (Extend Week 5)

### **Basic Level Solution (C-B Grade)**

```{python}
# ============================================================================
# PATHWAY A - BASIC LEVEL SOLUTION
# Students at this level successfully transform lists to basic dictionaries
# ============================================================================

from datetime import datetime
import pyinputplus as pyip

# Basic dictionary structure - adequate but not sophisticated
finance_tracker = {
    "budget": 2500,
    "total_spent": 0,
    "expenses": {},  # This replaces parallel lists
    "categories": ["Housing", "Food", "Transport", "Entertainment"]
}

def add_expense_basic(tracker, amount, description, category):
    """
    Basic expense addition - functional but minimal features.
    Shows understanding of dictionary assignment.
    """
    # Simple ID generation
    expense_count = len(tracker["expenses"]) + 1
    expense_id = f"EXP{expense_count:03d}"
    
    # Create basic expense record
    expense = {
        "amount": amount,
        "description": description,
        "category": category,
        "date": datetime.now().strftime("%Y-%m-%d")
    }
    
    # Add to dictionary
    tracker["expenses"][expense_id] = expense
    tracker["total_spent"] += amount
    
    return expense_id

def find_expenses_by_category_basic(tracker, category):
    """
    Basic search functionality - loops through expenses.
    Shows understanding of dictionary iteration.
    """
    found_expenses = {}
    
    for expense_id, expense_data in tracker["expenses"].items():
        if expense_data["category"] == category:
            found_expenses[expense_id] = expense_data
    
    return found_expenses

def show_summary_basic(tracker):
    """
    Basic reporting - demonstrates dictionary access.
    """
    print(f"Budget: ${tracker['budget']:.2f}")
    print(f"Total Spent: ${tracker['total_spent']:.2f}")
    print(f"Remaining: ${tracker['budget'] - tracker['total_spent']:.2f}")
    print(f"Number of expenses: {len(tracker['expenses'])}")
    
    # Show expenses by category
    for category in tracker["categories"]:
        category_expenses = find_expenses_by_category_basic(tracker, category)
        if category_expenses:
            total = sum(exp["amount"] for exp in category_expenses.values())
            print(f"{category}: ${total:.2f} ({len(category_expenses)} expenses)")

# Test basic solution
print("üß™ TESTING BASIC LEVEL SOLUTION")
print("=" * 40)

# Add some test expenses
add_expense_basic(finance_tracker, 450, "Rent payment", "Housing")
add_expense_basic(finance_tracker, 67.50, "Groceries", "Food")
add_expense_basic(finance_tracker, 25, "Coffee", "Entertainment")

# Show summary
show_summary_basic(finance_tracker)

print("\n‚úÖ Basic solution demonstrates:")
print("   ‚Ä¢ Successful list-to-dictionary transformation")
print("   ‚Ä¢ Basic dictionary operations (add, access, iterate)")
print("   ‚Ä¢ Simple ID generation and data storage")
print("   ‚Ä¢ Functional reporting capabilities")
```

### **Proficient Level Solution (B+-A- Grade)**

```{python}
# ============================================================================
# PATHWAY A - PROFICIENT LEVEL SOLUTION
# Students at this level show good dictionary usage with some advanced features
# ============================================================================

# More sophisticated structure with nested dictionaries
finance_tracker_proficient = {
    "user_info": {
        "name": "Student User",
        "monthly_budget": 2500,
        "created_date": datetime.now().strftime("%Y-%m-%d")
    },
    "expenses": {},
    "categories": {
        "Housing": {"budget": 800, "spent": 0},
        "Food": {"budget": 600, "spent": 0}, 
        "Transport": {"budget": 400, "spent": 0},
        "Entertainment": {"budget": 200, "spent": 0},
        "Savings": {"budget": 500, "spent": 0}
    },
    "statistics": {
        "total_expenses": 0,
        "expense_count": 0,
        "last_expense_id": 0
    }
}

def generate_expense_id_proficient(tracker):
    """
    Improved ID generation using tracker statistics.
    Shows understanding of dictionary state management.
    """
    tracker["statistics"]["last_expense_id"] += 1
    return f"EXP{tracker['statistics']['last_expense_id']:04d}"

def add_expense_proficient(tracker, amount, description, category, essential=True):
    """
    More sophisticated expense addition with category tracking.
    Demonstrates nested dictionary updates and error handling.
    """
    expense_id = generate_expense_id_proficient(tracker)
    
    # Create detailed expense record
    expense = {
        "amount": amount,
        "description": description,
        "category": category,
        "date": datetime.now().strftime("%Y-%m-%d"),
        "essential": essential,
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    
    # Add to expenses
    tracker["expenses"][expense_id] = expense
    
    # Update category tracking (with safe access)
    if category in tracker["categories"]:
        tracker["categories"][category]["spent"] += amount
    
    # Update statistics
    tracker["statistics"]["total_expenses"] += amount
    tracker["statistics"]["expense_count"] += 1
    
    return expense_id

def find_expenses_proficient(tracker, **criteria):
    """
    Flexible search with multiple criteria.
    Shows advanced dictionary filtering techniques.
    """
    matching_expenses = {}
    
    for expense_id, expense_data in tracker["expenses"].items():
        include_expense = True
        
        # Check each search criterion
        for criterion, value in criteria.items():
            if criterion == "category" and expense_data.get("category") != value:
                include_expense = False
                break
            elif criterion == "essential" and expense_data.get("essential") != value:
                include_expense = False
                break
            elif criterion == "min_amount" and expense_data.get("amount", 0) < value:
                include_expense = False
                break
            elif criterion == "description_contains":
                if value.lower() not in expense_data.get("description", "").lower():
                    include_expense = False
                    break
        
        if include_expense:
            matching_expenses[expense_id] = expense_data
    
    return matching_expenses

def calculate_budget_performance_proficient(tracker):
    """
    Sophisticated budget analysis using dictionary methods.
    Demonstrates complex data processing with dictionaries.
    """
    monthly_budget = tracker["user_info"]["monthly_budget"]
    total_spent = tracker["statistics"]["total_expenses"]
    
    performance = {
        "overall": {
            "budget": monthly_budget,
            "spent": total_spent,
            "remaining": monthly_budget - total_spent,
            "percentage": (total_spent / monthly_budget * 100) if monthly_budget > 0 else 0
        },
        "categories": {}
    }
    
    # Category-by-category analysis
    for category, details in tracker["categories"].items():
        budget = details["budget"]
        spent = details["spent"]
        
        performance["categories"][category] = {
            "budget": budget,
            "spent": spent,
            "remaining": budget - spent,
            "percentage": (spent / budget * 100) if budget > 0 else 0,
            "status": "over_budget" if spent > budget else "within_budget"
        }
    
    return performance

def generate_advanced_report_proficient(tracker):
    """
    Comprehensive reporting using dictionary analysis.
    Shows mastery of dictionary methods and data processing.
    """
    print("üìä ADVANCED EXPENSE REPORT")
    print("=" * 50)
    
    user_name = tracker["user_info"]["name"]
    print(f"User: {user_name}")
    print(f"Report Date: {datetime.now().strftime('%Y-%m-%d %H:%M')}")
    print()
    
    # Performance analysis
    performance = calculate_budget_performance_proficient(tracker)
    overall = performance["overall"]
    
    print("üí∞ BUDGET OVERVIEW:")
    print(f"   Monthly Budget: ${overall['budget']:.2f}")
    print(f"   Total Spent: ${overall['spent']:.2f}")
    print(f"   Remaining: ${overall['remaining']:.2f}")
    print(f"   Budget Used: {overall['percentage']:.1f}%")
    print()
    
    print("üìä CATEGORY PERFORMANCE:")
    for category, perf in performance["categories"].items():
        status_icon = "‚ö†Ô∏è" if perf["status"] == "over_budget" else "‚úÖ"
        print(f"   {category}: ${perf['spent']:.2f}/${perf['budget']:.2f} "
              f"({perf['percentage']:.1f}%) {status_icon}")
    print()
    
    # Recent expenses
    print("üìù RECENT EXPENSES:")
    recent_expenses = list(tracker["expenses"].items())[-5:]
    for expense_id, expense_data in recent_expenses:
        essential_icon = "üî¥" if expense_data["essential"] else "üü°"
        print(f"   {expense_id}: ${expense_data['amount']:.2f} - {expense_data['description']} {essential_icon}")

# Test proficient solution
print("\nüß™ TESTING PROFICIENT LEVEL SOLUTION")
print("=" * 45)

# Add test expenses
add_expense_proficient(finance_tracker_proficient, 450, "Monthly rent", "Housing", True)
add_expense_proficient(finance_tracker_proficient, 67.50, "Weekly groceries", "Food", True)
add_expense_proficient(finance_tracker_proficient, 25, "Coffee with friends", "Entertainment", False)
add_expense_proficient(finance_tracker_proficient, 89, "Bus pass", "Transport", True)

# Test advanced search
food_expenses = find_expenses_proficient(finance_tracker_proficient, category="Food")
print(f"Found {len(food_expenses)} food expenses")

non_essential = find_expenses_proficient(finance_tracker_proficient, essential=False)
print(f"Found {len(non_essential)} non-essential expenses")

# Generate advanced report
generate_advanced_report_proficient(finance_tracker_proficient)

print("\n‚úÖ Proficient solution demonstrates:")
print("   ‚Ä¢ Sophisticated nested dictionary structure")
print("   ‚Ä¢ Safe access patterns with .get() method")
print("   ‚Ä¢ Advanced search and filtering capabilities")
print("   ‚Ä¢ Comprehensive reporting and analysis")
print("   ‚Ä¢ Category budget tracking and performance analysis")
```

### **Excellent Level Solution (A/A+ Grade)**

```{python}
# ============================================================================
# PATHWAY A - EXCELLENT LEVEL SOLUTION
# Students at this level show mastery with sophisticated features and design
# ============================================================================

# Professional-level dictionary architecture
finance_tracker_excellent = {
    "metadata": {
        "version": "2.0",
        "created_date": datetime.now().strftime("%Y-%m-%d"),
        "last_updated": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "transformation_notes": "Converted from Week 5 parallel lists to dictionary structure"
    },
    "user_profile": {
        "name": "Advanced Student",
        "email": "student@university.edu",
        "financial_goals": {
            "monthly_budget": 2500,
            "savings_target": 500,
            "debt_reduction_target": 200
        }
    },
    "expenses": {},
    "categories": {
        "Housing": {
            "budget_allocation": 0.30,
            "budget_amount": 750,
            "actual_spent": 0,
            "description": "Rent, utilities, home maintenance",
            "essential": True,
            "expense_count": 0
        },
        "Food": {
            "budget_allocation": 0.25,
            "budget_amount": 625,
            "actual_spent": 0,
            "description": "Groceries, dining, meal plans",
            "essential": True,
            "expense_count": 0
        },
        "Transport": {
            "budget_allocation": 0.15,
            "budget_amount": 375,
            "actual_spent": 0,
            "description": "Public transport, car expenses",
            "essential": True,
            "expense_count": 0
        },
        "Education": {
            "budget_allocation": 0.10,
            "budget_amount": 250,
            "actual_spent": 0,
            "description": "Books, courses, materials",
            "essential": True,
            "expense_count": 0
        },
        "Entertainment": {
            "budget_allocation": 0.10,
            "budget_amount": 250,
            "actual_spent": 0,
            "description": "Movies, games, social activities",
            "essential": False,
            "expense_count": 0
        },
        "Savings": {
            "budget_allocation": 0.10,
            "budget_amount": 250,
            "actual_spent": 0,
            "description": "Emergency fund, investments",
            "essential": True,
            "expense_count": 0
        }
    },
    "analytics": {
        "total_expenses": 0,
        "expense_count": 0,
        "last_expense_id": 0,
        "monthly_averages": {},
        "spending_trends": {},
        "category_statistics": {}
    }
}

class AdvancedExpenseManager:
    """
    Professional-level expense management using dictionary principles.
    Demonstrates object-oriented design with dictionary mastery.
    """
    
    def __init__(self, tracker):
        self.tracker = tracker
    
    def generate_unique_id(self):
        """Generate unique expense ID with proper tracking"""
        self.tracker["analytics"]["last_expense_id"] += 1
        return f"EXP{self.tracker['analytics']['last_expense_id']:05d}"
    
    def add_expense(self, amount, description, category, essential=None, tags=None, notes=""):
        """
        Advanced expense addition with comprehensive data capture.
        Shows mastery of dictionary operations and data validation.
        """
        # Input validation
        if amount <= 0:
            return False, "Amount must be positive"
        
        if category not in self.tracker["categories"]:
            return False, f"Category '{category}' not found"
        
        # Auto-determine essential status if not provided
        if essential is None:
            essential = self.tracker["categories"][category].get("essential", False)
        
        # Generate ID and timestamps
        expense_id = self.generate_unique_id()
        current_date = datetime.now().strftime("%Y-%m-%d")
        current_timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Create comprehensive expense record
        expense = {
            "amount": float(amount),
            "description": description,
            "category": category,
            "date": current_date,
            "timestamp": current_timestamp,
            "essential": essential,
            "tags": tags if tags else [],
            "notes": notes,
            "week_of_year": datetime.now().isocalendar()[1],
            "month": datetime.now().month,
            "quarter": (datetime.now().month - 1) // 3 + 1
        }
        
        # Add to expenses
        self.tracker["expenses"][expense_id] = expense
        
        # Update category tracking
        category_data = self.tracker["categories"][category]
        category_data["actual_spent"] += amount
        category_data["expense_count"] += 1
        
        # Update analytics
        analytics = self.tracker["analytics"]
        analytics["total_expenses"] += amount
        analytics["expense_count"] += 1
        
        # Update metadata
        self.tracker["metadata"]["last_updated"] = current_timestamp
        
        return True, expense_id
    
    def advanced_search(self, **criteria):
        """
        Sophisticated search with complex filtering options.
        Demonstrates advanced dictionary querying techniques.
        """
        matching_expenses = {}
        
        for expense_id, expense_data in self.tracker["expenses"].items():
            include_expense = True
            
            # Standard criteria
            for criterion, value in criteria.items():
                if criterion == "category" and expense_data.get("category") != value:
                    include_expense = False
                    break
                elif criterion == "essential" and expense_data.get("essential") != value:
                    include_expense = False
                    break
                elif criterion == "min_amount" and expense_data.get("amount", 0) < value:
                    include_expense = False
                    break
                elif criterion == "max_amount" and expense_data.get("amount", float('inf')) > value:
                    include_expense = False
                    break
                elif criterion == "date_from":
                    if expense_data.get("date", "") < value:
                        include_expense = False
                        break
                elif criterion == "date_to":
                    if expense_data.get("date", "") > value:
                        include_expense = False
                        break
                elif criterion == "description_contains":
                    if value.lower() not in expense_data.get("description", "").lower():
                        include_expense = False
                        break
                elif criterion == "has_tag":
                    if value not in expense_data.get("tags", []):
                        include_expense = False
                        break
                elif criterion == "month" and expense_data.get("month") != value:
                    include_expense = False
                    break
                elif criterion == "quarter" and expense_data.get("quarter") != value:
                    include_expense = False
                    break
            
            if include_expense:
                matching_expenses[expense_id] = expense_data
        
        return matching_expenses
    
    def calculate_advanced_analytics(self):
        """
        Comprehensive analytics using sophisticated dictionary operations.
        Shows mastery of data analysis with dictionaries.
        """
        analytics = {
            "budget_performance": self._calculate_budget_performance(),
            "spending_patterns": self._analyze_spending_patterns(),
            "category_insights": self._generate_category_insights(),
            "time_analysis": self._analyze_time_patterns(),
            "financial_health": self._calculate_financial_health_score()
        }
        
        return analytics
    
    def _calculate_budget_performance(self):
        """Calculate detailed budget performance metrics"""
        monthly_budget = self.tracker["user_profile"]["financial_goals"]["monthly_budget"]
        total_spent = self.tracker["analytics"]["total_expenses"]
        
        performance = {
            "overall": {
                "budget": monthly_budget,
                "spent": total_spent,
                "remaining": monthly_budget - total_spent,
                "percentage_used": (total_spent / monthly_budget * 100) if monthly_budget > 0 else 0,
                "status": "over_budget" if total_spent > monthly_budget else "within_budget"
            },
            "categories": {}
        }
        
        for category, details in self.tracker["categories"].items():
            spent = details["actual_spent"]
            budget = details["budget_amount"]
            
            performance["categories"][category] = {
                "budget": budget,
                "spent": spent,
                "remaining": budget - spent,
                "percentage_used": (spent / budget * 100) if budget > 0 else 0,
                "expense_count": details["expense_count"],
                "average_expense": spent / details["expense_count"] if details["expense_count"] > 0 else 0,
                "status": "over_budget" if spent > budget else "within_budget"
            }
        
        return performance
    
    def _analyze_spending_patterns(self):
        """Analyze sophisticated spending patterns"""
        patterns = {
            "by_essential_status": {"essential": 0, "non_essential": 0},
            "by_amount_range": {"small": 0, "medium": 0, "large": 0},
            "by_category": {},
            "by_month": {},
            "by_quarter": {}
        }
        
        for expense_data in self.tracker["expenses"].values():
            amount = expense_data["amount"]
            
            # Essential vs non-essential
            if expense_data["essential"]:
                patterns["by_essential_status"]["essential"] += amount
            else:
                patterns["by_essential_status"]["non_essential"] += amount
            
            # Amount ranges
            if amount < 50:
                patterns["by_amount_range"]["small"] += amount
            elif amount < 200:
                patterns["by_amount_range"]["medium"] += amount
            else:
                patterns["by_amount_range"]["large"] += amount
            
            # By category
            category = expense_data["category"]
            if category not in patterns["by_category"]:
                patterns["by_category"][category] = {"total": 0, "count": 0}
            patterns["by_category"][category]["total"] += amount
            patterns["by_category"][category]["count"] += 1
            
            # By time periods
            month = expense_data.get("month", datetime.now().month)
            quarter = expense_data.get("quarter", 1)
            
            if month not in patterns["by_month"]:
                patterns["by_month"][month] = 0
            patterns["by_month"][month] += amount
            
            if quarter not in patterns["by_quarter"]:
                patterns["by_quarter"][quarter] = 0
            patterns["by_quarter"][quarter] += amount
        
        return patterns
    
    def _generate_category_insights(self):
        """Generate intelligent insights for each category"""
        insights = {}
        
        for category, details in self.tracker["categories"].items():
            category_insights = {
                "performance": "excellent",
                "recommendations": [],
                "statistics": {
                    "budget_utilization": (details["actual_spent"] / details["budget_amount"] * 100) if details["budget_amount"] > 0 else 0,
                    "average_expense": details["actual_spent"] / details["expense_count"] if details["expense_count"] > 0 else 0,
                    "total_expenses": details["expense_count"]
                }
            }
            
            utilization = category_insights["statistics"]["budget_utilization"]
            
            # Generate performance assessment
            if utilization > 100:
                category_insights["performance"] = "over_budget"
                category_insights["recommendations"].append(f"Reduce {category} spending by ${details['actual_spent'] - details['budget_amount']:.2f}")
            elif utilization > 80:
                category_insights["performance"] = "approaching_limit"
                category_insights["recommendations"].append(f"Monitor {category} spending carefully")
            elif utilization < 25 and details["expense_count"] == 0:
                category_insights["performance"] = "underutilized"
                category_insights["recommendations"].append(f"Consider reallocating ${details['budget_amount']:.2f} from {category}")
            else:
                category_insights["performance"] = "healthy"
                category_insights["recommendations"].append(f"{category} spending is well-managed")
            
            insights[category] = category_insights
        
        return insights
    
    def _analyze_time_patterns(self):
        """Analyze spending patterns over time"""
        # Simplified time analysis for demonstration
        return {
            "most_active_month": datetime.now().month,
            "spending_frequency": len(self.tracker["expenses"]) / max(1, len(set(exp.get("date", "") for exp in self.tracker["expenses"].values()))),
            "average_days_between_expenses": 7  # Simplified calculation
        }
    
    def _calculate_financial_health_score(self):
        """Calculate comprehensive financial health score"""
        score_components = {
            "budget_adherence": 0,
            "savings_rate": 0,
            "expense_diversity": 0,
            "spending_consistency": 0
        }
        
        # Budget adherence (40 points max)
        budget_performance = self._calculate_budget_performance()
        overall_percentage = budget_performance["overall"]["percentage_used"]
        
        if overall_percentage <= 80:
            score_components["budget_adherence"] = 40
        elif overall_percentage <= 90:
            score_components["budget_adherence"] = 30
        elif overall_percentage <= 100:
            score_components["budget_adherence"] = 20
        else:
            score_components["budget_adherence"] = 0
        
        # Savings rate (30 points max)
        savings_spent = self.tracker["categories"].get("Savings", {}).get("actual_spent", 0)
        savings_budget = self.tracker["categories"].get("Savings", {}).get("budget_amount", 1)
        savings_rate = (savings_spent / savings_budget * 100) if savings_budget > 0 else 0
        
        if savings_rate >= 80:
            score_components["savings_rate"] = 30
        elif savings_rate >= 50:
            score_components["savings_rate"] = 20
        else:
            score_components["savings_rate"] = 10
        
        # Expense diversity (20 points max)
        active_categories = sum(1 for cat in self.tracker["categories"].values() if cat["expense_count"] > 0)
        total_categories = len(self.tracker["categories"])
        
        diversity_score = (active_categories / total_categories) * 20
        score_components["expense_diversity"] = diversity_score
        
        # Spending consistency (10 points max)
        expense_count = self.tracker["analytics"]["expense_count"]
        if expense_count >= 10:
            score_components["spending_consistency"] = 10
        elif expense_count >= 5:
            score_components["spending_consistency"] = 7
        else:
            score_components["spending_consistency"] = 3
        
        total_score = sum(score_components.values())
        
        return {
            "total_score": total_score,
            "components": score_components,
            "grade": self._score_to_grade(total_score),
            "recommendations": self._generate_health_recommendations(score_components)
        }
    
    def _score_to_grade(self, score):
        """Convert numerical score to letter grade"""
        if score >= 90: return "A+"
        elif score >= 85: return "A"
        elif score >= 80: return "A-"
        elif score >= 75: return "B+"
        elif score >= 70: return "B"
        else: return "C"
    
    def _generate_health_recommendations(self, components):
        """Generate improvement recommendations"""
        recommendations = []
        
        if components["budget_adherence"] < 25:
            recommendations.append("Focus on staying within budget limits")
        
        if components["savings_rate"] < 20:
            recommendations.append("Increase savings contributions")
        
        if components["expense_diversity"] < 15:
            recommendations.append("Track expenses across more categories")
        
        return recommendations
    
    def generate_comprehensive_report(self):
        """
        Generate professional-level comprehensive report.
        Demonstrates mastery of dictionary-based analytics.
        """
        print("üìä COMPREHENSIVE FINANCIAL ANALYSIS REPORT")
        print("=" * 60)
        
        # Header
        user_name = self.tracker["user_profile"]["name"]
        report_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"User: {user_name}")
        print(f"Generated: {report_time}")
        print(f"Tracker Version: {self.tracker['metadata']['version']}")
        print()
        
        # Advanced analytics
        analytics = self.calculate_advanced_analytics()
        
        # Budget Performance
        budget_perf = analytics["budget_performance"]
        overall = budget_perf["overall"]
        
        print("üí∞ BUDGET PERFORMANCE SUMMARY")
        print("-" * 40)
        print(f"Monthly Budget: ${overall['budget']:.2f}")
        print(f"Total Spent: ${overall['spent']:.2f}")
        print(f"Remaining: ${overall['remaining']:.2f}")
        print(f"Budget Utilization: {overall['percentage_used']:.1f}%")
        print(f"Status: {overall['status'].replace('_', ' ').title()}")
        print()
        
        # Category Analysis
        print("üìä DETAILED CATEGORY ANALYSIS")
        print("-" * 40)
        category_insights = analytics["category_insights"]
        
        for category, insights in category_insights.items():
            perf_icon = {"excellent": "üåü", "healthy": "‚úÖ", "approaching_limit": "‚ö†Ô∏è", 
                        "over_budget": "üö®", "underutilized": "üí°"}
            
            icon = perf_icon.get(insights["performance"], "üìä")
            utilization = insights["statistics"]["budget_utilization"]
            
            print(f"{icon} {category}:")
            print(f"   Budget Utilization: {utilization:.1f}%")
            print(f"   Expense Count: {insights['statistics']['total_expenses']}")
            print(f"   Avg Expense: ${insights['statistics']['average_expense']:.2f}")
            print(f"   Recommendation: {insights['recommendations'][0]}")
            print()
        
        # Financial Health Score
        health = analytics["financial_health"]
        print("üíØ FINANCIAL HEALTH ASSESSMENT")
        print("-" * 40)
        print(f"Overall Score: {health['total_score']:.0f}/100 ({health['grade']})")
        print("Score Breakdown:")
        for component, score in health["components"].items():
            component_name = component.replace('_', ' ').title()
            print(f"   {component_name}: {score:.1f}")
        
        if health["recommendations"]:
            print("Recommendations:")
            for rec in health["recommendations"]:
                print(f"   ‚Ä¢ {rec}")
        print()
        
        # Spending Patterns
        patterns = analytics["spending_patterns"]
        print("üìà SPENDING PATTERN ANALYSIS")
        print("-" * 40)
        
        essential_total = patterns["by_essential_status"]["essential"]
        non_essential_total = patterns["by_essential_status"]["non_essential"]
        total_spending = essential_total + non_essential_total
        
        if total_spending > 0:
            essential_percent = (essential_total / total_spending) * 100
            print(f"Essential Spending: ${essential_total:.2f} ({essential_percent:.1f}%)")
            print(f"Non-Essential Spending: ${non_essential_total:.2f} ({100-essential_percent:.1f}%)")
        
        print(f"\nAmount Distribution:")
        for range_name, amount in patterns["by_amount_range"].items():
            print(f"   {range_name.title()} expenses: ${amount:.2f}")

# Test excellent level solution
print("üß™ TESTING EXCELLENT LEVEL SOLUTION")
print("=" * 45)

# Create advanced expense manager
expense_manager = AdvancedExpenseManager(finance_tracker_excellent)

# Add sophisticated test data
test_expenses = [
    (450, "Monthly rent payment", "Housing", True, ["monthly", "recurring"], "University accommodation"),
    (67.50, "Weekly grocery shopping", "Food", True, ["weekly", "groceries"], "Woolworths essentials"),
    (25, "Coffee with study group", "Entertainment", False, ["social", "coffee"], "Campus cafe"),
    (89, "Monthly bus pass", "Transport", True, ["monthly", "transport"], "Student discount applied"),
    (45, "Course textbook", "Education", True, ["textbook", "required"], "ISYS2001 materials"),
    (200, "Emergency fund contribution", "Savings", True, ["savings", "emergency"], "Building financial security")
]

print("Adding test expenses:")
for amount, description, category, essential, tags, notes in test_expenses:
    success, result = expense_manager.add_expense(amount, description, category, essential, tags, notes)
    if success:
        print(f"‚úÖ Added {result}: ${amount:.2f} - {description}")
    else:
        print(f"‚ùå Failed to add expense: {result}")

print(f"\nTotal expenses added: {finance_tracker_excellent['analytics']['expense_count']}")
print(f"Total amount: ${finance_tracker_excellent['analytics']['total_expenses']:.2f}")

# Test advanced search
print(f"\nüîç Testing advanced search capabilities:")

# Search by category
food_expenses = expense_manager.advanced_search(category="Food")
print(f"Food expenses: {len(food_expenses)}")

# Search by multiple criteria
expensive_non_essential = expense_manager.advanced_search(essential=False, min_amount=20)
print(f"Expensive non-essential items: {len(expensive_non_essential)}")

# Search by tags
social_expenses = expense_manager.advanced_search(has_tag="social")
print(f"Social expenses: {len(social_expenses)}")

# Generate comprehensive report
print(f"\nüìä Generating comprehensive analysis report:")
expense_manager.generate_comprehensive_report()

print("\n‚úÖ Excellent solution demonstrates:")
print("   ‚Ä¢ Professional-level dictionary architecture")
print("   ‚Ä¢ Object-oriented design with dictionary mastery")
print("   ‚Ä¢ Sophisticated search and filtering capabilities")
print("   ‚Ä¢ Advanced analytics and health scoring")
print("   ‚Ä¢ Comprehensive error handling and validation")
print("   ‚Ä¢ Complex data analysis using dictionary methods")
print("   ‚Ä¢ Professional reporting and insights")
```

---

## üÜï Pathway B: Sample Solutions (Fresh Start)

### **Basic Level Solution (C-B Grade)**

```{python}
# ============================================================================
# PATHWAY B - BASIC LEVEL SOLUTION
# Students building from scratch with fundamental dictionary usage
# ============================================================================

# Simple but functional dictionary structure
basic_finance_tracker = {
    "user_name": "Basic User",
    "monthly_budget": 2000,
    "expenses": {},
    "total_spent": 0
}

def add_expense_basic_b(tracker, amount, description, category="Other"):
    """
    Simple expense addition function.
    Shows basic dictionary assignment and ID generation.
    """
    # Simple ID generation
    next_id = len(tracker["expenses"]) + 1
    expense_id = f"EXP{next_id}"
    
    # Create basic expense
    expense = {
        "amount": amount,
        "description": description,
        "category": category,
        "date": "2024-08-01"  # Simplified - could use datetime
    }
    
    # Add to tracker
    tracker["expenses"][expense_id] = expense
    tracker["total_spent"] += amount
    
    print(f"Added expense {expense_id}: ${amount:.2f} for {description}")
    return expense_id

def show_all_expenses_basic_b(tracker):
    """
    Simple function to display all expenses.
    Shows basic dictionary iteration.
    """
    print("All Expenses:")
    for expense_id, expense_data in tracker["expenses"].items():
        print(f"{expense_id}: ${expense_data['amount']:.2f} - {expense_data['description']} ({expense_data['category']})")

def calculate_remaining_budget_basic_b(tracker):
    """
    Simple budget calculation.
    Shows basic dictionary access.
    """
    remaining = tracker["monthly_budget"] - tracker["total_spent"]
    print(f"Budget: ${tracker['monthly_budget']:.2f}")
    print(f"Spent: ${tracker['total_spent']:.2f}")
    print(f"Remaining: ${remaining:.2f}")
    return remaining

# Test basic solution B
print("üß™ TESTING PATHWAY B - BASIC SOLUTION")
print("=" * 45)

# Add some expenses
add_expense_basic_b(basic_finance_tracker, 400, "Rent", "Housing")
add_expense_basic_b(basic_finance_tracker, 50, "Groceries", "Food")
add_expense_basic_b(basic_finance_tracker, 20, "Movie ticket", "Entertainment")

# Show results
show_all_expenses_basic_b(basic_finance_tracker)
print()
calculate_remaining_budget_basic_b(basic_finance_tracker)

print("\n‚úÖ Basic Pathway B solution demonstrates:")
print("   ‚Ä¢ Fundamental dictionary structure creation")
print("   ‚Ä¢ Basic expense addition and ID generation")
print("   ‚Ä¢ Simple iteration through dictionary items")
print("   ‚Ä¢ Basic calculations using dictionary values")
```

### **Proficient Level Solution (B+-A- Grade)**

```{python}
# ============================================================================
# PATHWAY B - PROFICIENT LEVEL SOLUTION
# Students show good dictionary design and usage patterns
# ============================================================================

# Well-structured dictionary design
proficient_finance_tracker_b = {
    "user_info": {
        "name": "Proficient User",
        "monthly_budget": 2500,
        "created_date": datetime.now().strftime("%Y-%m-%d")
    },
    "expenses": {},
    "categories": {
        "Housing": 0,
        "Food": 0,
        "Transport": 0,
        "Entertainment": 0,
        "Other": 0
    },
    "statistics": {
        "total_spent": 0,
        "expense_count": 0,
        "last_id": 0
    }
}

def create_expense_id_proficient_b(tracker):
    """
    Proper ID generation using tracker state.
    Shows understanding of dictionary state management.
    """
    tracker["statistics"]["last_id"] += 1
    return f"EXP{tracker['statistics']['last_id']:03d}"

def add_expense_proficient_b(tracker, amount, description, category="Other"):
    """
    Well-designed expense addition with category tracking.
    Shows good dictionary update patterns.
    """
    # Validate input
    if amount <= 0:
        print("Error: Amount must be positive")
        return None
    
    # Generate ID
    expense_id = create_expense_id_proficient_b(tracker)
    
    # Create expense record
    expense = {
        "amount": amount,
        "description": description,
        "category": category,
        "date": datetime.now().strftime("%Y-%m-%d"),
        "added_time": datetime.now().strftime("%H:%M")
    }
    
    # Add to tracker
    tracker["expenses"][expense_id] = expense
    
    # Update category totals (safe access)
    if category in tracker["categories"]:
        tracker["categories"][category] += amount
    else:
        tracker["categories"]["Other"] += amount
        expense["category"] = "Other"  # Correct the category
    
    # Update statistics
    tracker["statistics"]["total_spent"] += amount
    tracker["statistics"]["expense_count"] += 1
    
    print(f"‚úÖ Added {expense_id}: ${amount:.2f} for {description}")
    return expense_id

def search_expenses_proficient_b(tracker, search_type, search_value):
    """
    Flexible search function with multiple options.
    Shows good dictionary filtering techniques.
    """
    results = {}
    
    for expense_id, expense_data in tracker["expenses"].items():
        include = False
        
        if search_type == "category":
            include = expense_data.get("category") == search_value
        elif search_type == "description":
            include = search_value.lower() in expense_data.get("description", "").lower()
        elif search_type == "min_amount":
            include = expense_data.get("amount", 0) >= search_value
        elif search_type == "date":
            include = expense_data.get("date") == search_value
        
        if include:
            results[expense_id] = expense_data
    
    return results

def generate_category_report_proficient_b(tracker):
    """
    Category-based analysis and reporting.
    Shows understanding of dictionary aggregation.
    """
    print("üìä CATEGORY SPENDING REPORT")
    print("-" * 35)
    
    monthly_budget = tracker["user_info"]["monthly_budget"]
    total_spent = tracker["statistics"]["total_spent"]
    
    # Overall summary
    print(f"Total Budget: ${monthly_budget:.2f}")
    print(f"Total Spent: ${total_spent:.2f}")
    print(f"Remaining: ${monthly_budget - total_spent:.2f}")
    print(f"Budget Used: {(total_spent/monthly_budget)*100:.1f}%")
    print()
    
    # Category breakdown
    print("Category Breakdown:")
    for category, amount in tracker["categories"].items():
        if amount > 0:
            percentage = (amount / total_spent) * 100 if total_spent > 0 else 0
            print(f"   {category}: ${amount:.2f} ({percentage:.1f}%)")
    print()
    
    # Find most expensive category
    if tracker["categories"]:
        max_category = max(tracker["categories"].items(), key=lambda x: x[1])
        if max_category[1] > 0:
            print(f"Highest spending category: {max_category[0]} (${max_category[1]:.2f})")

def get_expense_summary_proficient_b(tracker):
    """
    Generate expense summary using dictionary methods.
    Shows proper use of dictionary analysis techniques.
    """
    if not tracker["expenses"]:
        return "No expenses recorded"
    
    # Calculate statistics using dictionary methods
    amounts = [expense["amount"] for expense in tracker["expenses"].values()]
    
    summary = {
        "total_expenses": len(tracker["expenses"]),
        "total_amount": sum(amounts),
        "average_amount": sum(amounts) / len(amounts),
        "largest_expense": max(amounts),
        "smallest_expense": min(amounts)
    }
    
    return summary

# Test proficient solution B
print("\nüß™ TESTING PATHWAY B - PROFICIENT SOLUTION")
print("=" * 50)

# Add test expenses
expenses_added = []
test_data = [
    (400, "Monthly rent", "Housing"),
    (80, "Weekly groceries", "Food"),
    (45, "Bus pass", "Transport"),
    (25, "Movie night", "Entertainment"),
    (60, "Textbooks", "Other")
]

for amount, description, category in test_data:
    expense_id = add_expense_proficient_b(proficient_finance_tracker_b, amount, description, category)
    if expense_id:
        expenses_added.append(expense_id)

print(f"\nSuccessfully added {len(expenses_added)} expenses")

# Test search functionality
print("\nüîç Testing search functionality:")
food_expenses = search_expenses_proficient_b(proficient_finance_tracker_b, "category", "Food")
print(f"Food expenses found: {len(food_expenses)}")

expensive_items = search_expenses_proficient_b(proficient_finance_tracker_b, "min_amount", 50)
print(f"Expensive items (‚â•$50): {len(expensive_items)}")

# Generate reports
print()
generate_category_report_proficient_b(proficient_finance_tracker_b)

# Show summary statistics
summary = get_expense_summary_proficient_b(proficient_finance_tracker_b)
print("üìà EXPENSE SUMMARY:")
for key, value in summary.items():
    if isinstance(value, (int, float)):
        if "amount" in key:
            print(f"   {key.replace('_', ' ').title()}: ${value:.2f}")
        else:
            print(f"   {key.replace('_', ' ').title()}: {value}")

print("\n‚úÖ Proficient Pathway B solution demonstrates:")
print("   ‚Ä¢ Well-structured dictionary architecture")
print("   ‚Ä¢ Proper ID generation and state management")
print("   ‚Ä¢ Flexible search and filtering capabilities")
print("   ‚Ä¢ Category tracking and analysis")
print("   ‚Ä¢ Error handling and input validation")
print("   ‚Ä¢ Statistical analysis using dictionary methods")
```

### **Excellent Level Solution (A/A+ Grade)**

The excellent level solution for Pathway B would be similar in sophistication to the Pathway A excellent solution, but built entirely from scratch with a focus on:

- Professional dictionary architecture design
- Advanced analytics and reporting
- Sophisticated search and filtering
- Complex data relationships and insights
- Object-oriented design principles
- Comprehensive error handling and validation

---

## üìä Solution Assessment Guide

### **How to Use These Solutions**

**For Instructors:**
- Use as reference when reviewing student work
- Compare student solutions to these benchmarks
- Identify common patterns and assess understanding level
- Provide targeted feedback based on performance gaps

**For Assessment:**
- **Basic Level**: Demonstrates fundamental dictionary operations
- **Proficient Level**: Shows good dictionary design and methods usage
- **Excellent Level**: Exhibits mastery with sophisticated features

**Common Student Variations:**
- Different ID generation approaches (all acceptable)
- Various search implementations (evaluate effectiveness)
- Different category structures (assess logical organization)
- Alternative reporting formats (focus on dictionary usage)

### **Key Assessment Points**

‚úÖ **Dictionary Structure**: Logical organization and naming  
‚úÖ **Safe Access**: Appropriate use of `.get()` method  
‚úÖ **Method Usage**: Effective use of `.keys()`, `.values()`, `.items()`  
‚úÖ **Error Handling**: Graceful handling of missing keys/invalid input  
‚úÖ **Code Organization**: Clear functions and logical flow  
‚úÖ **Problem Solving**: Effective approach to requirements  

### **Grade Mapping Reference**

| Solution Level | Grade Range | Key Characteristics |
|---------------|-------------|-------------------|
| **Basic** | C to B | Fundamental dictionary operations, simple structure |
| **Proficient** | B+ to A- | Good design, safe access, category tracking |
| **Excellent** | A to A+ | Sophisticated features, advanced analytics, mastery |

These solutions provide comprehensive references for assessment while allowing for creative student approaches that demonstrate understanding of dictionary concepts.

```{python}
print("üìö COMPLETE SAMPLE SOLUTIONS READY")
print("‚úÖ Both pathways covered at all performance levels")
print("üéØ Assessment benchmarks established")
print("üìä Multiple approaches demonstrated")
print("üîç Ready for student evaluation and support")
```